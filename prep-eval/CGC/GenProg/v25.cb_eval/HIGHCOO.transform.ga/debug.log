[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : NULL
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : INIT_HAIKU_ID
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint32_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_recv_uint32 ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'num [ 1 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [num] = uint32_t * 
[C-t-3] sym_dict [num [ 1 ]] = uint32_t 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint32_t cgc_recv_uint32 ( ) { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint32_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_recv_uint16 ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint16_t'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'num [ 1 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [num] = uint16_t * 
[C-t-3] sym_dict [num [ 1 ]] = uint16_t 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint32_t cgc_recv_uint16 ( ) { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint8_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_haiku_list_exists ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == cgc_haiku_list
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_haiku_list
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == cgc_haiku_list
=> ['NULL', 'cgc_haiku_list']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cgc_haiku_list
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cgc_haiku_list']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cgc_haiku_list']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cgc_haiku_list']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cgc_haiku_list']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cgc_haiku_list']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cgc_haiku_list']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cgc_haiku_list']
Resolved type: [2.3]  UNDEF : cgc_haiku_list
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == cgc_haiku_list ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return FALSE ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == cgc_haiku_list ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return FALSE ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return TRUE ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return FALSE ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return TRUE ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint8_t cgc_haiku_list_exists ( ) { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint8_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_is_haiku_list_empty ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == cgc_haiku_list -> count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_haiku_list -> count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == cgc_haiku_list -> count
=> ['0', 'cgc_haiku_list -> count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cgc_haiku_list -> count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cgc_haiku_list -> count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cgc_haiku_list -> count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cgc_haiku_list -> count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cgc_haiku_list -> count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cgc_haiku_list -> count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cgc_haiku_list -> count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cgc_haiku_list', '->', 'count']
Resolved type: [2.3]  UNDEF : cgc_haiku_list
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == cgc_haiku_list -> count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return TRUE ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == cgc_haiku_list -> count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return TRUE ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return FALSE ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return TRUE ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return FALSE ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint8_t cgc_is_haiku_list_empty ( ) { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_init_haiku_list ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => FALSE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => FALSE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => FALSE == tlv1
=> ['FALSE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : FALSE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['FALSE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['FALSE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['FALSE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['FALSE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['FALSE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['FALSE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['FALSE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ FALSE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: cgc_haiku_list (cgc_haiku_list) = cgc_list_create ( )
var: UNDEF cgc_haiku_list (cgc_haiku_list) = cgc_list_create ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_haiku_list = cgc_list_create ( ) ; }
Assigns = [('UNDEF', 'cgc_haiku_list', '', 'cgc_list_create ( )')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_haiku_list = cgc_list_create ( ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } ]
Assigns = [('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_init_haiku_list ( ) { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_count ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
=> ['TRUE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return cgc_haiku_list -> count ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return cgc_haiku_list -> count ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_NOT_EXIST ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return cgc_haiku_list -> count ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_NOT_EXIST ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } ]
Assigns = [('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_get_count ( ) { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint32_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_id_from_haiku ( node_t * haiku )')]
ParameterDeclaration : type = node_t *, var = haiku [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['haiku']
[enterParameterDeclaration] node_t * : haiku
sym_dict [haiku] = node_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL != haiku -> data
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => haiku -> data
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL != haiku -> data
=> ['NULL', 'haiku -> data']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : haiku -> data
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['haiku -> data']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['haiku -> data']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['haiku -> data']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['haiku -> data']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['haiku -> data']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['haiku -> data']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['haiku', '->', 'data']
FOUND IT! [2.2]  node_t * : haiku
Resolved type: [2.3]  node_t * : haiku
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL != haiku -> data ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * h'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [h] = struct haiku * 
var: h (h) = ( struct haiku * ) haiku -> data
var: struct haiku * h (h) = ( struct haiku * ) haiku -> data
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; }
Assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku -> data')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL != haiku -> data ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_EMPTY_NODE ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_EMPTY_NODE ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint32_t cgc_get_id_from_haiku ( node_t * haiku ) { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint32_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_next_haiku_id ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { next_haiku_id ++ ; return next_haiku_id - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint32_t cgc_get_next_haiku_id ( ) { next_haiku_id ++ ; return next_haiku_id - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { next_haiku_id ++ ; return next_haiku_id - 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_random_idx ( uint32_t * idx )')]
ParameterDeclaration : type = uint32_t *, var = idx [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['idx']
[enterParameterDeclaration] uint32_t * : idx
sym_dict [idx] = uint32_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t random_idx'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [random_idx] = uint32_t 
var: random_idx (random_idx) = 0
var: uint32_t random_idx (random_idx) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = ( char * ) & random_idx
var: char * tlv2 (tlv2) = ( char * ) & random_idx
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = 4
var: cgc_size_t tlv1 (tlv1) = 4
var: ret (ret) = cgc_rand ( tlv2 , tlv1 )
var: int ret (ret) = cgc_rand ( tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; }
Assigns = [('char *', 'tlv2', '', '( char * ) & random_idx'), ('cgc_size_t', 'tlv1', '', '4'), ('int', 'ret', '', 'cgc_rand ( tlv2 , tlv1 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int32_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = int32_t 
var: count (count) = cgc_get_count ( )
var: int32_t count (count) = cgc_get_count ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ERR_LIST_NOT_EXIST == count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ERR_LIST_NOT_EXIST
[2] <class 'CParser.CParser.RelationalExpressionContext'> => count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ERR_LIST_NOT_EXIST == count
=> ['ERR_LIST_NOT_EXIST', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ERR_LIST_NOT_EXIST
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ERR_LIST_NOT_EXIST']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ERR_LIST_NOT_EXIST']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ERR_LIST_NOT_EXIST']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ERR_LIST_NOT_EXIST']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ERR_LIST_NOT_EXIST']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ERR_LIST_NOT_EXIST']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ERR_LIST_NOT_EXIST']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [2.2]  int32_t : count
Resolved type: [2.3]  int32_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ERR_LIST_NOT_EXIST == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return count ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ERR_LIST_NOT_EXIST == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return count ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [2.2]  int32_t : count
Resolved type: [2.3]  int32_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_EMPTY ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return ERR_LIST_EMPTY ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 != ret
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 != ret
=> ['0', 'ret']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 != ret ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_RAND_FAILED ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 != ret ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return ERR_RAND_FAILED ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: * idx (* idx) = random_idx % ( uint32_t ) count
var: UNDEF * idx (* idx) = random_idx % ( uint32_t ) count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; }
Assigns = [('UNDEF', '* idx', '', 'random_idx % ( uint32_t ) count')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_RAND_FAILED ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_EMPTY ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return count ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } ]
Assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0'), ('int32_t', 'count', '', 'cgc_get_count ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_get_random_idx ( uint32_t * idx ) { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_populate_array_with_haiku_ids ( uint32_t id_arr [ ] , uint32_t count )')]
ParameterDeclaration : type = uint32_t, var = id_arr [ ] [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['id_arr [ ]']
[enterParameterDeclaration] uint32_t : id_arr [ ]
sym_dict [id_arr] = uint32_t * 
sym_dict [id_arr [ ]] = uint32_t 
ParameterDeclaration : type = uint32_t, var = count [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['count']
[enterParameterDeclaration] uint32_t : count
sym_dict [count] = uint32_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'node_t * haiku_ptr'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [haiku_ptr] = node_t * 
var: haiku_ptr (haiku_ptr) = NULL
var: node_t * haiku_ptr (haiku_ptr) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * h'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [h] = struct haiku * 
var: h (h) = NULL
var: struct haiku * h (h) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [id] = uint32_t 
var: id (id) = 0
var: uint32_t id (id) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
=> ['TRUE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: haiku_ptr (haiku_ptr) = cgc_haiku_list -> tail
var: node_t * haiku_ptr (haiku_ptr) = cgc_haiku_list -> tail
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { haiku_ptr = cgc_haiku_list -> tail ; }
Assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> tail')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { haiku_ptr = cgc_haiku_list -> tail ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_NOT_EXIST ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { haiku_ptr = cgc_haiku_list -> tail ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_NOT_EXIST ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [2.2]  uint32_t : count
Resolved type: [2.3]  uint32_t : count
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == haiku_ptr
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => haiku_ptr
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == haiku_ptr
=> ['NULL', 'haiku_ptr']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : haiku_ptr
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['haiku_ptr']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['haiku_ptr']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['haiku_ptr']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['haiku_ptr']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['haiku_ptr']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['haiku_ptr']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['haiku_ptr']
FOUND IT! [2.2]  node_t * : haiku_ptr
Resolved type: [2.3]  node_t * : haiku_ptr
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( 0 == count ) || ( NULL == haiku_ptr ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_EMPTY ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_EMPTY ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 < count
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => count
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 < count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  uint32_t : count
Resolved type: [1.3]  uint32_t : count
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL != haiku_ptr
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => haiku_ptr
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL != haiku_ptr
=> ['NULL', 'haiku_ptr']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : haiku_ptr
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['haiku_ptr']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['haiku_ptr']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['haiku_ptr']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['haiku_ptr']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['haiku_ptr']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['haiku_ptr']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['haiku_ptr']
FOUND IT! [2.2]  node_t * : haiku_ptr
Resolved type: [2.3]  node_t * : haiku_ptr
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: h (h) = ( struct haiku * ) haiku_ptr -> data
var: struct haiku * h (h) = ( struct haiku * ) haiku_ptr -> data
var: id_arr  (id_arr [ count - 1 ]) = h -> id
var: UNDEF id_arr  (id_arr [ count - 1 ]) = h -> id
var: haiku_ptr (haiku_ptr) = haiku_ptr -> prev
var: node_t * haiku_ptr (haiku_ptr) = haiku_ptr -> prev
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }
Assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku_ptr -> data'), ('UNDEF', 'id_arr ', '[ count - 1 ]', 'h -> id'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> prev')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } ]
Assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_populate_array_with_haiku_ids ( uint32_t id_arr [ ] , uint32_t count ) { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_find_haiku_with_id ( struct haiku * * h , uint32_t id )')]
ParameterDeclaration : type = struct haiku * *, var = h [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['h']
[enterParameterDeclaration] struct haiku * * : h
sym_dict [h] = struct haiku * * 
ParameterDeclaration : type = uint32_t, var = id [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['id']
[enterParameterDeclaration] uint32_t : id
sym_dict [id] = uint32_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'node_t * haiku_ptr'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [haiku_ptr] = node_t * 
var: haiku_ptr (haiku_ptr) = NULL
var: node_t * haiku_ptr (haiku_ptr) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * tmp'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tmp] = struct haiku * 
var: tmp (tmp) = NULL
var: struct haiku * tmp (tmp) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = int 
var: count (count) = 0
var: int count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'bool_t found'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [found] = bool_t 
var: found (found) = FALSE
var: bool_t found (found) = FALSE
var: count (count) = cgc_get_count ( )
var: int count (count) = cgc_get_count ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 < count
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => count
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 < count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  int : count
Resolved type: [1.3]  int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 < count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: haiku_ptr (haiku_ptr) = cgc_haiku_list -> head
var: node_t * haiku_ptr (haiku_ptr) = cgc_haiku_list -> head
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { haiku_ptr = cgc_haiku_list -> head ; }
Assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> head')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 < count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { haiku_ptr = cgc_haiku_list -> head ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [2.2]  int : count
Resolved type: [2.3]  int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_EMPTY ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return ERR_LIST_EMPTY ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_NOT_EXIST ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_EMPTY ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_NOT_EXIST ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { haiku_ptr = cgc_haiku_list -> head ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL != haiku_ptr
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => haiku_ptr
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL != haiku_ptr
=> ['NULL', 'haiku_ptr']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : haiku_ptr
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['haiku_ptr']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['haiku_ptr']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['haiku_ptr']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['haiku_ptr']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['haiku_ptr']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['haiku_ptr']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['haiku_ptr']
FOUND IT! [2.2]  node_t * : haiku_ptr
Resolved type: [2.3]  node_t * : haiku_ptr
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: tmp (tmp) = ( struct haiku * ) haiku_ptr -> data
var: struct haiku * tmp (tmp) = ( struct haiku * ) haiku_ptr -> data
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => id == tmp -> id
[0] <class 'CParser.CParser.RelationalExpressionContext'> => id
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tmp -> id
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => id == tmp -> id
=> ['id', 'tmp -> id']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : id
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['id']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['id']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['id']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['id']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['id']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['id']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['id']
FOUND IT! [2.2]  uint32_t : id
Resolved type: [2.3]  uint32_t : id
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ id == tmp -> id ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: * h (* h) = tmp
var: UNDEF * h (* h) = tmp
var: found (found) = TRUE
var: bool_t found (found) = TRUE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { * h = tmp ; found = TRUE ; break ; }
Assigns = [('UNDEF', '* h', '', 'tmp'), ('bool_t', 'found', '', 'TRUE')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { * h = tmp ; found = TRUE ; break ; } ]
var: haiku_ptr (haiku_ptr) = haiku_ptr -> next
var: node_t * haiku_ptr (haiku_ptr) = haiku_ptr -> next
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } ]
Assigns = [('struct haiku *', 'tmp', '', '( struct haiku * ) haiku_ptr -> data'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> next')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == found
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => found
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == found
=> ['TRUE', 'found']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : found
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['found']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['found']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['found']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['found']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['found']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['found']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['found']
FOUND IT! [2.2]  bool_t : found
Resolved type: [2.3]  bool_t : found
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == found ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return SUCCESS ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == found ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return SUCCESS ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_INVALID_ID ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return SUCCESS ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_INVALID_ID ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } ]
Assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE'), ('int', 'count', '', 'cgc_get_count ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_find_haiku_with_id ( struct haiku * * h , uint32_t id ) { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_send_haiku ( struct haiku * h )')]
ParameterDeclaration : type = struct haiku *, var = h [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['h']
[enterParameterDeclaration] struct haiku * : h
sym_dict [h] = struct haiku * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [id] = uint32_t 
var: id (id) = h -> id
var: uint32_t id (id) = h -> id
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * content'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [content] = char * 
var: content (content) = h -> content
var: char * content (content) = h -> content
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint16_t length'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [length] = uint16_t 
var: length (length) = h -> length
var: uint16_t length (length) = h -> length
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv2 = ( char * ) & id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = sizeof ( uint32_t )
var: cgc_size_t tlv1 (tlv1) = sizeof ( uint32_t )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }
Assigns = [('cgc_size_t', 'tlv1', '', 'sizeof ( uint32_t )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 = ( char * ) & length'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
var: tlv3 (tlv3) = sizeof ( uint16_t )
var: cgc_size_t tlv3 (tlv3) = sizeof ( uint16_t )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( uint16_t )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = content'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = cgc_size_t 
var: tlv5 (tlv5) = length
var: cgc_size_t tlv5 (tlv5) = length
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }
Assigns = [('cgc_size_t', 'tlv5', '', 'length')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } ]
Assigns = [('uint32_t', 'id', '', 'h -> id'), ('char *', 'content', '', 'h -> content'), ('uint16_t', 'length', '', 'h -> length')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_send_haiku ( struct haiku * h ) { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_send_easter_egg_haiku ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [id] = uint32_t 
var: id (id) = EGG_ID
var: uint32_t id (id) = EGG_ID
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * content'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [content] = char * 
var: content (content) = EGG_HAIKU
var: char * content (content) = EGG_HAIKU
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint16_t length'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [length] = uint16_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 = content'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = const char * 
var: length (length) = cgc_strlen ( tlv7 )
var: uint16_t length (length) = cgc_strlen ( tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; }
Assigns = [('uint16_t', 'length', '', 'cgc_strlen ( tlv7 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv2 = ( char * ) & id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = sizeof ( uint32_t )
var: cgc_size_t tlv1 (tlv1) = sizeof ( uint32_t )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }
Assigns = [('cgc_size_t', 'tlv1', '', 'sizeof ( uint32_t )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 = ( char * ) & length'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
var: tlv3 (tlv3) = sizeof ( uint16_t )
var: cgc_size_t tlv3 (tlv3) = sizeof ( uint16_t )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( uint16_t )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = content'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = cgc_size_t 
var: tlv5 (tlv5) = length
var: cgc_size_t tlv5 (tlv5) = length
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }
Assigns = [('cgc_size_t', 'tlv5', '', 'length')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } ]
Assigns = [('uint32_t', 'id', '', 'EGG_ID'), ('char *', 'content', '', 'EGG_HAIKU')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_send_easter_egg_haiku ( ) { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_send_haiku_id ( uint32_t id )')]
ParameterDeclaration : type = uint32_t, var = id [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['id']
[enterParameterDeclaration] uint32_t : id
sym_dict [id] = uint32_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SENDUI'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( id )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [(] = SENDUI * 
[C-t-2] sym_dict [( id )] = SENDUI 
[C-t-3] sym_dict [id] = SENDUI 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SENDUI ( id ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_send_haiku_id ( uint32_t id ) { SENDUI ( id ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SENDUI ( id ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_add_haiku_to_list ( struct haiku * h )')]
ParameterDeclaration : type = struct haiku *, var = h [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['h']
[enterParameterDeclaration] struct haiku * : h
sym_dict [h] = struct haiku * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'node_t * nd'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [nd] = node_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = void * 
var: tlv1 (tlv1) = ( void * ) h
var: void * tlv1 (tlv1) = ( void * ) h
var: nd (nd) = cgc_node_create ( tlv1 )
var: node_t * nd (nd) = cgc_node_create ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; }
Assigns = [('void *', 'tlv1', '', '( void * ) h'), ('node_t *', 'nd', '', 'cgc_node_create ( tlv1 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_add_haiku_to_list ( struct haiku * h ) { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_recv_haiku_line ( char * haiku_content_ptr , int16_t bytes_remaining )')]
ParameterDeclaration : type = char *, var = haiku_content_ptr [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['haiku_content_ptr']
[enterParameterDeclaration] char * : haiku_content_ptr
sym_dict [haiku_content_ptr] = char * 
ParameterDeclaration : type = int16_t, var = bytes_remaining [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['bytes_remaining']
[enterParameterDeclaration] int16_t : bytes_remaining
sym_dict [bytes_remaining] = int16_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [temp_line_buf] = char * 
[C-t-3] sym_dict [temp_line_buf [ MAX_HAIKU_LINE_LEN ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int16_t bytes_received'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_received] = int16_t 
var: bytes_received (bytes_received) = 0
var: int16_t bytes_received (bytes_received) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int16_t bytes_written'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_written] = int16_t 
var: bytes_written (bytes_written) = 0
var: int16_t bytes_written (bytes_written) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
var: tlv3 (tlv3) = STDIN
var: int tlv3 (tlv3) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = temp_line_buf
var: char * tlv2 (tlv2) = temp_line_buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = MAX_HAIKU_LINE_LEN
var: cgc_size_t tlv1 (tlv1) = MAX_HAIKU_LINE_LEN
var: bytes_received (bytes_received) = cgc_recvline ( tlv3 , tlv2 , tlv1 )
var: int16_t bytes_received (bytes_received) = cgc_recvline ( tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv3', '', 'STDIN'), ('char *', 'tlv2', '', 'temp_line_buf'), ('cgc_size_t', 'tlv1', '', 'MAX_HAIKU_LINE_LEN'), ('int16_t', 'bytes_received', '', 'cgc_recvline ( tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 > bytes_received
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_received
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 > bytes_received
=> ['0', 'bytes_received']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_received
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_received']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_received']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_received']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_received']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_received']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_received']
FOUND IT! [1.2]  int16_t : bytes_received
Resolved type: [1.3]  int16_t : bytes_received
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 > bytes_received ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_INVALID_HAIKU ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_INVALID_HAIKU ; } ]
var: bytes_written (bytes_written) = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf )
var: int16_t bytes_written (bytes_written) = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } ]
Assigns = [('int16_t', 'bytes_received', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_written', '', 'cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\\x07" , temp_line_buf )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_recv_haiku_line ( char * haiku_content_ptr , int16_t bytes_remaining ) { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'struct haiku *'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_recv_haiku ( uint16_t total_bytes )')]
ParameterDeclaration : type = uint16_t, var = total_bytes [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['total_bytes']
[enterParameterDeclaration] uint16_t : total_bytes
sym_dict [total_bytes] = uint16_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * h'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [h] = struct haiku * 
var: h (h) = NULL
var: struct haiku * h (h) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * haiku_content_ptr'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [haiku_content_ptr] = char * 
var: haiku_content_ptr (haiku_content_ptr) = NULL
var: char * haiku_content_ptr (haiku_content_ptr) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int16_t bytes_remaining'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_remaining] = int16_t 
var: bytes_remaining (bytes_remaining) = 0
var: int16_t bytes_remaining (bytes_remaining) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int16_t bytes_written'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_written] = int16_t 
var: bytes_written (bytes_written) = 0
var: int16_t bytes_written (bytes_written) = 0
var: bytes_remaining (bytes_remaining) = ( int16_t ) total_bytes
var: int16_t bytes_remaining (bytes_remaining) = ( int16_t ) total_bytes
var: haiku_content_ptr (haiku_content_ptr) = h -> content
var: char * haiku_content_ptr (haiku_content_ptr) = h -> content
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 != bytes_remaining
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_remaining
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 != bytes_remaining
=> ['0', 'bytes_remaining']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : bytes_remaining
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['bytes_remaining']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_remaining']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_remaining']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_remaining']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_remaining']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_remaining']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_remaining']
FOUND IT! [2.2]  int16_t : bytes_remaining
Resolved type: [2.3]  int16_t : bytes_remaining
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = haiku_content_ptr
var: char * tlv2 (tlv2) = haiku_content_ptr
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int16_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int16_t 
var: tlv1 (tlv1) = bytes_remaining
var: int16_t tlv1 (tlv1) = bytes_remaining
var: bytes_written (bytes_written) = cgc_recv_haiku_line ( tlv2 , tlv1 )
var: int16_t bytes_written (bytes_written) = cgc_recv_haiku_line ( tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; }
Assigns = [('char *', 'tlv2', '', 'haiku_content_ptr'), ('int16_t', 'tlv1', '', 'bytes_remaining'), ('int16_t', 'bytes_written', '', 'cgc_recv_haiku_line ( tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 > bytes_written
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_written
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 > bytes_written
=> ['0', 'bytes_written']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_written
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_written']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_written']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_written']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_written']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_written']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_written']
FOUND IT! [1.2]  int16_t : bytes_written
Resolved type: [1.3]  int16_t : bytes_written
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 > bytes_written ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return NULL ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 > bytes_written ) { return NULL ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return NULL ; } ]
var: haiku_content_ptr (haiku_content_ptr) = bytes_written
var: char * haiku_content_ptr (haiku_content_ptr) = bytes_written
var: bytes_remaining (bytes_remaining) = bytes_written
var: int16_t bytes_remaining (bytes_remaining) = bytes_written
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 > bytes_written ) { return NULL ; } ]
Assigns = [('char *', 'haiku_content_ptr', '', 'bytes_written'), ('int16_t', 'bytes_remaining', '', 'bytes_written')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } ]
var: h -> id (h -> id) = cgc_get_next_haiku_id ( )
var: UNDEF h -> id (h -> id) = cgc_get_next_haiku_id ( )
var: h -> length (h -> length) = total_bytes
var: UNDEF h -> length (h -> length) = total_bytes
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } ]
Assigns = [('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content'), ('UNDEF', 'h -> id', '', 'cgc_get_next_haiku_id ( )'), ('UNDEF', 'h -> length', '', 'total_bytes')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : struct haiku * cgc_recv_haiku ( uint16_t total_bytes ) { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint16_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_recv_haiku_size ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return cgc_recv_uint16 ( ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint16_t cgc_recv_haiku_size ( ) { return cgc_recv_uint16 ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return cgc_recv_uint16 ( ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_add_haiku ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = SUCCESS
var: int ret (ret) = SUCCESS
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint16_t total_bytes'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [total_bytes] = uint16_t 
var: total_bytes (total_bytes) = 0
var: uint16_t total_bytes (total_bytes) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * h'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [h] = struct haiku * 
var: h (h) = NULL
var: struct haiku * h (h) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => FALSE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => FALSE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => FALSE == tlv1
=> ['FALSE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : FALSE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['FALSE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['FALSE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['FALSE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['FALSE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['FALSE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['FALSE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['FALSE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ FALSE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_init_haiku_list ( ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_init_haiku_list ( ) ; } ]
var: total_bytes (total_bytes) = cgc_recv_haiku_size ( )
var: uint16_t total_bytes (total_bytes) = cgc_recv_haiku_size ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 < total_bytes
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => total_bytes
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 < total_bytes
=> ['0', 'total_bytes']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : total_bytes
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['total_bytes']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['total_bytes']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['total_bytes']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['total_bytes']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['total_bytes']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['total_bytes']
FOUND IT! [1.2]  uint16_t : total_bytes
Resolved type: [1.3]  uint16_t : total_bytes
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => MAX_HAIKU_LEN > total_bytes
[0] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_HAIKU_LEN
[2] <class 'CParser.CParser.ShiftExpressionContext'> => total_bytes
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => MAX_HAIKU_LEN > total_bytes
=> ['MAX_HAIKU_LEN', 'total_bytes']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : MAX_HAIKU_LEN
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['MAX_HAIKU_LEN']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['MAX_HAIKU_LEN']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['MAX_HAIKU_LEN']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['MAX_HAIKU_LEN']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['MAX_HAIKU_LEN']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['MAX_HAIKU_LEN']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : total_bytes
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['total_bytes']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['total_bytes']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['total_bytes']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['total_bytes']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['total_bytes']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['total_bytes']
FOUND IT! [1.2]  uint16_t : total_bytes
Resolved type: [1.3]  uint16_t : total_bytes
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint16_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = uint16_t 
var: tlv2 (tlv2) = total_bytes
var: uint16_t tlv2 (tlv2) = total_bytes
var: h (h) = cgc_recv_haiku ( tlv2 )
var: struct haiku * h (h) = cgc_recv_haiku ( tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; }
Assigns = [('uint16_t', 'tlv2', '', 'total_bytes'), ('struct haiku *', 'h', '', 'cgc_recv_haiku ( tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == h
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => h
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == h
=> ['NULL', 'h']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : h
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['h']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['h']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['h']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['h']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['h']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['h']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['h']
FOUND IT! [2.2]  struct haiku * : h
Resolved type: [2.3]  struct haiku * : h
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == h ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = ERR_INVALID_HAIKU
var: int ret (ret) = ERR_INVALID_HAIKU
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = ERR_INVALID_HAIKU ; }
Assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == h ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = ERR_INVALID_HAIKU ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = struct haiku * 
var: tlv4 (tlv4) = h
var: struct haiku * tlv4 (tlv4) = h
var: ret (ret) = cgc_add_haiku_to_list ( tlv4 )
var: int ret (ret) = cgc_add_haiku_to_list ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; }
Assigns = [('struct haiku *', 'tlv4', '', 'h'), ('int', 'ret', '', 'cgc_add_haiku_to_list ( tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = uint32_t 
var: tlv3 (tlv3) = h -> id
var: uint32_t tlv3 (tlv3) = h -> id
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_send_haiku_id'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv3 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; }
Assigns = [('uint32_t', 'tlv3', '', 'h -> id')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = ERR_INVALID_HAIKU ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: ret (ret) = ERR_INVALID_HAIKU_LEN
var: int ret (ret) = ERR_INVALID_HAIKU_LEN
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = ERR_INVALID_HAIKU_LEN ; }
Assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU_LEN')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = ERR_INVALID_HAIKU_LEN ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } ]
Assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL'), ('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )'), ('uint16_t', 'total_bytes', '', 'cgc_recv_haiku_size ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_add_haiku ( ) { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_haiku_by_id ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * h'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [h] = struct haiku * 
var: h (h) = NULL
var: struct haiku * h (h) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [id] = uint32_t 
var: id (id) = 0
var: uint32_t id (id) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int res'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [res] = int 
var: res (res) = 0
var: int res (res) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
=> ['TRUE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: id (id) = cgc_recv_uint32 ( )
var: uint32_t id (id) = cgc_recv_uint32 ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => EGG_ID == id
[0] <class 'CParser.CParser.RelationalExpressionContext'> => EGG_ID
[2] <class 'CParser.CParser.RelationalExpressionContext'> => id
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => EGG_ID == id
=> ['EGG_ID', 'id']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : EGG_ID
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['EGG_ID']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['EGG_ID']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['EGG_ID']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['EGG_ID']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['EGG_ID']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['EGG_ID']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['EGG_ID']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : id
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['id']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['id']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['id']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['id']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['id']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['id']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['id']
FOUND IT! [2.2]  uint32_t : id
Resolved type: [2.3]  uint32_t : id
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ EGG_ID == id ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_send_easter_egg_haiku ( ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ EGG_ID == id ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_send_easter_egg_haiku ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = struct haiku * * 
var: tlv3 (tlv3) = & h
var: struct haiku * * tlv3 (tlv3) = & h
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = uint32_t 
var: tlv2 (tlv2) = id
var: uint32_t tlv2 (tlv2) = id
var: res (res) = cgc_find_haiku_with_id ( tlv3 , tlv2 )
var: int res (res) = cgc_find_haiku_with_id ( tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; }
Assigns = [('struct haiku * *', 'tlv3', '', '& h'), ('uint32_t', 'tlv2', '', 'id'), ('int', 'res', '', 'cgc_find_haiku_with_id ( tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => SUCCESS == res
[0] <class 'CParser.CParser.RelationalExpressionContext'> => SUCCESS
[2] <class 'CParser.CParser.RelationalExpressionContext'> => res
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => SUCCESS == res
=> ['SUCCESS', 'res']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : SUCCESS
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['SUCCESS']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['SUCCESS']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['SUCCESS']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['SUCCESS']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['SUCCESS']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['SUCCESS']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['SUCCESS']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : res
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['res']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['res']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['res']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['res']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['res']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['res']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['res']
FOUND IT! [2.2]  int : res
Resolved type: [2.3]  int : res
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ SUCCESS == res ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_send_haiku'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( h )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_send_haiku ( h ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_send_haiku ( h ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_send_easter_egg_haiku ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } ]
Assigns = [('uint32_t', 'id', '', 'cgc_recv_uint32 ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: res (res) = ERR_LIST_NOT_EXIST
var: int res (res) = ERR_LIST_NOT_EXIST
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { res = ERR_LIST_NOT_EXIST ; }
Assigns = [('int', 'res', '', 'ERR_LIST_NOT_EXIST')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { res = ERR_LIST_NOT_EXIST ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } ]
Assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0'), ('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_get_haiku_by_id ( ) { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_haiku_cgc_random ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t random_idx'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [random_idx] = uint32_t 
var: random_idx (random_idx) = 0
var: uint32_t random_idx (random_idx) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = uint32_t 
var: count (count) = 0
var: uint32_t count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t * id_arr'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [id_arr] = uint32_t * 
var: id_arr (id_arr) = NULL
var: uint32_t * id_arr (id_arr) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * rand_haiku'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rand_haiku] = struct haiku * 
var: rand_haiku (rand_haiku) = NULL
var: struct haiku * rand_haiku (rand_haiku) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int res'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [res] = int 
var: res (res) = SUCCESS
var: int res (res) = SUCCESS
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
=> ['TRUE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: count (count) = cgc_get_count ( )
var: uint32_t count (count) = cgc_get_count ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [2.2]  uint32_t : count
Resolved type: [2.3]  uint32_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_EMPTY ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == count ) { return ERR_LIST_EMPTY ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_EMPTY ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t * * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = uint32_t * * 
var: tlv3 (tlv3) = id_arr
var: uint32_t * * tlv3 (tlv3) = id_arr
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = uint32_t 
var: tlv2 (tlv2) = count
var: uint32_t tlv2 (tlv2) = count
var: res (res) = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 )
var: int res (res) = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; }
Assigns = [('uint32_t * *', 'tlv3', '', 'id_arr'), ('uint32_t', 'tlv2', '', 'count'), ('int', 'res', '', 'cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = uint32_t * 
var: tlv4 (tlv4) = & random_idx
var: uint32_t * tlv4 (tlv4) = & random_idx
var: res (res) = cgc_get_random_idx ( tlv4 )
var: int res (res) = cgc_get_random_idx ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; }
Assigns = [('uint32_t *', 'tlv4', '', '& random_idx'), ('int', 'res', '', 'cgc_get_random_idx ( tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ERR_RAND_FAILED != res
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ERR_RAND_FAILED
[2] <class 'CParser.CParser.RelationalExpressionContext'> => res
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ERR_RAND_FAILED != res
=> ['ERR_RAND_FAILED', 'res']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ERR_RAND_FAILED
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ERR_RAND_FAILED']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ERR_RAND_FAILED']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ERR_RAND_FAILED']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ERR_RAND_FAILED']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ERR_RAND_FAILED']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ERR_RAND_FAILED']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ERR_RAND_FAILED']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : res
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['res']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['res']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['res']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['res']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['res']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['res']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['res']
FOUND IT! [2.2]  int : res
Resolved type: [2.3]  int : res
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ERR_RAND_FAILED != res ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct haiku * * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = struct haiku * * 
var: tlv6 (tlv6) = & rand_haiku
var: struct haiku * * tlv6 (tlv6) = & rand_haiku
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = uint32_t 
var: tlv5 (tlv5) = id_arr [ random_idx ]
var: uint32_t tlv5 (tlv5) = id_arr [ random_idx ]
var: res (res) = cgc_find_haiku_with_id ( tlv6 , tlv5 )
var: int res (res) = cgc_find_haiku_with_id ( tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; }
Assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]'), ('int', 'res', '', 'cgc_find_haiku_with_id ( tlv6 , tlv5 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => SUCCESS == res
[0] <class 'CParser.CParser.RelationalExpressionContext'> => SUCCESS
[2] <class 'CParser.CParser.RelationalExpressionContext'> => res
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => SUCCESS == res
=> ['SUCCESS', 'res']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : SUCCESS
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['SUCCESS']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['SUCCESS']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['SUCCESS']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['SUCCESS']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['SUCCESS']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['SUCCESS']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['SUCCESS']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : res
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['res']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['res']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['res']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['res']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['res']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['res']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['res']
FOUND IT! [2.2]  int : res
Resolved type: [2.3]  int : res
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ SUCCESS == res ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_send_haiku'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( rand_haiku )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_send_haiku ( rand_haiku ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_send_haiku ( rand_haiku ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == count ) { return ERR_LIST_EMPTY ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } ]
Assigns = [('uint32_t', 'count', '', 'cgc_get_count ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: res (res) = ERR_LIST_NOT_EXIST
var: int res (res) = ERR_LIST_NOT_EXIST
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { res = ERR_LIST_NOT_EXIST ; }
Assigns = [('int', 'res', '', 'ERR_LIST_NOT_EXIST')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { res = ERR_LIST_NOT_EXIST ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } ]
Assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS'), ('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_get_haiku_cgc_random ( ) { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_haiku_count ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = uint32_t 
var: count (count) = 0
var: uint32_t count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
=> ['TRUE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: count (count) = cgc_get_count ( )
var: uint32_t count (count) = cgc_get_count ( )
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SENDUI'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( count )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [(] = SENDUI * 
[C-t-2] sym_dict [( count )] = SENDUI 
[C-t-3] sym_dict [count] = SENDUI 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; }
Assigns = [('uint32_t', 'count', '', 'cgc_get_count ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_NOT_EXIST ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_NOT_EXIST ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } ]
Assigns = [('uint32_t', 'count', '', '0'), ('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_get_haiku_count ( ) { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_haiku_ids ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint8_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = uint8_t 
var: tlv1 (tlv1) = cgc_haiku_list_exists ( )
var: uint8_t tlv1 (tlv1) = cgc_haiku_list_exists ( )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => TRUE
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => TRUE == tlv1
=> ['TRUE', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : TRUE
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['TRUE']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['TRUE']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['TRUE']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['TRUE']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['TRUE']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['TRUE']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['TRUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  uint8_t : tlv1
Resolved type: [2.3]  uint8_t : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = uint32_t 
var: count (count) = ( uint32_t ) cgc_get_count ( )
var: uint32_t count (count) = ( uint32_t ) cgc_get_count ( )
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SENDUI'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( count )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [(] = SENDUI * 
[C-t-2] sym_dict [( count )] = SENDUI 
[C-t-3] sym_dict [count] = SENDUI 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'node_t * hl_ptr'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [hl_ptr] = node_t * 
var: hl_ptr (hl_ptr) = cgc_haiku_list -> head
var: node_t * hl_ptr (hl_ptr) = cgc_haiku_list -> head
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL != hl_ptr
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => hl_ptr
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL != hl_ptr
=> ['NULL', 'hl_ptr']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : hl_ptr
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['hl_ptr']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['hl_ptr']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['hl_ptr']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['hl_ptr']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['hl_ptr']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['hl_ptr']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['hl_ptr']
FOUND IT! [2.2]  node_t * : hl_ptr
Resolved type: [2.3]  node_t * : hl_ptr
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [id] = uint32_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'node_t * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = node_t * 
var: tlv2 (tlv2) = hl_ptr
var: node_t * tlv2 (tlv2) = hl_ptr
var: id (id) = cgc_get_id_from_haiku ( tlv2 )
var: uint32_t id (id) = cgc_get_id_from_haiku ( tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; }
Assigns = [('node_t *', 'tlv2', '', 'hl_ptr'), ('uint32_t', 'id', '', 'cgc_get_id_from_haiku ( tlv2 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SENDUI'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( id )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [(] = SENDUI * 
[C-t-2] sym_dict [( id )] = SENDUI 
[C-t-3] sym_dict [id] = SENDUI 
var: hl_ptr (hl_ptr) = hl_ptr -> next
var: node_t * hl_ptr (hl_ptr) = hl_ptr -> next
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } ]
Assigns = [('node_t *', 'hl_ptr', '', 'hl_ptr -> next')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } ]
Assigns = [('uint32_t', 'count', '', '( uint32_t ) cgc_get_count ( )'), ('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ TRUE == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ERR_LIST_NOT_EXIST ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ERR_LIST_NOT_EXIST ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } ]
Assigns = [('uint8_t', 'tlv1', '', 'cgc_haiku_list_exists ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_get_haiku_ids ( ) { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; } ]
compound scope 0 : { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; } ] 
p_decls = [('uint32_t *', 'num', ' [ 1 ]'), ('uint32_t', 'num [ 1 ]', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'num', ' [ 1 ]'), ('uint32_t', 'num [ 1 ]', None)]
assigns = []
compares = []
===> context { uint32_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint32_t ) ) ; return num [ 0 ] ; }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t *, var: num
1 : |  decl_scope  | type: uint32_t, var: num [ 1 ]
=======END=======
compound scope 0 : { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; } ] 
p_decls = [('uint16_t *', 'num', ' [ 1 ]'), ('uint16_t', 'num [ 1 ]', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint16_t *', 'num', ' [ 1 ]'), ('uint16_t', 'num [ 1 ]', None)]
assigns = []
compares = []
===> context { uint16_t num [ 1 ] = { 0 } ; RECV ( num , sizeof ( uint16_t ) ) ; return num [ 0 ] ; }
ignore sibs: []
0 : |  decl_scope  | type: uint16_t *, var: num
1 : |  decl_scope  | type: uint16_t, var: num [ 1 ]
=======END=======
compound scope 0 : { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } }
compound scope 1 : { return FALSE ; }
compound scope 2 : { return TRUE ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { if ( NULL == cgc_haiku_list ) { return FALSE ; } else { return TRUE ; } }
ignore sibs: []
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return FALSE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return FALSE ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = ['', '']
===> context { return FALSE ; }
ignore sibs: ['else', '{ return TRUE ; }', '}']
0 : |compare_scopes| type: UNDEF, value: NULL
1 : |compare_scopes| type: UNDEF, value: cgc_haiku_list
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return TRUE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return TRUE ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = []
===> context { return TRUE ; }
ignore sibs: ['}']
=======END=======
compound scope 0 : { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } }
compound scope 1 : { return TRUE ; }
compound scope 2 : { return FALSE ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { if ( 0 == cgc_haiku_list -> count ) { return TRUE ; } else { return FALSE ; } }
ignore sibs: []
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return TRUE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return TRUE ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = ['', '']
===> context { return TRUE ; }
ignore sibs: ['else', '{ return FALSE ; }', '}']
0 : |compare_scopes| type: UNDEF, value: 0
1 : |compare_scopes| type: UNDEF, value: cgc_haiku_list -> count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return FALSE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return FALSE ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = []
===> context { return FALSE ; }
ignore sibs: ['}']
=======END=======
compound scope 0 : { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } }
compound scope 1 : { cgc_haiku_list = cgc_list_create ( ) ; }
len(compound_scope) : 2
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } } ] 
p_decls = [('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
===> context { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_haiku_list = cgc_list_create ( ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: uint8_t, var: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_haiku_list = cgc_list_create ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_haiku_list = cgc_list_create ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = ['', '']
===> context { cgc_haiku_list = cgc_list_create ( ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: uint8_t, var: tlv1
0 : |compare_scopes| type: uint8_t, value: FALSE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
compound scope 0 : { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } }
compound scope 1 : { return cgc_haiku_list -> count ; }
compound scope 2 : { return ERR_LIST_NOT_EXIST ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } } ] 
p_decls = [('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
===> context { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { return cgc_haiku_list -> count ; } else { return ERR_LIST_NOT_EXIST ; } }
ignore sibs: []
0 : |  decl_scope  | type: uint8_t, var: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return cgc_haiku_list -> count ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return cgc_haiku_list -> count ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = ['', '']
===> context { return cgc_haiku_list -> count ; }
ignore sibs: ['else', '{ return ERR_LIST_NOT_EXIST ; }', '}']
0 : |  decl_scope  | type: uint8_t, var: tlv1
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
===> context { return ERR_LIST_NOT_EXIST ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: uint8_t, var: tlv1
=======END=======
compound scope 0 : { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } }
compound scope 1 : { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; }
compound scope 2 : { return ERR_EMPTY_NODE ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('node_t *', 'haiku', None)]
assigns = []
compares = []
===> context { if ( NULL != haiku -> data ) { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } else { return ERR_EMPTY_NODE ; } }
ignore sibs: []
0 : |  decl_scope  | type: node_t *, var: haiku
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; } ] 
p_decls = [('struct haiku *', 'h', None)]
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku *', 'h', None), ('node_t *', 'haiku', None)]
assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku -> data')]
compares = []
decls = [('struct haiku *', 'h', None), ('node_t *', 'haiku', None)]
assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku -> data')]
compares = []
decls = [('struct haiku *', 'h', None), ('node_t *', 'haiku', None)]
assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku -> data')]
compares = ['', '']
===> context { struct haiku * h ; h = ( struct haiku * ) haiku -> data ; return h -> id ; }
ignore sibs: ['else', '{ return ERR_EMPTY_NODE ; }', '}']
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: node_t *, var: haiku
0 : | assign_scope | type: struct haiku *, value: ( struct haiku * ) haiku -> data
0 : |compare_scopes| type: node_t *, value: NULL
1 : |compare_scopes| type: node_t *, value: haiku -> data
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_EMPTY_NODE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_EMPTY_NODE ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('node_t *', 'haiku', None)]
assigns = []
compares = []
decls = [('node_t *', 'haiku', None)]
assigns = []
compares = []
===> context { return ERR_EMPTY_NODE ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: node_t *, var: haiku
=======END=======
compound scope 0 : { next_haiku_id ++ ; return next_haiku_id - 1 ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { next_haiku_id ++ ; return next_haiku_id - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { next_haiku_id ++ ; return next_haiku_id - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { next_haiku_id ++ ; return next_haiku_id - 1 ; }
ignore sibs: []
=======END=======
compound scope 0 : { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } }
compound scope 1 : { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; }
compound scope 2 : { return count ; }
compound scope 3 : { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } }
compound scope 4 : { return ERR_LIST_EMPTY ; }
compound scope 5 : { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } }
compound scope 6 : { return ERR_RAND_FAILED ; }
compound scope 7 : { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; }
len(compound_scope) : 8
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } } ] 
p_decls = [('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None), ('uint32_t *', 'idx', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { uint32_t random_idx ; random_idx = 0 ; int ret ; ret = 0 ; { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } int32_t count ; count = cgc_get_count ( ) ; if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: int32_t, var: count
3 : |  decl_scope  | type: uint32_t *, var: idx
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; } ] 
p_decls = [('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('uint32_t *', 'idx', None)]
assigns = [('char *', 'tlv2', '', '( char * ) & random_idx'), ('cgc_size_t', 'tlv1', '', '4')]
compares = []
decls = [('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv2', '', '( char * ) & random_idx'), ('cgc_size_t', 'tlv1', '', '4'), ('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv2 ; tlv2 = ( char * ) & random_idx ; cgc_size_t tlv1 ; tlv1 = 4 ; ret = cgc_rand ( tlv2 , tlv1 ) ; }
ignore sibs: ['int32_t count ;', 'count = cgc_get_count ( ) ;', 'if ( ERR_LIST_NOT_EXIST == count ) { return count ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } }', '}']
0 : |  decl_scope  | type: char *, var: tlv2
1 : |  decl_scope  | type: cgc_size_t, var: tlv1
2 : |  decl_scope  | type: uint32_t *, var: idx
3 : |  decl_scope  | type: uint32_t, var: random_idx
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: ( char * ) & random_idx
1 : | assign_scope | type: cgc_size_t, value: 4
2 : | assign_scope | type: uint32_t, value: 0
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return count ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return count ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'idx', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { return count ; }
ignore sibs: ['else', '{ if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } }', '}']
0 : |  decl_scope  | type: uint32_t *, var: idx
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int32_t, var: count
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int32_t, value: ERR_LIST_NOT_EXIST
1 : |compare_scopes| type: int32_t, value: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'idx', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } }
ignore sibs: ['}']
0 : |  decl_scope  | type: uint32_t *, var: idx
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int32_t, var: count
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'idx', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { return ERR_LIST_EMPTY ; }
ignore sibs: ['else', '{ if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } }', '}', '}']
0 : |  decl_scope  | type: uint32_t *, var: idx
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int32_t, var: count
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int32_t, value: 0
1 : |compare_scopes| type: int32_t, value: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'idx', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { if ( 0 != ret ) { return ERR_RAND_FAILED ; } else { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } }
ignore sibs: ['}', '}']
0 : |  decl_scope  | type: uint32_t *, var: idx
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int32_t, var: count
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_RAND_FAILED ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_RAND_FAILED ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'idx', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { return ERR_RAND_FAILED ; }
ignore sibs: ['else', '{ * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; }', '}', '}', '}']
0 : |  decl_scope  | type: uint32_t *, var: idx
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int32_t, var: count
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: ret
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'idx', None)]
assigns = [('UNDEF', '* idx', '', 'random_idx % ( uint32_t ) count')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('UNDEF', '* idx', '', 'random_idx % ( uint32_t ) count'), ('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('UNDEF', '* idx', '', 'random_idx % ( uint32_t ) count'), ('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('uint32_t *', 'idx', None), ('uint32_t', 'random_idx', None), ('int', 'ret', None), ('int32_t', 'count', None)]
assigns = [('UNDEF', '* idx', '', 'random_idx % ( uint32_t ) count'), ('uint32_t', 'random_idx', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { * idx = random_idx % ( uint32_t ) count ; return SUCCESS ; }
ignore sibs: ['}', '}', '}']
0 : |  decl_scope  | type: uint32_t *, var: idx
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int32_t, var: count
0 : | assign_scope | type: UNDEF, value: random_idx % ( uint32_t ) count
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
compound scope 0 : { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; }
compound scope 1 : { haiku_ptr = cgc_haiku_list -> tail ; }
compound scope 2 : { return ERR_LIST_NOT_EXIST ; }
compound scope 3 : { return ERR_LIST_EMPTY ; }
compound scope 4 : { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; } ] 
p_decls = [('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None), ('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = []
===> context { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { haiku_ptr = cgc_haiku_list -> tail ; } else { return ERR_LIST_NOT_EXIST ; } if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; } while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: node_t *, var: haiku_ptr
1 : |  decl_scope  | type: struct haiku *, var: h
2 : |  decl_scope  | type: uint32_t, var: id
3 : |  decl_scope  | type: uint8_t, var: tlv1
4 : |  decl_scope  | type: uint32_t *, var: id_arr
5 : |  decl_scope  | type: uint32_t, var: id_arr [ ]
6 : |  decl_scope  | type: uint32_t, var: count
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: uint32_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { haiku_ptr = cgc_haiku_list -> tail ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { haiku_ptr = cgc_haiku_list -> tail ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> tail')]
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> tail'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> tail'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = ['', '']
===> context { haiku_ptr = cgc_haiku_list -> tail ; }
ignore sibs: ['else', '{ return ERR_LIST_NOT_EXIST ; }', 'if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; }', 'while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint32_t *, var: id_arr
1 : |  decl_scope  | type: uint32_t, var: id_arr [ ]
2 : |  decl_scope  | type: uint32_t, var: count
3 : |  decl_scope  | type: node_t *, var: haiku_ptr
4 : |  decl_scope  | type: struct haiku *, var: h
5 : |  decl_scope  | type: uint32_t, var: id
6 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: node_t *, value: cgc_haiku_list -> tail
1 : | assign_scope | type: node_t *, value: NULL
2 : | assign_scope | type: struct haiku *, value: NULL
3 : | assign_scope | type: uint32_t, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = []
===> context { return ERR_LIST_NOT_EXIST ; }
ignore sibs: ['if ( ( 0 == count ) || ( NULL == haiku_ptr ) ) { return ERR_LIST_EMPTY ; }', 'while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint32_t *, var: id_arr
1 : |  decl_scope  | type: uint32_t, var: id_arr [ ]
2 : |  decl_scope  | type: uint32_t, var: count
3 : |  decl_scope  | type: node_t *, var: haiku_ptr
4 : |  decl_scope  | type: struct haiku *, var: h
5 : |  decl_scope  | type: uint32_t, var: id
6 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: uint32_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None)]
assigns = []
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = ['', '', '', '']
===> context { return ERR_LIST_EMPTY ; }
ignore sibs: ['while ( ( 0 < count ) && ( NULL != haiku_ptr ) ) { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint32_t *, var: id_arr
1 : |  decl_scope  | type: uint32_t, var: id_arr [ ]
2 : |  decl_scope  | type: uint32_t, var: count
3 : |  decl_scope  | type: node_t *, var: haiku_ptr
4 : |  decl_scope  | type: struct haiku *, var: h
5 : |  decl_scope  | type: uint32_t, var: id
6 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: uint32_t, value: 0
0 : |compare_scopes| type: uint32_t, value: 0
1 : |compare_scopes| type: uint32_t, value: count
2 : |compare_scopes| type: node_t *, value: NULL
3 : |compare_scopes| type: node_t *, value: haiku_ptr
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None)]
assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku_ptr -> data'), ('UNDEF', 'id_arr ', '[ count - 1 ]', 'h -> id'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> prev')]
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku_ptr -> data'), ('UNDEF', 'id_arr ', '[ count - 1 ]', 'h -> id'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> prev'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = []
decls = [('uint32_t *', 'id_arr', ' [ ]'), ('uint32_t', 'id_arr [ ]', None), ('uint32_t', 'count', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', '( struct haiku * ) haiku_ptr -> data'), ('UNDEF', 'id_arr ', '[ count - 1 ]', 'h -> id'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> prev'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0')]
compares = ['', '', '', '']
===> context { h = ( struct haiku * ) haiku_ptr -> data ; id_arr [ count - 1 ] = h -> id ; count -- ; haiku_ptr = haiku_ptr -> prev ; }
ignore sibs: ['return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint32_t *, var: id_arr
1 : |  decl_scope  | type: uint32_t, var: id_arr [ ]
2 : |  decl_scope  | type: uint32_t, var: count
3 : |  decl_scope  | type: node_t *, var: haiku_ptr
4 : |  decl_scope  | type: struct haiku *, var: h
5 : |  decl_scope  | type: uint32_t, var: id
6 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: ( struct haiku * ) haiku_ptr -> data
1 : | assign_scope | type: UNDEF, value: h -> id
2 : | assign_scope | type: node_t *, value: haiku_ptr -> prev
3 : | assign_scope | type: node_t *, value: NULL
4 : | assign_scope | type: struct haiku *, value: NULL
5 : | assign_scope | type: uint32_t, value: 0
0 : |compare_scopes| type: uint32_t, value: 0
1 : |compare_scopes| type: uint32_t, value: count
2 : |compare_scopes| type: node_t *, value: NULL
3 : |compare_scopes| type: node_t *, value: haiku_ptr
=======END=======
compound scope 0 : { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } }
compound scope 1 : { haiku_ptr = cgc_haiku_list -> head ; }
compound scope 2 : { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } }
compound scope 3 : { return ERR_LIST_EMPTY ; }
compound scope 4 : { return ERR_LIST_NOT_EXIST ; }
compound scope 5 : { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }
compound scope 6 : { * h = tmp ; found = TRUE ; break ; }
compound scope 7 : { return SUCCESS ; }
compound scope 8 : { return ERR_INVALID_ID ; }
len(compound_scope) : 9
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } } ] 
p_decls = [('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None), ('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
===> context { node_t * haiku_ptr ; haiku_ptr = NULL ; struct haiku * tmp ; tmp = NULL ; int count ; count = 0 ; bool_t found ; found = FALSE ; count = cgc_get_count ( ) ; if ( 0 < count ) { haiku_ptr = cgc_haiku_list -> head ; } else { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; } }
ignore sibs: []
0 : |  decl_scope  | type: node_t *, var: haiku_ptr
1 : |  decl_scope  | type: struct haiku *, var: tmp
2 : |  decl_scope  | type: int, var: count
3 : |  decl_scope  | type: bool_t, var: found
4 : |  decl_scope  | type: struct haiku * *, var: h
5 : |  decl_scope  | type: uint32_t, var: id
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: bool_t, value: FALSE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { haiku_ptr = cgc_haiku_list -> head ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { haiku_ptr = cgc_haiku_list -> head ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> head')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> head'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'cgc_haiku_list -> head'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = ['', '']
===> context { haiku_ptr = cgc_haiku_list -> head ; }
ignore sibs: ['else', '{ if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } }', 'while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }', 'if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: node_t *, value: cgc_haiku_list -> head
1 : | assign_scope | type: node_t *, value: NULL
2 : | assign_scope | type: struct haiku *, value: NULL
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: bool_t, value: FALSE
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = []
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
===> context { if ( 0 == count ) { return ERR_LIST_EMPTY ; } else { return ERR_LIST_NOT_EXIST ; } }
ignore sibs: ['while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }', 'if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: bool_t, value: FALSE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = []
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = ['', '']
===> context { return ERR_LIST_EMPTY ; }
ignore sibs: ['else', '{ return ERR_LIST_NOT_EXIST ; }', '}', 'while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }', 'if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: bool_t, value: FALSE
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = []
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
===> context { return ERR_LIST_NOT_EXIST ; }
ignore sibs: ['}', 'while ( NULL != haiku_ptr ) { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }', 'if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: bool_t, value: FALSE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = [('struct haiku *', 'tmp', '', '( struct haiku * ) haiku_ptr -> data'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> next')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('struct haiku *', 'tmp', '', '( struct haiku * ) haiku_ptr -> data'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> next'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('struct haiku *', 'tmp', '', '( struct haiku * ) haiku_ptr -> data'), ('node_t *', 'haiku_ptr', '', 'haiku_ptr -> next'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = ['', '']
===> context { tmp = ( struct haiku * ) haiku_ptr -> data ; if ( id == tmp -> id ) { * h = tmp ; found = TRUE ; break ; } haiku_ptr = haiku_ptr -> next ; }
ignore sibs: ['if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: struct haiku *, value: ( struct haiku * ) haiku_ptr -> data
1 : | assign_scope | type: node_t *, value: haiku_ptr -> next
2 : | assign_scope | type: node_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: bool_t, value: FALSE
0 : |compare_scopes| type: node_t *, value: NULL
1 : |compare_scopes| type: node_t *, value: haiku_ptr
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { * h = tmp ; found = TRUE ; break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { * h = tmp ; found = TRUE ; break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = [('UNDEF', '* h', '', 'tmp'), ('bool_t', 'found', '', 'TRUE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('UNDEF', '* h', '', 'tmp'), ('bool_t', 'found', '', 'TRUE'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('UNDEF', '* h', '', 'tmp'), ('bool_t', 'found', '', 'TRUE'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = ['', '']
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('UNDEF', '* h', '', 'tmp'), ('bool_t', 'found', '', 'TRUE'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE'), ('struct haiku *', 'tmp', '', '( struct haiku * ) haiku_ptr -> data')]
compares = ['', '']
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('UNDEF', '* h', '', 'tmp'), ('bool_t', 'found', '', 'TRUE'), ('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE'), ('struct haiku *', 'tmp', '', '( struct haiku * ) haiku_ptr -> data')]
compares = ['', '', '', '']
===> context { * h = tmp ; found = TRUE ; break ; }
ignore sibs: ['haiku_ptr = haiku_ptr -> next ;', '}', 'if ( TRUE == found ) { return SUCCESS ; } else { return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: UNDEF, value: tmp
1 : | assign_scope | type: bool_t, value: TRUE
2 : | assign_scope | type: node_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: bool_t, value: FALSE
6 : | assign_scope | type: struct haiku *, value: ( struct haiku * ) haiku_ptr -> data
0 : |compare_scopes| type: node_t *, value: NULL
1 : |compare_scopes| type: node_t *, value: haiku_ptr
2 : |compare_scopes| type: uint32_t, value: id
3 : |compare_scopes| type: uint32_t, value: tmp -> id
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return SUCCESS ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = []
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = ['', '']
===> context { return SUCCESS ; }
ignore sibs: ['else', '{ return ERR_INVALID_ID ; }', '}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: bool_t, value: FALSE
0 : |compare_scopes| type: bool_t, value: TRUE
1 : |compare_scopes| type: bool_t, value: found
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_INVALID_ID ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_INVALID_ID ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None)]
assigns = []
compares = []
decls = [('struct haiku * *', 'h', None), ('uint32_t', 'id', None), ('node_t *', 'haiku_ptr', None), ('struct haiku *', 'tmp', None), ('int', 'count', None), ('bool_t', 'found', None)]
assigns = [('node_t *', 'haiku_ptr', '', 'NULL'), ('struct haiku *', 'tmp', '', 'NULL'), ('int', 'count', '', '0'), ('bool_t', 'found', '', 'FALSE')]
compares = []
===> context { return ERR_INVALID_ID ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: struct haiku * *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: node_t *, var: haiku_ptr
3 : |  decl_scope  | type: struct haiku *, var: tmp
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: bool_t, var: found
0 : | assign_scope | type: node_t *, value: NULL
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: bool_t, value: FALSE
=======END=======
compound scope 0 : { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
compound scope 1 : { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }
compound scope 2 : { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }
compound scope 3 : { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } } ] 
p_decls = [('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None), ('struct haiku *', 'h', None)]
assigns = [('uint32_t', 'id', '', 'h -> id'), ('char *', 'content', '', 'h -> content'), ('uint16_t', 'length', '', 'h -> length')]
compares = []
===> context { uint32_t id ; id = h -> id ; char * content ; content = h -> content ; uint16_t length ; length = h -> length ; { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t, var: id
1 : |  decl_scope  | type: char *, var: content
2 : |  decl_scope  | type: uint16_t, var: length
3 : |  decl_scope  | type: struct haiku *, var: h
0 : | assign_scope | type: uint32_t, value: h -> id
1 : | assign_scope | type: char *, value: h -> content
2 : | assign_scope | type: uint16_t, value: h -> length
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } ] 
p_decls = [('const char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('struct haiku *', 'h', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'sizeof ( uint32_t )')]
compares = []
decls = [('const char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'sizeof ( uint32_t )'), ('uint32_t', 'id', '', 'h -> id'), ('char *', 'content', '', 'h -> content'), ('uint16_t', 'length', '', 'h -> length')]
compares = []
===> context { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }
ignore sibs: ['{ const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }', '{ const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv2
1 : |  decl_scope  | type: cgc_size_t, var: tlv1
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint32_t, var: id
4 : |  decl_scope  | type: char *, var: content
5 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: cgc_size_t, value: sizeof ( uint32_t )
1 : | assign_scope | type: uint32_t, value: h -> id
2 : | assign_scope | type: char *, value: h -> content
3 : | assign_scope | type: uint16_t, value: h -> length
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } ] 
p_decls = [('const char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('struct haiku *', 'h', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( uint16_t )')]
compares = []
decls = [('const char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( uint16_t )'), ('uint32_t', 'id', '', 'h -> id'), ('char *', 'content', '', 'h -> content'), ('uint16_t', 'length', '', 'h -> length')]
compares = []
===> context { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }
ignore sibs: ['{ const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv4
1 : |  decl_scope  | type: cgc_size_t, var: tlv3
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint32_t, var: id
4 : |  decl_scope  | type: char *, var: content
5 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: cgc_size_t, value: sizeof ( uint16_t )
1 : | assign_scope | type: uint32_t, value: h -> id
2 : | assign_scope | type: char *, value: h -> content
3 : | assign_scope | type: uint16_t, value: h -> length
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('struct haiku *', 'h', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'length')]
compares = []
decls = [('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'length'), ('uint32_t', 'id', '', 'h -> id'), ('char *', 'content', '', 'h -> content'), ('uint16_t', 'length', '', 'h -> length')]
compares = []
===> context { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: cgc_size_t, var: tlv5
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint32_t, var: id
4 : |  decl_scope  | type: char *, var: content
5 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: cgc_size_t, value: length
1 : | assign_scope | type: uint32_t, value: h -> id
2 : | assign_scope | type: char *, value: h -> content
3 : | assign_scope | type: uint16_t, value: h -> length
=======END=======
compound scope 0 : { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
compound scope 1 : { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; }
compound scope 2 : { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }
compound scope 3 : { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }
compound scope 4 : { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } } ] 
p_decls = [('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('uint32_t', 'id', '', 'EGG_ID'), ('char *', 'content', '', 'EGG_HAIKU')]
compares = []
===> context { uint32_t id ; id = EGG_ID ; char * content ; content = EGG_HAIKU ; uint16_t length ; { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t, var: id
1 : |  decl_scope  | type: char *, var: content
2 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: uint32_t, value: EGG_ID
1 : | assign_scope | type: char *, value: EGG_HAIKU
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; } ] 
p_decls = [('const char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv7', None)]
assigns = [('uint16_t', 'length', '', 'cgc_strlen ( tlv7 )')]
compares = []
decls = [('const char *', 'tlv7', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('uint16_t', 'length', '', 'cgc_strlen ( tlv7 )'), ('uint32_t', 'id', '', 'EGG_ID'), ('char *', 'content', '', 'EGG_HAIKU')]
compares = []
===> context { const char * tlv7 = content ; length = cgc_strlen ( tlv7 ) ; }
ignore sibs: ['{ const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }', '{ const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }', '{ const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv7
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: char *, var: content
3 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: uint16_t, value: cgc_strlen ( tlv7 )
1 : | assign_scope | type: uint32_t, value: EGG_ID
2 : | assign_scope | type: char *, value: EGG_HAIKU
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; } ] 
p_decls = [('const char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'sizeof ( uint32_t )')]
compares = []
decls = [('const char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'sizeof ( uint32_t )'), ('uint32_t', 'id', '', 'EGG_ID'), ('char *', 'content', '', 'EGG_HAIKU')]
compares = []
===> context { const char * tlv2 = ( char * ) & id ; cgc_size_t tlv1 ; tlv1 = sizeof ( uint32_t ) ; cgc_send ( tlv2 , tlv1 ) ; }
ignore sibs: ['{ const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }', '{ const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv2
1 : |  decl_scope  | type: cgc_size_t, var: tlv1
2 : |  decl_scope  | type: uint32_t, var: id
3 : |  decl_scope  | type: char *, var: content
4 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: cgc_size_t, value: sizeof ( uint32_t )
1 : | assign_scope | type: uint32_t, value: EGG_ID
2 : | assign_scope | type: char *, value: EGG_HAIKU
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; } ] 
p_decls = [('const char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( uint16_t )')]
compares = []
decls = [('const char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( uint16_t )'), ('uint32_t', 'id', '', 'EGG_ID'), ('char *', 'content', '', 'EGG_HAIKU')]
compares = []
===> context { const char * tlv4 = ( char * ) & length ; cgc_size_t tlv3 ; tlv3 = sizeof ( uint16_t ) ; cgc_send ( tlv4 , tlv3 ) ; }
ignore sibs: ['{ const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }', '}']
0 : |  decl_scope  | type: const char *, var: tlv4
1 : |  decl_scope  | type: cgc_size_t, var: tlv3
2 : |  decl_scope  | type: uint32_t, var: id
3 : |  decl_scope  | type: char *, var: content
4 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: cgc_size_t, value: sizeof ( uint16_t )
1 : | assign_scope | type: uint32_t, value: EGG_ID
2 : | assign_scope | type: char *, value: EGG_HAIKU
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'length')]
compares = []
decls = [('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('uint32_t', 'id', None), ('char *', 'content', None), ('uint16_t', 'length', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'length'), ('uint32_t', 'id', '', 'EGG_ID'), ('char *', 'content', '', 'EGG_HAIKU')]
compares = []
===> context { const char * tlv6 = content ; cgc_size_t tlv5 ; tlv5 = length ; cgc_send ( tlv6 , tlv5 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: cgc_size_t, var: tlv5
2 : |  decl_scope  | type: uint32_t, var: id
3 : |  decl_scope  | type: char *, var: content
4 : |  decl_scope  | type: uint16_t, var: length
0 : | assign_scope | type: cgc_size_t, value: length
1 : | assign_scope | type: uint32_t, value: EGG_ID
2 : | assign_scope | type: char *, value: EGG_HAIKU
=======END=======
compound scope 0 : { SENDUI ( id ) ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SENDUI ( id ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SENDUI ( id ) ; } ] 
p_decls = [('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None), ('uint32_t', 'id', None)]
assigns = []
compares = []
===> context { SENDUI ( id ) ; }
ignore sibs: []
0 : |  decl_scope  | type: SENDUI *, var: (
1 : |  decl_scope  | type: SENDUI, var: ( id )
2 : |  decl_scope  | type: SENDUI, var: id
3 : |  decl_scope  | type: uint32_t, var: id
=======END=======
compound scope 0 : { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; }
compound scope 1 : { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; }
len(compound_scope) : 2
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; } ] 
p_decls = [('node_t *', 'nd', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('node_t *', 'nd', None), ('struct haiku *', 'h', None)]
assigns = []
compares = []
===> context { node_t * nd ; { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } return cgc_list_push ( cgc_haiku_list , nd ) ; }
ignore sibs: []
0 : |  decl_scope  | type: node_t *, var: nd
1 : |  decl_scope  | type: struct haiku *, var: h
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; } ] 
p_decls = [('void *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv1', None), ('struct haiku *', 'h', None)]
assigns = [('void *', 'tlv1', '', '( void * ) h')]
compares = []
decls = [('void *', 'tlv1', None), ('struct haiku *', 'h', None), ('node_t *', 'nd', None)]
assigns = [('void *', 'tlv1', '', '( void * ) h')]
compares = []
===> context { void * tlv1 ; tlv1 = ( void * ) h ; nd = cgc_node_create ( tlv1 ) ; }
ignore sibs: ['return cgc_list_push ( cgc_haiku_list , nd ) ;', '}']
0 : |  decl_scope  | type: void *, var: tlv1
1 : |  decl_scope  | type: struct haiku *, var: h
2 : |  decl_scope  | type: node_t *, var: nd
0 : | assign_scope | type: void *, value: ( void * ) h
=======END=======
compound scope 0 : { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; }
compound scope 1 : { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { return ERR_INVALID_HAIKU ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; } ] 
p_decls = [('char *', 'temp_line_buf', ' [ MAX_HAIKU_LINE_LEN ]'), ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None), ('int16_t', 'bytes_received', None), ('int16_t', 'bytes_written', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'temp_line_buf', ' [ MAX_HAIKU_LINE_LEN ]'), ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None), ('int16_t', 'bytes_received', None), ('int16_t', 'bytes_written', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None)]
assigns = [('int16_t', 'bytes_received', '', '0'), ('int16_t', 'bytes_written', '', '0')]
compares = []
===> context { char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ; int16_t bytes_received ; bytes_received = 0 ; int16_t bytes_written ; bytes_written = 0 ; { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; } bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\x07" , temp_line_buf ) ; return bytes_written ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: temp_line_buf
1 : |  decl_scope  | type: char, var: temp_line_buf [ MAX_HAIKU_LINE_LEN ]
2 : |  decl_scope  | type: int16_t, var: bytes_received
3 : |  decl_scope  | type: int16_t, var: bytes_written
4 : |  decl_scope  | type: char *, var: haiku_content_ptr
5 : |  decl_scope  | type: int16_t, var: bytes_remaining
0 : | assign_scope | type: int16_t, value: 0
1 : | assign_scope | type: int16_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None)]
assigns = [('int', 'tlv3', '', 'STDIN'), ('char *', 'tlv2', '', 'temp_line_buf'), ('cgc_size_t', 'tlv1', '', 'MAX_HAIKU_LINE_LEN')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('char *', 'temp_line_buf', ' [ MAX_HAIKU_LINE_LEN ]'), ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None), ('int16_t', 'bytes_received', None), ('int16_t', 'bytes_written', None)]
assigns = [('int', 'tlv3', '', 'STDIN'), ('char *', 'tlv2', '', 'temp_line_buf'), ('cgc_size_t', 'tlv1', '', 'MAX_HAIKU_LINE_LEN'), ('int16_t', 'bytes_received', '', '0'), ('int16_t', 'bytes_written', '', '0')]
compares = []
===> context { int tlv3 ; tlv3 = STDIN ; char * tlv2 ; tlv2 = temp_line_buf ; cgc_size_t tlv1 ; tlv1 = MAX_HAIKU_LINE_LEN ; bytes_received = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( 0 > bytes_received ) { return ERR_INVALID_HAIKU ; }', 'bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\\x07" , temp_line_buf ) ;', 'return bytes_written ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: char *, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: char *, var: haiku_content_ptr
4 : |  decl_scope  | type: int16_t, var: bytes_remaining
5 : |  decl_scope  | type: char *, var: temp_line_buf
6 : |  decl_scope  | type: char, var: temp_line_buf [ MAX_HAIKU_LINE_LEN ]
7 : |  decl_scope  | type: int16_t, var: bytes_received
8 : |  decl_scope  | type: int16_t, var: bytes_written
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: char *, value: temp_line_buf
2 : | assign_scope | type: cgc_size_t, value: MAX_HAIKU_LINE_LEN
3 : | assign_scope | type: int16_t, value: 0
4 : | assign_scope | type: int16_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_INVALID_HAIKU ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_INVALID_HAIKU ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None)]
assigns = []
compares = []
decls = [('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('char *', 'temp_line_buf', ' [ MAX_HAIKU_LINE_LEN ]'), ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None), ('int16_t', 'bytes_received', None), ('int16_t', 'bytes_written', None)]
assigns = [('int16_t', 'bytes_received', '', '0'), ('int16_t', 'bytes_written', '', '0')]
compares = []
decls = [('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('char *', 'temp_line_buf', ' [ MAX_HAIKU_LINE_LEN ]'), ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None), ('int16_t', 'bytes_received', None), ('int16_t', 'bytes_written', None)]
assigns = [('int16_t', 'bytes_received', '', '0'), ('int16_t', 'bytes_written', '', '0')]
compares = ['', '']
===> context { return ERR_INVALID_HAIKU ; }
ignore sibs: ['bytes_written = cgc_snprintf ( haiku_content_ptr , bytes_remaining + 1 , "~c\\x07" , temp_line_buf ) ;', 'return bytes_written ;', '}']
0 : |  decl_scope  | type: char *, var: haiku_content_ptr
1 : |  decl_scope  | type: int16_t, var: bytes_remaining
2 : |  decl_scope  | type: char *, var: temp_line_buf
3 : |  decl_scope  | type: char, var: temp_line_buf [ MAX_HAIKU_LINE_LEN ]
4 : |  decl_scope  | type: int16_t, var: bytes_received
5 : |  decl_scope  | type: int16_t, var: bytes_written
0 : | assign_scope | type: int16_t, value: 0
1 : | assign_scope | type: int16_t, value: 0
0 : |compare_scopes| type: int16_t, value: 0
1 : |compare_scopes| type: int16_t, value: bytes_received
=======END=======
compound scope 0 : { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; }
compound scope 1 : { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; }
compound scope 2 : { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; }
compound scope 3 : { return NULL ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; } ] 
p_decls = [('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None), ('uint16_t', 'total_bytes', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content'), ('UNDEF', 'h -> length', '', 'total_bytes')]
compares = []
===> context { struct haiku * h ; h = NULL ; char * haiku_content_ptr ; haiku_content_ptr = NULL ; int16_t bytes_remaining ; bytes_remaining = 0 ; int16_t bytes_written ; bytes_written = 0 ; bytes_remaining = ( int16_t ) total_bytes ; ALLOC ( sizeof ( struct haiku ) + total_bytes + 1 , & h ) ; ; haiku_content_ptr = h -> content ; while ( 0 != bytes_remaining ) { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } h -> id = cgc_get_next_haiku_id ( ) ; h -> length = total_bytes ; return h ; }
ignore sibs: []
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: char *, var: haiku_content_ptr
2 : |  decl_scope  | type: int16_t, var: bytes_remaining
3 : |  decl_scope  | type: int16_t, var: bytes_written
4 : |  decl_scope  | type: uint16_t, var: total_bytes
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int16_t, value: 0
3 : | assign_scope | type: int16_t, value: 0
4 : | assign_scope | type: int16_t, value: ( int16_t ) total_bytes
5 : | assign_scope | type: char *, value: h -> content
6 : | assign_scope | type: UNDEF, value: total_bytes
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint16_t', 'total_bytes', None)]
assigns = [('char *', 'haiku_content_ptr', '', 'bytes_written'), ('int16_t', 'bytes_remaining', '', 'bytes_written')]
compares = []
decls = [('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('char *', 'haiku_content_ptr', '', 'bytes_written'), ('int16_t', 'bytes_remaining', '', 'bytes_written'), ('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = []
decls = [('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('char *', 'haiku_content_ptr', '', 'bytes_written'), ('int16_t', 'bytes_remaining', '', 'bytes_written'), ('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = ['']
===> context { { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } if ( 0 > bytes_written ) { return NULL ; } haiku_content_ptr += bytes_written ; bytes_remaining -= bytes_written ; }
ignore sibs: ['h -> id = cgc_get_next_haiku_id ( ) ;', 'h -> length = total_bytes ;', 'return h ;', '}']
0 : |  decl_scope  | type: uint16_t, var: total_bytes
1 : |  decl_scope  | type: struct haiku *, var: h
2 : |  decl_scope  | type: char *, var: haiku_content_ptr
3 : |  decl_scope  | type: int16_t, var: bytes_remaining
4 : |  decl_scope  | type: int16_t, var: bytes_written
0 : | assign_scope | type: char *, value: bytes_written
1 : | assign_scope | type: int16_t, value: bytes_written
2 : | assign_scope | type: struct haiku *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int16_t, value: 0
5 : | assign_scope | type: int16_t, value: 0
6 : | assign_scope | type: int16_t, value: ( int16_t ) total_bytes
7 : | assign_scope | type: char *, value: h -> content
0 : |compare_scopes| type: int16_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; } ] 
p_decls = [('char *', 'tlv2', None), ('int16_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv2', None), ('int16_t', 'tlv1', None), ('uint16_t', 'total_bytes', None)]
assigns = [('char *', 'tlv2', '', 'haiku_content_ptr')]
compares = []
decls = [('char *', 'tlv2', None), ('int16_t', 'tlv1', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('char *', 'tlv2', '', 'haiku_content_ptr'), ('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = []
decls = [('char *', 'tlv2', None), ('int16_t', 'tlv1', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('char *', 'tlv2', '', 'haiku_content_ptr'), ('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = ['']
decls = [('char *', 'tlv2', None), ('int16_t', 'tlv1', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('char *', 'tlv2', '', 'haiku_content_ptr'), ('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = ['']
===> context { char * tlv2 ; tlv2 = haiku_content_ptr ; int16_t tlv1 ; tlv1 = bytes_remaining ; bytes_written = cgc_recv_haiku_line ( tlv2 , tlv1 ) ; }
ignore sibs: ['if ( 0 > bytes_written ) { return NULL ; }', 'haiku_content_ptr += bytes_written ;', 'bytes_remaining -= bytes_written ;', '}', 'h -> id = cgc_get_next_haiku_id ( ) ;', 'h -> length = total_bytes ;', 'return h ;', '}']
0 : |  decl_scope  | type: char *, var: tlv2
1 : |  decl_scope  | type: int16_t, var: tlv1
2 : |  decl_scope  | type: uint16_t, var: total_bytes
3 : |  decl_scope  | type: struct haiku *, var: h
4 : |  decl_scope  | type: char *, var: haiku_content_ptr
5 : |  decl_scope  | type: int16_t, var: bytes_remaining
6 : |  decl_scope  | type: int16_t, var: bytes_written
0 : | assign_scope | type: char *, value: haiku_content_ptr
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int16_t, value: 0
4 : | assign_scope | type: int16_t, value: 0
5 : | assign_scope | type: int16_t, value: ( int16_t ) total_bytes
6 : | assign_scope | type: char *, value: h -> content
0 : |compare_scopes| type: int16_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return NULL ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return NULL ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint16_t', 'total_bytes', None)]
assigns = []
compares = []
decls = [('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = []
decls = [('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = ['']
decls = [('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = ['']
decls = [('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('char *', 'haiku_content_ptr', None), ('int16_t', 'bytes_remaining', None), ('int16_t', 'bytes_written', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('char *', 'haiku_content_ptr', '', 'NULL'), ('int16_t', 'bytes_remaining', '', '0'), ('int16_t', 'bytes_written', '', '0'), ('int16_t', 'bytes_remaining', '', '( int16_t ) total_bytes'), ('char *', 'haiku_content_ptr', '', 'h -> content')]
compares = ['', '', '']
===> context { return NULL ; }
ignore sibs: ['haiku_content_ptr += bytes_written ;', 'bytes_remaining -= bytes_written ;', '}', 'h -> id = cgc_get_next_haiku_id ( ) ;', 'h -> length = total_bytes ;', 'return h ;', '}']
0 : |  decl_scope  | type: uint16_t, var: total_bytes
1 : |  decl_scope  | type: struct haiku *, var: h
2 : |  decl_scope  | type: char *, var: haiku_content_ptr
3 : |  decl_scope  | type: int16_t, var: bytes_remaining
4 : |  decl_scope  | type: int16_t, var: bytes_written
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int16_t, value: 0
3 : | assign_scope | type: int16_t, value: 0
4 : | assign_scope | type: int16_t, value: ( int16_t ) total_bytes
5 : | assign_scope | type: char *, value: h -> content
0 : |compare_scopes| type: int16_t, value: 0
1 : |compare_scopes| type: int16_t, value: 0
2 : |compare_scopes| type: int16_t, value: bytes_written
=======END=======
compound scope 0 : { return cgc_recv_uint16 ( ) ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return cgc_recv_uint16 ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return cgc_recv_uint16 ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { return cgc_recv_uint16 ( ) ; }
ignore sibs: []
=======END=======
compound scope 0 : { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; }
compound scope 1 : { cgc_init_haiku_list ( ) ; }
compound scope 2 : { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } }
compound scope 3 : { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; }
compound scope 4 : { ret = ERR_INVALID_HAIKU ; }
compound scope 5 : { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } }
compound scope 6 : { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; }
compound scope 7 : { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; }
compound scope 8 : { ret = ERR_INVALID_HAIKU_LEN ; }
len(compound_scope) : 9
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; } ] 
p_decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
===> context { int ret ; ret = SUCCESS ; uint16_t total_bytes ; total_bytes = 0 ; ; struct haiku * h ; h = NULL ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( FALSE == tlv1 ) { cgc_init_haiku_list ( ) ; } total_bytes = cgc_recv_haiku_size ( ) ; if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; } return ret ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: uint16_t, var: total_bytes
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: SUCCESS
1 : | assign_scope | type: uint16_t, value: 0
2 : | assign_scope | type: struct haiku *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_init_haiku_list ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_init_haiku_list ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '']
===> context { cgc_init_haiku_list ( ) ; }
ignore sibs: ['total_bytes = cgc_recv_haiku_size ( ) ;', 'if ( ( 0 < total_bytes ) && ( MAX_HAIKU_LEN > total_bytes ) ) { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } else { ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: uint16_t, var: total_bytes
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: SUCCESS
1 : | assign_scope | type: uint16_t, value: 0
2 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint8_t, value: FALSE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
===> context { { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } }
ignore sibs: ['else', '{ ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: uint16_t, var: total_bytes
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: SUCCESS
1 : | assign_scope | type: uint16_t, value: 0
2 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint16_t, value: 0
1 : |compare_scopes| type: uint16_t, value: total_bytes
2 : |compare_scopes| type: uint16_t, value: MAX_HAIKU_LEN
3 : |compare_scopes| type: uint16_t, value: total_bytes
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; } ] 
p_decls = [('uint16_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint16_t', 'tlv2', None)]
assigns = [('uint16_t', 'tlv2', '', 'total_bytes')]
compares = []
decls = [('uint16_t', 'tlv2', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint16_t', 'tlv2', '', 'total_bytes'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('uint16_t', 'tlv2', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint16_t', 'tlv2', '', 'total_bytes'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('uint16_t', 'tlv2', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint16_t', 'tlv2', '', 'total_bytes'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
===> context { uint16_t tlv2 ; tlv2 = total_bytes ; h = cgc_recv_haiku ( tlv2 ) ; }
ignore sibs: ['if ( NULL == h ) { ret = ERR_INVALID_HAIKU ; } else { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } }', '}', 'else', '{ ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: uint16_t, var: tlv2
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: uint16_t, var: total_bytes
3 : |  decl_scope  | type: struct haiku *, var: h
4 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint16_t, value: total_bytes
1 : | assign_scope | type: int, value: SUCCESS
2 : | assign_scope | type: uint16_t, value: 0
3 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint16_t, value: 0
1 : |compare_scopes| type: uint16_t, value: total_bytes
2 : |compare_scopes| type: uint16_t, value: MAX_HAIKU_LEN
3 : |compare_scopes| type: uint16_t, value: total_bytes
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = ERR_INVALID_HAIKU ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = ERR_INVALID_HAIKU ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU')]
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '', '', '']
===> context { ret = ERR_INVALID_HAIKU ; }
ignore sibs: ['else', '{ { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } }', '}', 'else', '{ ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: uint16_t, var: total_bytes
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: ERR_INVALID_HAIKU
1 : | assign_scope | type: int, value: SUCCESS
2 : | assign_scope | type: uint16_t, value: 0
3 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint16_t, value: 0
1 : |compare_scopes| type: uint16_t, value: total_bytes
2 : |compare_scopes| type: uint16_t, value: MAX_HAIKU_LEN
3 : |compare_scopes| type: uint16_t, value: total_bytes
4 : |compare_scopes| type: struct haiku *, value: NULL
5 : |compare_scopes| type: struct haiku *, value: h
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
===> context { { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } }
ignore sibs: ['}', 'else', '{ ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: uint16_t, var: total_bytes
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: SUCCESS
1 : | assign_scope | type: uint16_t, value: 0
2 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint16_t, value: 0
1 : |compare_scopes| type: uint16_t, value: total_bytes
2 : |compare_scopes| type: uint16_t, value: MAX_HAIKU_LEN
3 : |compare_scopes| type: uint16_t, value: total_bytes
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; } ] 
p_decls = [('struct haiku *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku *', 'tlv4', None)]
assigns = [('struct haiku *', 'tlv4', '', 'h')]
compares = []
decls = [('struct haiku *', 'tlv4', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'tlv4', '', 'h'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('struct haiku *', 'tlv4', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'tlv4', '', 'h'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('struct haiku *', 'tlv4', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'tlv4', '', 'h'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('struct haiku *', 'tlv4', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'tlv4', '', 'h'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
===> context { struct haiku * tlv4 ; tlv4 = h ; ret = cgc_add_haiku_to_list ( tlv4 ) ; }
ignore sibs: ['{ uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; }', '}', '}', 'else', '{ ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: struct haiku *, var: tlv4
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: uint16_t, var: total_bytes
3 : |  decl_scope  | type: struct haiku *, var: h
4 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: h
1 : | assign_scope | type: int, value: SUCCESS
2 : | assign_scope | type: uint16_t, value: 0
3 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint16_t, value: 0
1 : |compare_scopes| type: uint16_t, value: total_bytes
2 : |compare_scopes| type: uint16_t, value: MAX_HAIKU_LEN
3 : |compare_scopes| type: uint16_t, value: total_bytes
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; } ] 
p_decls = [('uint32_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'tlv3', None)]
assigns = [('uint32_t', 'tlv3', '', 'h -> id')]
compares = []
decls = [('uint32_t', 'tlv3', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'tlv3', '', 'h -> id'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
decls = [('uint32_t', 'tlv3', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'tlv3', '', 'h -> id'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('uint32_t', 'tlv3', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'tlv3', '', 'h -> id'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
decls = [('uint32_t', 'tlv3', None), ('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'tlv3', '', 'h -> id'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = ['', '', '', '']
===> context { uint32_t tlv3 ; tlv3 = h -> id ; cgc_send_haiku_id ( tlv3 ) ; }
ignore sibs: ['}', '}', 'else', '{ ret = ERR_INVALID_HAIKU_LEN ; }', 'return ret ;', '}']
0 : |  decl_scope  | type: uint32_t, var: tlv3
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: uint16_t, var: total_bytes
3 : |  decl_scope  | type: struct haiku *, var: h
4 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: h -> id
1 : | assign_scope | type: int, value: SUCCESS
2 : | assign_scope | type: uint16_t, value: 0
3 : | assign_scope | type: struct haiku *, value: NULL
0 : |compare_scopes| type: uint16_t, value: 0
1 : |compare_scopes| type: uint16_t, value: total_bytes
2 : |compare_scopes| type: uint16_t, value: MAX_HAIKU_LEN
3 : |compare_scopes| type: uint16_t, value: total_bytes
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = ERR_INVALID_HAIKU_LEN ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = ERR_INVALID_HAIKU_LEN ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU_LEN')]
compares = []
decls = [('int', 'ret', None), ('uint16_t', 'total_bytes', None), ('struct haiku *', 'h', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'ret', '', 'ERR_INVALID_HAIKU_LEN'), ('int', 'ret', '', 'SUCCESS'), ('uint16_t', 'total_bytes', '', '0'), ('struct haiku *', 'h', '', 'NULL')]
compares = []
===> context { ret = ERR_INVALID_HAIKU_LEN ; }
ignore sibs: ['return ret ;', '}']
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: uint16_t, var: total_bytes
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: ERR_INVALID_HAIKU_LEN
1 : | assign_scope | type: int, value: SUCCESS
2 : | assign_scope | type: uint16_t, value: 0
3 : | assign_scope | type: struct haiku *, value: NULL
=======END=======
compound scope 0 : { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
compound scope 1 : { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } }
compound scope 2 : { cgc_send_easter_egg_haiku ( ) ; }
compound scope 3 : { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } }
compound scope 4 : { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; }
compound scope 5 : { cgc_send_haiku ( h ) ; }
compound scope 6 : { res = ERR_LIST_NOT_EXIST ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; } ] 
p_decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
===> context { struct haiku * h ; h = NULL ; uint32_t id ; id = 0 ; int res ; res = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
ignore sibs: []
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: int, var: res
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
===> context { id = cgc_recv_uint32 ( ) ; if ( EGG_ID == id ) { cgc_send_easter_egg_haiku ( ) ; } else { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } }
ignore sibs: ['else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: int, var: res
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_send_easter_egg_haiku ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_send_easter_egg_haiku ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '', '', '']
===> context { cgc_send_easter_egg_haiku ( ) ; }
ignore sibs: ['else', '{ { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } }', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: int, var: res
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: uint32_t, value: EGG_ID
3 : |compare_scopes| type: uint32_t, value: id
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
===> context { { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; } }
ignore sibs: ['}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: int, var: res
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; } ] 
p_decls = [('struct haiku * *', 'tlv3', None), ('uint32_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'tlv3', None), ('uint32_t', 'tlv2', None)]
assigns = [('struct haiku * *', 'tlv3', '', '& h'), ('uint32_t', 'tlv2', '', 'id')]
compares = []
decls = [('struct haiku * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv3', '', '& h'), ('uint32_t', 'tlv2', '', 'id'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
decls = [('struct haiku * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv3', '', '& h'), ('uint32_t', 'tlv2', '', 'id'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv3', '', '& h'), ('uint32_t', 'tlv2', '', 'id'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv3', '', '& h'), ('uint32_t', 'tlv2', '', 'id'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
===> context { struct haiku * * tlv3 ; tlv3 = & h ; uint32_t tlv2 ; tlv2 = id ; res = cgc_find_haiku_with_id ( tlv3 , tlv2 ) ; }
ignore sibs: ['if ( SUCCESS == res ) { cgc_send_haiku ( h ) ; }', '}', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: struct haiku * *, var: tlv3
1 : |  decl_scope  | type: uint32_t, var: tlv2
2 : |  decl_scope  | type: struct haiku *, var: h
3 : |  decl_scope  | type: uint32_t, var: id
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku * *, value: & h
1 : | assign_scope | type: uint32_t, value: id
2 : | assign_scope | type: struct haiku *, value: NULL
3 : | assign_scope | type: uint32_t, value: 0
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_send_haiku ( h ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_send_haiku ( h ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '']
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = ['', '', '', '']
===> context { cgc_send_haiku ( h ) ; }
ignore sibs: ['}', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: int, var: res
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku *, value: NULL
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: int, value: SUCCESS
3 : |compare_scopes| type: int, value: res
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { res = ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { res = ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('int', 'res', '', 'ERR_LIST_NOT_EXIST')]
compares = []
decls = [('struct haiku *', 'h', None), ('uint32_t', 'id', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'res', '', 'ERR_LIST_NOT_EXIST'), ('struct haiku *', 'h', '', 'NULL'), ('uint32_t', 'id', '', '0'), ('int', 'res', '', '0')]
compares = []
===> context { res = ERR_LIST_NOT_EXIST ; }
ignore sibs: ['return res ;', '}']
0 : |  decl_scope  | type: struct haiku *, var: h
1 : |  decl_scope  | type: uint32_t, var: id
2 : |  decl_scope  | type: int, var: res
3 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: ERR_LIST_NOT_EXIST
1 : | assign_scope | type: struct haiku *, value: NULL
2 : | assign_scope | type: uint32_t, value: 0
3 : | assign_scope | type: int, value: 0
=======END=======
compound scope 0 : { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
compound scope 1 : { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } }
compound scope 2 : { return ERR_LIST_EMPTY ; }
compound scope 3 : { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; }
compound scope 4 : { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; }
compound scope 5 : { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }
compound scope 6 : { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; }
compound scope 7 : { cgc_send_haiku ( rand_haiku ) ; }
compound scope 8 : { res = ERR_LIST_NOT_EXIST ; }
len(compound_scope) : 9
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; } ] 
p_decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
===> context { uint32_t random_idx ; random_idx = 0 ; uint32_t count ; count = 0 ; uint32_t * id_arr ; id_arr = NULL ; struct haiku * rand_haiku ; rand_haiku = NULL ; int res ; res = SUCCESS ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } else { res = ERR_LIST_NOT_EXIST ; } return res ; }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: uint32_t, var: count
2 : |  decl_scope  | type: uint32_t *, var: id_arr
3 : |  decl_scope  | type: struct haiku *, var: rand_haiku
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: SUCCESS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
===> context { count = cgc_get_count ( ) ; if ( 0 == count ) { return ERR_LIST_EMPTY ; } ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ; { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ; if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; } }
ignore sibs: ['else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: uint32_t, var: count
2 : |  decl_scope  | type: uint32_t *, var: id_arr
3 : |  decl_scope  | type: struct haiku *, var: rand_haiku
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_EMPTY ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '', '', '']
===> context { return ERR_LIST_EMPTY ; }
ignore sibs: ['ALLOC ( count * sizeof ( uint32_t ) , & id_arr ) ;', '{ uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; }', '{ uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; }', 'if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }', 'DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ;', 'if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; }', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: uint32_t, var: count
2 : |  decl_scope  | type: uint32_t *, var: id_arr
3 : |  decl_scope  | type: struct haiku *, var: rand_haiku
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: uint32_t, value: 0
3 : |compare_scopes| type: uint32_t, value: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; } ] 
p_decls = [('uint32_t * *', 'tlv3', None), ('uint32_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t * *', 'tlv3', None), ('uint32_t', 'tlv2', None)]
assigns = [('uint32_t * *', 'tlv3', '', 'id_arr'), ('uint32_t', 'tlv2', '', 'count')]
compares = []
decls = [('uint32_t * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t * *', 'tlv3', '', 'id_arr'), ('uint32_t', 'tlv2', '', 'count'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('uint32_t * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t * *', 'tlv3', '', 'id_arr'), ('uint32_t', 'tlv2', '', 'count'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t * *', 'tlv3', None), ('uint32_t', 'tlv2', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t * *', 'tlv3', '', 'id_arr'), ('uint32_t', 'tlv2', '', 'count'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
===> context { uint32_t * * tlv3 ; tlv3 = id_arr ; uint32_t tlv2 ; tlv2 = count ; res = cgc_populate_array_with_haiku_ids ( tlv3 , tlv2 ) ; }
ignore sibs: ['{ uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; }', 'if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }', 'DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ;', 'if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; }', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: uint32_t * *, var: tlv3
1 : |  decl_scope  | type: uint32_t, var: tlv2
2 : |  decl_scope  | type: uint32_t, var: random_idx
3 : |  decl_scope  | type: uint32_t, var: count
4 : |  decl_scope  | type: uint32_t *, var: id_arr
5 : |  decl_scope  | type: struct haiku *, var: rand_haiku
6 : |  decl_scope  | type: int, var: res
7 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t * *, value: id_arr
1 : | assign_scope | type: uint32_t, value: count
2 : | assign_scope | type: uint32_t, value: 0
3 : | assign_scope | type: uint32_t, value: 0
4 : | assign_scope | type: uint32_t *, value: NULL
5 : | assign_scope | type: struct haiku *, value: NULL
6 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; } ] 
p_decls = [('uint32_t *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t *', 'tlv4', None)]
assigns = [('uint32_t *', 'tlv4', '', '& random_idx')]
compares = []
decls = [('uint32_t *', 'tlv4', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t *', 'tlv4', '', '& random_idx'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('uint32_t *', 'tlv4', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t *', 'tlv4', '', '& random_idx'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t *', 'tlv4', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t *', 'tlv4', '', '& random_idx'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
===> context { uint32_t * tlv4 ; tlv4 = & random_idx ; res = cgc_get_random_idx ( tlv4 ) ; }
ignore sibs: ['if ( ERR_RAND_FAILED != res ) { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }', 'DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ;', 'if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; }', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: uint32_t *, var: tlv4
1 : |  decl_scope  | type: uint32_t, var: random_idx
2 : |  decl_scope  | type: uint32_t, var: count
3 : |  decl_scope  | type: uint32_t *, var: id_arr
4 : |  decl_scope  | type: struct haiku *, var: rand_haiku
5 : |  decl_scope  | type: int, var: res
6 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t *, value: & random_idx
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t, value: 0
3 : | assign_scope | type: uint32_t *, value: NULL
4 : | assign_scope | type: struct haiku *, value: NULL
5 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '', '', '']
===> context { { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } }
ignore sibs: ['DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ;', 'if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; }', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: uint32_t, var: count
2 : |  decl_scope  | type: uint32_t *, var: id_arr
3 : |  decl_scope  | type: struct haiku *, var: rand_haiku
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: int, value: ERR_RAND_FAILED
3 : |compare_scopes| type: int, value: res
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; } ] 
p_decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None)]
assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]')]
compares = []
decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '', '', '']
decls = [('struct haiku * *', 'tlv6', None), ('uint32_t', 'tlv5', None), ('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('struct haiku * *', 'tlv6', '', '& rand_haiku'), ('uint32_t', 'tlv5', '', 'id_arr [ random_idx ]'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '', '', '']
===> context { struct haiku * * tlv6 ; tlv6 = & rand_haiku ; uint32_t tlv5 ; tlv5 = id_arr [ random_idx ] ; res = cgc_find_haiku_with_id ( tlv6 , tlv5 ) ; }
ignore sibs: ['}', 'DEALLOC ( id_arr , count * sizeof ( uint32_t ) ) ;', 'if ( SUCCESS == res ) { cgc_send_haiku ( rand_haiku ) ; }', '}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: struct haiku * *, var: tlv6
1 : |  decl_scope  | type: uint32_t, var: tlv5
2 : |  decl_scope  | type: uint32_t, var: random_idx
3 : |  decl_scope  | type: uint32_t, var: count
4 : |  decl_scope  | type: uint32_t *, var: id_arr
5 : |  decl_scope  | type: struct haiku *, var: rand_haiku
6 : |  decl_scope  | type: int, var: res
7 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: struct haiku * *, value: & rand_haiku
1 : | assign_scope | type: uint32_t, value: id_arr [ random_idx ]
2 : | assign_scope | type: uint32_t, value: 0
3 : | assign_scope | type: uint32_t, value: 0
4 : | assign_scope | type: uint32_t *, value: NULL
5 : | assign_scope | type: struct haiku *, value: NULL
6 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: int, value: ERR_RAND_FAILED
3 : |compare_scopes| type: int, value: res
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_send_haiku ( rand_haiku ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_send_haiku ( rand_haiku ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '']
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = ['', '', '', '']
===> context { cgc_send_haiku ( rand_haiku ) ; }
ignore sibs: ['}', 'else', '{ res = ERR_LIST_NOT_EXIST ; }', 'return res ;', '}']
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: uint32_t, var: count
2 : |  decl_scope  | type: uint32_t *, var: id_arr
3 : |  decl_scope  | type: struct haiku *, var: rand_haiku
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t *, value: NULL
3 : | assign_scope | type: struct haiku *, value: NULL
4 : | assign_scope | type: int, value: SUCCESS
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: int, value: SUCCESS
3 : |compare_scopes| type: int, value: res
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { res = ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { res = ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('int', 'res', '', 'ERR_LIST_NOT_EXIST')]
compares = []
decls = [('uint32_t', 'random_idx', None), ('uint32_t', 'count', None), ('uint32_t *', 'id_arr', None), ('struct haiku *', 'rand_haiku', None), ('int', 'res', None), ('uint8_t', 'tlv1', None)]
assigns = [('int', 'res', '', 'ERR_LIST_NOT_EXIST'), ('uint32_t', 'random_idx', '', '0'), ('uint32_t', 'count', '', '0'), ('uint32_t *', 'id_arr', '', 'NULL'), ('struct haiku *', 'rand_haiku', '', 'NULL'), ('int', 'res', '', 'SUCCESS')]
compares = []
===> context { res = ERR_LIST_NOT_EXIST ; }
ignore sibs: ['return res ;', '}']
0 : |  decl_scope  | type: uint32_t, var: random_idx
1 : |  decl_scope  | type: uint32_t, var: count
2 : |  decl_scope  | type: uint32_t *, var: id_arr
3 : |  decl_scope  | type: struct haiku *, var: rand_haiku
4 : |  decl_scope  | type: int, var: res
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: int, value: ERR_LIST_NOT_EXIST
1 : | assign_scope | type: uint32_t, value: 0
2 : | assign_scope | type: uint32_t, value: 0
3 : | assign_scope | type: uint32_t *, value: NULL
4 : | assign_scope | type: struct haiku *, value: NULL
5 : | assign_scope | type: int, value: SUCCESS
=======END=======
compound scope 0 : { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } }
compound scope 1 : { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; }
compound scope 2 : { return ERR_LIST_NOT_EXIST ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } } ] 
p_decls = [('uint32_t', 'count', None), ('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'count', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'count', '', '0')]
compares = []
===> context { uint32_t count ; count = 0 ; uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } else { return ERR_LIST_NOT_EXIST ; } }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t, var: count
1 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; } ] 
p_decls = [('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None)]
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None)]
assigns = []
compares = []
decls = [('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('uint32_t', 'count', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'count', '', '0')]
compares = []
decls = [('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('uint32_t', 'count', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'count', '', '0')]
compares = ['', '']
===> context { count = cgc_get_count ( ) ; SENDUI ( count ) ; return SUCCESS ; }
ignore sibs: ['else', '{ return ERR_LIST_NOT_EXIST ; }', '}']
0 : |  decl_scope  | type: SENDUI *, var: (
1 : |  decl_scope  | type: SENDUI, var: ( count )
2 : |  decl_scope  | type: SENDUI, var: count
3 : |  decl_scope  | type: uint32_t, var: count
4 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint32_t', 'count', None), ('uint8_t', 'tlv1', None)]
assigns = [('uint32_t', 'count', '', '0')]
compares = []
===> context { return ERR_LIST_NOT_EXIST ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: uint32_t, var: count
1 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: uint32_t, value: 0
=======END=======
compound scope 0 : { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; }
compound scope 1 : { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } }
compound scope 2 : { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; }
compound scope 3 : { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; }
compound scope 4 : { return ERR_LIST_NOT_EXIST ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; } ] 
p_decls = [('uint8_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
===> context { uint8_t tlv1 ; tlv1 = cgc_haiku_list_exists ( ) ; if ( TRUE == tlv1 ) { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } else { return ERR_LIST_NOT_EXIST ; } return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: uint8_t, var: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } } ] 
p_decls = [('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None)]
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None)]
assigns = [('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = []
decls = [('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = []
decls = [('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = ['', '']
===> context { uint32_t count ; count = ( uint32_t ) cgc_get_count ( ) ; SENDUI ( count ) ; node_t * hl_ptr ; hl_ptr = cgc_haiku_list -> head ; while ( NULL != hl_ptr ) { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } }
ignore sibs: ['else', '{ return ERR_LIST_NOT_EXIST ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint32_t, var: count
1 : |  decl_scope  | type: SENDUI *, var: (
2 : |  decl_scope  | type: SENDUI, var: ( count )
3 : |  decl_scope  | type: SENDUI, var: count
4 : |  decl_scope  | type: node_t *, var: hl_ptr
5 : |  decl_scope  | type: uint8_t, var: tlv1
0 : | assign_scope | type: node_t *, value: cgc_haiku_list -> head
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; } ] 
p_decls = [('uint32_t', 'id', None), ('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'id', None), ('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None)]
assigns = [('node_t *', 'hl_ptr', '', 'hl_ptr -> next')]
compares = []
decls = [('uint32_t', 'id', None), ('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'hl_ptr', '', 'hl_ptr -> next')]
compares = []
decls = [('uint32_t', 'id', None), ('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'hl_ptr', '', 'hl_ptr -> next')]
compares = ['', '']
decls = [('uint32_t', 'id', None), ('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None), ('uint8_t', 'tlv1', None), ('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None)]
assigns = [('node_t *', 'hl_ptr', '', 'hl_ptr -> next'), ('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = ['', '']
decls = [('uint32_t', 'id', None), ('SENDUI *', '(', ' id )'), ('SENDUI', '( id )', None), ('SENDUI', 'id', None), ('uint8_t', 'tlv1', None), ('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None)]
assigns = [('node_t *', 'hl_ptr', '', 'hl_ptr -> next'), ('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = ['', '', '', '']
===> context { uint32_t id ; { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } SENDUI ( id ) ; hl_ptr = hl_ptr -> next ; }
ignore sibs: ['}', 'else', '{ return ERR_LIST_NOT_EXIST ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint32_t, var: id
1 : |  decl_scope  | type: SENDUI *, var: (
2 : |  decl_scope  | type: SENDUI, var: ( id )
3 : |  decl_scope  | type: SENDUI, var: id
4 : |  decl_scope  | type: uint8_t, var: tlv1
5 : |  decl_scope  | type: uint32_t, var: count
6 : |  decl_scope  | type: SENDUI *, var: (
7 : |  decl_scope  | type: SENDUI, var: ( count )
8 : |  decl_scope  | type: SENDUI, var: count
9 : |  decl_scope  | type: node_t *, var: hl_ptr
0 : | assign_scope | type: node_t *, value: hl_ptr -> next
1 : | assign_scope | type: node_t *, value: cgc_haiku_list -> head
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: node_t *, value: NULL
3 : |compare_scopes| type: node_t *, value: hl_ptr
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; } ] 
p_decls = [('node_t *', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('node_t *', 'tlv2', None)]
assigns = [('node_t *', 'tlv2', '', 'hl_ptr')]
compares = []
decls = [('node_t *', 'tlv2', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'tlv2', '', 'hl_ptr')]
compares = []
decls = [('node_t *', 'tlv2', None), ('uint8_t', 'tlv1', None)]
assigns = [('node_t *', 'tlv2', '', 'hl_ptr')]
compares = ['', '']
decls = [('node_t *', 'tlv2', None), ('uint8_t', 'tlv1', None), ('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None)]
assigns = [('node_t *', 'tlv2', '', 'hl_ptr'), ('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = ['', '']
decls = [('node_t *', 'tlv2', None), ('uint8_t', 'tlv1', None), ('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None)]
assigns = [('node_t *', 'tlv2', '', 'hl_ptr'), ('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = ['', '', '', '']
decls = [('node_t *', 'tlv2', None), ('uint8_t', 'tlv1', None), ('uint32_t', 'count', None), ('SENDUI *', '(', ' count )'), ('SENDUI', '( count )', None), ('SENDUI', 'count', None), ('node_t *', 'hl_ptr', None), ('uint32_t', 'id', None)]
assigns = [('node_t *', 'tlv2', '', 'hl_ptr'), ('node_t *', 'hl_ptr', '', 'cgc_haiku_list -> head')]
compares = ['', '', '', '']
===> context { node_t * tlv2 ; tlv2 = hl_ptr ; id = cgc_get_id_from_haiku ( tlv2 ) ; }
ignore sibs: ['SENDUI ( id ) ;', 'hl_ptr = hl_ptr -> next ;', '}', '}', 'else', '{ return ERR_LIST_NOT_EXIST ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: node_t *, var: tlv2
1 : |  decl_scope  | type: uint8_t, var: tlv1
2 : |  decl_scope  | type: uint32_t, var: count
3 : |  decl_scope  | type: SENDUI *, var: (
4 : |  decl_scope  | type: SENDUI, var: ( count )
5 : |  decl_scope  | type: SENDUI, var: count
6 : |  decl_scope  | type: node_t *, var: hl_ptr
7 : |  decl_scope  | type: uint32_t, var: id
0 : | assign_scope | type: node_t *, value: hl_ptr
1 : | assign_scope | type: node_t *, value: cgc_haiku_list -> head
0 : |compare_scopes| type: uint8_t, value: TRUE
1 : |compare_scopes| type: uint8_t, value: tlv1
2 : |compare_scopes| type: node_t *, value: NULL
3 : |compare_scopes| type: node_t *, value: hl_ptr
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ERR_LIST_NOT_EXIST ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('uint8_t', 'tlv1', None)]
assigns = []
compares = []
===> context { return ERR_LIST_NOT_EXIST ; }
ignore sibs: ['return SUCCESS ;', '}']
0 : |  decl_scope  | type: uint8_t, var: tlv1
=======END=======
def_vars[0]: [cgc_recv_uint32] : <class 'CParser.CParser.DeclarationContext'> : uint32_t num [ 1 ] = { 0 } ;
sym_lut=>'{'num': 'uint32_t *', 'num [ 1 ]': 'uint32_t'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_0(){
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_operation_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_recv_uint16] : <class 'CParser.CParser.DeclarationContext'> : uint16_t num [ 1 ] = { 0 } ;
sym_lut=>'{'num': 'uint16_t *', 'num [ 1 ]': 'uint16_t'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_1(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_1();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3306d8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d330a58>)]'
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_2(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_2();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d347c88>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d31c048>)]'
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_3(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_3();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_init_haiku_list] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
sym_lut=>'{'tlv1': 'uint8_t'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'tlv1': 'uint8_t'}'
val_s=>'[]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d32d128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d32d4a8>)]'
is_func_ [F] => '[False, False, False]'
has_multiptr_refs 'FALSE' - False OR  False
[i=4/23][j=1/2][dd=0/1][k=0/2] | type: uint8_t ; var :  ; varinfo :  ; value_node : FALSE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : FALSE
 => is literal (False) | is operator (False) FALSE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=4/23][j=1/2][dd=0/1][k=1/2] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
unique : ('uint8_t', 'tlv1', None)
----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

not valid - uint8_t tlv1; tlv1 = ((uint8_t)tlv1);

==== Scope 1 ====
void fix_ingred_operation_4_1_0(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint8_t tlv1; tlv1 = (uint8_t)(FALSE); }
}
void fix_ingred_operation_4_1(){
fix_ingred_operation_4_1_0();
}

==== Scope 2 ====
void fix_ingred_operation_4_1_0(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint8_t tlv1; tlv1 = (uint8_t)(FALSE); }
}
void fix_ingred_operation_4_1(){
fix_ingred_operation_4_1_0();
}
void fix_ingred_operation_4(){
fix_ingred_operation_4_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_4_1_0();
void fix_ingred_operation_4_1();
void fix_ingred_operation_4();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_count] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
sym_lut=>'{'tlv1': 'uint8_t'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'tlv1': 'uint8_t'}'
val_s=>'[]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d313d68>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d317128>)]'
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=5/23][j=1/3][dd=0/1][k=0/2] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
----
==== Scope 1 ====
void fix_ingred_operation_5_1_0(){
    {uint8_t tlv1; tlv1 = (uint8_t)(TRUE); }
}
void fix_ingred_operation_5_1(){
fix_ingred_operation_5_1_0();
}

sym_lut=>'{'tlv1': 'uint8_t'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_5_1_0(){
    {uint8_t tlv1; tlv1 = (uint8_t)(TRUE); }
}
void fix_ingred_operation_5_1(){
fix_ingred_operation_5_1_0();
}
void fix_ingred_operation_5(){
fix_ingred_operation_5_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_5_1_0();
void fix_ingred_operation_5_1();
void fix_ingred_operation_5();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_id_from_haiku] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * h ;
sym_lut=>'{'haiku': 'node_t *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'haiku': 'node_t *', 'h': 'struct haiku *'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3979e8>)]'
cval_s=>'[('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d39a828>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d39aba8>)]'
sym_lut=>'{'haiku': 'node_t *', 'h': 'struct haiku *'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_6(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_6();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_7(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_7();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_random_idx] : <class 'CParser.CParser.DeclarationContext'> : uint32_t random_idx ;
def_vars[1]: [cgc_get_random_idx] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[2]: [cgc_get_random_idx] : <class 'CParser.CParser.DeclarationContext'> : int32_t count ;
def_vars[3]: [cgc_get_random_idx] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[4]: [cgc_get_random_idx] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=0/5][k=0/2] | type: uint32_t ; var : random_idx ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=0/5][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=1/5][k=0/2] | type: uint32_t ; var : random_idx ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=1/5][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=3/5][k=0/2] | type: uint32_t ; var : random_idx ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=3/5][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=4/5][k=0/2] | type: uint32_t ; var : random_idx ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/23][j=0/8][dd=4/5][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_operation_8_0_0(){
    {uint32_t random_idx; random_idx = (uint32_t)(0); }
    {int ret; ret = (int)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
}
void fix_ingred_operation_8_0_1(){
    {uint32_t random_idx; random_idx = (uint32_t)(0); }
    {int ret; ret = (int)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
}
void fix_ingred_operation_8_0(){
fix_ingred_operation_8_0_0();
fix_ingred_operation_8_0_1();
}

sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d393208>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c0518>), ('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)&random_idx' - False OR  False
[i=8/23][j=1/8][dd=0/5][k=0/4] | type: char * ; var : tlv2 ; varinfo :  ; value_node : ( char * ) & random_idx (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),&,random_idx
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
unique : ('uint32_t', 'random_idx', None)
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=8/23][j=1/8][dd=0/5][k=1/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)&random_idx' - False OR  False
[i=8/23][j=1/8][dd=1/5][k=0/4] | type: char * ; var : tlv2 ; varinfo :  ; value_node : ( char * ) & random_idx (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),&,random_idx
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=8/23][j=1/8][dd=1/5][k=1/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)&random_idx' - False OR  False
[i=8/23][j=1/8][dd=3/5][k=0/4] | type: char * ; var : tlv2 ; varinfo :  ; value_node : ( char * ) & random_idx (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),&,random_idx
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=8/23][j=1/8][dd=3/5][k=1/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)&random_idx' - False OR  False
[i=8/23][j=1/8][dd=4/5][k=0/4] | type: char * ; var : tlv2 ; varinfo :  ; value_node : ( char * ) & random_idx (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),&,random_idx
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=8/23][j=1/8][dd=4/5][k=1/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
not valid - uint32_t random_idx; random_idx = ((uint32_t)( char * ) & random_idx);

----
UNIQ_INIT: ('uint32_t','random_idx','None','None');

----
UNIQ_INIT: ('uint32_t','random_idx','None','None');

==== Scope 1 ====
void fix_ingred_operation_8_1_0(){
uint32_t random_idx;
    bzero(&random_idx,sizeof(uint32_t));
    {int ret; ret = (int)(( char * ) & random_idx); }
    {char * tlv2; tlv2 = (char *)(( char * ) & random_idx); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(( char * ) & random_idx); }
}
void fix_ingred_operation_8_1_1(){
uint32_t random_idx;
    bzero(&random_idx,sizeof(uint32_t));
    {uint32_t random_idx; random_idx = (uint32_t)(4); }
    {int ret; ret = (int)(4); }
    {char * tlv2; tlv2 = (char *)(4); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(4); }
}
void fix_ingred_operation_8_1(){
fix_ingred_operation_8_1_0();
fix_ingred_operation_8_1_1();
}

sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'count': 'int32_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[('int32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3cdf98>), ('int32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3bb358>)]'
sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'count': 'int32_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[]'
sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'count': 'int32_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[('int32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3aa7b8>), ('int32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3aab38>)]'
sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'count': 'int32_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[]'
sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'count': 'int32_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3b5f98>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d394358>)]'
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/23][j=6/8][dd=0/5][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/23][j=6/8][dd=1/5][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/23][j=6/8][dd=3/5][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/23][j=6/8][dd=4/5][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
not valid - int ret; ret = ((int)ret);

----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_operation_8_6_3(){
int ret;
    bzero(&ret,sizeof(int));
    {uint32_t random_idx; random_idx = (uint32_t)(ret); }
    {char * tlv2; tlv2 = (char *)(ret); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(ret); }
}
void fix_ingred_operation_8_6(){
fix_ingred_operation_8_6_3();
}

sym_lut=>'{'idx': 'uint32_t *', 'random_idx': 'uint32_t', 'ret': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'count': 'int32_t'}'
val_s=>'[('UNDEF', '* idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3cc4a8>), ('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d38f208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3950b8>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_8_0_0(){
    {uint32_t random_idx; random_idx = (uint32_t)(0); }
    {int ret; ret = (int)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
}
void fix_ingred_operation_8_0_1(){
    {uint32_t random_idx; random_idx = (uint32_t)(0); }
    {int ret; ret = (int)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
}
void fix_ingred_operation_8_0(){
fix_ingred_operation_8_0_0();
fix_ingred_operation_8_0_1();
}
void fix_ingred_operation_8_1_0(){
uint32_t random_idx;
    bzero(&random_idx,sizeof(uint32_t));
    {int ret; ret = (int)(( char * ) & random_idx); }
    {char * tlv2; tlv2 = (char *)(( char * ) & random_idx); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(( char * ) & random_idx); }
}
void fix_ingred_operation_8_1_1(){
uint32_t random_idx;
    bzero(&random_idx,sizeof(uint32_t));
    {uint32_t random_idx; random_idx = (uint32_t)(4); }
    {int ret; ret = (int)(4); }
    {char * tlv2; tlv2 = (char *)(4); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(4); }
}
void fix_ingred_operation_8_1(){
fix_ingred_operation_8_1_0();
fix_ingred_operation_8_1_1();
}
void fix_ingred_operation_8_6_3(){
int ret;
    bzero(&ret,sizeof(int));
    {uint32_t random_idx; random_idx = (uint32_t)(ret); }
    {char * tlv2; tlv2 = (char *)(ret); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(ret); }
}
void fix_ingred_operation_8_6(){
fix_ingred_operation_8_6_3();
}
void fix_ingred_operation_8(){
fix_ingred_operation_8_0();
fix_ingred_operation_8_1();
fix_ingred_operation_8_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_8_0_0();
void fix_ingred_operation_8_0_1();
void fix_ingred_operation_8_0();
void fix_ingred_operation_8_1_0();
void fix_ingred_operation_8_1_1();
void fix_ingred_operation_8_1();
void fix_ingred_operation_8_6_3();
void fix_ingred_operation_8_6();
void fix_ingred_operation_8();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_populate_array_with_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : node_t * haiku_ptr ;
def_vars[1]: [cgc_populate_array_with_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * h ;
def_vars[2]: [cgc_populate_array_with_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : uint32_t id ;
def_vars[3]: [cgc_populate_array_with_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
sym_lut=>'{'id_arr': 'uint32_t *', 'id_arr [ ]': 'uint32_t', 'count': 'uint32_t', 'haiku_ptr': 'node_t *', 'h': 'struct haiku *', 'id': 'uint32_t', 'tlv1': 'uint8_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c40b8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d396128>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c6048>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=9/23][j=0/5][dd=2/4][k=2/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=9/23][j=0/5][dd=3/4][k=2/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_operation_9_0_2(){
    {uint32_t id; id = (uint32_t)(0); }
    {uint8_t tlv1; tlv1 = (uint8_t)(0); }
}
void fix_ingred_operation_9_0(){
fix_ingred_operation_9_0_2();
}

sym_lut=>'{'id_arr': 'uint32_t *', 'id_arr [ ]': 'uint32_t', 'count': 'uint32_t', 'haiku_ptr': 'node_t *', 'h': 'struct haiku *', 'id': 'uint32_t', 'tlv1': 'uint8_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3b1828>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c40b8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d396128>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c6048>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3bdba8>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3bdf28>)]'
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=9/23][j=1/5][dd=2/4][k=4/6] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=9/23][j=1/5][dd=2/4][k=5/6] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
unique : ('uint8_t', 'tlv1', None)
----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_operation_9_1_4(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t id; id = (uint32_t)(TRUE); }
}
void fix_ingred_operation_9_1_5(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t id; id = (uint32_t)(tlv1); }
}
void fix_ingred_operation_9_1(){
fix_ingred_operation_9_1_4();
fix_ingred_operation_9_1_5();
}

sym_lut=>'{'id_arr': 'uint32_t *', 'id_arr [ ]': 'uint32_t', 'count': 'uint32_t', 'haiku_ptr': 'node_t *', 'h': 'struct haiku *', 'id': 'uint32_t', 'tlv1': 'uint8_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c40b8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d396128>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c6048>)]'
cval_s=>'[]'
sym_lut=>'{'id_arr': 'uint32_t *', 'id_arr [ ]': 'uint32_t', 'count': 'uint32_t', 'haiku_ptr': 'node_t *', 'h': 'struct haiku *', 'id': 'uint32_t', 'tlv1': 'uint8_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c40b8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d396128>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c6048>)]'
cval_s=>'[('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6a3668>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6a39e8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6a4748>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6a4ac8>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=9/23][j=3/5][dd=2/4][k=4/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
unique : ('uint32_t', 'count', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=9/23][j=3/5][dd=3/4][k=4/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
not unique: ('uint32_t', 'count', None) ... continue!
----
UNIQ_INIT: ('uint32_t','count','None','None');

==== Scope 1 ====
void fix_ingred_operation_9_3_4(){
uint32_t count;
    bzero(&count,sizeof(uint32_t));
    {uint32_t id; id = (uint32_t)(count); }
    {uint8_t tlv1; tlv1 = (uint8_t)(count); }
}
void fix_ingred_operation_9_3(){
fix_ingred_operation_9_3_4();
}

sym_lut=>'{'id_arr': 'uint32_t *', 'id_arr [ ]': 'uint32_t', 'count': 'uint32_t', 'haiku_ptr': 'node_t *', 'h': 'struct haiku *', 'id': 'uint32_t', 'tlv1': 'uint8_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6c9208>), ('UNDEF', 'id_arr ', '[ count - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6cea58>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d690e48>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c40b8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d396128>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3c6048>)]'
cval_s=>'[('uint32_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d6be5f8>), ('uint32_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d6be908>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6ae588>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6ae2e8>)]'
==== Scope 2 ====
void fix_ingred_operation_9_0_2(){
    {uint32_t id; id = (uint32_t)(0); }
    {uint8_t tlv1; tlv1 = (uint8_t)(0); }
}
void fix_ingred_operation_9_0(){
fix_ingred_operation_9_0_2();
}
void fix_ingred_operation_9_1_4(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t id; id = (uint32_t)(TRUE); }
}
void fix_ingred_operation_9_1_5(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t id; id = (uint32_t)(tlv1); }
}
void fix_ingred_operation_9_1(){
fix_ingred_operation_9_1_4();
fix_ingred_operation_9_1_5();
}
void fix_ingred_operation_9_3_4(){
uint32_t count;
    bzero(&count,sizeof(uint32_t));
    {uint32_t id; id = (uint32_t)(count); }
    {uint8_t tlv1; tlv1 = (uint8_t)(count); }
}
void fix_ingred_operation_9_3(){
fix_ingred_operation_9_3_4();
}
void fix_ingred_operation_9(){
fix_ingred_operation_9_0();
fix_ingred_operation_9_1();
fix_ingred_operation_9_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_9_0_2();
void fix_ingred_operation_9_0();
void fix_ingred_operation_9_1_4();
void fix_ingred_operation_9_1_5();
void fix_ingred_operation_9_1();
void fix_ingred_operation_9_3_4();
void fix_ingred_operation_9_3();
void fix_ingred_operation_9();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_find_haiku_with_id] : <class 'CParser.CParser.DeclarationContext'> : node_t * haiku_ptr ;
def_vars[1]: [cgc_find_haiku_with_id] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * tmp ;
def_vars[2]: [cgc_find_haiku_with_id] : <class 'CParser.CParser.DeclarationContext'> : int count ;
def_vars[3]: [cgc_find_haiku_with_id] : <class 'CParser.CParser.DeclarationContext'> : bool_t found ;
sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/23][j=0/9][dd=2/4][k=2/4] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_operation_10_0_2(){
    {int count; count = (int)(0); }
}
void fix_ingred_operation_10_0(){
fix_ingred_operation_10_0_2();
}

sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6bf5f8>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d6bda58>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d6bdd68>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=10/23][j=1/9][dd=2/4][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
not valid - int count; count = ((int)count);

sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[]'
sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6a53c8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6a5748>)]'
sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[]'
sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6c7128>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6bc668>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6c14a8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6c1828>)]'
sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('UNDEF', '* h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6bbeb8>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a69e8>), ('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6c7128>)]'
cval_s=>'[('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6c14a8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6c1828>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6bb128>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6bb4a8>)]'
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id' - False OR  False
[i=10/23][j=6/9][dd=2/4][k=9/11] | type: uint32_t ; var :  ; varinfo :  ; value_node : id (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id
 => is literal (False) | is operator (False) id [vtype=uint32_t]
unique : ('uint32_t', 'id', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tmp->id' - False OR  False
[i=10/23][j=6/9][dd=2/4][k=10/11] | type: uint32_t ; var :  ; varinfo :  ; value_node : tmp -> id (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tmp,->,id
 => is literal (False) | is operator (False) tmp [vtype=struct haiku *]
unique : ('struct haiku *', 'tmp', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
----
UNIQ_INIT: ('uint32_t','id','None','None');

UNIQ_INIT: ('struct haiku *','tmp','None','None');

----
UNIQ_INIT: ('uint32_t','id','None','None');

UNIQ_INIT: ('struct haiku *','tmp','None','None');

==== Scope 1 ====
void fix_ingred_operation_10_6_9(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
struct haiku tmp_ref;
    bzero(&tmp_ref,1*sizeof(struct haiku));
struct haiku * tmp = &tmp_ref;
    {int count; count = (int)(id); }
}
void fix_ingred_operation_10_6_10(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
struct haiku tmp_ref;
    bzero(&tmp_ref,1*sizeof(struct haiku));
struct haiku * tmp = &tmp_ref;
    {int count; count = (int)(tmp -> id); }
}
void fix_ingred_operation_10_6(){
fix_ingred_operation_10_6_9();
fix_ingred_operation_10_6_10();
}

sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[('bool_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6ba358>), ('bool_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d6ba048>)]'
sym_lut=>'{'h': 'struct haiku * *', 'id': 'uint32_t', 'haiku_ptr': 'node_t *', 'tmp': 'struct haiku *', 'count': 'int', 'found': 'bool_t'}'
val_s=>'[('node_t *', 'haiku_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a9438>), ('struct haiku *', 'tmp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a24a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a8358>), ('bool_t', 'found', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6a1278>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_10_0_2(){
    {int count; count = (int)(0); }
}
void fix_ingred_operation_10_0(){
fix_ingred_operation_10_0_2();
}
void fix_ingred_operation_10_6_9(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
struct haiku tmp_ref;
    bzero(&tmp_ref,1*sizeof(struct haiku));
struct haiku * tmp = &tmp_ref;
    {int count; count = (int)(id); }
}
void fix_ingred_operation_10_6_10(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
struct haiku tmp_ref;
    bzero(&tmp_ref,1*sizeof(struct haiku));
struct haiku * tmp = &tmp_ref;
    {int count; count = (int)(tmp -> id); }
}
void fix_ingred_operation_10_6(){
fix_ingred_operation_10_6_9();
fix_ingred_operation_10_6_10();
}
void fix_ingred_operation_10(){
fix_ingred_operation_10_0();
fix_ingred_operation_10_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_10_0_2();
void fix_ingred_operation_10_0();
void fix_ingred_operation_10_6_9();
void fix_ingred_operation_10_6_10();
void fix_ingred_operation_10_6();
void fix_ingred_operation_10();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint32_t id ;
def_vars[1]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : char * content ;
def_vars[2]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint16_t length ;
def_vars[3]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv2 = ( char * ) & id ;
def_vars[4]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[5]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv4 = ( char * ) & length ;
def_vars[6]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[7]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = content ;
def_vars[8]: [cgc_send_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv5 ;
sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t'}'
val_s=>'[('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8048>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8f98>), ('uint16_t', 'length', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c9eb8>)]'
cval_s=>'[]'
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=11/23][j=0/4][dd=0/9][k=0/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
unique : ('struct haiku *', 'h', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
unique : ('uint32_t', 'id', None)
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=11/23][j=0/4][dd=0/9][k=1/3] | type: char * ; var : content ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=char *]
unique : ('char *', 'content', None)
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->length' - False OR  False
[i=11/23][j=0/4][dd=0/9][k=2/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : h -> length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,length
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) length [vtype=uint16_t]
unique : ('uint16_t', 'length', None)
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=11/23][j=0/4][dd=1/9][k=0/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=11/23][j=0/4][dd=1/9][k=1/3] | type: char * ; var : content ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=char *]
not unique: ('char *', 'content', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->length' - False OR  False
[i=11/23][j=0/4][dd=1/9][k=2/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : h -> length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,length
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=11/23][j=0/4][dd=2/9][k=0/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=11/23][j=0/4][dd=2/9][k=1/3] | type: char * ; var : content ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=char *]
not unique: ('char *', 'content', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->length' - False OR  False
[i=11/23][j=0/4][dd=2/9][k=2/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : h -> length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,length
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=11/23][j=0/4][dd=4/9][k=0/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=11/23][j=0/4][dd=4/9][k=1/3] | type: char * ; var : content ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=char *]
not unique: ('char *', 'content', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->length' - False OR  False
[i=11/23][j=0/4][dd=4/9][k=2/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : h -> length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,length
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=11/23][j=0/4][dd=6/9][k=0/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=11/23][j=0/4][dd=6/9][k=1/3] | type: char * ; var : content ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=char *]
not unique: ('char *', 'content', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->length' - False OR  False
[i=11/23][j=0/4][dd=6/9][k=2/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : h -> length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,length
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=11/23][j=0/4][dd=8/9][k=0/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=11/23][j=0/4][dd=8/9][k=1/3] | type: char * ; var : content ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=char *]
not unique: ('char *', 'content', None) ... continue!
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->length' - False OR  False
[i=11/23][j=0/4][dd=8/9][k=2/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : h -> length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,length
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
not valid - uint32_t id; id = ((uint32_t)h -> id);

----
UNIQ_INIT: ('struct haiku *','h','None','None');

UNIQ_INIT: ('uint32_t','id','None','None');

UNIQ_INIT: ('char *','content','None','None');

UNIQ_INIT: ('uint16_t','length','None','None');

not valid - char * content; content = ((char *)h -> content);

----
UNIQ_INIT: ('struct haiku *','h','None','None');

UNIQ_INIT: ('uint32_t','id','None','None');

UNIQ_INIT: ('char *','content','None','None');

UNIQ_INIT: ('uint16_t','length','None','None');

not valid - uint16_t length; length = ((uint16_t)h -> length);

----
UNIQ_INIT: ('struct haiku *','h','None','None');

UNIQ_INIT: ('uint32_t','id','None','None');

UNIQ_INIT: ('char *','content','None','None');

UNIQ_INIT: ('uint16_t','length','None','None');

==== Scope 1 ====
void fix_ingred_operation_11_0_0(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
uint32_t id;
    bzero(&id,sizeof(uint32_t));
char content_ref;
    bzero(&content_ref,1*sizeof(char));
char * content = &content_ref;
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {char * content; content = (char *)(h -> id); }
    {uint16_t length; length = (uint16_t)(h -> id); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(h -> id); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(h -> id); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(h -> id); }
}
void fix_ingred_operation_11_0_1(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
uint32_t id;
    bzero(&id,sizeof(uint32_t));
char content_ref;
    bzero(&content_ref,1*sizeof(char));
char * content = &content_ref;
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {uint32_t id; id = (uint32_t)(h -> content); }
    {uint16_t length; length = (uint16_t)(h -> content); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(h -> content); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(h -> content); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(h -> content); }
}
void fix_ingred_operation_11_0_2(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
uint32_t id;
    bzero(&id,sizeof(uint32_t));
char content_ref;
    bzero(&content_ref,1*sizeof(char));
char * content = &content_ref;
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {uint32_t id; id = (uint32_t)(h -> length); }
    {char * content; content = (char *)(h -> length); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(h -> length); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(h -> length); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(h -> length); }
}
void fix_ingred_operation_11_0(){
fix_ingred_operation_11_0_0();
fix_ingred_operation_11_0_1();
fix_ingred_operation_11_0_2();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv2': 'const char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c2128>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8048>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8f98>), ('uint16_t', 'length', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c9eb8>)]'
cval_s=>'[]'
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint32_t)' - False OR  False
[i=11/23][j=1/4][dd=0/9][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( uint32_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint32_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint32_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint32_t)' - False OR  False
[i=11/23][j=1/4][dd=1/9][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( uint32_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint32_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint32_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint32_t)' - False OR  False
[i=11/23][j=1/4][dd=2/9][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( uint32_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint32_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint32_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint32_t)' - False OR  False
[i=11/23][j=1/4][dd=4/9][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( uint32_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint32_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint32_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint32_t)' - False OR  False
[i=11/23][j=1/4][dd=6/9][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( uint32_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint32_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint32_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint32_t)' - False OR  False
[i=11/23][j=1/4][dd=8/9][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( uint32_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint32_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint32_t [vtype=None]
 => is literal (False) | is operator (True) )
----
==== Scope 1 ====
void fix_ingred_operation_11_1_0(){
    {uint32_t id; id = (uint32_t)(sizeof ( uint32_t )); }
    {char * content; content = (char *)(sizeof ( uint32_t )); }
    {uint16_t length; length = (uint16_t)(sizeof ( uint32_t )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( uint32_t )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( uint32_t )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(sizeof ( uint32_t )); }
}
void fix_ingred_operation_11_1(){
fix_ingred_operation_11_1_0();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv2': 'const char *', 'tlv1': 'cgc_size_t', 'tlv4': 'const char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4af7b8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8048>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8f98>), ('uint16_t', 'length', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c9eb8>)]'
cval_s=>'[]'
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint16_t)' - False OR  False
[i=11/23][j=2/4][dd=0/9][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( uint16_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint16_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint16_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint16_t)' - False OR  False
[i=11/23][j=2/4][dd=1/9][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( uint16_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint16_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint16_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint16_t)' - False OR  False
[i=11/23][j=2/4][dd=2/9][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( uint16_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint16_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint16_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint16_t)' - False OR  False
[i=11/23][j=2/4][dd=4/9][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( uint16_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint16_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint16_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint16_t)' - False OR  False
[i=11/23][j=2/4][dd=6/9][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( uint16_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint16_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint16_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(uint16_t)' - False OR  False
[i=11/23][j=2/4][dd=8/9][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( uint16_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,uint16_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) uint16_t [vtype=None]
 => is literal (False) | is operator (True) )
----
==== Scope 1 ====
void fix_ingred_operation_11_2_0(){
    {uint32_t id; id = (uint32_t)(sizeof ( uint16_t )); }
    {char * content; content = (char *)(sizeof ( uint16_t )); }
    {uint16_t length; length = (uint16_t)(sizeof ( uint16_t )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( uint16_t )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( uint16_t )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(sizeof ( uint16_t )); }
}
void fix_ingred_operation_11_2(){
fix_ingred_operation_11_2_0();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv2': 'const char *', 'tlv1': 'cgc_size_t', 'tlv4': 'const char *', 'tlv3': 'cgc_size_t', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d49ca58>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8048>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b8f98>), ('uint16_t', 'length', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c9eb8>)]'
cval_s=>'[]'
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'length' - False OR  False
[i=11/23][j=3/4][dd=0/9][k=0/4] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : length
 => is literal (False) | is operator (False) length [vtype=uint16_t]
unique : ('uint16_t', 'length', None)
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'length' - False OR  False
[i=11/23][j=3/4][dd=1/9][k=0/4] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : length
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'length' - False OR  False
[i=11/23][j=3/4][dd=2/9][k=0/4] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : length
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'length' - False OR  False
[i=11/23][j=3/4][dd=4/9][k=0/4] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : length
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'length' - False OR  False
[i=11/23][j=3/4][dd=6/9][k=0/4] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : length
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'length' - False OR  False
[i=11/23][j=3/4][dd=8/9][k=0/4] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : length (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : length
 => is literal (False) | is operator (False) length [vtype=uint16_t]
not unique: ('uint16_t', 'length', None) ... continue!
not valid - uint16_t length; length = ((uint16_t)length);

----
UNIQ_INIT: ('uint16_t','length','None','None');

==== Scope 1 ====
void fix_ingred_operation_11_3_0(){
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {uint32_t id; id = (uint32_t)(length); }
    {char * content; content = (char *)(length); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(length); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(length); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(length); }
}
void fix_ingred_operation_11_3(){
fix_ingred_operation_11_3_0();
}

==== Scope 2 ====
void fix_ingred_operation_11_0_0(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
uint32_t id;
    bzero(&id,sizeof(uint32_t));
char content_ref;
    bzero(&content_ref,1*sizeof(char));
char * content = &content_ref;
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {char * content; content = (char *)(h -> id); }
    {uint16_t length; length = (uint16_t)(h -> id); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(h -> id); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(h -> id); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(h -> id); }
}
void fix_ingred_operation_11_0_1(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
uint32_t id;
    bzero(&id,sizeof(uint32_t));
char content_ref;
    bzero(&content_ref,1*sizeof(char));
char * content = &content_ref;
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {uint32_t id; id = (uint32_t)(h -> content); }
    {uint16_t length; length = (uint16_t)(h -> content); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(h -> content); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(h -> content); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(h -> content); }
}
void fix_ingred_operation_11_0_2(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
uint32_t id;
    bzero(&id,sizeof(uint32_t));
char content_ref;
    bzero(&content_ref,1*sizeof(char));
char * content = &content_ref;
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {uint32_t id; id = (uint32_t)(h -> length); }
    {char * content; content = (char *)(h -> length); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(h -> length); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(h -> length); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(h -> length); }
}
void fix_ingred_operation_11_0(){
fix_ingred_operation_11_0_0();
fix_ingred_operation_11_0_1();
fix_ingred_operation_11_0_2();
}
void fix_ingred_operation_11_1_0(){
    {uint32_t id; id = (uint32_t)(sizeof ( uint32_t )); }
    {char * content; content = (char *)(sizeof ( uint32_t )); }
    {uint16_t length; length = (uint16_t)(sizeof ( uint32_t )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( uint32_t )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( uint32_t )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(sizeof ( uint32_t )); }
}
void fix_ingred_operation_11_1(){
fix_ingred_operation_11_1_0();
}
void fix_ingred_operation_11_2_0(){
    {uint32_t id; id = (uint32_t)(sizeof ( uint16_t )); }
    {char * content; content = (char *)(sizeof ( uint16_t )); }
    {uint16_t length; length = (uint16_t)(sizeof ( uint16_t )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( uint16_t )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( uint16_t )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(sizeof ( uint16_t )); }
}
void fix_ingred_operation_11_2(){
fix_ingred_operation_11_2_0();
}
void fix_ingred_operation_11_3_0(){
uint16_t length;
    bzero(&length,sizeof(uint16_t));
    {uint32_t id; id = (uint32_t)(length); }
    {char * content; content = (char *)(length); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(length); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(length); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(length); }
}
void fix_ingred_operation_11_3(){
fix_ingred_operation_11_3_0();
}
void fix_ingred_operation_11(){
fix_ingred_operation_11_0();
fix_ingred_operation_11_1();
fix_ingred_operation_11_2();
fix_ingred_operation_11_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_11_0_0();
void fix_ingred_operation_11_0_1();
void fix_ingred_operation_11_0_2();
void fix_ingred_operation_11_0();
void fix_ingred_operation_11_1_0();
void fix_ingred_operation_11_1();
void fix_ingred_operation_11_2_0();
void fix_ingred_operation_11_2();
void fix_ingred_operation_11_3_0();
void fix_ingred_operation_11_3();
void fix_ingred_operation_11();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint32_t id ;
def_vars[1]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : char * content ;
def_vars[2]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint16_t length ;
def_vars[3]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv7 = content ;
def_vars[4]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv2 = ( char * ) & id ;
def_vars[5]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[6]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv4 = ( char * ) & length ;
def_vars[7]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[8]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = content ;
def_vars[9]: [cgc_send_easter_egg_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv5 ;
sym_lut=>'{'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t'}'
val_s=>'[('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c8ac8>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4a1a58>)]'
cval_s=>'[]'
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=12/23][j=0/5][dd=0/10][k=0/2] | type: uint32_t ; var : id ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_HAIKU' - False OR  False
[i=12/23][j=0/5][dd=0/10][k=1/2] | type: char * ; var : content ; varinfo :  ; value_node : EGG_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_HAIKU
 => is literal (False) | is operator (False) EGG_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=12/23][j=0/5][dd=1/10][k=0/2] | type: uint32_t ; var : id ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_HAIKU' - False OR  False
[i=12/23][j=0/5][dd=1/10][k=1/2] | type: char * ; var : content ; varinfo :  ; value_node : EGG_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_HAIKU
 => is literal (False) | is operator (False) EGG_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=12/23][j=0/5][dd=2/10][k=0/2] | type: uint32_t ; var : id ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_HAIKU' - False OR  False
[i=12/23][j=0/5][dd=2/10][k=1/2] | type: char * ; var : content ; varinfo :  ; value_node : EGG_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_HAIKU
 => is literal (False) | is operator (False) EGG_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=12/23][j=0/5][dd=5/10][k=0/2] | type: uint32_t ; var : id ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_HAIKU' - False OR  False
[i=12/23][j=0/5][dd=5/10][k=1/2] | type: char * ; var : content ; varinfo :  ; value_node : EGG_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_HAIKU
 => is literal (False) | is operator (False) EGG_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=12/23][j=0/5][dd=7/10][k=0/2] | type: uint32_t ; var : id ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_HAIKU' - False OR  False
[i=12/23][j=0/5][dd=7/10][k=1/2] | type: char * ; var : content ; varinfo :  ; value_node : EGG_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_HAIKU
 => is literal (False) | is operator (False) EGG_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=12/23][j=0/5][dd=9/10][k=0/2] | type: uint32_t ; var : id ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_HAIKU' - False OR  False
[i=12/23][j=0/5][dd=9/10][k=1/2] | type: char * ; var : content ; varinfo :  ; value_node : EGG_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_HAIKU
 => is literal (False) | is operator (False) EGG_HAIKU [vtype=None]
----
----
==== Scope 1 ====
void fix_ingred_operation_12_0_0(){
    {uint32_t id; id = (uint32_t)(EGG_ID); }
    {char * content; content = (char *)(EGG_ID); }
    {uint16_t length; length = (uint16_t)(EGG_ID); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(EGG_ID); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(EGG_ID); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(EGG_ID); }
}
void fix_ingred_operation_12_0_1(){
    {uint32_t id; id = (uint32_t)(EGG_HAIKU); }
    {char * content; content = (char *)(EGG_HAIKU); }
    {uint16_t length; length = (uint16_t)(EGG_HAIKU); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(EGG_HAIKU); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(EGG_HAIKU); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(EGG_HAIKU); }
}
void fix_ingred_operation_12_0(){
fix_ingred_operation_12_0_0();
fix_ingred_operation_12_0_1();
}

sym_lut=>'{'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv7': 'const char *'}'
val_s=>'[('uint16_t', 'length', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b7898>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c8ac8>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4a1a58>)]'
cval_s=>'[]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/23][j=1/5][dd=0/10][k=0/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
unique : ('const char *', 'tlv7', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/23][j=1/5][dd=1/10][k=0/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/23][j=1/5][dd=2/10][k=0/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/23][j=1/5][dd=5/10][k=0/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/23][j=1/5][dd=7/10][k=0/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/23][j=1/5][dd=9/10][k=0/3] | type: uint16_t ; var : length ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv7','None','None');

==== Scope 1 ====
void fix_ingred_operation_12_1_0(){
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
const char * tlv7 = &tlv7_ref;
    {uint32_t id; id = (uint32_t)(cgc_strlen ( tlv7 )); }
    {char * content; content = (char *)(cgc_strlen ( tlv7 )); }
    {uint16_t length; length = (uint16_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_operation_12_1(){
fix_ingred_operation_12_1_0();
}

sym_lut=>'{'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv7': 'const char *', 'tlv2': 'const char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d495cf8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c8ac8>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4a1a58>)]'
cval_s=>'[]'
sym_lut=>'{'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv7': 'const char *', 'tlv2': 'const char *', 'tlv1': 'cgc_size_t', 'tlv4': 'const char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d49b3c8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c8ac8>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4a1a58>)]'
cval_s=>'[]'
sym_lut=>'{'id': 'uint32_t', 'content': 'char *', 'length': 'uint16_t', 'tlv7': 'const char *', 'tlv2': 'const char *', 'tlv1': 'cgc_size_t', 'tlv4': 'const char *', 'tlv3': 'cgc_size_t', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d622e48>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4c8ac8>), ('char *', 'content', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4a1a58>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_12_0_0(){
    {uint32_t id; id = (uint32_t)(EGG_ID); }
    {char * content; content = (char *)(EGG_ID); }
    {uint16_t length; length = (uint16_t)(EGG_ID); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(EGG_ID); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(EGG_ID); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(EGG_ID); }
}
void fix_ingred_operation_12_0_1(){
    {uint32_t id; id = (uint32_t)(EGG_HAIKU); }
    {char * content; content = (char *)(EGG_HAIKU); }
    {uint16_t length; length = (uint16_t)(EGG_HAIKU); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(EGG_HAIKU); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(EGG_HAIKU); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(EGG_HAIKU); }
}
void fix_ingred_operation_12_0(){
fix_ingred_operation_12_0_0();
fix_ingred_operation_12_0_1();
}
void fix_ingred_operation_12_1_0(){
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
const char * tlv7 = &tlv7_ref;
    {uint32_t id; id = (uint32_t)(cgc_strlen ( tlv7 )); }
    {char * content; content = (char *)(cgc_strlen ( tlv7 )); }
    {uint16_t length; length = (uint16_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_operation_12_1(){
fix_ingred_operation_12_1_0();
}
void fix_ingred_operation_12(){
fix_ingred_operation_12_0();
fix_ingred_operation_12_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_12_0_0();
void fix_ingred_operation_12_0_1();
void fix_ingred_operation_12_0();
void fix_ingred_operation_12_1_0();
void fix_ingred_operation_12_1();
void fix_ingred_operation_12();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_send_haiku_id] : <class 'CParser.CParser.DeclarationContext'> : SENDUI ( id ) ;
sym_lut=>'{'id': 'uint32_t', '(': 'SENDUI *', '( id )': 'SENDUI'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'SENDUI( id )' - is_func=True, is_func_ptr=False
SENDUI( id ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_operation_13(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_13();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_add_haiku_to_list] : <class 'CParser.CParser.DeclarationContext'> : node_t * nd ;
def_vars[1]: [cgc_add_haiku_to_list] : <class 'CParser.CParser.DeclarationContext'> : void * tlv1 ;
sym_lut=>'{'h': 'struct haiku *', 'nd': 'node_t *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'h': 'struct haiku *', 'nd': 'node_t *', 'tlv1': 'void *'}'
val_s=>'[('void *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d463a58>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)h' - False OR  False
[i=14/23][j=1/2][dd=1/2][k=0/1] | type: void * ; var : tlv1 ; varinfo :  ; value_node : ( void * ) h (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),h
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
unique : ('struct haiku *', 'h', None)
----
UNIQ_INIT: ('struct haiku *','h','None','None');

==== Scope 1 ====
void fix_ingred_operation_14_1_0(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {void * tlv1; tlv1 = (void *)(( void * ) h); }
}
void fix_ingred_operation_14_1(){
fix_ingred_operation_14_1_0();
}

==== Scope 2 ====
void fix_ingred_operation_14_1_0(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {void * tlv1; tlv1 = (void *)(( void * ) h); }
}
void fix_ingred_operation_14_1(){
fix_ingred_operation_14_1_0();
}
void fix_ingred_operation_14(){
fix_ingred_operation_14_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_14_1_0();
void fix_ingred_operation_14_1();
void fix_ingred_operation_14();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_recv_haiku_line] : <class 'CParser.CParser.DeclarationContext'> : char temp_line_buf [ MAX_HAIKU_LINE_LEN ] = { 0 } ;
def_vars[1]: [cgc_recv_haiku_line] : <class 'CParser.CParser.DeclarationContext'> : int16_t bytes_received ;
def_vars[2]: [cgc_recv_haiku_line] : <class 'CParser.CParser.DeclarationContext'> : int16_t bytes_written ;
def_vars[3]: [cgc_recv_haiku_line] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[4]: [cgc_recv_haiku_line] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[5]: [cgc_recv_haiku_line] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
sym_lut=>'{'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'temp_line_buf': 'char *', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]': 'char', 'bytes_received': 'int16_t', 'bytes_written': 'int16_t'}'
val_s=>'[('int16_t', 'bytes_received', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d494278>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4cb198>)]'
cval_s=>'[]'
Skipping MAX_HAIKU_LINE_LEN => #define
sym_lut=>'{'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'temp_line_buf': 'char *', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]': 'char', 'bytes_received': 'int16_t', 'bytes_written': 'int16_t', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4b5208>), ('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d718198>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d7150b8>), ('int16_t', 'bytes_received', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d494278>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4cb198>)]'
cval_s=>'[]'
Skipping MAX_HAIKU_LINE_LEN => #define
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/23][j=1/3][dd=0/6][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'temp_line_buf' - False OR  False
[i=15/23][j=1/3][dd=0/6][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : temp_line_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : temp_line_buf
 => is literal (False) | is operator (False) temp_line_buf [vtype=char *]
BEFORE => literal (False) temp_line_buf => char *
AFTER => literal (False) temp_line_buf [ MAX_HAIKU_LINE_LEN ] => char [size=MAX_HAIKU_LINE_LEN]
Array size is variable => 'MAX_HAIKU_LINE_LEN'
unique : ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None)
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LINE_LEN' - False OR  False
[i=15/23][j=1/3][dd=0/6][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : MAX_HAIKU_LINE_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LINE_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LINE_LEN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/23][j=1/3][dd=3/6][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'temp_line_buf' - False OR  False
[i=15/23][j=1/3][dd=3/6][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : temp_line_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : temp_line_buf
 => is literal (False) | is operator (False) temp_line_buf [vtype=char *]
BEFORE => literal (False) temp_line_buf => char *
AFTER => literal (False) temp_line_buf [ MAX_HAIKU_LINE_LEN ] => char [size=MAX_HAIKU_LINE_LEN]
Array size is variable => 'MAX_HAIKU_LINE_LEN'
not unique: ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LINE_LEN' - False OR  False
[i=15/23][j=1/3][dd=3/6][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : MAX_HAIKU_LINE_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LINE_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LINE_LEN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/23][j=1/3][dd=4/6][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'temp_line_buf' - False OR  False
[i=15/23][j=1/3][dd=4/6][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : temp_line_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : temp_line_buf
 => is literal (False) | is operator (False) temp_line_buf [vtype=char *]
BEFORE => literal (False) temp_line_buf => char *
AFTER => literal (False) temp_line_buf [ MAX_HAIKU_LINE_LEN ] => char [size=MAX_HAIKU_LINE_LEN]
Array size is variable => 'MAX_HAIKU_LINE_LEN'
not unique: ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LINE_LEN' - False OR  False
[i=15/23][j=1/3][dd=4/6][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : MAX_HAIKU_LINE_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LINE_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LINE_LEN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/23][j=1/3][dd=5/6][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'temp_line_buf' - False OR  False
[i=15/23][j=1/3][dd=5/6][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : temp_line_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : temp_line_buf
 => is literal (False) | is operator (False) temp_line_buf [vtype=char *]
BEFORE => literal (False) temp_line_buf => char *
AFTER => literal (False) temp_line_buf [ MAX_HAIKU_LINE_LEN ] => char [size=MAX_HAIKU_LINE_LEN]
Array size is variable => 'MAX_HAIKU_LINE_LEN'
not unique: ('char', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LINE_LEN' - False OR  False
[i=15/23][j=1/3][dd=5/6][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : MAX_HAIKU_LINE_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LINE_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LINE_LEN [vtype=None]
----
UNIQ_INIT: ('char','temp_line_buf [ MAX_HAIKU_LINE_LEN ]','None','None');

----
UNIQ_INIT: ('char','temp_line_buf [ MAX_HAIKU_LINE_LEN ]','None','None');

----
UNIQ_INIT: ('char','temp_line_buf [ MAX_HAIKU_LINE_LEN ]','None','None');

==== Scope 1 ====
void fix_ingred_operation_15_1_0(){
char temp_line_buf [ MAX_HAIKU_LINE_LEN ];
    bzero(&temp_line_buf,( MAX_HAIKU_LINE_LEN *sizeof(char) ) );
    {char temp_line_buf [ MAX_HAIKU_LINE_LEN ]; temp_line_buf [ ( MAX_HAIKU_LINE_LEN )-1 ] = (char)(STDIN); }
    {int tlv3; tlv3 = (int)(STDIN); }
    {char * tlv2; tlv2 = (char *)(STDIN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(STDIN); }
}
void fix_ingred_operation_15_1_1(){
char temp_line_buf [ MAX_HAIKU_LINE_LEN ];
    bzero(&temp_line_buf,( MAX_HAIKU_LINE_LEN *sizeof(char) ) );
    {char temp_line_buf [ MAX_HAIKU_LINE_LEN ]; temp_line_buf [ ( MAX_HAIKU_LINE_LEN )-1 ] = (char)(temp_line_buf); }
    {int tlv3; tlv3 = (int)(temp_line_buf); }
    {char * tlv2; tlv2 = (char *)(temp_line_buf); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(temp_line_buf); }
}
void fix_ingred_operation_15_1_2(){
char temp_line_buf [ MAX_HAIKU_LINE_LEN ];
    bzero(&temp_line_buf,( MAX_HAIKU_LINE_LEN *sizeof(char) ) );
    {char temp_line_buf [ MAX_HAIKU_LINE_LEN ]; temp_line_buf [ ( MAX_HAIKU_LINE_LEN )-1 ] = (char)(MAX_HAIKU_LINE_LEN); }
    {int tlv3; tlv3 = (int)(MAX_HAIKU_LINE_LEN); }
    {char * tlv2; tlv2 = (char *)(MAX_HAIKU_LINE_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(MAX_HAIKU_LINE_LEN); }
}
void fix_ingred_operation_15_1(){
fix_ingred_operation_15_1_0();
fix_ingred_operation_15_1_1();
fix_ingred_operation_15_1_2();
}

sym_lut=>'{'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'temp_line_buf': 'char *', 'temp_line_buf [ MAX_HAIKU_LINE_LEN ]': 'char', 'bytes_received': 'int16_t', 'bytes_written': 'int16_t', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int16_t', 'bytes_received', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d494278>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d4cb198>)]'
cval_s=>'[('int16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d71be48>), ('int16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d71a198>)]'
Skipping MAX_HAIKU_LINE_LEN => #define
==== Scope 2 ====
void fix_ingred_operation_15_1_0(){
char temp_line_buf [ MAX_HAIKU_LINE_LEN ];
    bzero(&temp_line_buf,( MAX_HAIKU_LINE_LEN *sizeof(char) ) );
    {char temp_line_buf [ MAX_HAIKU_LINE_LEN ]; temp_line_buf [ ( MAX_HAIKU_LINE_LEN )-1 ] = (char)(STDIN); }
    {int tlv3; tlv3 = (int)(STDIN); }
    {char * tlv2; tlv2 = (char *)(STDIN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(STDIN); }
}
void fix_ingred_operation_15_1_1(){
char temp_line_buf [ MAX_HAIKU_LINE_LEN ];
    bzero(&temp_line_buf,( MAX_HAIKU_LINE_LEN *sizeof(char) ) );
    {char temp_line_buf [ MAX_HAIKU_LINE_LEN ]; temp_line_buf [ ( MAX_HAIKU_LINE_LEN )-1 ] = (char)(temp_line_buf); }
    {int tlv3; tlv3 = (int)(temp_line_buf); }
    {char * tlv2; tlv2 = (char *)(temp_line_buf); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(temp_line_buf); }
}
void fix_ingred_operation_15_1_2(){
char temp_line_buf [ MAX_HAIKU_LINE_LEN ];
    bzero(&temp_line_buf,( MAX_HAIKU_LINE_LEN *sizeof(char) ) );
    {char temp_line_buf [ MAX_HAIKU_LINE_LEN ]; temp_line_buf [ ( MAX_HAIKU_LINE_LEN )-1 ] = (char)(MAX_HAIKU_LINE_LEN); }
    {int tlv3; tlv3 = (int)(MAX_HAIKU_LINE_LEN); }
    {char * tlv2; tlv2 = (char *)(MAX_HAIKU_LINE_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(MAX_HAIKU_LINE_LEN); }
}
void fix_ingred_operation_15_1(){
fix_ingred_operation_15_1_0();
fix_ingred_operation_15_1_1();
fix_ingred_operation_15_1_2();
}
void fix_ingred_operation_15(){
fix_ingred_operation_15_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_15_1_0();
void fix_ingred_operation_15_1_1();
void fix_ingred_operation_15_1_2();
void fix_ingred_operation_15_1();
void fix_ingred_operation_15();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_recv_haiku] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * h ;
def_vars[1]: [cgc_recv_haiku] : <class 'CParser.CParser.DeclarationContext'> : char * haiku_content_ptr ;
def_vars[2]: [cgc_recv_haiku] : <class 'CParser.CParser.DeclarationContext'> : int16_t bytes_remaining ;
def_vars[3]: [cgc_recv_haiku] : <class 'CParser.CParser.DeclarationContext'> : int16_t bytes_written ;
def_vars[4]: [cgc_recv_haiku] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[5]: [cgc_recv_haiku] : <class 'CParser.CParser.DeclarationContext'> : int16_t tlv1 ;
sym_lut=>'{'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'bytes_written': 'int16_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3daba8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e0b38>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3dda58>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e8978>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e74a8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da1a2e8>), ('UNDEF', 'h -> length', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94a2e8>)]'
cval_s=>'[]'
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/23][j=0/4][dd=1/6][k=1/7] | type: char * ; var : haiku_content_ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=16/23][j=0/4][dd=1/6][k=5/7] | type: char * ; var : haiku_content_ptr ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
unique : ('struct haiku *', 'h', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=16/23][j=0/4][dd=4/6][k=1/7] | type: char * ; var : haiku_content_ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->content' - False OR  False
[i=16/23][j=0/4][dd=4/6][k=5/7] | type: char * ; var : haiku_content_ptr ; varinfo :  ; value_node : h -> content (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,content
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) content [vtype=None]
----
UNIQ_INIT: ('struct haiku *','h','None','None');

----
UNIQ_INIT: ('struct haiku *','h','None','None');

==== Scope 1 ====
void fix_ingred_operation_16_0_1(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {char * haiku_content_ptr; haiku_content_ptr = (char *)(NULL); }
    {char * tlv2; tlv2 = (char *)(NULL); }
}
void fix_ingred_operation_16_0_5(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {char * haiku_content_ptr; haiku_content_ptr = (char *)(h -> content); }
    {char * tlv2; tlv2 = (char *)(h -> content); }
}
void fix_ingred_operation_16_0(){
fix_ingred_operation_16_0_1();
fix_ingred_operation_16_0_5();
}

sym_lut=>'{'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'bytes_written': 'int16_t'}'
val_s=>'[('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da42198>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da42c88>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3daba8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e0b38>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3dda58>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e8978>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e74a8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da1a2e8>)]'
cval_s=>'[('int16_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212da1af28>)]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=16/23][j=1/4][dd=1/6][k=0/9] | type: char * ; var : haiku_content_ptr ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=int16_t]
unique : ('int16_t', 'bytes_written', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=16/23][j=1/4][dd=4/6][k=0/9] | type: char * ; var : haiku_content_ptr ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=int16_t]
not unique: ('int16_t', 'bytes_written', None) ... continue!
----
UNIQ_INIT: ('int16_t','bytes_written','None','None');

==== Scope 1 ====
void fix_ingred_operation_16_1_0(){
int16_t bytes_written;
    bzero(&bytes_written,sizeof(int16_t));
    {char * haiku_content_ptr; haiku_content_ptr = (char *)(bytes_written); }
    {char * tlv2; tlv2 = (char *)(bytes_written); }
}
void fix_ingred_operation_16_1(){
fix_ingred_operation_16_1_0();
}

sym_lut=>'{'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'bytes_written': 'int16_t', 'tlv2': 'char *', 'tlv1': 'int16_t'}'
val_s=>'[('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da3d208>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3daba8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e0b38>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3dda58>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e8978>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e74a8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da1a2e8>)]'
cval_s=>'[('int16_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212da1af28>)]'
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'haiku_content_ptr' - False OR  False
[i=16/23][j=2/4][dd=1/6][k=0/8] | type: char * ; var : tlv2 ; varinfo :  ; value_node : haiku_content_ptr (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : haiku_content_ptr
 => is literal (False) | is operator (False) haiku_content_ptr [vtype=char *]
unique : ('char *', 'haiku_content_ptr', None)
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'haiku_content_ptr' - False OR  False
[i=16/23][j=2/4][dd=4/6][k=0/8] | type: char * ; var : tlv2 ; varinfo :  ; value_node : haiku_content_ptr (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : haiku_content_ptr
 => is literal (False) | is operator (False) haiku_content_ptr [vtype=char *]
not unique: ('char *', 'haiku_content_ptr', None) ... continue!
not valid - char * haiku_content_ptr; haiku_content_ptr = ((char *)haiku_content_ptr);

----
UNIQ_INIT: ('char *','haiku_content_ptr','None','None');

==== Scope 1 ====
void fix_ingred_operation_16_2_0(){
char haiku_content_ptr_ref;
    bzero(&haiku_content_ptr_ref,1*sizeof(char));
char * haiku_content_ptr = &haiku_content_ptr_ref;
    {char * tlv2; tlv2 = (char *)(haiku_content_ptr); }
}
void fix_ingred_operation_16_2(){
fix_ingred_operation_16_2_0();
}

sym_lut=>'{'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'haiku_content_ptr': 'char *', 'bytes_remaining': 'int16_t', 'bytes_written': 'int16_t', 'tlv2': 'char *', 'tlv1': 'int16_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3daba8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e0b38>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3dda58>), ('int16_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e8978>), ('int16_t', 'bytes_remaining', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3e74a8>), ('char *', 'haiku_content_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212da1a2e8>)]'
cval_s=>'[('int16_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212da1af28>), ('int16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212da44cf8>), ('int16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212da39048>)]'
==== Scope 2 ====
void fix_ingred_operation_16_0_1(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {char * haiku_content_ptr; haiku_content_ptr = (char *)(NULL); }
    {char * tlv2; tlv2 = (char *)(NULL); }
}
void fix_ingred_operation_16_0_5(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {char * haiku_content_ptr; haiku_content_ptr = (char *)(h -> content); }
    {char * tlv2; tlv2 = (char *)(h -> content); }
}
void fix_ingred_operation_16_0(){
fix_ingred_operation_16_0_1();
fix_ingred_operation_16_0_5();
}
void fix_ingred_operation_16_1_0(){
int16_t bytes_written;
    bzero(&bytes_written,sizeof(int16_t));
    {char * haiku_content_ptr; haiku_content_ptr = (char *)(bytes_written); }
    {char * tlv2; tlv2 = (char *)(bytes_written); }
}
void fix_ingred_operation_16_1(){
fix_ingred_operation_16_1_0();
}
void fix_ingred_operation_16_2_0(){
char haiku_content_ptr_ref;
    bzero(&haiku_content_ptr_ref,1*sizeof(char));
char * haiku_content_ptr = &haiku_content_ptr_ref;
    {char * tlv2; tlv2 = (char *)(haiku_content_ptr); }
}
void fix_ingred_operation_16_2(){
fix_ingred_operation_16_2_0();
}
void fix_ingred_operation_16(){
fix_ingred_operation_16_0();
fix_ingred_operation_16_1();
fix_ingred_operation_16_2();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_16_0_1();
void fix_ingred_operation_16_0_5();
void fix_ingred_operation_16_0();
void fix_ingred_operation_16_1_0();
void fix_ingred_operation_16_1();
void fix_ingred_operation_16_2_0();
void fix_ingred_operation_16_2();
void fix_ingred_operation_16();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_operation_17(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_17();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint16_t total_bytes ;
def_vars[2]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * h ;
def_vars[3]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
def_vars[4]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint16_t tlv2 ;
def_vars[5]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * tlv4 ;
def_vars[6]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : uint32_t tlv3 ;
def_vars[7]: [cgc_add_haiku] : <class 'CParser.CParser.DeclarationContext'> : cgc_send_haiku_id ( tlv3 ) ;
sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=18/23][j=0/9][dd=0/8][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/23][j=0/9][dd=0/8][k=1/3] | type: uint16_t ; var : total_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=18/23][j=0/9][dd=1/8][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/23][j=0/9][dd=1/8][k=1/3] | type: uint16_t ; var : total_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=18/23][j=0/9][dd=3/8][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/23][j=0/9][dd=3/8][k=1/3] | type: uint16_t ; var : total_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=18/23][j=0/9][dd=4/8][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/23][j=0/9][dd=4/8][k=1/3] | type: uint16_t ; var : total_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=18/23][j=0/9][dd=6/8][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=18/23][j=0/9][dd=6/8][k=1/3] | type: uint16_t ; var : total_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_operation_18_0_0(){
    {int ret; ret = (int)(SUCCESS); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(SUCCESS); }
    {uint8_t tlv1; tlv1 = (uint8_t)(SUCCESS); }
    {uint16_t tlv2; tlv2 = (uint16_t)(SUCCESS); }
    {uint32_t tlv3; tlv3 = (uint32_t)(SUCCESS); }
}
void fix_ingred_operation_18_0_1(){
    {int ret; ret = (int)(0); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(0); }
    {uint8_t tlv1; tlv1 = (uint8_t)(0); }
    {uint16_t tlv2; tlv2 = (uint16_t)(0); }
    {uint32_t tlv3; tlv3 = (uint32_t)(0); }
}
void fix_ingred_operation_18_0(){
fix_ingred_operation_18_0_0();
fix_ingred_operation_18_0_1();
}

sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d92e908>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d92ec88>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
is_func_ [F] => '[False, False, False]'
has_multiptr_refs 'FALSE' - False OR  False
[i=18/23][j=1/9][dd=0/8][k=3/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : FALSE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : FALSE
 => is literal (False) | is operator (False) FALSE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=18/23][j=1/9][dd=0/8][k=4/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
unique : ('uint8_t', 'tlv1', None)
is_func_ [F] => '[False, False, False]'
has_multiptr_refs 'FALSE' - False OR  False
[i=18/23][j=1/9][dd=1/8][k=3/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : FALSE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : FALSE
 => is literal (False) | is operator (False) FALSE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=18/23][j=1/9][dd=1/8][k=4/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
not unique: ('uint8_t', 'tlv1', None) ... continue!
is_func_ [F] => '[False, False, False]'
has_multiptr_refs 'FALSE' - False OR  False
[i=18/23][j=1/9][dd=4/8][k=3/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : FALSE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : FALSE
 => is literal (False) | is operator (False) FALSE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=18/23][j=1/9][dd=4/8][k=4/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
not unique: ('uint8_t', 'tlv1', None) ... continue!
is_func_ [F] => '[False, False, False]'
has_multiptr_refs 'FALSE' - False OR  False
[i=18/23][j=1/9][dd=6/8][k=3/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : FALSE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : FALSE
 => is literal (False) | is operator (False) FALSE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=18/23][j=1/9][dd=6/8][k=4/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
not unique: ('uint8_t', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_operation_18_1_3(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int ret; ret = (int)(FALSE); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(FALSE); }
    {uint16_t tlv2; tlv2 = (uint16_t)(FALSE); }
    {uint32_t tlv3; tlv3 = (uint32_t)(FALSE); }
}
void fix_ingred_operation_18_1_4(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int ret; ret = (int)(tlv1); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(tlv1); }
    {uint16_t tlv2; tlv2 = (uint16_t)(tlv1); }
    {uint32_t tlv3; tlv3 = (uint32_t)(tlv1); }
}
void fix_ingred_operation_18_1(){
fix_ingred_operation_18_1_3();
fix_ingred_operation_18_1_4();
}

sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c5f8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e5f8>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total_bytes' - False OR  False
[i=18/23][j=2/9][dd=0/8][k=4/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : total_bytes (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total_bytes
 => is literal (False) | is operator (False) total_bytes [vtype=uint16_t]
unique : ('uint16_t', 'total_bytes', None)
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LEN' - False OR  False
[i=18/23][j=2/9][dd=0/8][k=5/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : MAX_HAIKU_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total_bytes' - False OR  False
[i=18/23][j=2/9][dd=1/8][k=4/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : total_bytes (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total_bytes
 => is literal (False) | is operator (False) total_bytes [vtype=uint16_t]
not unique: ('uint16_t', 'total_bytes', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LEN' - False OR  False
[i=18/23][j=2/9][dd=1/8][k=5/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : MAX_HAIKU_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total_bytes' - False OR  False
[i=18/23][j=2/9][dd=3/8][k=4/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : total_bytes (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total_bytes
 => is literal (False) | is operator (False) total_bytes [vtype=uint16_t]
not unique: ('uint16_t', 'total_bytes', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LEN' - False OR  False
[i=18/23][j=2/9][dd=3/8][k=5/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : MAX_HAIKU_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total_bytes' - False OR  False
[i=18/23][j=2/9][dd=4/8][k=4/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : total_bytes (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total_bytes
 => is literal (False) | is operator (False) total_bytes [vtype=uint16_t]
not unique: ('uint16_t', 'total_bytes', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LEN' - False OR  False
[i=18/23][j=2/9][dd=4/8][k=5/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : MAX_HAIKU_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total_bytes' - False OR  False
[i=18/23][j=2/9][dd=6/8][k=4/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : total_bytes (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total_bytes
 => is literal (False) | is operator (False) total_bytes [vtype=uint16_t]
not unique: ('uint16_t', 'total_bytes', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_HAIKU_LEN' - False OR  False
[i=18/23][j=2/9][dd=6/8][k=5/7] | type: uint16_t ; var :  ; varinfo :  ; value_node : MAX_HAIKU_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_HAIKU_LEN
 => is literal (False) | is operator (False) MAX_HAIKU_LEN [vtype=None]
not valid - uint16_t total_bytes; total_bytes = ((uint16_t)total_bytes);

----
UNIQ_INIT: ('uint16_t','total_bytes','None','None');

----
UNIQ_INIT: ('uint16_t','total_bytes','None','None');

==== Scope 1 ====
void fix_ingred_operation_18_2_4(){
uint16_t total_bytes;
    bzero(&total_bytes,sizeof(uint16_t));
    {int ret; ret = (int)(total_bytes); }
    {uint8_t tlv1; tlv1 = (uint8_t)(total_bytes); }
    {uint16_t tlv2; tlv2 = (uint16_t)(total_bytes); }
    {uint32_t tlv3; tlv3 = (uint32_t)(total_bytes); }
}
void fix_ingred_operation_18_2_5(){
uint16_t total_bytes;
    bzero(&total_bytes,sizeof(uint16_t));
    {int ret; ret = (int)(MAX_HAIKU_LEN); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(MAX_HAIKU_LEN); }
    {uint8_t tlv1; tlv1 = (uint8_t)(MAX_HAIKU_LEN); }
    {uint16_t tlv2; tlv2 = (uint16_t)(MAX_HAIKU_LEN); }
    {uint32_t tlv3; tlv3 = (uint32_t)(MAX_HAIKU_LEN); }
}
void fix_ingred_operation_18_2(){
fix_ingred_operation_18_2_4();
fix_ingred_operation_18_2_5();
}

sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t', 'tlv2': 'uint16_t'}'
val_s=>'[('uint16_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d575438>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c5f8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e5f8>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t', 'tlv2': 'uint16_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d57ca58>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c5f8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e5f8>), ('struct haiku *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d566dd8>), ('struct haiku *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d57c198>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU' - False OR  False
[i=18/23][j=4/9][dd=0/8][k=0/10] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU' - False OR  False
[i=18/23][j=4/9][dd=1/8][k=0/10] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU' - False OR  False
[i=18/23][j=4/9][dd=3/8][k=0/10] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU' - False OR  False
[i=18/23][j=4/9][dd=4/8][k=0/10] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU' - False OR  False
[i=18/23][j=4/9][dd=6/8][k=0/10] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU [vtype=None]
----
==== Scope 1 ====
void fix_ingred_operation_18_4_0(){
    {int ret; ret = (int)(ERR_INVALID_HAIKU); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(ERR_INVALID_HAIKU); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_INVALID_HAIKU); }
    {uint16_t tlv2; tlv2 = (uint16_t)(ERR_INVALID_HAIKU); }
    {uint32_t tlv3; tlv3 = (uint32_t)(ERR_INVALID_HAIKU); }
}
void fix_ingred_operation_18_4(){
fix_ingred_operation_18_4_0();
}

sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t', 'tlv2': 'uint16_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c5f8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e5f8>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t', 'tlv2': 'uint16_t', 'tlv4': 'struct haiku *'}'
val_s=>'[('struct haiku *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d562dd8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c5f8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e5f8>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t', 'tlv2': 'uint16_t', 'tlv4': 'struct haiku *', 'tlv3': 'uint32_t'}'
val_s=>'[('uint32_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d585c18>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56c5f8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e2e8>), ('uint16_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15212d56e5f8>)]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=18/23][j=7/9][dd=0/8][k=0/8] | type: uint32_t ; var : tlv3 ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
unique : ('struct haiku *', 'h', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=18/23][j=7/9][dd=1/8][k=0/8] | type: uint32_t ; var : tlv3 ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=18/23][j=7/9][dd=3/8][k=0/8] | type: uint32_t ; var : tlv3 ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=18/23][j=7/9][dd=4/8][k=0/8] | type: uint32_t ; var : tlv3 ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [h] => '[False, False, False]'
has_multiptr_refs 'h->id' - False OR  False
[i=18/23][j=7/9][dd=6/8][k=0/8] | type: uint32_t ; var : tlv3 ; varinfo :  ; value_node : h -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : h,->,id
 => is literal (False) | is operator (False) h [vtype=struct haiku *]
not unique: ('struct haiku *', 'h', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
----
UNIQ_INIT: ('struct haiku *','h','None','None');

==== Scope 1 ====
void fix_ingred_operation_18_7_0(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {int ret; ret = (int)(h -> id); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(h -> id); }
    {uint8_t tlv1; tlv1 = (uint8_t)(h -> id); }
    {uint16_t tlv2; tlv2 = (uint16_t)(h -> id); }
    {uint32_t tlv3; tlv3 = (uint32_t)(h -> id); }
}
void fix_ingred_operation_18_7(){
fix_ingred_operation_18_7_0();
}

sym_lut=>'{'ret': 'int', 'total_bytes': 'uint16_t', 'h': 'struct haiku *', 'tlv1': 'uint8_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d560dd8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92c358>), ('uint16_t', 'total_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d94eba8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d92fd68>)]'
cval_s=>'[]'
Checking 'cgc_send_haiku_id( tlv3 )' - is_func=True, is_func_ptr=False
cgc_send_haiku_id( tlv3 ) is a function.
Skipping.
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU_LEN' - False OR  False
[i=18/23][j=8/9][dd=0/8][k=0/4] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU_LEN
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU_LEN [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU_LEN' - False OR  False
[i=18/23][j=8/9][dd=1/8][k=0/4] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU_LEN
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU_LEN [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU_LEN' - False OR  False
[i=18/23][j=8/9][dd=3/8][k=0/4] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU_LEN
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU_LEN [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU_LEN' - False OR  False
[i=18/23][j=8/9][dd=4/8][k=0/4] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU_LEN
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU_LEN [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_INVALID_HAIKU_LEN' - False OR  False
[i=18/23][j=8/9][dd=6/8][k=0/4] | type: int ; var : ret ; varinfo :  ; value_node : ERR_INVALID_HAIKU_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_INVALID_HAIKU_LEN
 => is literal (False) | is operator (False) ERR_INVALID_HAIKU_LEN [vtype=None]
----
==== Scope 1 ====
void fix_ingred_operation_18_8_0(){
    {int ret; ret = (int)(ERR_INVALID_HAIKU_LEN); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(ERR_INVALID_HAIKU_LEN); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_INVALID_HAIKU_LEN); }
    {uint16_t tlv2; tlv2 = (uint16_t)(ERR_INVALID_HAIKU_LEN); }
    {uint32_t tlv3; tlv3 = (uint32_t)(ERR_INVALID_HAIKU_LEN); }
}
void fix_ingred_operation_18_8(){
fix_ingred_operation_18_8_0();
}

==== Scope 2 ====
void fix_ingred_operation_18_0_0(){
    {int ret; ret = (int)(SUCCESS); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(SUCCESS); }
    {uint8_t tlv1; tlv1 = (uint8_t)(SUCCESS); }
    {uint16_t tlv2; tlv2 = (uint16_t)(SUCCESS); }
    {uint32_t tlv3; tlv3 = (uint32_t)(SUCCESS); }
}
void fix_ingred_operation_18_0_1(){
    {int ret; ret = (int)(0); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(0); }
    {uint8_t tlv1; tlv1 = (uint8_t)(0); }
    {uint16_t tlv2; tlv2 = (uint16_t)(0); }
    {uint32_t tlv3; tlv3 = (uint32_t)(0); }
}
void fix_ingred_operation_18_0(){
fix_ingred_operation_18_0_0();
fix_ingred_operation_18_0_1();
}
void fix_ingred_operation_18_1_3(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int ret; ret = (int)(FALSE); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(FALSE); }
    {uint16_t tlv2; tlv2 = (uint16_t)(FALSE); }
    {uint32_t tlv3; tlv3 = (uint32_t)(FALSE); }
}
void fix_ingred_operation_18_1_4(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int ret; ret = (int)(tlv1); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(tlv1); }
    {uint16_t tlv2; tlv2 = (uint16_t)(tlv1); }
    {uint32_t tlv3; tlv3 = (uint32_t)(tlv1); }
}
void fix_ingred_operation_18_1(){
fix_ingred_operation_18_1_3();
fix_ingred_operation_18_1_4();
}
void fix_ingred_operation_18_2_4(){
uint16_t total_bytes;
    bzero(&total_bytes,sizeof(uint16_t));
    {int ret; ret = (int)(total_bytes); }
    {uint8_t tlv1; tlv1 = (uint8_t)(total_bytes); }
    {uint16_t tlv2; tlv2 = (uint16_t)(total_bytes); }
    {uint32_t tlv3; tlv3 = (uint32_t)(total_bytes); }
}
void fix_ingred_operation_18_2_5(){
uint16_t total_bytes;
    bzero(&total_bytes,sizeof(uint16_t));
    {int ret; ret = (int)(MAX_HAIKU_LEN); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(MAX_HAIKU_LEN); }
    {uint8_t tlv1; tlv1 = (uint8_t)(MAX_HAIKU_LEN); }
    {uint16_t tlv2; tlv2 = (uint16_t)(MAX_HAIKU_LEN); }
    {uint32_t tlv3; tlv3 = (uint32_t)(MAX_HAIKU_LEN); }
}
void fix_ingred_operation_18_2(){
fix_ingred_operation_18_2_4();
fix_ingred_operation_18_2_5();
}
void fix_ingred_operation_18_4_0(){
    {int ret; ret = (int)(ERR_INVALID_HAIKU); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(ERR_INVALID_HAIKU); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_INVALID_HAIKU); }
    {uint16_t tlv2; tlv2 = (uint16_t)(ERR_INVALID_HAIKU); }
    {uint32_t tlv3; tlv3 = (uint32_t)(ERR_INVALID_HAIKU); }
}
void fix_ingred_operation_18_4(){
fix_ingred_operation_18_4_0();
}
void fix_ingred_operation_18_7_0(){
struct haiku h_ref;
    bzero(&h_ref,1*sizeof(struct haiku));
struct haiku * h = &h_ref;
    {int ret; ret = (int)(h -> id); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(h -> id); }
    {uint8_t tlv1; tlv1 = (uint8_t)(h -> id); }
    {uint16_t tlv2; tlv2 = (uint16_t)(h -> id); }
    {uint32_t tlv3; tlv3 = (uint32_t)(h -> id); }
}
void fix_ingred_operation_18_7(){
fix_ingred_operation_18_7_0();
}
void fix_ingred_operation_18_8_0(){
    {int ret; ret = (int)(ERR_INVALID_HAIKU_LEN); }
    {uint16_t total_bytes; total_bytes = (uint16_t)(ERR_INVALID_HAIKU_LEN); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_INVALID_HAIKU_LEN); }
    {uint16_t tlv2; tlv2 = (uint16_t)(ERR_INVALID_HAIKU_LEN); }
    {uint32_t tlv3; tlv3 = (uint32_t)(ERR_INVALID_HAIKU_LEN); }
}
void fix_ingred_operation_18_8(){
fix_ingred_operation_18_8_0();
}
void fix_ingred_operation_18(){
fix_ingred_operation_18_0();
fix_ingred_operation_18_1();
fix_ingred_operation_18_2();
fix_ingred_operation_18_4();
fix_ingred_operation_18_7();
fix_ingred_operation_18_8();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_18_0_0();
void fix_ingred_operation_18_0_1();
void fix_ingred_operation_18_0();
void fix_ingred_operation_18_1_3();
void fix_ingred_operation_18_1_4();
void fix_ingred_operation_18_1();
void fix_ingred_operation_18_2_4();
void fix_ingred_operation_18_2_5();
void fix_ingred_operation_18_2();
void fix_ingred_operation_18_4_0();
void fix_ingred_operation_18_4();
void fix_ingred_operation_18_7_0();
void fix_ingred_operation_18_7();
void fix_ingred_operation_18_8_0();
void fix_ingred_operation_18_8();
void fix_ingred_operation_18();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * h ;
def_vars[1]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : uint32_t id ;
def_vars[2]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : int res ;
def_vars[3]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
def_vars[4]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * * tlv3 ;
def_vars[5]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : uint32_t tlv2 ;
def_vars[6]: [cgc_get_haiku_by_id] : <class 'CParser.CParser.DeclarationContext'> : cgc_send_haiku ( h ) ;
sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=19/23][j=0/7][dd=1/7][k=2/3] | type: int ; var : res ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=19/23][j=0/7][dd=2/7][k=1/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=19/23][j=0/7][dd=2/7][k=2/3] | type: int ; var : res ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=19/23][j=0/7][dd=3/7][k=2/3] | type: int ; var : res ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=19/23][j=0/7][dd=5/7][k=1/3] | type: uint32_t ; var : id ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=19/23][j=0/7][dd=5/7][k=2/3] | type: int ; var : res ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_operation_19_0_1(){
    {int res; res = (int)(0); }
    {uint32_t tlv2; tlv2 = (uint32_t)(0); }
}
void fix_ingred_operation_19_0_2(){
    {uint32_t id; id = (uint32_t)(0); }
    {int res; res = (int)(0); }
    {uint8_t tlv1; tlv1 = (uint8_t)(0); }
    {uint32_t tlv2; tlv2 = (uint32_t)(0); }
}
void fix_ingred_operation_19_0(){
fix_ingred_operation_19_0_1();
fix_ingred_operation_19_0_2();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6518>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6898>)]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=19/23][j=1/7][dd=2/7][k=3/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=19/23][j=1/7][dd=2/7][k=4/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
unique : ('uint8_t', 'tlv1', None)
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=19/23][j=1/7][dd=5/7][k=3/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=19/23][j=1/7][dd=5/7][k=4/5] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
not unique: ('uint8_t', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_operation_19_1_3(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int res; res = (int)(TRUE); }
    {uint32_t tlv2; tlv2 = (uint32_t)(TRUE); }
}
void fix_ingred_operation_19_1_4(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int res; res = (int)(tlv1); }
    {uint32_t tlv2; tlv2 = (uint32_t)(tlv1); }
}
void fix_ingred_operation_19_1(){
fix_ingred_operation_19_1_3();
fix_ingred_operation_19_1_4();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6518>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6898>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce0dd8>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dcd9198>)]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id' - False OR  False
[i=19/23][j=2/7][dd=1/7][k=6/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : id (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id
 => is literal (False) | is operator (False) id [vtype=uint32_t]
unique : ('uint32_t', 'id', None)
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=19/23][j=2/7][dd=2/7][k=5/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id' - False OR  False
[i=19/23][j=2/7][dd=2/7][k=6/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : id (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=19/23][j=2/7][dd=3/7][k=5/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id' - False OR  False
[i=19/23][j=2/7][dd=3/7][k=6/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : id (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'EGG_ID' - False OR  False
[i=19/23][j=2/7][dd=5/7][k=5/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : EGG_ID (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : EGG_ID
 => is literal (False) | is operator (False) EGG_ID [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id' - False OR  False
[i=19/23][j=2/7][dd=5/7][k=6/7] | type: uint32_t ; var :  ; varinfo :  ; value_node : id (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id
 => is literal (False) | is operator (False) id [vtype=uint32_t]
not unique: ('uint32_t', 'id', None) ... continue!
----
UNIQ_INIT: ('uint32_t','id','None','None');

not valid - uint32_t id; id = ((uint32_t)id);

----
UNIQ_INIT: ('uint32_t','id','None','None');

==== Scope 1 ====
void fix_ingred_operation_19_2_5(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
    {int res; res = (int)(EGG_ID); }
    {uint8_t tlv1; tlv1 = (uint8_t)(EGG_ID); }
    {uint32_t tlv2; tlv2 = (uint32_t)(EGG_ID); }
}
void fix_ingred_operation_19_2_6(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
    {int res; res = (int)(id); }
    {uint8_t tlv1; tlv1 = (uint8_t)(id); }
    {uint32_t tlv2; tlv2 = (uint32_t)(id); }
}
void fix_ingred_operation_19_2(){
fix_ingred_operation_19_2_5();
fix_ingred_operation_19_2_6();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6518>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6898>)]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'struct haiku * *', 'tlv2': 'uint32_t'}'
val_s=>'[('struct haiku * *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dce5ba8>), ('uint32_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcddc18>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6518>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6898>)]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'struct haiku * *', 'tlv2': 'uint32_t'}'
val_s=>'[('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6518>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dce6898>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dcea7b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212dceab38>)]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=19/23][j=5/7][dd=1/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=19/23][j=5/7][dd=1/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
unique : ('int', 'res', None)
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=19/23][j=5/7][dd=2/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=19/23][j=5/7][dd=2/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
not unique: ('int', 'res', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=19/23][j=5/7][dd=3/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
not unique: ('int', 'res', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=19/23][j=5/7][dd=5/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=19/23][j=5/7][dd=5/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
not unique: ('int', 'res', None) ... continue!
----
UNIQ_INIT: ('int','res','None','None');

not valid - int res; res = ((int)res);

----
UNIQ_INIT: ('int','res','None','None');

==== Scope 1 ====
void fix_ingred_operation_19_5_5(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t id; id = (uint32_t)(SUCCESS); }
    {int res; res = (int)(SUCCESS); }
    {uint32_t tlv2; tlv2 = (uint32_t)(SUCCESS); }
}
void fix_ingred_operation_19_5_6(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t id; id = (uint32_t)(res); }
    {uint8_t tlv1; tlv1 = (uint8_t)(res); }
    {uint32_t tlv2; tlv2 = (uint32_t)(res); }
}
void fix_ingred_operation_19_5(){
fix_ingred_operation_19_5_5();
fix_ingred_operation_19_5_6();
}

sym_lut=>'{'h': 'struct haiku *', 'id': 'uint32_t', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dce4ac8>), ('struct haiku *', 'h', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d55dba8>), ('uint32_t', 'id', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcd8ac8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212dcec978>)]'
cval_s=>'[]'
Checking 'cgc_send_haiku( h )' - is_func=True, is_func_ptr=False
cgc_send_haiku( h ) is a function.
Skipping.
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=19/23][j=6/7][dd=1/7][k=0/4] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=19/23][j=6/7][dd=2/7][k=0/4] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=19/23][j=6/7][dd=3/7][k=0/4] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=19/23][j=6/7][dd=5/7][k=0/4] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
----
==== Scope 1 ====
void fix_ingred_operation_19_6_0(){
    {uint32_t id; id = (uint32_t)(ERR_LIST_NOT_EXIST); }
    {int res; res = (int)(ERR_LIST_NOT_EXIST); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_LIST_NOT_EXIST); }
    {uint32_t tlv2; tlv2 = (uint32_t)(ERR_LIST_NOT_EXIST); }
}
void fix_ingred_operation_19_6(){
fix_ingred_operation_19_6_0();
}

==== Scope 2 ====
void fix_ingred_operation_19_0_1(){
    {int res; res = (int)(0); }
    {uint32_t tlv2; tlv2 = (uint32_t)(0); }
}
void fix_ingred_operation_19_0_2(){
    {uint32_t id; id = (uint32_t)(0); }
    {int res; res = (int)(0); }
    {uint8_t tlv1; tlv1 = (uint8_t)(0); }
    {uint32_t tlv2; tlv2 = (uint32_t)(0); }
}
void fix_ingred_operation_19_0(){
fix_ingred_operation_19_0_1();
fix_ingred_operation_19_0_2();
}
void fix_ingred_operation_19_1_3(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int res; res = (int)(TRUE); }
    {uint32_t tlv2; tlv2 = (uint32_t)(TRUE); }
}
void fix_ingred_operation_19_1_4(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {int res; res = (int)(tlv1); }
    {uint32_t tlv2; tlv2 = (uint32_t)(tlv1); }
}
void fix_ingred_operation_19_1(){
fix_ingred_operation_19_1_3();
fix_ingred_operation_19_1_4();
}
void fix_ingred_operation_19_2_5(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
    {int res; res = (int)(EGG_ID); }
    {uint8_t tlv1; tlv1 = (uint8_t)(EGG_ID); }
    {uint32_t tlv2; tlv2 = (uint32_t)(EGG_ID); }
}
void fix_ingred_operation_19_2_6(){
uint32_t id;
    bzero(&id,sizeof(uint32_t));
    {int res; res = (int)(id); }
    {uint8_t tlv1; tlv1 = (uint8_t)(id); }
    {uint32_t tlv2; tlv2 = (uint32_t)(id); }
}
void fix_ingred_operation_19_2(){
fix_ingred_operation_19_2_5();
fix_ingred_operation_19_2_6();
}
void fix_ingred_operation_19_5_5(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t id; id = (uint32_t)(SUCCESS); }
    {int res; res = (int)(SUCCESS); }
    {uint32_t tlv2; tlv2 = (uint32_t)(SUCCESS); }
}
void fix_ingred_operation_19_5_6(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t id; id = (uint32_t)(res); }
    {uint8_t tlv1; tlv1 = (uint8_t)(res); }
    {uint32_t tlv2; tlv2 = (uint32_t)(res); }
}
void fix_ingred_operation_19_5(){
fix_ingred_operation_19_5_5();
fix_ingred_operation_19_5_6();
}
void fix_ingred_operation_19_6_0(){
    {uint32_t id; id = (uint32_t)(ERR_LIST_NOT_EXIST); }
    {int res; res = (int)(ERR_LIST_NOT_EXIST); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_LIST_NOT_EXIST); }
    {uint32_t tlv2; tlv2 = (uint32_t)(ERR_LIST_NOT_EXIST); }
}
void fix_ingred_operation_19_6(){
fix_ingred_operation_19_6_0();
}
void fix_ingred_operation_19(){
fix_ingred_operation_19_0();
fix_ingred_operation_19_1();
fix_ingred_operation_19_2();
fix_ingred_operation_19_5();
fix_ingred_operation_19_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_19_0_1();
void fix_ingred_operation_19_0_2();
void fix_ingred_operation_19_0();
void fix_ingred_operation_19_1_3();
void fix_ingred_operation_19_1_4();
void fix_ingred_operation_19_1();
void fix_ingred_operation_19_2_5();
void fix_ingred_operation_19_2_6();
void fix_ingred_operation_19_2();
void fix_ingred_operation_19_5_5();
void fix_ingred_operation_19_5_6();
void fix_ingred_operation_19_5();
void fix_ingred_operation_19_6_0();
void fix_ingred_operation_19_6();
void fix_ingred_operation_19();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t random_idx ;
def_vars[1]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t count ;
def_vars[2]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t * id_arr ;
def_vars[3]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * rand_haiku ;
def_vars[4]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : int res ;
def_vars[5]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
def_vars[6]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t * * tlv3 ;
def_vars[7]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t tlv2 ;
def_vars[8]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t * tlv4 ;
def_vars[9]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : cgc_send_haiku ( rand_haiku ) ;
def_vars[10]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : struct haiku * * tlv6 ;
def_vars[11]: [cgc_get_haiku_cgc_random] : <class 'CParser.CParser.DeclarationContext'> : uint32_t tlv5 ;
sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=20/23][j=0/9][dd=0/12][k=4/5] | type: int ; var : res ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=20/23][j=0/9][dd=1/12][k=0/5] | type: uint32_t ; var : random_idx ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=20/23][j=0/9][dd=1/12][k=4/5] | type: int ; var : res ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=20/23][j=0/9][dd=10/12][k=0/5] | type: uint32_t ; var : random_idx ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SUCCESS' - False OR  False
[i=20/23][j=0/9][dd=10/12][k=4/5] | type: int ; var : res ; varinfo :  ; value_node : SUCCESS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SUCCESS
 => is literal (False) | is operator (False) SUCCESS [vtype=None]
----
----
==== Scope 1 ====
void fix_ingred_operation_20_0_0(){
    {uint32_t count; count = (uint32_t)(0); }
    {uint32_t tlv5; tlv5 = (uint32_t)(0); }
}
void fix_ingred_operation_20_0_4(){
    {uint32_t random_idx; random_idx = (uint32_t)(SUCCESS); }
    {uint32_t count; count = (uint32_t)(SUCCESS); }
    {uint32_t tlv5; tlv5 = (uint32_t)(SUCCESS); }
}
void fix_ingred_operation_20_0(){
fix_ingred_operation_20_0_0();
fix_ingred_operation_20_0_4();
}

sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=20/23][j=1/9][dd=0/12][k=5/7] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=20/23][j=1/9][dd=0/12][k=6/7] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
unique : ('uint8_t', 'tlv1', None)
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=20/23][j=1/9][dd=1/12][k=5/7] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=20/23][j=1/9][dd=1/12][k=6/7] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
not unique: ('uint8_t', 'tlv1', None) ... continue!
is_func_ [T] => '[False, False, False]'
has_multiptr_refs 'TRUE' - False OR  False
[i=20/23][j=1/9][dd=10/12][k=5/7] | type: uint8_t ; var :  ; varinfo :  ; value_node : TRUE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : TRUE
 => is literal (False) | is operator (False) TRUE [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=20/23][j=1/9][dd=10/12][k=6/7] | type: uint8_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=uint8_t]
not unique: ('uint8_t', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

----
UNIQ_INIT: ('uint8_t','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_operation_20_1_5(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t random_idx; random_idx = (uint32_t)(TRUE); }
    {uint32_t count; count = (uint32_t)(TRUE); }
    {uint32_t tlv5; tlv5 = (uint32_t)(TRUE); }
}
void fix_ingred_operation_20_1_6(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t random_idx; random_idx = (uint32_t)(tlv1); }
    {uint32_t count; count = (uint32_t)(tlv1); }
    {uint32_t tlv5; tlv5 = (uint32_t)(tlv1); }
}
void fix_ingred_operation_20_1(){
fix_ingred_operation_20_1_5();
fix_ingred_operation_20_1_6();
}

sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d64c9e8>), ('uint32_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d64cd68>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=20/23][j=2/9][dd=0/12][k=8/9] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
unique : ('uint32_t', 'count', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=20/23][j=2/9][dd=1/12][k=8/9] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
not unique: ('uint32_t', 'count', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=20/23][j=2/9][dd=4/12][k=8/9] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
not unique: ('uint32_t', 'count', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=20/23][j=2/9][dd=7/12][k=8/9] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
not unique: ('uint32_t', 'count', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=20/23][j=2/9][dd=10/12][k=8/9] | type: uint32_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=uint32_t]
not unique: ('uint32_t', 'count', None) ... continue!
not valid - uint32_t count; count = ((uint32_t)count);

----
UNIQ_INIT: ('uint32_t','count','None','None');

==== Scope 1 ====
void fix_ingred_operation_20_2_8(){
uint32_t count;
    bzero(&count,sizeof(uint32_t));
    {uint32_t random_idx; random_idx = (uint32_t)(count); }
    {int res; res = (int)(count); }
    {uint32_t tlv2; tlv2 = (uint32_t)(count); }
    {uint32_t tlv5; tlv5 = (uint32_t)(count); }
}
void fix_ingred_operation_20_2(){
fix_ingred_operation_20_2_8();
}

sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'uint32_t * *', 'tlv2': 'uint32_t'}'
val_s=>'[('uint32_t * *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d638908>), ('uint32_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d61a828>), ('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'uint32_t * *', 'tlv2': 'uint32_t', 'tlv4': 'uint32_t *'}'
val_s=>'[('uint32_t *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d332908>), ('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'uint32_t * *', 'tlv2': 'uint32_t', 'tlv4': 'uint32_t *'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d318438>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3187b8>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_RAND_FAILED' - False OR  False
[i=20/23][j=5/9][dd=0/12][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : ERR_RAND_FAILED (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_RAND_FAILED
 => is literal (False) | is operator (False) ERR_RAND_FAILED [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=20/23][j=5/9][dd=0/12][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
unique : ('int', 'res', None)
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_RAND_FAILED' - False OR  False
[i=20/23][j=5/9][dd=1/12][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : ERR_RAND_FAILED (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_RAND_FAILED
 => is literal (False) | is operator (False) ERR_RAND_FAILED [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=20/23][j=5/9][dd=1/12][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
not unique: ('int', 'res', None) ... continue!
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_RAND_FAILED' - False OR  False
[i=20/23][j=5/9][dd=4/12][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : ERR_RAND_FAILED (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_RAND_FAILED
 => is literal (False) | is operator (False) ERR_RAND_FAILED [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_RAND_FAILED' - False OR  False
[i=20/23][j=5/9][dd=5/12][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : ERR_RAND_FAILED (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_RAND_FAILED
 => is literal (False) | is operator (False) ERR_RAND_FAILED [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_RAND_FAILED' - False OR  False
[i=20/23][j=5/9][dd=7/12][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : ERR_RAND_FAILED (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_RAND_FAILED
 => is literal (False) | is operator (False) ERR_RAND_FAILED [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_RAND_FAILED' - False OR  False
[i=20/23][j=5/9][dd=10/12][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : ERR_RAND_FAILED (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_RAND_FAILED
 => is literal (False) | is operator (False) ERR_RAND_FAILED [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'res' - False OR  False
[i=20/23][j=5/9][dd=10/12][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : res (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : res
 => is literal (False) | is operator (False) res [vtype=int]
not unique: ('int', 'res', None) ... continue!
----
UNIQ_INIT: ('int','res','None','None');

----
UNIQ_INIT: ('int','res','None','None');

==== Scope 1 ====
void fix_ingred_operation_20_5_7(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t random_idx; random_idx = (uint32_t)(ERR_RAND_FAILED); }
    {uint32_t count; count = (uint32_t)(ERR_RAND_FAILED); }
    {int res; res = (int)(ERR_RAND_FAILED); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_RAND_FAILED); }
    {uint32_t tlv2; tlv2 = (uint32_t)(ERR_RAND_FAILED); }
    {uint32_t tlv5; tlv5 = (uint32_t)(ERR_RAND_FAILED); }
}
void fix_ingred_operation_20_5_8(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t random_idx; random_idx = (uint32_t)(res); }
    {uint32_t count; count = (uint32_t)(res); }
    {uint32_t tlv5; tlv5 = (uint32_t)(res); }
}
void fix_ingred_operation_20_5(){
fix_ingred_operation_20_5_7();
fix_ingred_operation_20_5_8();
}

sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'uint32_t * *', 'tlv2': 'uint32_t', 'tlv4': 'uint32_t *', 'tlv6': 'struct haiku * *', 'tlv5': 'uint32_t'}'
val_s=>'[('struct haiku * *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3377b8>), ('uint32_t', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d314828>), ('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d318438>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d3187b8>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id_arr[random_idx]' - False OR  False
[i=20/23][j=6/9][dd=0/12][k=1/11] | type: uint32_t ; var : tlv5 ; varinfo :  ; value_node : id_arr [ random_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id_arr,[,random_idx,]
 => is literal (False) | is operator (False) id_arr [vtype=uint32_t *]
unique : ('uint32_t *', 'id_arr', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
unique : ('uint32_t', 'random_idx', None)
 => is literal (False) | is operator (True) ]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id_arr[random_idx]' - False OR  False
[i=20/23][j=6/9][dd=1/12][k=1/11] | type: uint32_t ; var : tlv5 ; varinfo :  ; value_node : id_arr [ random_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id_arr,[,random_idx,]
 => is literal (False) | is operator (False) id_arr [vtype=uint32_t *]
not unique: ('uint32_t *', 'id_arr', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id_arr[random_idx]' - False OR  False
[i=20/23][j=6/9][dd=4/12][k=1/11] | type: uint32_t ; var : tlv5 ; varinfo :  ; value_node : id_arr [ random_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id_arr,[,random_idx,]
 => is literal (False) | is operator (False) id_arr [vtype=uint32_t *]
not unique: ('uint32_t *', 'id_arr', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id_arr[random_idx]' - False OR  False
[i=20/23][j=6/9][dd=5/12][k=1/11] | type: uint32_t ; var : tlv5 ; varinfo :  ; value_node : id_arr [ random_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id_arr,[,random_idx,]
 => is literal (False) | is operator (False) id_arr [vtype=uint32_t *]
not unique: ('uint32_t *', 'id_arr', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id_arr[random_idx]' - False OR  False
[i=20/23][j=6/9][dd=7/12][k=1/11] | type: uint32_t ; var : tlv5 ; varinfo :  ; value_node : id_arr [ random_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id_arr,[,random_idx,]
 => is literal (False) | is operator (False) id_arr [vtype=uint32_t *]
not unique: ('uint32_t *', 'id_arr', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'id_arr[random_idx]' - False OR  False
[i=20/23][j=6/9][dd=10/12][k=1/11] | type: uint32_t ; var : tlv5 ; varinfo :  ; value_node : id_arr [ random_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : id_arr,[,random_idx,]
 => is literal (False) | is operator (False) id_arr [vtype=uint32_t *]
not unique: ('uint32_t *', 'id_arr', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) random_idx [vtype=uint32_t]
not unique: ('uint32_t', 'random_idx', None) ... continue!
 => is literal (False) | is operator (True) ]
not valid - uint32_t random_idx; random_idx = ((uint32_t)id_arr [ random_idx ]);

----
UNIQ_INIT: ('uint32_t *','id_arr','None','None');

UNIQ_INIT: ('uint32_t','random_idx','None','None');

==== Scope 1 ====
void fix_ingred_operation_20_6_1(){
uint32_t id_arr_ref;
    bzero(&id_arr_ref,1*sizeof(uint32_t));
uint32_t * id_arr = &id_arr_ref;
uint32_t random_idx;
    bzero(&random_idx,sizeof(uint32_t));
    {    random_idx = 0;
         uint32_t count; count = (uint32_t)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         int res; res = (int)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         uint8_t tlv1; tlv1 = (uint8_t)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         uint32_t tlv2; tlv2 = (uint32_t)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         uint32_t tlv5; tlv5 = (uint32_t)(id_arr [ random_idx ]); }
}
void fix_ingred_operation_20_6(){
fix_ingred_operation_20_6_1();
}

sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t', 'tlv3': 'uint32_t * *', 'tlv2': 'uint32_t', 'tlv4': 'uint32_t *'}'
val_s=>'[('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c128>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d61c4a8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d333748>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d333ac8>)]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
sym_lut=>'{'random_idx': 'uint32_t', 'count': 'uint32_t', 'id_arr': 'uint32_t *', 'rand_haiku': 'struct haiku *', 'res': 'int', 'tlv1': 'uint8_t'}'
val_s=>'[('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d32ea58>), ('uint32_t', 'random_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63b748>), ('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d63c668>), ('uint32_t *', 'id_arr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d636668>), ('struct haiku *', 'rand_haiku', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d6456d8>), ('int', 'res', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d64d588>)]'
cval_s=>'[]'
Checking 'cgc_send_haiku( rand_haiku )' - is_func=True, is_func_ptr=False
cgc_send_haiku( rand_haiku ) is a function.
Skipping.
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=20/23][j=8/9][dd=0/12][k=0/6] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=20/23][j=8/9][dd=1/12][k=0/6] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
is_func_ [E] => '[False, False, False]'
has_multiptr_refs 'ERR_LIST_NOT_EXIST' - False OR  False
[i=20/23][j=8/9][dd=10/12][k=0/6] | type: int ; var : res ; varinfo :  ; value_node : ERR_LIST_NOT_EXIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ERR_LIST_NOT_EXIST
 => is literal (False) | is operator (False) ERR_LIST_NOT_EXIST [vtype=None]
----
==== Scope 1 ====
void fix_ingred_operation_20_8_0(){
    {uint32_t random_idx; random_idx = (uint32_t)(ERR_LIST_NOT_EXIST); }
    {uint32_t count; count = (uint32_t)(ERR_LIST_NOT_EXIST); }
    {uint32_t tlv5; tlv5 = (uint32_t)(ERR_LIST_NOT_EXIST); }
}
void fix_ingred_operation_20_8(){
fix_ingred_operation_20_8_0();
}

==== Scope 2 ====
void fix_ingred_operation_20_0_0(){
    {uint32_t count; count = (uint32_t)(0); }
    {uint32_t tlv5; tlv5 = (uint32_t)(0); }
}
void fix_ingred_operation_20_0_4(){
    {uint32_t random_idx; random_idx = (uint32_t)(SUCCESS); }
    {uint32_t count; count = (uint32_t)(SUCCESS); }
    {uint32_t tlv5; tlv5 = (uint32_t)(SUCCESS); }
}
void fix_ingred_operation_20_0(){
fix_ingred_operation_20_0_0();
fix_ingred_operation_20_0_4();
}
void fix_ingred_operation_20_1_5(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t random_idx; random_idx = (uint32_t)(TRUE); }
    {uint32_t count; count = (uint32_t)(TRUE); }
    {uint32_t tlv5; tlv5 = (uint32_t)(TRUE); }
}
void fix_ingred_operation_20_1_6(){
uint8_t tlv1;
    bzero(&tlv1,sizeof(uint8_t));
    {uint32_t random_idx; random_idx = (uint32_t)(tlv1); }
    {uint32_t count; count = (uint32_t)(tlv1); }
    {uint32_t tlv5; tlv5 = (uint32_t)(tlv1); }
}
void fix_ingred_operation_20_1(){
fix_ingred_operation_20_1_5();
fix_ingred_operation_20_1_6();
}
void fix_ingred_operation_20_2_8(){
uint32_t count;
    bzero(&count,sizeof(uint32_t));
    {uint32_t random_idx; random_idx = (uint32_t)(count); }
    {int res; res = (int)(count); }
    {uint32_t tlv2; tlv2 = (uint32_t)(count); }
    {uint32_t tlv5; tlv5 = (uint32_t)(count); }
}
void fix_ingred_operation_20_2(){
fix_ingred_operation_20_2_8();
}
void fix_ingred_operation_20_5_7(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t random_idx; random_idx = (uint32_t)(ERR_RAND_FAILED); }
    {uint32_t count; count = (uint32_t)(ERR_RAND_FAILED); }
    {int res; res = (int)(ERR_RAND_FAILED); }
    {uint8_t tlv1; tlv1 = (uint8_t)(ERR_RAND_FAILED); }
    {uint32_t tlv2; tlv2 = (uint32_t)(ERR_RAND_FAILED); }
    {uint32_t tlv5; tlv5 = (uint32_t)(ERR_RAND_FAILED); }
}
void fix_ingred_operation_20_5_8(){
int res;
    bzero(&res,sizeof(int));
    {uint32_t random_idx; random_idx = (uint32_t)(res); }
    {uint32_t count; count = (uint32_t)(res); }
    {uint32_t tlv5; tlv5 = (uint32_t)(res); }
}
void fix_ingred_operation_20_5(){
fix_ingred_operation_20_5_7();
fix_ingred_operation_20_5_8();
}
void fix_ingred_operation_20_6_1(){
uint32_t id_arr_ref;
    bzero(&id_arr_ref,1*sizeof(uint32_t));
uint32_t * id_arr = &id_arr_ref;
uint32_t random_idx;
    bzero(&random_idx,sizeof(uint32_t));
    {    random_idx = 0;
         uint32_t count; count = (uint32_t)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         int res; res = (int)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         uint8_t tlv1; tlv1 = (uint8_t)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         uint32_t tlv2; tlv2 = (uint32_t)(id_arr [ random_idx ]); }
    {    random_idx = 0;
         uint32_t tlv5; tlv5 = (uint32_t)(id_arr [ random_idx ]); }
}
void fix_ingred_operation_20_6(){
fix_ingred_operation_20_6_1();
}
void fix_ingred_operation_20_8_0(){
    {uint32_t random_idx; random_idx = (uint32_t)(ERR_LIST_NOT_EXIST); }
    {uint32_t count; count = (uint32_t)(ERR_LIST_NOT_EXIST); }
    {uint32_t tlv5; tlv5 = (uint32_t)(ERR_LIST_NOT_EXIST); }
}
void fix_ingred_operation_20_8(){
fix_ingred_operation_20_8_0();
}
void fix_ingred_operation_20(){
fix_ingred_operation_20_0();
fix_ingred_operation_20_1();
fix_ingred_operation_20_2();
fix_ingred_operation_20_5();
fix_ingred_operation_20_6();
fix_ingred_operation_20_8();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_20_0_0();
void fix_ingred_operation_20_0_4();
void fix_ingred_operation_20_0();
void fix_ingred_operation_20_1_5();
void fix_ingred_operation_20_1_6();
void fix_ingred_operation_20_1();
void fix_ingred_operation_20_2_8();
void fix_ingred_operation_20_2();
void fix_ingred_operation_20_5_7();
void fix_ingred_operation_20_5_8();
void fix_ingred_operation_20_5();
void fix_ingred_operation_20_6_1();
void fix_ingred_operation_20_6();
void fix_ingred_operation_20_8_0();
void fix_ingred_operation_20_8();
void fix_ingred_operation_20();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_haiku_count] : <class 'CParser.CParser.DeclarationContext'> : uint32_t count ;
def_vars[1]: [cgc_get_haiku_count] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
def_vars[2]: [cgc_get_haiku_count] : <class 'CParser.CParser.DeclarationContext'> : SENDUI ( count ) ;
sym_lut=>'{'count': 'uint32_t', 'tlv1': 'uint8_t'}'
val_s=>'[('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3286d8>)]'
cval_s=>'[]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
sym_lut=>'{'count': 'uint32_t', 'tlv1': 'uint8_t', '(': 'SENDUI *', '( count )': 'SENDUI'}'
val_s=>'[('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3286d8>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d33b278>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d33b5f8>)]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
sym_lut=>'{'count': 'uint32_t', 'tlv1': 'uint8_t', '(': 'SENDUI *', '( count )': 'SENDUI'}'
val_s=>'[('uint32_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d3286d8>)]'
cval_s=>'[]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_operation_21(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_21();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : uint8_t tlv1 ;
def_vars[1]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : uint32_t count ;
def_vars[2]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : SENDUI ( count ) ;
def_vars[3]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : node_t * hl_ptr ;
def_vars[4]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : uint32_t id ;
def_vars[5]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : SENDUI ( id ) ;
def_vars[6]: [cgc_get_haiku_ids] : <class 'CParser.CParser.DeclarationContext'> : node_t * tlv2 ;
sym_lut=>'{'tlv1': 'uint8_t'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
Checking 'SENDUI( id )' - is_func=True, is_func_ptr=False
SENDUI( id ) is a function.
Skipping.
sym_lut=>'{'tlv1': 'uint8_t', 'count': 'SENDUI', '(': 'SENDUI *', '( count )': 'SENDUI', 'hl_ptr': 'node_t *'}'
val_s=>'[('node_t *', 'hl_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d761f28>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d767748>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d767ac8>)]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
Checking 'SENDUI( id )' - is_func=True, is_func_ptr=False
SENDUI( id ) is a function.
Skipping.
sym_lut=>'{'tlv1': 'uint8_t', 'count': 'SENDUI', '(': 'SENDUI *', '( count )': 'SENDUI', 'hl_ptr': 'node_t *', 'id': 'uint32_t'}'
val_s=>'[('node_t *', 'hl_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d7570b8>), ('node_t *', 'hl_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d761f28>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d767748>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d767ac8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d765ba8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d765f28>)]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
Checking 'SENDUI( id )' - is_func=True, is_func_ptr=False
SENDUI( id ) is a function.
Skipping.
sym_lut=>'{'tlv1': 'uint8_t', 'count': 'SENDUI', '(': 'SENDUI *', '( count )': 'SENDUI', 'hl_ptr': 'node_t *', 'id': 'uint32_t', 'tlv2': 'node_t *'}'
val_s=>'[('node_t *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d7662e8>), ('node_t *', 'hl_ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x15212d761f28>)]'
cval_s=>'[('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d767748>), ('uint8_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d767ac8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d765ba8>), ('node_t *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15212d765f28>)]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
Checking 'SENDUI( id )' - is_func=True, is_func_ptr=False
SENDUI( id ) is a function.
Skipping.
sym_lut=>'{'tlv1': 'uint8_t', 'count': 'SENDUI', '(': 'SENDUI *', '( count )': 'SENDUI', 'hl_ptr': 'node_t *'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'SENDUI( count )' - is_func=True, is_func_ptr=False
SENDUI( count ) is a function.
Skipping.
Checking 'SENDUI( id )' - is_func=True, is_func_ptr=False
SENDUI( id ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_operation_22(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_operation_22();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_operation_0
- fix_ingred_operation_1
- fix_ingred_operation_2
- fix_ingred_operation_3
- fix_ingred_operation_4_1_0
- fix_ingred_operation_4_1
- fix_ingred_operation_4
- fix_ingred_operation_5_1_0
- fix_ingred_operation_5_1
- fix_ingred_operation_5
- fix_ingred_operation_6
- fix_ingred_operation_7
- fix_ingred_operation_8_0_0
- fix_ingred_operation_8_0_1
- fix_ingred_operation_8_0
- fix_ingred_operation_8_1_0
- fix_ingred_operation_8_1_1
- fix_ingred_operation_8_1
- fix_ingred_operation_8_6_3
- fix_ingred_operation_8_6
- fix_ingred_operation_8
- fix_ingred_operation_9_0_2
- fix_ingred_operation_9_0
- fix_ingred_operation_9_1_4
- fix_ingred_operation_9_1_5
- fix_ingred_operation_9_1
- fix_ingred_operation_9_3_4
- fix_ingred_operation_9_3
- fix_ingred_operation_9
- fix_ingred_operation_10_0_2
- fix_ingred_operation_10_0
- fix_ingred_operation_10_6_9
- fix_ingred_operation_10_6_10
- fix_ingred_operation_10_6
- fix_ingred_operation_10
- fix_ingred_operation_11_0_0
- fix_ingred_operation_11_0_1
- fix_ingred_operation_11_0_2
- fix_ingred_operation_11_0
- fix_ingred_operation_11_1_0
- fix_ingred_operation_11_1
- fix_ingred_operation_11_2_0
- fix_ingred_operation_11_2
- fix_ingred_operation_11_3_0
- fix_ingred_operation_11_3
- fix_ingred_operation_11
- fix_ingred_operation_12_0_0
- fix_ingred_operation_12_0_1
- fix_ingred_operation_12_0
- fix_ingred_operation_12_1_0
- fix_ingred_operation_12_1
- fix_ingred_operation_12
- fix_ingred_operation_13
- fix_ingred_operation_14_1_0
- fix_ingred_operation_14_1
- fix_ingred_operation_14
- fix_ingred_operation_15_1_0
- fix_ingred_operation_15_1_1
- fix_ingred_operation_15_1_2
- fix_ingred_operation_15_1
- fix_ingred_operation_15
- fix_ingred_operation_16_0_1
- fix_ingred_operation_16_0_5
- fix_ingred_operation_16_0
- fix_ingred_operation_16_1_0
- fix_ingred_operation_16_1
- fix_ingred_operation_16_2_0
- fix_ingred_operation_16_2
- fix_ingred_operation_16
- fix_ingred_operation_17
- fix_ingred_operation_18_0_0
- fix_ingred_operation_18_0_1
- fix_ingred_operation_18_0
- fix_ingred_operation_18_1_3
- fix_ingred_operation_18_1_4
- fix_ingred_operation_18_1
- fix_ingred_operation_18_2_4
- fix_ingred_operation_18_2_5
- fix_ingred_operation_18_2
- fix_ingred_operation_18_4_0
- fix_ingred_operation_18_4
- fix_ingred_operation_18_7_0
- fix_ingred_operation_18_7
- fix_ingred_operation_18_8_0
- fix_ingred_operation_18_8
- fix_ingred_operation_18
- fix_ingred_operation_19_0_1
- fix_ingred_operation_19_0_2
- fix_ingred_operation_19_0
- fix_ingred_operation_19_1_3
- fix_ingred_operation_19_1_4
- fix_ingred_operation_19_1
- fix_ingred_operation_19_2_5
- fix_ingred_operation_19_2_6
- fix_ingred_operation_19_2
- fix_ingred_operation_19_5_5
- fix_ingred_operation_19_5_6
- fix_ingred_operation_19_5
- fix_ingred_operation_19_6_0
- fix_ingred_operation_19_6
- fix_ingred_operation_19
- fix_ingred_operation_20_0_0
- fix_ingred_operation_20_0_4
- fix_ingred_operation_20_0
- fix_ingred_operation_20_1_5
- fix_ingred_operation_20_1_6
- fix_ingred_operation_20_1
- fix_ingred_operation_20_2_8
- fix_ingred_operation_20_2
- fix_ingred_operation_20_5_7
- fix_ingred_operation_20_5_8
- fix_ingred_operation_20_5
- fix_ingred_operation_20_6_1
- fix_ingred_operation_20_6
- fix_ingred_operation_20_8_0
- fix_ingred_operation_20_8
- fix_ingred_operation_20
- fix_ingred_operation_21
- fix_ingred_operation_22
