[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_read_until ( int fd , char * buf , cgc_size_t len , char delim )')]
ParameterDeclaration : type = int, var = fd [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['fd']
[enterParameterDeclaration] int : fd
sym_dict [fd] = int 
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
ParameterDeclaration : type = cgc_size_t, var = len [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['len']
[enterParameterDeclaration] cgc_size_t : len
sym_dict [len] = cgc_size_t 
ParameterDeclaration : type = char, var = delim [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['delim']
[enterParameterDeclaration] char : delim
sym_dict [delim] = char 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = cgc_size_t 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * c'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [c] = char * 
var: c (c) = buf
var: char * c (c) = buf
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: cgc_size_t i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < len
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => len
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < len
=> ['i', 'len']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  cgc_size_t : i
Resolved type: [1.3]  cgc_size_t : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t rx'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rx] = cgc_size_t 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
var: tlv5 (tlv5) = fd
var: int tlv5 (tlv5) = fd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = c
var: void * tlv4 (tlv4) = c
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
var: tlv3 (tlv3) = 1
var: cgc_size_t tlv3 (tlv3) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t * 
var: tlv2 (tlv2) = & rx
var: cgc_size_t * tlv2 (tlv2) = & rx
var: tlv1 (tlv1) = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 )
var: int tlv1 (tlv1) = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('int', 'tlv5', '', 'fd'), ('void *', 'tlv4', '', 'c'), ('cgc_size_t', 'tlv3', '', '1'), ('cgc_size_t *', 'tlv2', '', '& rx'), ('int', 'tlv1', '', 'cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => rx == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => rx
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => rx == 0
=> ['rx', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : rx
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['rx']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['rx']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['rx']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['rx']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['rx']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['rx']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['rx']
FOUND IT! [2.2]  cgc_size_t : rx
Resolved type: [2.3]  cgc_size_t : rx
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 != 0 || rx == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 != 0 || rx == 0 ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => * ( c ++ ) == delim
[0] <class 'CParser.CParser.RelationalExpressionContext'> => * ( c ++ )
[2] <class 'CParser.CParser.RelationalExpressionContext'> => delim
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => * ( c ++ ) == delim
=> ['* ( c ++ )', 'delim']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : * ( c ++ )
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['* ( c ++ )']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['* ( c ++ )']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['* ( c ++ )']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['* ( c ++ )']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['* ( c ++ )']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.UnaryOperatorContext'>, <class 'CParser.CParser.CastExpressionContext'>] ['*', '( c ++ )']
-------<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['( c ++ )']
--------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['( c ++ )']
---------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['( c ++ )']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : delim
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['delim']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['delim']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['delim']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['delim']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['delim']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['delim']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['delim']
FOUND IT! [2.2]  char : delim
Resolved type: [2.3]  char : delim
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ * ( c ++ ) == delim ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { break ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( * ( c ++ ) == delim ) { break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( * ( c ++ ) == delim ) { break ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } ]
var: * ( c - 1 ) (* ( c - 1 )) = '\0'
var: UNDEF * ( c - 1 ) (* ( c - 1 )) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } ]
Assigns = [('char *', 'c', '', 'buf'), ('UNDEF', '* ( c - 1 )', '', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_read_until ( int fd , char * buf , cgc_size_t len , char delim ) { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_import_kty ( char * buf )')]
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => my_kty != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => my_kty
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => my_kty != NULL
=> ['my_kty', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : my_kty
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['my_kty']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['my_kty']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['my_kty']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['my_kty']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['my_kty']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['my_kty']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['my_kty']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
Resolved type: [2.3]  UNDEF : NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ my_kty != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free_kty_item'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( my_kty )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
var: my_kty (my_kty) = NULL
var: UNDEF my_kty (my_kty) = NULL
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; }
Assigns = [('UNDEF', 'my_kty', '', 'NULL')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } ]
var: parser -> cats (parser -> cats) = 0
var: UNDEF parser -> cats (parser -> cats) = 0
var: my_kty (my_kty) = parser -> loads ( buf )
var: UNDEF my_kty (my_kty) = parser -> loads ( buf )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => my_kty == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => my_kty
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => my_kty == NULL
=> ['my_kty', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : my_kty
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['my_kty']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['my_kty']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['my_kty']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['my_kty']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['my_kty']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['my_kty']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['my_kty']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
Resolved type: [2.3]  UNDEF : NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ my_kty == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = STDOUT
var: int tlv2 (tlv2) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "Error!\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv2', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } ]
Assigns = [('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_import_kty ( char * buf ) { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_print_kty ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => my_kty == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => my_kty
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => my_kty == NULL
=> ['my_kty', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : my_kty
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['my_kty']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['my_kty']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['my_kty']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['my_kty']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['my_kty']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['my_kty']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['my_kty']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
Resolved type: [2.3]  UNDEF : NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ my_kty == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = STDOUT
var: int tlv2 (tlv2) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "Error!\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv2', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ]
var: parser -> cats (parser -> cats) = 0
var: UNDEF parser -> cats (parser -> cats) = 0
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ]
Assigns = [('UNDEF', 'parser -> cats', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_print_kty ( ) { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_nyan ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * c'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [c] = char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ 1024 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'nyan_cat [ ] = "\\n\\n\\\n+      o     +              o\\n\\\n    +             o     +       +\\n\\\no          +\\n\\\n    o  +           +        +\\n\\\n+        o     o       +        o\\n\\\n-_-_-_-_-_-_-_,------,      o\\n\\\n_-_-_-_-_-_-_-|   /\\\\_/\\\\\\n\\\n-_-_-_-_-_-_-~|__( ^ .^)  +     +\\n\\\n_-_-_-_-_-_-_-\\"\\"  \\"\\"\\n\\\n+      o         o   +       o\\n\\\n    +         +\\n\\\no        o         o      o     +\\n\\\n    o           +\\n\\\n+      +     o        o      +\\n\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [nyan_cat] = char * 
[C-t-2] sym_dict [nyan_cat [ ]] = char 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => my_kty == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => my_kty
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => my_kty == NULL
=> ['my_kty', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : my_kty
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['my_kty']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['my_kty']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['my_kty']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['my_kty']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['my_kty']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['my_kty']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['my_kty']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
Resolved type: [2.3]  UNDEF : NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ my_kty == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = STDOUT
var: int tlv2 (tlv2) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "Error!\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv2', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => parser -> cats < 3
[0] <class 'CParser.CParser.ShiftExpressionContext'> => parser -> cats
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 3
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => parser -> cats < 3
=> ['parser -> cats', '3']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : parser -> cats
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['parser -> cats']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['parser -> cats']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['parser -> cats']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['parser -> cats']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['parser -> cats']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['parser', '->', 'cats']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 3
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['3']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['3']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['3']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['3']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['3']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['3']
Resolved type: [1.3]  UNDEF : 3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ parser -> cats < 3 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( parser -> cats < 3 ) { return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ; } ]
var: c (c) = buf
var: char * c (c) = buf
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < cgc_array_length ( parser -> nyan_says )
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => cgc_array_length ( parser -> nyan_says )
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < cgc_array_length ( parser -> nyan_says )
=> ['i', 'cgc_array_length ( parser -> nyan_says )']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'kty_item_t * item'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [item] = kty_item_t * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'array_t * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = array_t * 
var: tlv6 (tlv6) = parser -> nyan_says
var: array_t * tlv6 (tlv6) = parser -> nyan_says
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
var: tlv5 (tlv5) = i
var: int tlv5 (tlv5) = i
var: item (item) = cgc_array_get ( tlv6 , tlv5 )
var: kty_item_t * item (item) = cgc_array_get ( tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; }
Assigns = [('array_t *', 'tlv6', '', 'parser -> nyan_says'), ('int', 'tlv5', '', 'i'), ('kty_item_t *', 'item', '', 'cgc_array_get ( tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = char * 
var: tlv4 (tlv4) = c
var: char * tlv4 (tlv4) = c
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 = item -> item . i_string . s'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; }
Assigns = [('char *', 'tlv4', '', 'c')]
Compares = []
var: c (c) = item -> item . i_string . len
var: char * c (c) = item -> item . i_string . len
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } ]
Assigns = [('char *', 'c', '', 'item -> item . i_string . len')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( parser -> cats < 3 ) { return ; } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } ]
Assigns = [('char *', 'c', '', 'buf')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_nyan ( ) { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_quit ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = STDOUT
var: int tlv2 (tlv2) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "\\n\\n=^.^=// Bye!\\n\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv2', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_quit ( ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_menu ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = STDOUT
var: int tlv2 (tlv2) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "=======================\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv2', '', 'STDOUT')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = STDOUT
var: int tlv4 (tlv4) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 [ ] = " 1. Import KTY\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv3] = const char * 
[C-t-2] sym_dict [tlv3 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }
Assigns = [('int', 'tlv4', '', 'STDOUT')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = int 
var: tlv6 (tlv6) = STDOUT
var: int tlv6 (tlv6) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 [ ] = " 2. Print KTY\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv5] = const char * 
[C-t-2] sym_dict [tlv5 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; }
Assigns = [('int', 'tlv6', '', 'STDOUT')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = int 
var: tlv8 (tlv8) = STDOUT
var: int tlv8 (tlv8) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 [ ] = " 3. Quit\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv7] = const char * 
[C-t-2] sym_dict [tlv7 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }
Assigns = [('int', 'tlv8', '', 'STDOUT')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = int 
var: tlv10 (tlv10) = STDOUT
var: int tlv10 (tlv10) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 [ ] = "=======================\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv9] = const char * 
[C-t-2] sym_dict [tlv9 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }
Assigns = [('int', 'tlv10', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_menu ( ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'main ( int cgc_argc , char * cgc_argv [ ] )')]
ParameterDeclaration : type = int, var = cgc_argc [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cgc_argc']
[enterParameterDeclaration] int : cgc_argc
sym_dict [cgc_argc] = int 
ParameterDeclaration : type = char *, var = cgc_argv [ ] [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cgc_argv [ ]']
[enterParameterDeclaration] char * : cgc_argv [ ]
sym_dict [cgc_argv] = char * * 
sym_dict [cgc_argv [ ]] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ MAX_KTY_LENGTH ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ MAX_KTY_LENGTH ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'cgc_select [ 16 ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [cgc_select] = char * 
[C-t-3] sym_dict [cgc_select [ 16 ]] = char 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = STDOUT
var: int tlv4 (tlv4) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 [ ] = "KTY Pretty Printer v0.1\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv3] = const char * 
[C-t-2] sym_dict [tlv3 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }
Assigns = [('int', 'tlv4', '', 'STDOUT')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = cgc_size_t 
var: tlv6 (tlv6) = sizeof ( kty_parser_t )
var: cgc_size_t tlv6 (tlv6) = sizeof ( kty_parser_t )
var: parser (parser) = ( kty_parser_t * ) cgc_malloc ( tlv6 )
var: UNDEF parser (parser) = ( kty_parser_t * ) cgc_malloc ( tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; }
Assigns = [('cgc_size_t', 'tlv6', '', 'sizeof ( kty_parser_t )'), ('UNDEF', 'parser', '', '( kty_parser_t * ) cgc_malloc ( tlv6 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'kty_parser_t * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = kty_parser_t * 
var: tlv5 (tlv5) = parser
var: kty_parser_t * tlv5 (tlv5) = parser
var: tlv1 (tlv1) = cgc_kty_init ( tlv5 )
var: int tlv1 (tlv1) = cgc_kty_init ( tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; }
Assigns = [('kty_parser_t *', 'tlv5', '', 'parser'), ('int', 'tlv1', '', 'cgc_kty_init ( tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = int 
var: tlv8 (tlv8) = STDOUT
var: int tlv8 (tlv8) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 [ ] = "Error!\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv7] = const char * 
[C-t-2] sym_dict [tlv7 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }
Assigns = [('int', 'tlv8', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned long tlv_size_0'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv_size_0] = unsigned long 
var: tlv_size_0 (tlv_size_0) = sizeof ( cgc_select )
var: unsigned long tlv_size_0 (tlv_size_0) = sizeof ( cgc_select )
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' )
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0
=> ["cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\\n' )", '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' )
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ["cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\\n' )"]
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ["cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\\n' )"]
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ["cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\\n' )"]
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ["cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\\n' )"]
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ["cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\\n' )"]
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ArgumentExpressionListContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cgc_read_until', '(', "STDIN , cgc_select , tlv_size_0 , '\\n'", ')']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
Resolved type: [1.3]  UNDEF : 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int menu'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [menu] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv11 = cgc_select'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = char * * 
var: tlv10 (tlv10) = NULL
var: char * * tlv10 (tlv10) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = int 
var: tlv9 (tlv9) = 10
var: int tlv9 (tlv9) = 10
var: menu (menu) = cgc_strtol ( tlv11 , tlv10 , tlv9 )
var: int menu (menu) = cgc_strtol ( tlv11 , tlv10 , tlv9 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; }
Assigns = [('char * *', 'tlv10', '', 'NULL'), ('int', 'tlv9', '', '10'), ('int', 'menu', '', 'cgc_strtol ( tlv11 , tlv10 , tlv9 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ switch ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ menu ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv17'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = int 
var: tlv17 (tlv17) = STDIN
var: int tlv17 (tlv17) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = char * 
var: tlv16 (tlv16) = buf
var: char * tlv16 (tlv16) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = cgc_size_t 
var: tlv15 (tlv15) = MAX_KTY_LENGTH
var: cgc_size_t tlv15 (tlv15) = MAX_KTY_LENGTH
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = char 
var: tlv14 (tlv14) = '\x00'
var: char tlv14 (tlv14) = '\x00'
var: tlv2 (tlv2) = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 )
var: int tlv2 (tlv2) = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; }
Assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('int', 'tlv2', '', 'cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2 > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => tlv2
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => tlv2 > 0
=> ['tlv2', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : tlv2
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [1.2]  int : tlv2
Resolved type: [1.3]  int : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_import_kty'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( buf )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_import_kty ( buf ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_import_kty ( buf ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv19'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = int 
var: tlv19 (tlv19) = STDOUT
var: int tlv19 (tlv19) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv18 [ ] = "Error!\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv18] = const char * 
[C-t-2] sym_dict [tlv18 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; }
Assigns = [('int', 'tlv19', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_import_kty ( buf ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_print_kty ( ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_quit ( ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_nyan ( ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = int 
var: tlv13 (tlv13) = STDOUT
var: int tlv13 (tlv13) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv12 [ ] = "Invalid menu. Try again.\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv12] = const char * 
[C-t-2] sym_dict [tlv12 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; }
Assigns = [('int', 'tlv13', '', 'STDOUT')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_print_kty ( ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_quit ( ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_nyan ( ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } ]
 4 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } ]
Assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int main ( int cgc_argc , char * cgc_argv [ ] ) { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; } ]
compound scope 0 : { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; }
compound scope 1 : { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } }
compound scope 2 : { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }
compound scope 3 : { return - 1 ; }
compound scope 4 : { break ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; } ] 
p_decls = [('cgc_size_t', 'i', None), ('char *', 'c', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'i', None), ('char *', 'c', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None)]
assigns = [('char *', 'c', '', 'buf'), ('UNDEF', '* ( c - 1 )', '', "'\\0'")]
compares = []
===> context { cgc_size_t i ; char * c ; c = buf ; for ( i = 0 ; i < len ; ++ i ) { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } * ( c - 1 ) = '\0' ; return c - buf ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: i
1 : |  decl_scope  | type: char *, var: c
2 : |  decl_scope  | type: int, var: fd
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: cgc_size_t, var: len
5 : |  decl_scope  | type: char, var: delim
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } } ] 
p_decls = [('cgc_size_t', 'rx', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'rx', None), ('int', 'tlv1', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None)]
assigns = []
compares = []
decls = [('cgc_size_t', 'rx', None), ('int', 'tlv1', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('char *', 'c', '', 'buf')]
compares = []
decls = [('cgc_size_t', 'rx', None), ('int', 'tlv1', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
===> context { cgc_size_t rx ; int tlv1 ; { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( tlv1 != 0 || rx == 0 ) { return - 1 ; } if ( * ( c ++ ) == delim ) { break ; } }
ignore sibs: ["* ( c - 1 ) = '\\0' ;", 'return c - buf ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: rx
1 : |  decl_scope  | type: int, var: tlv1
2 : |  decl_scope  | type: int, var: fd
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: cgc_size_t, var: len
5 : |  decl_scope  | type: char, var: delim
6 : |  decl_scope  | type: cgc_size_t, var: i
7 : |  decl_scope  | type: char *, var: c
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: i
1 : |compare_scopes| type: cgc_size_t, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('int', 'tlv5', None), ('void *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('cgc_size_t *', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv5', None), ('void *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('cgc_size_t *', 'tlv2', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None)]
assigns = [('int', 'tlv5', '', 'fd'), ('void *', 'tlv4', '', 'c'), ('cgc_size_t', 'tlv3', '', '1'), ('cgc_size_t *', 'tlv2', '', '& rx')]
compares = []
decls = [('int', 'tlv5', None), ('void *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('cgc_size_t *', 'tlv2', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('int', 'tlv5', '', 'fd'), ('void *', 'tlv4', '', 'c'), ('cgc_size_t', 'tlv3', '', '1'), ('cgc_size_t *', 'tlv2', '', '& rx'), ('char *', 'c', '', 'buf')]
compares = []
decls = [('int', 'tlv5', None), ('void *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('cgc_size_t *', 'tlv2', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('int', 'tlv5', '', 'fd'), ('void *', 'tlv4', '', 'c'), ('cgc_size_t', 'tlv3', '', '1'), ('cgc_size_t *', 'tlv2', '', '& rx'), ('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'tlv5', None), ('void *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('cgc_size_t *', 'tlv2', None), ('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None), ('cgc_size_t', 'rx', None), ('int', 'tlv1', None)]
assigns = [('int', 'tlv5', '', 'fd'), ('void *', 'tlv4', '', 'c'), ('cgc_size_t', 'tlv3', '', '1'), ('cgc_size_t *', 'tlv2', '', '& rx'), ('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
===> context { int tlv5 ; tlv5 = fd ; void * tlv4 ; tlv4 = c ; cgc_size_t tlv3 ; tlv3 = 1 ; cgc_size_t * tlv2 ; tlv2 = & rx ; tlv1 = cgc_receive ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( tlv1 != 0 || rx == 0 ) { return - 1 ; }', 'if ( * ( c ++ ) == delim ) { break ; }', '}', "* ( c - 1 ) = '\\0' ;", 'return c - buf ;', '}']
0 : |  decl_scope  | type: int, var: tlv5
1 : |  decl_scope  | type: void *, var: tlv4
2 : |  decl_scope  | type: cgc_size_t, var: tlv3
3 : |  decl_scope  | type: cgc_size_t *, var: tlv2
4 : |  decl_scope  | type: int, var: fd
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: cgc_size_t, var: len
7 : |  decl_scope  | type: char, var: delim
8 : |  decl_scope  | type: cgc_size_t, var: i
9 : |  decl_scope  | type: char *, var: c
10 : |  decl_scope  | type: cgc_size_t, var: rx
11 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: fd
1 : | assign_scope | type: void *, value: c
2 : | assign_scope | type: cgc_size_t, value: 1
3 : | assign_scope | type: cgc_size_t *, value: & rx
4 : | assign_scope | type: char *, value: buf
5 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: i
1 : |compare_scopes| type: cgc_size_t, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('char *', 'c', '', 'buf')]
compares = []
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None), ('cgc_size_t', 'rx', None), ('int', 'tlv1', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None), ('cgc_size_t', 'rx', None), ('int', 'tlv1', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '', '', '', '', '']
===> context { return - 1 ; }
ignore sibs: ['if ( * ( c ++ ) == delim ) { break ; }', '}', "* ( c - 1 ) = '\\0' ;", 'return c - buf ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: char, var: delim
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: char *, var: c
6 : |  decl_scope  | type: cgc_size_t, var: rx
7 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: i
1 : |compare_scopes| type: cgc_size_t, value: len
2 : |compare_scopes| type: int, value: tlv1
3 : |compare_scopes| type: int, value: 0
4 : |compare_scopes| type: cgc_size_t, value: rx
5 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('char *', 'c', '', 'buf')]
compares = []
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None), ('cgc_size_t', 'rx', None), ('int', 'tlv1', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('char', 'delim', None), ('cgc_size_t', 'i', None), ('char *', 'c', None), ('cgc_size_t', 'rx', None), ('int', 'tlv1', None)]
assigns = [('char *', 'c', '', 'buf'), ('cgc_size_t', 'i', '', '0')]
compares = ['', '', '', '']
===> context { break ; }
ignore sibs: ['}', "* ( c - 1 ) = '\\0' ;", 'return c - buf ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: char, var: delim
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: char *, var: c
6 : |  decl_scope  | type: cgc_size_t, var: rx
7 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: i
1 : |compare_scopes| type: cgc_size_t, value: len
2 : |compare_scopes| type: char, value: * ( c ++ )
3 : |compare_scopes| type: char, value: delim
=======END=======
compound scope 0 : { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } }
compound scope 1 : { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; }
compound scope 2 : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } }
compound scope 3 : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None)]
assigns = [('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
compares = []
===> context { if ( my_kty != NULL ) { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } parser -> cats = 0 ; my_kty = parser -> loads ( buf ) ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: UNDEF, value: 0
1 : | assign_scope | type: UNDEF, value: parser -> loads ( buf )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None)]
assigns = [('UNDEF', 'my_kty', '', 'NULL')]
compares = []
decls = [('char *', 'buf', None)]
assigns = [('UNDEF', 'my_kty', '', 'NULL')]
compares = []
decls = [('char *', 'buf', None)]
assigns = [('UNDEF', 'my_kty', '', 'NULL')]
compares = ['', '']
===> context { cgc_free_kty_item ( my_kty ) ; my_kty = NULL ; }
ignore sibs: ['parser -> cats = 0 ;', 'my_kty = parser -> loads ( buf ) ;', 'if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } }', '}']
0 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: UNDEF, value: NULL
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None)]
assigns = [('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
compares = []
decls = [('char *', 'buf', None)]
assigns = [('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
compares = ['', '']
===> context { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } }
ignore sibs: ['}']
0 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: UNDEF, value: 0
1 : | assign_scope | type: UNDEF, value: parser -> loads ( buf )
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('char *', 'buf', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('char *', 'buf', None)]
assigns = [('int', 'tlv2', '', 'STDOUT'), ('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('char *', 'buf', None)]
assigns = [('int', 'tlv2', '', 'STDOUT'), ('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
compares = ['', '']
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('char *', 'buf', None)]
assigns = [('int', 'tlv2', '', 'STDOUT'), ('UNDEF', 'parser -> cats', '', '0'), ('UNDEF', 'my_kty', '', 'parser -> loads ( buf )')]
compares = ['', '']
===> context { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
ignore sibs: ['}', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: const char, var: tlv1 [ ]
3 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: UNDEF, value: 0
2 : | assign_scope | type: UNDEF, value: parser -> loads ( buf )
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
compound scope 0 : { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; }
compound scope 1 : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
compound scope 2 : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('UNDEF', 'parser -> cats', '', '0')]
compares = []
===> context { if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> cats = 0 ; parser -> dumps ( my_kty ) ; }
ignore sibs: []
0 : | assign_scope | type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = []
decls = []
assigns = []
compares = ['', '']
===> context { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
ignore sibs: ['parser -> cats = 0 ;', 'parser -> dumps ( my_kty ) ;', '}']
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = ['', '']
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = ['', '']
===> context { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
ignore sibs: ['return ;', '}', 'parser -> cats = 0 ;', 'parser -> dumps ( my_kty ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: const char, var: tlv1 [ ]
0 : | assign_scope | type: int, value: STDOUT
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
compound scope 0 : { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; }
compound scope 1 : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
compound scope 2 : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
compound scope 3 : { return ; }
compound scope 4 : { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }
compound scope 5 : { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; }
compound scope 6 : { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; } ] 
p_decls = [('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('char *', 'c', '', 'buf')]
compares = []
===> context { int i ; char * c ; char buf [ 1024 ] = { 0 } ; char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ; if ( my_kty == NULL ) { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } parser -> dumps ( my_kty ) ; if ( parser -> cats < 3 ) { return ; } cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ; c = buf ; for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } cgc_fdprintf ( STDOUT , "NYAN SAYS...\n\"\n%s\n\"" , buf ) ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: char *, var: c
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: char *, var: nyan_cat
5 : |  decl_scope  | type: char, var: nyan_cat [ ]
0 : | assign_scope | type: char *, value: buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = []
compares = []
decls = [('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = []
compares = ['', '']
===> context { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } return ; }
ignore sibs: ['parser -> dumps ( my_kty ) ;', 'if ( parser -> cats < 3 ) { return ; }', 'cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ;', 'c = buf ;', 'for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }', 'cgc_fdprintf ( STDOUT , "NYAN SAYS...\\n\\"\\n%s\\n\\"" , buf ) ;', '}']
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: char *, var: c
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: char *, var: nyan_cat
5 : |  decl_scope  | type: char, var: nyan_cat [ ]
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = ['', '']
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = ['', '']
===> context { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "Error!\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
ignore sibs: ['return ;', '}', 'parser -> dumps ( my_kty ) ;', 'if ( parser -> cats < 3 ) { return ; }', 'cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ;', 'c = buf ;', 'for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }', 'cgc_fdprintf ( STDOUT , "NYAN SAYS...\\n\\"\\n%s\\n\\"" , buf ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: const char, var: tlv1 [ ]
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: char *, var: c
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ 1024 ]
7 : |  decl_scope  | type: char *, var: nyan_cat
8 : |  decl_scope  | type: char, var: nyan_cat [ ]
0 : | assign_scope | type: int, value: STDOUT
0 : |compare_scopes| type: UNDEF, value: my_kty
1 : |compare_scopes| type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = []
compares = []
decls = [('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = []
compares = ['', '']
===> context { return ; }
ignore sibs: ['cgc_fdprintf ( STDOUT , "%s" , nyan_cat ) ;', 'c = buf ;', 'for ( i = 0 ; i < cgc_array_length ( parser -> nyan_says ) ; ++ i ) { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }', 'cgc_fdprintf ( STDOUT , "NYAN SAYS...\\n\\"\\n%s\\n\\"" , buf ) ;', '}']
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: char *, var: c
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: char *, var: nyan_cat
5 : |  decl_scope  | type: char, var: nyan_cat [ ]
0 : |compare_scopes| type: UNDEF, value: parser -> cats
1 : |compare_scopes| type: UNDEF, value: 3
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; } ] 
p_decls = [('kty_item_t *', 'item', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('kty_item_t *', 'item', None)]
assigns = [('char *', 'c', '', 'item -> item . i_string . len')]
compares = []
decls = [('kty_item_t *', 'item', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('char *', 'c', '', 'item -> item . i_string . len'), ('char *', 'c', '', 'buf')]
compares = []
decls = [('kty_item_t *', 'item', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('char *', 'c', '', 'item -> item . i_string . len'), ('char *', 'c', '', 'buf'), ('int', 'i', '', '0')]
compares = ['']
===> context { kty_item_t * item ; { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } c += item -> item . i_string . len ; }
ignore sibs: ['cgc_fdprintf ( STDOUT , "NYAN SAYS...\\n\\"\\n%s\\n\\"" , buf ) ;', '}']
0 : |  decl_scope  | type: kty_item_t *, var: item
1 : |  decl_scope  | type: int, var: i
2 : |  decl_scope  | type: char *, var: c
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: char *, var: nyan_cat
6 : |  decl_scope  | type: char, var: nyan_cat [ ]
0 : | assign_scope | type: char *, value: item -> item . i_string . len
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; } ] 
p_decls = [('array_t *', 'tlv6', None), ('int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('array_t *', 'tlv6', None), ('int', 'tlv5', None)]
assigns = [('array_t *', 'tlv6', '', 'parser -> nyan_says'), ('int', 'tlv5', '', 'i')]
compares = []
decls = [('array_t *', 'tlv6', None), ('int', 'tlv5', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('array_t *', 'tlv6', '', 'parser -> nyan_says'), ('int', 'tlv5', '', 'i'), ('char *', 'c', '', 'buf')]
compares = []
decls = [('array_t *', 'tlv6', None), ('int', 'tlv5', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('array_t *', 'tlv6', '', 'parser -> nyan_says'), ('int', 'tlv5', '', 'i'), ('char *', 'c', '', 'buf'), ('int', 'i', '', '0')]
compares = ['']
decls = [('array_t *', 'tlv6', None), ('int', 'tlv5', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None), ('kty_item_t *', 'item', None)]
assigns = [('array_t *', 'tlv6', '', 'parser -> nyan_says'), ('int', 'tlv5', '', 'i'), ('char *', 'c', '', 'buf'), ('int', 'i', '', '0')]
compares = ['']
===> context { array_t * tlv6 ; tlv6 = parser -> nyan_says ; int tlv5 ; tlv5 = i ; item = cgc_array_get ( tlv6 , tlv5 ) ; }
ignore sibs: ['{ char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; }', 'c += item -> item . i_string . len ;', '}', 'cgc_fdprintf ( STDOUT , "NYAN SAYS...\\n\\"\\n%s\\n\\"" , buf ) ;', '}']
0 : |  decl_scope  | type: array_t *, var: tlv6
1 : |  decl_scope  | type: int, var: tlv5
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: char *, var: c
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: char *, var: nyan_cat
7 : |  decl_scope  | type: char, var: nyan_cat [ ]
8 : |  decl_scope  | type: kty_item_t *, var: item
0 : | assign_scope | type: array_t *, value: parser -> nyan_says
1 : | assign_scope | type: int, value: i
2 : | assign_scope | type: char *, value: buf
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; } ] 
p_decls = [('char *', 'tlv4', None), ('const char *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv4', None), ('const char *', 'tlv3', None)]
assigns = [('char *', 'tlv4', '', 'c')]
compares = []
decls = [('char *', 'tlv4', None), ('const char *', 'tlv3', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('char *', 'tlv4', '', 'c'), ('char *', 'c', '', 'buf')]
compares = []
decls = [('char *', 'tlv4', None), ('const char *', 'tlv3', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None)]
assigns = [('char *', 'tlv4', '', 'c'), ('char *', 'c', '', 'buf'), ('int', 'i', '', '0')]
compares = ['']
decls = [('char *', 'tlv4', None), ('const char *', 'tlv3', None), ('int', 'i', None), ('char *', 'c', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('char *', 'nyan_cat', ' [ ]'), ('char', 'nyan_cat [ ]', None), ('kty_item_t *', 'item', None)]
assigns = [('char *', 'tlv4', '', 'c'), ('char *', 'c', '', 'buf'), ('int', 'i', '', '0')]
compares = ['']
===> context { char * tlv4 ; tlv4 = c ; const char * tlv3 = item -> item . i_string . s ; cgc_strcpy ( tlv4 , tlv3 ) ; }
ignore sibs: ['c += item -> item . i_string . len ;', '}', 'cgc_fdprintf ( STDOUT , "NYAN SAYS...\\n\\"\\n%s\\n\\"" , buf ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv4
1 : |  decl_scope  | type: const char *, var: tlv3
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: char *, var: c
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: char *, var: nyan_cat
7 : |  decl_scope  | type: char, var: nyan_cat [ ]
8 : |  decl_scope  | type: kty_item_t *, var: item
0 : | assign_scope | type: char *, value: c
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
=======END=======
compound scope 0 : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; }
compound scope 1 : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
len(compound_scope) : 2
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } cgc_exit ( 0 ) ; }
ignore sibs: []
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
===> context { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
ignore sibs: ['cgc_exit ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: const char, var: tlv1 [ ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
compound scope 0 : { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } }
compound scope 1 : { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
compound scope 2 : { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }
compound scope 3 : { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; }
compound scope 4 : { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }
compound scope 5 : { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } }
ignore sibs: []
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv2', None), ('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
assigns = [('int', 'tlv2', '', 'STDOUT')]
compares = []
===> context { int tlv2 ; tlv2 = STDOUT ; const char tlv1 [ ] = "=======================\n" ; cgc_fdprintf ( tlv2 , tlv1 ) ; }
ignore sibs: ['{ int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }', '{ int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; }', '{ int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }', '{ int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: const char *, var: tlv1
2 : |  decl_scope  | type: const char, var: tlv1 [ ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None)]
assigns = [('int', 'tlv4', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None)]
assigns = [('int', 'tlv4', '', 'STDOUT')]
compares = []
===> context { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = " 1. Import KTY\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }
ignore sibs: ['{ int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; }', '{ int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }', '{ int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: const char *, var: tlv3
2 : |  decl_scope  | type: const char, var: tlv3 [ ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; } ] 
p_decls = [('int', 'tlv6', None), ('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv6', None), ('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None)]
assigns = [('int', 'tlv6', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv6', None), ('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None)]
assigns = [('int', 'tlv6', '', 'STDOUT')]
compares = []
===> context { int tlv6 ; tlv6 = STDOUT ; const char tlv5 [ ] = " 2. Print KTY\n" ; cgc_fdprintf ( tlv6 , tlv5 ) ; }
ignore sibs: ['{ int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }', '{ int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }', '}']
0 : |  decl_scope  | type: int, var: tlv6
1 : |  decl_scope  | type: const char *, var: tlv5
2 : |  decl_scope  | type: const char, var: tlv5 [ ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } ] 
p_decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None)]
assigns = [('int', 'tlv8', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None)]
assigns = [('int', 'tlv8', '', 'STDOUT')]
compares = []
===> context { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = " 3. Quit\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }
ignore sibs: ['{ int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }', '}']
0 : |  decl_scope  | type: int, var: tlv8
1 : |  decl_scope  | type: const char *, var: tlv7
2 : |  decl_scope  | type: const char, var: tlv7 [ ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; } ] 
p_decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None)]
assigns = [('int', 'tlv10', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None)]
assigns = [('int', 'tlv10', '', 'STDOUT')]
compares = []
===> context { int tlv10 ; tlv10 = STDOUT ; const char tlv9 [ ] = "=======================\n" ; cgc_fdprintf ( tlv10 , tlv9 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: int, var: tlv10
1 : |  decl_scope  | type: const char *, var: tlv9
2 : |  decl_scope  | type: const char, var: tlv9 [ ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
compound scope 0 : { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; }
compound scope 1 : { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }
compound scope 2 : { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; }
compound scope 3 : { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; }
compound scope 4 : { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }
compound scope 5 : { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }
compound scope 6 : { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }
compound scope 7 : { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; }
compound scope 8 : { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; }
compound scope 9 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } }
compound scope 10 : { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; }
compound scope 11 : { cgc_import_kty ( buf ) ; }
compound scope 12 : { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } }
compound scope 13 : { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; }
compound scope 14 : { cgc_print_kty ( ) ; }
compound scope 15 : { cgc_quit ( ) ; }
compound scope 16 : { cgc_nyan ( ) ; }
compound scope 17 : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }
compound scope 18 : { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; }
len(compound_scope) : 19
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; } ] 
p_decls = [('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
===> context { char buf [ MAX_KTY_LENGTH ] ; char cgc_select [ 16 ] ; { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } int tlv1 ; { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } cgc_menu ( ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( cgc_select ) ; while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , '\n' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
2 : |  decl_scope  | type: char *, var: cgc_select
3 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: unsigned long, var: tlv_size_0
6 : |  decl_scope  | type: int, var: cgc_argc
7 : |  decl_scope  | type: char * *, var: cgc_argv
8 : |  decl_scope  | type: char *, var: cgc_argv [ ]
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv4', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv4', None), ('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None)]
assigns = [('int', 'tlv4', '', 'STDOUT')]
compares = []
===> context { int tlv4 ; tlv4 = STDOUT ; const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ; cgc_fdprintf ( tlv4 , tlv3 ) ; }
ignore sibs: ['{ cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; }', 'int tlv1 ;', '{ kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; }', 'if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }', 'cgc_menu ( ) ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( cgc_select ) ;', 'while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , \'\\n\' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = \'\\x00\' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: const char *, var: tlv3
2 : |  decl_scope  | type: const char, var: tlv3 [ ]
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
8 : |  decl_scope  | type: char *, var: cgc_select
9 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
0 : | assign_scope | type: int, value: STDOUT
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv6', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'sizeof ( kty_parser_t )')]
compares = []
decls = [('cgc_size_t', 'tlv6', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'sizeof ( kty_parser_t )')]
compares = []
===> context { cgc_size_t tlv6 ; tlv6 = sizeof ( kty_parser_t ) ; parser = ( kty_parser_t * ) cgc_malloc ( tlv6 ) ; }
ignore sibs: ['int tlv1 ;', '{ kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; }', 'if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }', 'cgc_menu ( ) ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( cgc_select ) ;', 'while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , \'\\n\' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = \'\\x00\' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv6
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
6 : |  decl_scope  | type: char *, var: cgc_select
7 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
0 : | assign_scope | type: cgc_size_t, value: sizeof ( kty_parser_t )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; } ] 
p_decls = [('kty_parser_t *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('kty_parser_t *', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('kty_parser_t *', 'tlv5', '', 'parser')]
compares = []
decls = [('kty_parser_t *', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None)]
assigns = [('kty_parser_t *', 'tlv5', '', 'parser')]
compares = []
===> context { kty_parser_t * tlv5 ; tlv5 = parser ; tlv1 = cgc_kty_init ( tlv5 ) ; }
ignore sibs: ['if ( tlv1 != 0 ) { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }', 'cgc_menu ( ) ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( cgc_select ) ;', 'while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , \'\\n\' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = \'\\x00\' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: kty_parser_t *, var: tlv5
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
6 : |  decl_scope  | type: char *, var: cgc_select
7 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
8 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: kty_parser_t *, value: parser
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None)]
assigns = []
compares = ['', '']
===> context { { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } cgc_quit ( ) ; }
ignore sibs: ['cgc_menu ( ) ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( cgc_select ) ;', 'while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , \'\\n\' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = \'\\x00\' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; } ] 
p_decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv8', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None)]
assigns = [('int', 'tlv8', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None)]
assigns = [('int', 'tlv8', '', 'STDOUT')]
compares = ['', '']
decls = [('int', 'tlv8', None), ('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None)]
assigns = [('int', 'tlv8', '', 'STDOUT')]
compares = ['', '']
===> context { int tlv8 ; tlv8 = STDOUT ; const char tlv7 [ ] = "Error!\n" ; cgc_fdprintf ( tlv8 , tlv7 ) ; }
ignore sibs: ['cgc_quit ( ) ;', '}', 'cgc_menu ( ) ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( cgc_select ) ;', 'while ( cgc_read_until ( STDIN , cgc_select , tlv_size_0 , \'\\n\' ) > 0 ) { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = \'\\x00\' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv8
1 : |  decl_scope  | type: const char *, var: tlv7
2 : |  decl_scope  | type: const char, var: tlv7 [ ]
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
8 : |  decl_scope  | type: char *, var: cgc_select
9 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: STDOUT
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } } ] 
p_decls = [('int', 'menu', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'menu', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'menu', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'menu', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { int menu ; { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: int, var: menu
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
6 : |  decl_scope  | type: char *, var: cgc_select
7 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
8 : |  decl_scope  | type: int, var: tlv1
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; } ] 
p_decls = [('const char *', 'tlv11', None), ('char * *', 'tlv10', None), ('int', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv11', None), ('char * *', 'tlv10', None), ('int', 'tlv9', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char * *', 'tlv10', '', 'NULL'), ('int', 'tlv9', '', '10')]
compares = []
decls = [('const char *', 'tlv11', None), ('char * *', 'tlv10', None), ('int', 'tlv9', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('char * *', 'tlv10', '', 'NULL'), ('int', 'tlv9', '', '10'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('const char *', 'tlv11', None), ('char * *', 'tlv10', None), ('int', 'tlv9', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('char * *', 'tlv10', '', 'NULL'), ('int', 'tlv9', '', '10'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('const char *', 'tlv11', None), ('char * *', 'tlv10', None), ('int', 'tlv9', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('char * *', 'tlv10', '', 'NULL'), ('int', 'tlv9', '', '10'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { const char * tlv11 = cgc_select ; char * * tlv10 ; tlv10 = NULL ; int tlv9 ; tlv9 = 10 ; menu = cgc_strtol ( tlv11 , tlv10 , tlv9 ) ; }
ignore sibs: ['switch ( menu ) { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = \'\\x00\' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv11
1 : |  decl_scope  | type: char * *, var: tlv10
2 : |  decl_scope  | type: int, var: tlv9
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
8 : |  decl_scope  | type: char *, var: cgc_select
9 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: char * *, value: NULL
1 : | assign_scope | type: int, value: 10
2 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { case 1 : { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } break ; case 2 : { cgc_print_kty ( ) ; } break ; case 3 : { cgc_quit ( ) ; } break ; case 777 : { cgc_nyan ( ) ; } break ; default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } break ; }
ignore sibs: ['}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } } ] 
p_decls = [('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { int tlv2 ; { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } }
ignore sibs: ['break ;', 'case 2 : { cgc_print_kty ( ) ; }', 'break ;', 'case 3 : { cgc_quit ( ) ; }', 'break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
6 : |  decl_scope  | type: char *, var: cgc_select
7 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
8 : |  decl_scope  | type: int, var: tlv1
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; } ] 
p_decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'")]
compares = []
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv17', None), ('char *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('char', 'tlv14', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None), ('int', 'tlv2', None)]
assigns = [('int', 'tlv17', '', 'STDIN'), ('char *', 'tlv16', '', 'buf'), ('cgc_size_t', 'tlv15', '', 'MAX_KTY_LENGTH'), ('char', 'tlv14', '', "'\\x00'"), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { int tlv17 ; tlv17 = STDIN ; char * tlv16 ; tlv16 = buf ; cgc_size_t tlv15 ; tlv15 = MAX_KTY_LENGTH ; char tlv14 ; tlv14 = '\x00' ; tlv2 = cgc_read_until ( tlv17 , tlv16 , tlv15 , tlv14 ) ; }
ignore sibs: ['if ( tlv2 > 0 ) { cgc_import_kty ( buf ) ; } else { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } }', '}', 'break ;', 'case 2 : { cgc_print_kty ( ) ; }', 'break ;', 'case 3 : { cgc_quit ( ) ; }', 'break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv17
1 : |  decl_scope  | type: char *, var: tlv16
2 : |  decl_scope  | type: cgc_size_t, var: tlv15
3 : |  decl_scope  | type: char, var: tlv14
4 : |  decl_scope  | type: int, var: cgc_argc
5 : |  decl_scope  | type: char * *, var: cgc_argv
6 : |  decl_scope  | type: char *, var: cgc_argv [ ]
7 : |  decl_scope  | type: char *, var: buf
8 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
9 : |  decl_scope  | type: char *, var: cgc_select
10 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: unsigned long, var: tlv_size_0
13 : |  decl_scope  | type: int, var: menu
14 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: cgc_size_t, value: MAX_KTY_LENGTH
3 : | assign_scope | type: char, value: '\x00'
4 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_import_kty ( buf ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_import_kty ( buf ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None), ('int', 'tlv2', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None), ('int', 'tlv2', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['', '', '']
===> context { cgc_import_kty ( buf ) ; }
ignore sibs: ['else', '{ { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } }', '}', 'break ;', 'case 2 : { cgc_print_kty ( ) ; }', 'break ;', 'case 3 : { cgc_quit ( ) ; }', 'break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
10 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
1 : |compare_scopes| type: int, value: tlv2
2 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None), ('int', 'tlv2', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } }
ignore sibs: ['}', 'break ;', 'case 2 : { cgc_print_kty ( ) ; }', 'break ;', 'case 3 : { cgc_quit ( ) ; }', 'break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
10 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; } ] 
p_decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv19', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None), ('int', 'tlv2', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv19', None), ('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None), ('int', 'tlv2', None)]
assigns = [('int', 'tlv19', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { int tlv19 ; tlv19 = STDOUT ; const char tlv18 [ ] = "Error!\n" ; cgc_fdprintf ( tlv19 , tlv18 ) ; }
ignore sibs: ['}', '}', 'break ;', 'case 2 : { cgc_print_kty ( ) ; }', 'break ;', 'case 3 : { cgc_quit ( ) ; }', 'break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv19
1 : |  decl_scope  | type: const char *, var: tlv18
2 : |  decl_scope  | type: const char, var: tlv18 [ ]
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
8 : |  decl_scope  | type: char *, var: cgc_select
9 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: menu
13 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_kty ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_print_kty ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { cgc_print_kty ( ) ; }
ignore sibs: ['break ;', 'case 3 : { cgc_quit ( ) ; }', 'break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_quit ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_quit ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { cgc_quit ( ) ; }
ignore sibs: ['break ;', 'case 777 : { cgc_nyan ( ) ; }', 'break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_nyan ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_nyan ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { cgc_nyan ( ) ; }
ignore sibs: ['break ;', 'default : { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } }
ignore sibs: ['break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
5 : |  decl_scope  | type: char *, var: cgc_select
6 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; } ] 
p_decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv13', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('int', 'tlv13', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = []
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('int', 'tlv13', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv13', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv13', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv13', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
decls = [('int', 'tlv13', None), ('const char *', 'tlv12', ' [ ]'), ('const char', 'tlv12 [ ]', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ MAX_KTY_LENGTH ]'), ('char', 'buf [ MAX_KTY_LENGTH ]', None), ('char *', 'cgc_select', ' [ 16 ]'), ('char', 'cgc_select [ 16 ]', None), ('int', 'tlv1', None), ('unsigned long', 'tlv_size_0', None), ('int', 'menu', None)]
assigns = [('int', 'tlv13', '', 'STDOUT'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( cgc_select )')]
compares = ['']
===> context { int tlv13 ; tlv13 = STDOUT ; const char tlv12 [ ] = "Invalid menu. Try again.\n" ; cgc_fdprintf ( tlv13 , tlv12 ) ; }
ignore sibs: ['}', 'break ;', '}', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv13
1 : |  decl_scope  | type: const char *, var: tlv12
2 : |  decl_scope  | type: const char, var: tlv12 [ ]
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ MAX_KTY_LENGTH ]
8 : |  decl_scope  | type: char *, var: cgc_select
9 : |  decl_scope  | type: char, var: cgc_select [ 16 ]
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: menu
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: unsigned long, value: sizeof ( cgc_select )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
def_vars[0]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t i ;
def_vars[1]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : char * c ;
def_vars[2]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t rx ;
def_vars[3]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[4]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[5]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[6]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[7]: [cgc_read_until] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t * tlv2 ;
sym_lut=>'{'fd': 'int', 'buf': 'char *', 'len': 'cgc_size_t', 'delim': 'char', 'i': 'cgc_size_t', 'c': 'char *'}'
val_s=>'[('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7643eb8>), ('UNDEF', '* ( c - 1 )', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d760d828>)]'
cval_s=>'[]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=0/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=1/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=2/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=3/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=4/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=5/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/7][j=0/5][dd=6/8][k=0/2] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
----
UNIQ_INIT: ('char *','buf','None','None');

==== Scope 1 ====
void fix_ingred_main_0_0_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t i; i = (cgc_size_t)(buf); }
    {char * c; c = (char *)(buf); }
    {cgc_size_t rx; rx = (cgc_size_t)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {int tlv5; tlv5 = (int)(buf); }
    {void * tlv4; tlv4 = (void *)(buf); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(buf); }
}
void fix_ingred_main_0_0(){
fix_ingred_main_0_0_0();
}

sym_lut=>'{'fd': 'int', 'buf': 'char *', 'len': 'cgc_size_t', 'delim': 'char', 'i': 'cgc_size_t', 'c': 'char *', 'rx': 'cgc_size_t', 'tlv1': 'int'}'
val_s=>'[('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7643eb8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d763fa58>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d76055f8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d7605908>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=0/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=0/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
unique : ('cgc_size_t', 'i', None)
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=0/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
unique : ('cgc_size_t', 'len', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=1/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=1/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=1/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=2/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=2/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=2/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=3/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=3/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=3/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=4/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=4/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=4/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=5/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=5/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=5/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=1/5][dd=6/8][k=1/4] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/7][j=1/5][dd=6/8][k=2/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=0/7][j=1/5][dd=6/8][k=3/4] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

not valid - cgc_size_t i; i = ((cgc_size_t)i);

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

==== Scope 1 ====
void fix_ingred_main_0_1_1(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {char * c; c = (char *)(0); }
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
}
void fix_ingred_main_0_1_2(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {char * c; c = (char *)(i); }
    {cgc_size_t rx; rx = (cgc_size_t)(i); }
    {int tlv1; tlv1 = (int)(i); }
    {int tlv5; tlv5 = (int)(i); }
    {void * tlv4; tlv4 = (void *)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
}
void fix_ingred_main_0_1_3(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(len); }
    {char * c; c = (char *)(len); }
    {cgc_size_t rx; rx = (cgc_size_t)(len); }
    {int tlv1; tlv1 = (int)(len); }
    {int tlv5; tlv5 = (int)(len); }
    {void * tlv4; tlv4 = (void *)(len); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(len); }
}
void fix_ingred_main_0_1(){
fix_ingred_main_0_1_1();
fix_ingred_main_0_1_2();
fix_ingred_main_0_1_3();
}

sym_lut=>'{'fd': 'int', 'buf': 'char *', 'len': 'cgc_size_t', 'delim': 'char', 'i': 'cgc_size_t', 'c': 'char *', 'rx': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'int', 'tlv4': 'void *', 'tlv3': 'cgc_size_t', 'tlv2': 'cgc_size_t *'}'
val_s=>'[('int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d762d5f8>), ('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7632588>), ('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d76354a8>), ('cgc_size_t *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d762c4a8>), ('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7643eb8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d763fa58>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d76055f8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d7605908>)]'
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=0/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
unique : ('int', 'fd', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=0/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
unique : ('char *', 'c', None)
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=0/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=1/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=1/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=1/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=2/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=2/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=2/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=3/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=3/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=3/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=4/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=4/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=4/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=5/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=5/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=5/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=0/7][j=2/5][dd=6/8][k=0/8] | type: int ; var : tlv5 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=0/7][j=2/5][dd=6/8][k=1/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/7][j=2/5][dd=6/8][k=2/8] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('int','fd','None','None');

UNIQ_INIT: ('char *','c','None','None');

not valid - char * c; c = ((char *)c);

----
UNIQ_INIT: ('int','fd','None','None');

UNIQ_INIT: ('char *','c','None','None');

----
UNIQ_INIT: ('int','fd','None','None');

UNIQ_INIT: ('char *','c','None','None');

==== Scope 1 ====
void fix_ingred_main_0_2_0(){
int fd;
    bzero(&fd,sizeof(int));
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {cgc_size_t i; i = (cgc_size_t)(fd); }
    {char * c; c = (char *)(fd); }
    {cgc_size_t rx; rx = (cgc_size_t)(fd); }
    {int tlv1; tlv1 = (int)(fd); }
    {int tlv5; tlv5 = (int)(fd); }
    {void * tlv4; tlv4 = (void *)(fd); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(fd); }
}
void fix_ingred_main_0_2_1(){
int fd;
    bzero(&fd,sizeof(int));
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {cgc_size_t i; i = (cgc_size_t)(c); }
    {cgc_size_t rx; rx = (cgc_size_t)(c); }
    {int tlv1; tlv1 = (int)(c); }
    {int tlv5; tlv5 = (int)(c); }
    {void * tlv4; tlv4 = (void *)(c); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(c); }
}
void fix_ingred_main_0_2_2(){
int fd;
    bzero(&fd,sizeof(int));
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {cgc_size_t i; i = (cgc_size_t)(1); }
    {char * c; c = (char *)(1); }
    {cgc_size_t rx; rx = (cgc_size_t)(1); }
    {int tlv1; tlv1 = (int)(1); }
    {int tlv5; tlv5 = (int)(1); }
    {void * tlv4; tlv4 = (void *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
}
void fix_ingred_main_0_2(){
fix_ingred_main_0_2_0();
fix_ingred_main_0_2_1();
fix_ingred_main_0_2_2();
}

sym_lut=>'{'fd': 'int', 'buf': 'char *', 'len': 'cgc_size_t', 'delim': 'char', 'i': 'cgc_size_t', 'c': 'char *', 'rx': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'int', 'tlv4': 'void *', 'tlv3': 'cgc_size_t', 'tlv2': 'cgc_size_t *'}'
val_s=>'[('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7643eb8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d763fa58>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d76055f8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d7605908>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7640518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7640898>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7640e48>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7636208>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=0/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=0/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=0/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
unique : ('cgc_size_t', 'rx', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=1/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=1/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=1/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=2/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=2/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=2/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=3/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=3/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=3/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=4/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=4/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=4/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=5/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=5/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=5/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=0/7][j=3/5][dd=6/8][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/7][j=3/5][dd=6/8][k=5/8] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=0/7][j=3/5][dd=6/8][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
not valid - int tlv1; tlv1 = ((int)tlv1);

----
UNIQ_INIT: ('int','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','rx','None','None');

----
UNIQ_INIT: ('int','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','rx','None','None');

not valid - cgc_size_t rx; rx = ((cgc_size_t)rx);

----
UNIQ_INIT: ('int','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','rx','None','None');

==== Scope 1 ====
void fix_ingred_main_0_3_4(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(tlv1); }
    {char * c; c = (char *)(tlv1); }
    {cgc_size_t rx; rx = (cgc_size_t)(tlv1); }
    {int tlv5; tlv5 = (int)(tlv1); }
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv1); }
}
void fix_ingred_main_0_3_5(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {char * c; c = (char *)(0); }
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
}
void fix_ingred_main_0_3_6(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(rx); }
    {char * c; c = (char *)(rx); }
    {int tlv1; tlv1 = (int)(rx); }
    {int tlv5; tlv5 = (int)(rx); }
    {void * tlv4; tlv4 = (void *)(rx); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(rx); }
}
void fix_ingred_main_0_3(){
fix_ingred_main_0_3_4();
fix_ingred_main_0_3_5();
fix_ingred_main_0_3_6();
}

sym_lut=>'{'fd': 'int', 'buf': 'char *', 'len': 'cgc_size_t', 'delim': 'char', 'i': 'cgc_size_t', 'c': 'char *', 'rx': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'int', 'tlv4': 'void *', 'tlv3': 'cgc_size_t', 'tlv2': 'cgc_size_t *'}'
val_s=>'[('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7643eb8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d763fa58>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d76055f8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d7605908>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7630668>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d76282e8>)]'
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=0/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
unique : ('char *', 'c', None)
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=0/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
unique : ('char', 'delim', None)
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=1/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=1/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
not unique: ('char', 'delim', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=2/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=2/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
not unique: ('char', 'delim', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=3/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=3/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
not unique: ('char', 'delim', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=4/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=4/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
not unique: ('char', 'delim', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=5/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=5/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
not unique: ('char', 'delim', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(c++)' - False OR  False
[i=0/7][j=4/5][dd=6/8][k=4/6] | type: char ; var :  ; varinfo :  ; value_node : * ( c ++ ) (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,c,++,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (True) )
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'delim' - False OR  False
[i=0/7][j=4/5][dd=6/8][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : delim
 => is literal (False) | is operator (False) delim [vtype=char]
not unique: ('char', 'delim', None) ... continue!
not valid - char * c; c = ((char *)* ( c ++ ));

----
UNIQ_INIT: ('char *','c','None','None');

UNIQ_INIT: ('char','delim','None','None');

----
UNIQ_INIT: ('char *','c','None','None');

UNIQ_INIT: ('char','delim','None','None');

==== Scope 1 ====
void fix_ingred_main_0_4_4(){
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
char delim;
    bzero(&delim,sizeof(char));
    {cgc_size_t i; i = (cgc_size_t)(* ( c ++ )); }
    {cgc_size_t rx; rx = (cgc_size_t)(* ( c ++ )); }
    {int tlv1; tlv1 = (int)(* ( c ++ )); }
    {int tlv5; tlv5 = (int)(* ( c ++ )); }
    {void * tlv4; tlv4 = (void *)(* ( c ++ )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(* ( c ++ )); }
}
void fix_ingred_main_0_4_5(){
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
char delim;
    bzero(&delim,sizeof(char));
    {cgc_size_t i; i = (cgc_size_t)(delim); }
    {char * c; c = (char *)(delim); }
    {cgc_size_t rx; rx = (cgc_size_t)(delim); }
    {int tlv1; tlv1 = (int)(delim); }
    {int tlv5; tlv5 = (int)(delim); }
    {void * tlv4; tlv4 = (void *)(delim); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(delim); }
}
void fix_ingred_main_0_4(){
fix_ingred_main_0_4_4();
fix_ingred_main_0_4_5();
}

==== Scope 2 ====
void fix_ingred_main_0_0_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t i; i = (cgc_size_t)(buf); }
    {char * c; c = (char *)(buf); }
    {cgc_size_t rx; rx = (cgc_size_t)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {int tlv5; tlv5 = (int)(buf); }
    {void * tlv4; tlv4 = (void *)(buf); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(buf); }
}
void fix_ingred_main_0_0(){
fix_ingred_main_0_0_0();
}
void fix_ingred_main_0_1_1(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {char * c; c = (char *)(0); }
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
}
void fix_ingred_main_0_1_2(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {char * c; c = (char *)(i); }
    {cgc_size_t rx; rx = (cgc_size_t)(i); }
    {int tlv1; tlv1 = (int)(i); }
    {int tlv5; tlv5 = (int)(i); }
    {void * tlv4; tlv4 = (void *)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
}
void fix_ingred_main_0_1_3(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(len); }
    {char * c; c = (char *)(len); }
    {cgc_size_t rx; rx = (cgc_size_t)(len); }
    {int tlv1; tlv1 = (int)(len); }
    {int tlv5; tlv5 = (int)(len); }
    {void * tlv4; tlv4 = (void *)(len); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(len); }
}
void fix_ingred_main_0_1(){
fix_ingred_main_0_1_1();
fix_ingred_main_0_1_2();
fix_ingred_main_0_1_3();
}
void fix_ingred_main_0_2_0(){
int fd;
    bzero(&fd,sizeof(int));
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {cgc_size_t i; i = (cgc_size_t)(fd); }
    {char * c; c = (char *)(fd); }
    {cgc_size_t rx; rx = (cgc_size_t)(fd); }
    {int tlv1; tlv1 = (int)(fd); }
    {int tlv5; tlv5 = (int)(fd); }
    {void * tlv4; tlv4 = (void *)(fd); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(fd); }
}
void fix_ingred_main_0_2_1(){
int fd;
    bzero(&fd,sizeof(int));
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {cgc_size_t i; i = (cgc_size_t)(c); }
    {cgc_size_t rx; rx = (cgc_size_t)(c); }
    {int tlv1; tlv1 = (int)(c); }
    {int tlv5; tlv5 = (int)(c); }
    {void * tlv4; tlv4 = (void *)(c); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(c); }
}
void fix_ingred_main_0_2_2(){
int fd;
    bzero(&fd,sizeof(int));
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {cgc_size_t i; i = (cgc_size_t)(1); }
    {char * c; c = (char *)(1); }
    {cgc_size_t rx; rx = (cgc_size_t)(1); }
    {int tlv1; tlv1 = (int)(1); }
    {int tlv5; tlv5 = (int)(1); }
    {void * tlv4; tlv4 = (void *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
}
void fix_ingred_main_0_2(){
fix_ingred_main_0_2_0();
fix_ingred_main_0_2_1();
fix_ingred_main_0_2_2();
}
void fix_ingred_main_0_3_4(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(tlv1); }
    {char * c; c = (char *)(tlv1); }
    {cgc_size_t rx; rx = (cgc_size_t)(tlv1); }
    {int tlv5; tlv5 = (int)(tlv1); }
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv1); }
}
void fix_ingred_main_0_3_5(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {char * c; c = (char *)(0); }
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
}
void fix_ingred_main_0_3_6(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t i; i = (cgc_size_t)(rx); }
    {char * c; c = (char *)(rx); }
    {int tlv1; tlv1 = (int)(rx); }
    {int tlv5; tlv5 = (int)(rx); }
    {void * tlv4; tlv4 = (void *)(rx); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(rx); }
}
void fix_ingred_main_0_3(){
fix_ingred_main_0_3_4();
fix_ingred_main_0_3_5();
fix_ingred_main_0_3_6();
}
void fix_ingred_main_0_4_4(){
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
char delim;
    bzero(&delim,sizeof(char));
    {cgc_size_t i; i = (cgc_size_t)(* ( c ++ )); }
    {cgc_size_t rx; rx = (cgc_size_t)(* ( c ++ )); }
    {int tlv1; tlv1 = (int)(* ( c ++ )); }
    {int tlv5; tlv5 = (int)(* ( c ++ )); }
    {void * tlv4; tlv4 = (void *)(* ( c ++ )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(* ( c ++ )); }
}
void fix_ingred_main_0_4_5(){
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
char delim;
    bzero(&delim,sizeof(char));
    {cgc_size_t i; i = (cgc_size_t)(delim); }
    {char * c; c = (char *)(delim); }
    {cgc_size_t rx; rx = (cgc_size_t)(delim); }
    {int tlv1; tlv1 = (int)(delim); }
    {int tlv5; tlv5 = (int)(delim); }
    {void * tlv4; tlv4 = (void *)(delim); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(delim); }
}
void fix_ingred_main_0_4(){
fix_ingred_main_0_4_4();
fix_ingred_main_0_4_5();
}
void fix_ingred_main_0(){
fix_ingred_main_0_0();
fix_ingred_main_0_1();
fix_ingred_main_0_2();
fix_ingred_main_0_3();
fix_ingred_main_0_4();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_main_0_0_0();
void fix_ingred_main_0_0();
void fix_ingred_main_0_1_1();
void fix_ingred_main_0_1_2();
void fix_ingred_main_0_1_3();
void fix_ingred_main_0_1();
void fix_ingred_main_0_2_0();
void fix_ingred_main_0_2_1();
void fix_ingred_main_0_2_2();
void fix_ingred_main_0_2();
void fix_ingred_main_0_3_4();
void fix_ingred_main_0_3_5();
void fix_ingred_main_0_3_6();
void fix_ingred_main_0_3();
void fix_ingred_main_0_4_4();
void fix_ingred_main_0_4_5();
void fix_ingred_main_0_4();
void fix_ingred_main_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_import_kty] : <class 'CParser.CParser.DeclarationContext'> : cgc_free_kty_item ( my_kty ) ;
def_vars[1]: [cgc_import_kty] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[2]: [cgc_import_kty] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "Error!\n" ;
sym_lut=>'{'buf': 'char *'}'
val_s=>'[('UNDEF', 'parser -> cats', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7709588>), ('UNDEF', 'my_kty', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d773e0b8>)]'
cval_s=>'[]'
Checking 'cgc_free_kty_item( my_kty )' - is_func=True, is_func_ptr=False
cgc_free_kty_item( my_kty ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *'}'
val_s=>'[('UNDEF', 'my_kty', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d772ea58>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7637898>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7637c18>)]'
Checking 'cgc_free_kty_item( my_kty )' - is_func=True, is_func_ptr=False
cgc_free_kty_item( my_kty ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *'}'
val_s=>'[('UNDEF', 'parser -> cats', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7709588>), ('UNDEF', 'my_kty', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d773e0b8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d773ef28>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d77302e8>)]'
Checking 'cgc_free_kty_item( my_kty )' - is_func=True, is_func_ptr=False
cgc_free_kty_item( my_kty ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7733128>), ('UNDEF', 'parser -> cats', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7709588>), ('UNDEF', 'my_kty', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d773e0b8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d773ef28>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d77302e8>)]'
Checking 'cgc_free_kty_item( my_kty )' - is_func=True, is_func_ptr=False
cgc_free_kty_item( my_kty ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/7][j=3/4][dd=0/3][k=0/5] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
----
==== Scope 1 ====
void fix_ingred_main_1_3_0(){
    {int tlv2; tlv2 = (int)(STDOUT); }
}
void fix_ingred_main_1_3(){
fix_ingred_main_1_3_0();
}

==== Scope 2 ====
void fix_ingred_main_1_3_0(){
    {int tlv2; tlv2 = (int)(STDOUT); }
}
void fix_ingred_main_1_3(){
fix_ingred_main_1_3_0();
}
void fix_ingred_main_1(){
fix_ingred_main_1_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_1_3_0();
void fix_ingred_main_1_3();
void fix_ingred_main_1();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_print_kty] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[1]: [cgc_print_kty] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "Error!\n" ;
sym_lut=>'{}'
val_s=>'[('UNDEF', 'parser -> cats', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d77383c8>)]'
cval_s=>'[]'
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7737ba8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7737f28>)]'
sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d771cd68>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7737ba8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d7737f28>)]'
==== Scope 2 ====
void fix_ingred_main_2(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_2();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[1]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : char * c ;
def_vars[2]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : char buf [ 1024 ] = { 0 } ;
def_vars[3]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : char nyan_cat [ ] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n" ;
def_vars[4]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : kty_item_t * item ;
def_vars[5]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[6]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "Error!\n" ;
def_vars[7]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : array_t * tlv6 ;
def_vars[8]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[9]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : char * tlv4 ;
def_vars[10]: [cgc_nyan] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv3 = item -> item . i_string . s ;
sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char'}'
val_s=>'[('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7712dd8>)]'
cval_s=>'[]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=3/7][j=0/7][dd=0/11][k=0/1] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
unique : ('char', 'buf [ 1024 ]', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=3/7][j=0/7][dd=2/11][k=0/1] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=3/7][j=0/7][dd=3/11][k=0/1] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=3/7][j=0/7][dd=5/11][k=0/1] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=3/7][j=0/7][dd=9/11][k=0/1] | type: char * ; var : c ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
----
UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

==== Scope 1 ====
void fix_ingred_main_3_0_0(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int i; i = (int)(buf); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(buf); }
    {char* nyan_cat ; nyan_cat  = (char*)(buf); }
    {int tlv2; tlv2 = (int)(buf); }
    {char * tlv4; tlv4 = (char *)(buf); }
}
void fix_ingred_main_3_0(){
fix_ingred_main_3_0_0();
}

sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char'}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d770a7b8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d770ab38>)]'
sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char', 'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7719978>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d770a7b8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d770ab38>)]'
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=3/7][j=2/7][dd=0/11][k=0/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=3/7][j=2/7][dd=1/11][k=0/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=3/7][j=2/7][dd=2/11][k=0/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=3/7][j=2/7][dd=3/11][k=0/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=3/7][j=2/7][dd=8/11][k=0/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=3/7][j=2/7][dd=9/11][k=0/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
----
==== Scope 1 ====
void fix_ingred_main_3_2_0(){
    {int i; i = (int)(STDOUT); }
    {char * c; c = (char *)(STDOUT); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(STDOUT); }
    {char* nyan_cat ; nyan_cat  = (char*)(STDOUT); }
    {int tlv5; tlv5 = (int)(STDOUT); }
    {char * tlv4; tlv4 = (char *)(STDOUT); }
}
void fix_ingred_main_3_2(){
fix_ingred_main_3_2_0();
}

sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char'}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d7740c88>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d7740f98>)]'
sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char', 'item': 'kty_item_t *'}'
val_s=>'[('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d735b048>), ('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7712dd8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d772f978>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d770f518>)]'
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=0/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/7][j=4/7][dd=0/11][k=2/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=0/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=1/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=1/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=2/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/7][j=4/7][dd=2/11][k=2/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=2/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=3/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/7][j=4/7][dd=3/11][k=2/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=3/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=5/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/7][j=4/7][dd=5/11][k=2/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=5/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=8/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=8/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'item->item.i_string.len' - True OR  False
[i=3/7][j=4/7][dd=9/11][k=0/4] | type: char * ; var : c ; varinfo :  ; value_node : item -> item . i_string . len (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/7][j=4/7][dd=9/11][k=2/4] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=3/7][j=4/7][dd=9/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
----
UNIQ_INIT: ('int','i','None','None');

not valid - int i; i = ((int)i);

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_main_3_4_2(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(0); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(0); }
    {char* nyan_cat ; nyan_cat  = (char*)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {char * tlv4; tlv4 = (char *)(0); }
}
void fix_ingred_main_3_4_3(){
int i;
    bzero(&i,sizeof(int));
    {char * c; c = (char *)(i); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(i); }
    {char* nyan_cat ; nyan_cat  = (char*)(i); }
    {int tlv2; tlv2 = (int)(i); }
    {int tlv5; tlv5 = (int)(i); }
    {char * tlv4; tlv4 = (char *)(i); }
}
void fix_ingred_main_3_4(){
fix_ingred_main_3_4_2();
fix_ingred_main_3_4_3();
}

sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char', 'item': 'kty_item_t *', 'tlv6': 'array_t *', 'tlv5': 'int'}'
val_s=>'[('array_t *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d737bba8>), ('int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d735ea58>), ('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7712dd8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d772f978>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d770f518>)]'
sym_lut=>'{'i': 'int', 'c': 'char *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'nyan_cat': 'char *', 'nyan_cat [ ]': 'char', 'item': 'kty_item_t *', 'tlv6': 'array_t *', 'tlv5': 'int', 'tlv4': 'char *', 'tlv3': 'const char *'}'
val_s=>'[('char *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7372ac8>), ('char *', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7712dd8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d772f978>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d770f518>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=0/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
unique : ('char *', 'c', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=1/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=2/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=3/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=5/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=8/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=3/7][j=6/7][dd=9/11][k=0/4] | type: char * ; var : tlv4 ; varinfo :  ; value_node : c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char *]
not unique: ('char *', 'c', None) ... continue!
not valid - char * c; c = ((char *)c);

----
UNIQ_INIT: ('char *','c','None','None');

==== Scope 1 ====
void fix_ingred_main_3_6_0(){
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {int i; i = (int)(c); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(c); }
    {char* nyan_cat ; nyan_cat  = (char*)(c); }
    {int tlv2; tlv2 = (int)(c); }
    {int tlv5; tlv5 = (int)(c); }
    {char * tlv4; tlv4 = (char *)(c); }
}
void fix_ingred_main_3_6(){
fix_ingred_main_3_6_0();
}

==== Scope 2 ====
void fix_ingred_main_3_0_0(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int i; i = (int)(buf); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(buf); }
    {char* nyan_cat ; nyan_cat  = (char*)(buf); }
    {int tlv2; tlv2 = (int)(buf); }
    {char * tlv4; tlv4 = (char *)(buf); }
}
void fix_ingred_main_3_0(){
fix_ingred_main_3_0_0();
}
void fix_ingred_main_3_2_0(){
    {int i; i = (int)(STDOUT); }
    {char * c; c = (char *)(STDOUT); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(STDOUT); }
    {char* nyan_cat ; nyan_cat  = (char*)(STDOUT); }
    {int tlv5; tlv5 = (int)(STDOUT); }
    {char * tlv4; tlv4 = (char *)(STDOUT); }
}
void fix_ingred_main_3_2(){
fix_ingred_main_3_2_0();
}
void fix_ingred_main_3_4_2(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(0); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(0); }
    {char* nyan_cat ; nyan_cat  = (char*)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {char * tlv4; tlv4 = (char *)(0); }
}
void fix_ingred_main_3_4_3(){
int i;
    bzero(&i,sizeof(int));
    {char * c; c = (char *)(i); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(i); }
    {char* nyan_cat ; nyan_cat  = (char*)(i); }
    {int tlv2; tlv2 = (int)(i); }
    {int tlv5; tlv5 = (int)(i); }
    {char * tlv4; tlv4 = (char *)(i); }
}
void fix_ingred_main_3_4(){
fix_ingred_main_3_4_2();
fix_ingred_main_3_4_3();
}
void fix_ingred_main_3_6_0(){
char c_ref;
    bzero(&c_ref,1*sizeof(char));
char * c = &c_ref;
    {int i; i = (int)(c); }
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(c); }
    {char* nyan_cat ; nyan_cat  = (char*)(c); }
    {int tlv2; tlv2 = (int)(c); }
    {int tlv5; tlv5 = (int)(c); }
    {char * tlv4; tlv4 = (char *)(c); }
}
void fix_ingred_main_3_6(){
fix_ingred_main_3_6_0();
}
void fix_ingred_main_3(){
fix_ingred_main_3_0();
fix_ingred_main_3_2();
fix_ingred_main_3_4();
fix_ingred_main_3_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_3_0_0();
void fix_ingred_main_3_0();
void fix_ingred_main_3_2_0();
void fix_ingred_main_3_2();
void fix_ingred_main_3_4_2();
void fix_ingred_main_3_4_3();
void fix_ingred_main_3_4();
void fix_ingred_main_3_6_0();
void fix_ingred_main_3_6();
void fix_ingred_main_3();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_quit] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[1]: [cgc_quit] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n" ;
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d737a978>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_main_4(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_4();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[1]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "=======================\n" ;
def_vars[2]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[3]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : const char tlv3 [ ] = " 1. Import KTY\n" ;
def_vars[4]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : int tlv6 ;
def_vars[5]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : const char tlv5 [ ] = " 2. Print KTY\n" ;
def_vars[6]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : int tlv8 ;
def_vars[7]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : const char tlv7 [ ] = " 3. Quit\n" ;
def_vars[8]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : int tlv10 ;
def_vars[9]: [cgc_menu] : <class 'CParser.CParser.DeclarationContext'> : const char tlv9 [ ] = "=======================\n" ;
sym_lut=>'{}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7368908>)]'
cval_s=>'[]'
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=5/7][j=1/6][dd=2/10][k=0/1] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=5/7][j=1/6][dd=4/10][k=0/1] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=5/7][j=1/6][dd=6/10][k=0/1] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=5/7][j=1/6][dd=8/10][k=0/1] | type: int ; var : tlv2 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
----
==== Scope 1 ====
void fix_ingred_main_5_1_0(){
    {int tlv4; tlv4 = (int)(STDOUT); }
    {int tlv6; tlv6 = (int)(STDOUT); }
    {int tlv8; tlv8 = (int)(STDOUT); }
    {int tlv10; tlv10 = (int)(STDOUT); }
}
void fix_ingred_main_5_1(){
fix_ingred_main_5_1_0();
}

sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d736f358>)]'
cval_s=>'[]'
sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'int', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char'}'
val_s=>'[('int', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7370d68>)]'
cval_s=>'[]'
sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'int', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv8': 'int', 'tlv7': 'const char *', 'tlv7 [ ]': 'const char'}'
val_s=>'[('int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d72f07b8>)]'
cval_s=>'[]'
sym_lut=>'{'tlv2': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'int', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv8': 'int', 'tlv7': 'const char *', 'tlv7 [ ]': 'const char', 'tlv10': 'int', 'tlv9': 'const char *', 'tlv9 [ ]': 'const char'}'
val_s=>'[('int', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7303208>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_main_5_1_0(){
    {int tlv4; tlv4 = (int)(STDOUT); }
    {int tlv6; tlv6 = (int)(STDOUT); }
    {int tlv8; tlv8 = (int)(STDOUT); }
    {int tlv10; tlv10 = (int)(STDOUT); }
}
void fix_ingred_main_5_1(){
fix_ingred_main_5_1_0();
}
void fix_ingred_main_5(){
fix_ingred_main_5_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_5_1_0();
void fix_ingred_main_5_1();
void fix_ingred_main_5();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [main] : <class 'CParser.CParser.DeclarationContext'> : char buf [ MAX_KTY_LENGTH ] ;
def_vars[1]: [main] : <class 'CParser.CParser.DeclarationContext'> : char cgc_select [ 16 ] ;
def_vars[2]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[3]: [main] : <class 'CParser.CParser.DeclarationContext'> : unsigned long tlv_size_0 ;
def_vars[4]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[5]: [main] : <class 'CParser.CParser.DeclarationContext'> : const char tlv3 [ ] = "KTY Pretty Printer v0.1\n" ;
def_vars[6]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv6 ;
def_vars[7]: [main] : <class 'CParser.CParser.DeclarationContext'> : kty_parser_t * tlv5 ;
def_vars[8]: [main] : <class 'CParser.CParser.DeclarationContext'> : int menu ;
def_vars[9]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv8 ;
def_vars[10]: [main] : <class 'CParser.CParser.DeclarationContext'> : const char tlv7 [ ] = "Error!\n" ;
def_vars[11]: [main] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv11 = cgc_select ;
def_vars[12]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv10 ;
def_vars[13]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv9 ;
def_vars[14]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[15]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv17 ;
def_vars[16]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv16 ;
def_vars[17]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv15 ;
def_vars[18]: [main] : <class 'CParser.CParser.DeclarationContext'> : char tlv14 ;
def_vars[19]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv13 ;
def_vars[20]: [main] : <class 'CParser.CParser.DeclarationContext'> : const char tlv12 [ ] = "Invalid menu. Try again.\n" ;
def_vars[21]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_import_kty ( buf ) ;
def_vars[22]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv19 ;
def_vars[23]: [main] : <class 'CParser.CParser.DeclarationContext'> : const char tlv18 [ ] = "Error!\n" ;
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=0/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
unique : ('char', 'cgc_select [ 16 ]', None)
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=1/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=2/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=3/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=4/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=6/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=8/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=9/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=13/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=14/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=15/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=16/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=17/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=18/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=19/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(cgc_select)' - False OR  False
[i=6/7][j=0/19][dd=21/24][k=0/1] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( cgc_select ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,cgc_select,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) cgc_select [vtype=char *]
BEFORE => literal (False) cgc_select => char *
AFTER => literal (False) cgc_select [ 16 ] => char [size=16]
not unique: ('char', 'cgc_select [ 16 ]', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','cgc_select [ 16 ]','None','None');

==== Scope 1 ====
void fix_ingred_main_6_0_0(){
char cgc_select [ 16 ];
    bzero(&cgc_select,( 16 *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(sizeof ( cgc_select )); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(sizeof ( cgc_select )); }
    {int tlv1; tlv1 = (int)(sizeof ( cgc_select )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( cgc_select )); }
    {int tlv4; tlv4 = (int)(sizeof ( cgc_select )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(sizeof ( cgc_select )); }
    {int menu; menu = (int)(sizeof ( cgc_select )); }
    {int tlv8; tlv8 = (int)(sizeof ( cgc_select )); }
    {int tlv9; tlv9 = (int)(sizeof ( cgc_select )); }
    {int tlv2; tlv2 = (int)(sizeof ( cgc_select )); }
    {int tlv17; tlv17 = (int)(sizeof ( cgc_select )); }
    {char * tlv16; tlv16 = (char *)(sizeof ( cgc_select )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( cgc_select )); }
    {char tlv14; tlv14 = (char)(sizeof ( cgc_select )); }
    {int tlv13; tlv13 = (int)(sizeof ( cgc_select )); }
    {int tlv19; tlv19 = (int)(sizeof ( cgc_select )); }
}
void fix_ingred_main_6_0(){
fix_ingred_main_6_0_0();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d72cef28>)]'
cval_s=>'[]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=0/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=1/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=2/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=3/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=6/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=8/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=13/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=15/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=16/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=17/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=18/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=19/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=6/7][j=1/19][dd=21/24][k=0/1] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
----
==== Scope 1 ====
void fix_ingred_main_6_1_0(){
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(STDOUT); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(STDOUT); }
    {int tlv1; tlv1 = (int)(STDOUT); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(STDOUT); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(STDOUT); }
    {int menu; menu = (int)(STDOUT); }
    {int tlv9; tlv9 = (int)(STDOUT); }
    {int tlv17; tlv17 = (int)(STDOUT); }
    {char * tlv16; tlv16 = (char *)(STDOUT); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(STDOUT); }
    {char tlv14; tlv14 = (char)(STDOUT); }
    {int tlv13; tlv13 = (int)(STDOUT); }
    {int tlv19; tlv19 = (int)(STDOUT); }
}
void fix_ingred_main_6_1(){
fix_ingred_main_6_1_0();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d72e09e8>)]'
cval_s=>'[]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=0/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=1/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=2/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=3/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=4/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=6/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=8/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=9/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=13/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=14/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=15/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=16/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=17/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=18/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=19/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(kty_parser_t)' - False OR  False
[i=6/7][j=2/19][dd=21/24][k=0/1] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : sizeof ( kty_parser_t ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,kty_parser_t,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) kty_parser_t [vtype=None]
 => is literal (False) | is operator (True) )
----
==== Scope 1 ====
void fix_ingred_main_6_2_0(){
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(sizeof ( kty_parser_t )); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(sizeof ( kty_parser_t )); }
    {int tlv1; tlv1 = (int)(sizeof ( kty_parser_t )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( kty_parser_t )); }
    {int tlv4; tlv4 = (int)(sizeof ( kty_parser_t )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(sizeof ( kty_parser_t )); }
    {int menu; menu = (int)(sizeof ( kty_parser_t )); }
    {int tlv8; tlv8 = (int)(sizeof ( kty_parser_t )); }
    {int tlv9; tlv9 = (int)(sizeof ( kty_parser_t )); }
    {int tlv2; tlv2 = (int)(sizeof ( kty_parser_t )); }
    {int tlv17; tlv17 = (int)(sizeof ( kty_parser_t )); }
    {char * tlv16; tlv16 = (char *)(sizeof ( kty_parser_t )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( kty_parser_t )); }
    {char tlv14; tlv14 = (char)(sizeof ( kty_parser_t )); }
    {int tlv13; tlv13 = (int)(sizeof ( kty_parser_t )); }
    {int tlv19; tlv19 = (int)(sizeof ( kty_parser_t )); }
}
void fix_ingred_main_6_2(){
fix_ingred_main_6_2_0();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *'}'
val_s=>'[('kty_parser_t *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d72e1748>)]'
cval_s=>'[]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *'}'
val_s=>'[]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d72dd128>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d72dd4a8>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=0/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=0/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=1/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=1/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=3/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=3/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=4/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=4/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=6/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=6/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=8/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=8/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=9/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=9/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=13/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=13/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=14/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=15/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=15/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=16/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=16/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=17/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=17/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=18/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=18/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=19/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=19/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=6/7][j=4/19][dd=21/24][k=0/2] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/7][j=4/19][dd=21/24][k=1/2] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
UNIQ_INIT: ('int','tlv1','None','None');

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_main_6_4_0(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(tlv1); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(tlv1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {int menu; menu = (int)(tlv1); }
    {int tlv8; tlv8 = (int)(tlv1); }
    {int tlv9; tlv9 = (int)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {int tlv17; tlv17 = (int)(tlv1); }
    {char * tlv16; tlv16 = (char *)(tlv1); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv1); }
    {char tlv14; tlv14 = (char)(tlv1); }
    {int tlv13; tlv13 = (int)(tlv1); }
    {int tlv19; tlv19 = (int)(tlv1); }
}
void fix_ingred_main_6_4_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(0); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int menu; menu = (int)(0); }
    {int tlv8; tlv8 = (int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {int tlv17; tlv17 = (int)(0); }
    {char * tlv16; tlv16 = (char *)(0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(0); }
    {char tlv14; tlv14 = (char)(0); }
    {int tlv13; tlv13 = (int)(0); }
    {int tlv19; tlv19 = (int)(0); }
}
void fix_ingred_main_6_4(){
fix_ingred_main_6_4_0();
fix_ingred_main_6_4_1();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv8': 'int', 'tlv7': 'const char *', 'tlv7 [ ]': 'const char'}'
val_s=>'[('int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d72f42e8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d72dd128>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x1543d72dd4a8>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int'}'
val_s=>'[('char * *', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d74ef828>), ('int', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d75996d8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=0/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=1/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=2/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=3/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=4/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=6/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=8/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=9/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=13/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=14/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=15/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=16/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=17/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=18/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=19/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/7][j=7/19][dd=21/24][k=1/4] | type: int ; var : tlv9 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
----
==== Scope 1 ====
void fix_ingred_main_6_7_1(){
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(10); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(10); }
    {int tlv1; tlv1 = (int)(10); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(10); }
    {int tlv4; tlv4 = (int)(10); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(10); }
    {int menu; menu = (int)(10); }
    {int tlv8; tlv8 = (int)(10); }
    {int tlv9; tlv9 = (int)(10); }
    {int tlv2; tlv2 = (int)(10); }
    {int tlv17; tlv17 = (int)(10); }
    {char * tlv16; tlv16 = (char *)(10); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(10); }
    {char tlv14; tlv14 = (char)(10); }
    {int tlv13; tlv13 = (int)(10); }
    {int tlv19; tlv19 = (int)(10); }
}
void fix_ingred_main_6_7(){
fix_ingred_main_6_7_1();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int', 'tlv17': 'int', 'tlv16': 'char *', 'tlv15': 'cgc_size_t', 'tlv14': 'char'}'
val_s=>'[('int', 'tlv17', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d78fb748>), ('char *', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d764a518>), ('cgc_size_t', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7597e48>), ('char', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d75c0278>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=0/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=0/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
unique : ('char', 'buf [ MAX_KTY_LENGTH ]', None)
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=0/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=0/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=1/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=1/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=1/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=1/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=2/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=2/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=2/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=3/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=3/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=3/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=3/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=4/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=4/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=4/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=4/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=6/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=6/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=6/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=6/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=8/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=8/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=8/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=8/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=9/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=9/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=9/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=9/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=13/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=13/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=13/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=13/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=14/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=14/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=14/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=15/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=15/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=15/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=15/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=16/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=16/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=16/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=16/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=17/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=17/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=17/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=17/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=18/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=18/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=18/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=18/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=19/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=19/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=19/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=19/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=6/7][j=10/19][dd=21/24][k=0/6] | type: int ; var : tlv17 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/7][j=10/19][dd=21/24][k=1/6] | type: char * ; var : tlv16 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ MAX_KTY_LENGTH ] => char [size=MAX_KTY_LENGTH]
Array size is variable => 'MAX_KTY_LENGTH'
not unique: ('char', 'buf [ MAX_KTY_LENGTH ]', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_KTY_LENGTH' - False OR  False
[i=6/7][j=10/19][dd=21/24][k=2/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : MAX_KTY_LENGTH (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_KTY_LENGTH
 => is literal (False) | is operator (False) MAX_KTY_LENGTH [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\x00'' - False OR  False
[i=6/7][j=10/19][dd=21/24][k=3/6] | type: char ; var : tlv14 ; varinfo :  ; value_node : '\x00' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\x00'
 => is literal (False) | is operator (False) '\x00' [vtype=None]
----
UNIQ_INIT: ('char','buf [ MAX_KTY_LENGTH ]','None','None');

----
UNIQ_INIT: ('char','buf [ MAX_KTY_LENGTH ]','None','None');

----
UNIQ_INIT: ('char','buf [ MAX_KTY_LENGTH ]','None','None');

----
UNIQ_INIT: ('char','buf [ MAX_KTY_LENGTH ]','None','None');

==== Scope 1 ====
void fix_ingred_main_6_10_0(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(STDIN); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(STDIN); }
    {int tlv1; tlv1 = (int)(STDIN); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(STDIN); }
    {int tlv4; tlv4 = (int)(STDIN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(STDIN); }
    {int menu; menu = (int)(STDIN); }
    {int tlv8; tlv8 = (int)(STDIN); }
    {int tlv9; tlv9 = (int)(STDIN); }
    {int tlv2; tlv2 = (int)(STDIN); }
    {int tlv17; tlv17 = (int)(STDIN); }
    {char * tlv16; tlv16 = (char *)(STDIN); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(STDIN); }
    {char tlv14; tlv14 = (char)(STDIN); }
    {int tlv13; tlv13 = (int)(STDIN); }
    {int tlv19; tlv19 = (int)(STDIN); }
}
void fix_ingred_main_6_10_1(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(buf); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(buf); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(buf); }
    {int menu; menu = (int)(buf); }
    {int tlv8; tlv8 = (int)(buf); }
    {int tlv9; tlv9 = (int)(buf); }
    {int tlv17; tlv17 = (int)(buf); }
    {char * tlv16; tlv16 = (char *)(buf); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(buf); }
    {char tlv14; tlv14 = (char)(buf); }
    {int tlv13; tlv13 = (int)(buf); }
    {int tlv19; tlv19 = (int)(buf); }
}
void fix_ingred_main_6_10_2(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(MAX_KTY_LENGTH); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(MAX_KTY_LENGTH); }
    {int tlv1; tlv1 = (int)(MAX_KTY_LENGTH); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(MAX_KTY_LENGTH); }
    {int tlv4; tlv4 = (int)(MAX_KTY_LENGTH); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(MAX_KTY_LENGTH); }
    {int menu; menu = (int)(MAX_KTY_LENGTH); }
    {int tlv8; tlv8 = (int)(MAX_KTY_LENGTH); }
    {int tlv9; tlv9 = (int)(MAX_KTY_LENGTH); }
    {int tlv2; tlv2 = (int)(MAX_KTY_LENGTH); }
    {int tlv17; tlv17 = (int)(MAX_KTY_LENGTH); }
    {char * tlv16; tlv16 = (char *)(MAX_KTY_LENGTH); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(MAX_KTY_LENGTH); }
    {char tlv14; tlv14 = (char)(MAX_KTY_LENGTH); }
    {int tlv13; tlv13 = (int)(MAX_KTY_LENGTH); }
    {int tlv19; tlv19 = (int)(MAX_KTY_LENGTH); }
}
void fix_ingred_main_6_10_3(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)('\x00'); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)('\x00'); }
    {int tlv1; tlv1 = (int)('\x00'); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)('\x00'); }
    {int tlv4; tlv4 = (int)('\x00'); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)('\x00'); }
    {int menu; menu = (int)('\x00'); }
    {int tlv8; tlv8 = (int)('\x00'); }
    {int tlv9; tlv9 = (int)('\x00'); }
    {int tlv2; tlv2 = (int)('\x00'); }
    {int tlv17; tlv17 = (int)('\x00'); }
    {char * tlv16; tlv16 = (char *)('\x00'); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)('\x00'); }
    {char tlv14; tlv14 = (char)('\x00'); }
    {int tlv13; tlv13 = (int)('\x00'); }
    {int tlv19; tlv19 = (int)('\x00'); }
}
void fix_ingred_main_6_10(){
fix_ingred_main_6_10_0();
fix_ingred_main_6_10_1();
fix_ingred_main_6_10_2();
fix_ingred_main_6_10_3();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int', 'tlv17': 'int', 'tlv16': 'char *', 'tlv15': 'cgc_size_t', 'tlv14': 'char'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d76a8ba8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d76a8518>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=0/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
unique : ('int', 'tlv2', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=1/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=2/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=3/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=4/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=6/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=8/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=9/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=13/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=14/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=15/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=16/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=17/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=18/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=19/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=6/7][j=11/19][dd=21/24][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
not valid - int tlv2; tlv2 = ((int)tlv2);

----
UNIQ_INIT: ('int','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_main_6_11_2(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(tlv2); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv2); }
    {int menu; menu = (int)(tlv2); }
    {int tlv8; tlv8 = (int)(tlv2); }
    {int tlv9; tlv9 = (int)(tlv2); }
    {int tlv17; tlv17 = (int)(tlv2); }
    {char * tlv16; tlv16 = (char *)(tlv2); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv2); }
    {char tlv14; tlv14 = (char)(tlv2); }
    {int tlv13; tlv13 = (int)(tlv2); }
    {int tlv19; tlv19 = (int)(tlv2); }
}
void fix_ingred_main_6_11(){
fix_ingred_main_6_11_2();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int', 'tlv17': 'int', 'tlv16': 'char *', 'tlv15': 'cgc_size_t', 'tlv14': 'char'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int', 'tlv17': 'int', 'tlv16': 'char *', 'tlv15': 'cgc_size_t', 'tlv14': 'char', 'tlv19': 'int', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char'}'
val_s=>'[('int', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d76d7978>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int'}'
val_s=>'[('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ MAX_KTY_LENGTH ]': 'char', 'cgc_select': 'char *', 'cgc_select [ 16 ]': 'char', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv6': 'cgc_size_t', 'tlv1': 'int', 'tlv5': 'kty_parser_t *', 'tlv_size_0': 'unsigned long', 'menu': 'int', 'tlv11': 'const char *', 'tlv10': 'char * *', 'tlv9': 'int', 'tlv2': 'int', 'tlv13': 'int', 'tlv12': 'const char *', 'tlv12 [ ]': 'const char'}'
val_s=>'[('int', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d766a908>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x1543d7b026d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x1543d74a5f98>)]'
Checking 'cgc_import_kty( buf )' - is_func=True, is_func_ptr=False
cgc_import_kty( buf ) is a function.
Skipping.
Skipping MAX_KTY_LENGTH => #define
==== Scope 2 ====
void fix_ingred_main_6_0_0(){
char cgc_select [ 16 ];
    bzero(&cgc_select,( 16 *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(sizeof ( cgc_select )); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(sizeof ( cgc_select )); }
    {int tlv1; tlv1 = (int)(sizeof ( cgc_select )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( cgc_select )); }
    {int tlv4; tlv4 = (int)(sizeof ( cgc_select )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(sizeof ( cgc_select )); }
    {int menu; menu = (int)(sizeof ( cgc_select )); }
    {int tlv8; tlv8 = (int)(sizeof ( cgc_select )); }
    {int tlv9; tlv9 = (int)(sizeof ( cgc_select )); }
    {int tlv2; tlv2 = (int)(sizeof ( cgc_select )); }
    {int tlv17; tlv17 = (int)(sizeof ( cgc_select )); }
    {char * tlv16; tlv16 = (char *)(sizeof ( cgc_select )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( cgc_select )); }
    {char tlv14; tlv14 = (char)(sizeof ( cgc_select )); }
    {int tlv13; tlv13 = (int)(sizeof ( cgc_select )); }
    {int tlv19; tlv19 = (int)(sizeof ( cgc_select )); }
}
void fix_ingred_main_6_0(){
fix_ingred_main_6_0_0();
}
void fix_ingred_main_6_1_0(){
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(STDOUT); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(STDOUT); }
    {int tlv1; tlv1 = (int)(STDOUT); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(STDOUT); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(STDOUT); }
    {int menu; menu = (int)(STDOUT); }
    {int tlv9; tlv9 = (int)(STDOUT); }
    {int tlv17; tlv17 = (int)(STDOUT); }
    {char * tlv16; tlv16 = (char *)(STDOUT); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(STDOUT); }
    {char tlv14; tlv14 = (char)(STDOUT); }
    {int tlv13; tlv13 = (int)(STDOUT); }
    {int tlv19; tlv19 = (int)(STDOUT); }
}
void fix_ingred_main_6_1(){
fix_ingred_main_6_1_0();
}
void fix_ingred_main_6_2_0(){
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(sizeof ( kty_parser_t )); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(sizeof ( kty_parser_t )); }
    {int tlv1; tlv1 = (int)(sizeof ( kty_parser_t )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( kty_parser_t )); }
    {int tlv4; tlv4 = (int)(sizeof ( kty_parser_t )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(sizeof ( kty_parser_t )); }
    {int menu; menu = (int)(sizeof ( kty_parser_t )); }
    {int tlv8; tlv8 = (int)(sizeof ( kty_parser_t )); }
    {int tlv9; tlv9 = (int)(sizeof ( kty_parser_t )); }
    {int tlv2; tlv2 = (int)(sizeof ( kty_parser_t )); }
    {int tlv17; tlv17 = (int)(sizeof ( kty_parser_t )); }
    {char * tlv16; tlv16 = (char *)(sizeof ( kty_parser_t )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( kty_parser_t )); }
    {char tlv14; tlv14 = (char)(sizeof ( kty_parser_t )); }
    {int tlv13; tlv13 = (int)(sizeof ( kty_parser_t )); }
    {int tlv19; tlv19 = (int)(sizeof ( kty_parser_t )); }
}
void fix_ingred_main_6_2(){
fix_ingred_main_6_2_0();
}
void fix_ingred_main_6_4_0(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(tlv1); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(tlv1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {int menu; menu = (int)(tlv1); }
    {int tlv8; tlv8 = (int)(tlv1); }
    {int tlv9; tlv9 = (int)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {int tlv17; tlv17 = (int)(tlv1); }
    {char * tlv16; tlv16 = (char *)(tlv1); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv1); }
    {char tlv14; tlv14 = (char)(tlv1); }
    {int tlv13; tlv13 = (int)(tlv1); }
    {int tlv19; tlv19 = (int)(tlv1); }
}
void fix_ingred_main_6_4_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(0); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int menu; menu = (int)(0); }
    {int tlv8; tlv8 = (int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {int tlv17; tlv17 = (int)(0); }
    {char * tlv16; tlv16 = (char *)(0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(0); }
    {char tlv14; tlv14 = (char)(0); }
    {int tlv13; tlv13 = (int)(0); }
    {int tlv19; tlv19 = (int)(0); }
}
void fix_ingred_main_6_4(){
fix_ingred_main_6_4_0();
fix_ingred_main_6_4_1();
}
void fix_ingred_main_6_7_1(){
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(10); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(10); }
    {int tlv1; tlv1 = (int)(10); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(10); }
    {int tlv4; tlv4 = (int)(10); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(10); }
    {int menu; menu = (int)(10); }
    {int tlv8; tlv8 = (int)(10); }
    {int tlv9; tlv9 = (int)(10); }
    {int tlv2; tlv2 = (int)(10); }
    {int tlv17; tlv17 = (int)(10); }
    {char * tlv16; tlv16 = (char *)(10); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(10); }
    {char tlv14; tlv14 = (char)(10); }
    {int tlv13; tlv13 = (int)(10); }
    {int tlv19; tlv19 = (int)(10); }
}
void fix_ingred_main_6_7(){
fix_ingred_main_6_7_1();
}
void fix_ingred_main_6_10_0(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(STDIN); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(STDIN); }
    {int tlv1; tlv1 = (int)(STDIN); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(STDIN); }
    {int tlv4; tlv4 = (int)(STDIN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(STDIN); }
    {int menu; menu = (int)(STDIN); }
    {int tlv8; tlv8 = (int)(STDIN); }
    {int tlv9; tlv9 = (int)(STDIN); }
    {int tlv2; tlv2 = (int)(STDIN); }
    {int tlv17; tlv17 = (int)(STDIN); }
    {char * tlv16; tlv16 = (char *)(STDIN); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(STDIN); }
    {char tlv14; tlv14 = (char)(STDIN); }
    {int tlv13; tlv13 = (int)(STDIN); }
    {int tlv19; tlv19 = (int)(STDIN); }
}
void fix_ingred_main_6_10_1(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(buf); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(buf); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(buf); }
    {int menu; menu = (int)(buf); }
    {int tlv8; tlv8 = (int)(buf); }
    {int tlv9; tlv9 = (int)(buf); }
    {int tlv17; tlv17 = (int)(buf); }
    {char * tlv16; tlv16 = (char *)(buf); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(buf); }
    {char tlv14; tlv14 = (char)(buf); }
    {int tlv13; tlv13 = (int)(buf); }
    {int tlv19; tlv19 = (int)(buf); }
}
void fix_ingred_main_6_10_2(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(MAX_KTY_LENGTH); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(MAX_KTY_LENGTH); }
    {int tlv1; tlv1 = (int)(MAX_KTY_LENGTH); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(MAX_KTY_LENGTH); }
    {int tlv4; tlv4 = (int)(MAX_KTY_LENGTH); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(MAX_KTY_LENGTH); }
    {int menu; menu = (int)(MAX_KTY_LENGTH); }
    {int tlv8; tlv8 = (int)(MAX_KTY_LENGTH); }
    {int tlv9; tlv9 = (int)(MAX_KTY_LENGTH); }
    {int tlv2; tlv2 = (int)(MAX_KTY_LENGTH); }
    {int tlv17; tlv17 = (int)(MAX_KTY_LENGTH); }
    {char * tlv16; tlv16 = (char *)(MAX_KTY_LENGTH); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(MAX_KTY_LENGTH); }
    {char tlv14; tlv14 = (char)(MAX_KTY_LENGTH); }
    {int tlv13; tlv13 = (int)(MAX_KTY_LENGTH); }
    {int tlv19; tlv19 = (int)(MAX_KTY_LENGTH); }
}
void fix_ingred_main_6_10_3(){
char buf [ MAX_KTY_LENGTH ];
    bzero(&buf,( MAX_KTY_LENGTH *sizeof(char) ) );
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)('\x00'); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)('\x00'); }
    {int tlv1; tlv1 = (int)('\x00'); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)('\x00'); }
    {int tlv4; tlv4 = (int)('\x00'); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)('\x00'); }
    {int menu; menu = (int)('\x00'); }
    {int tlv8; tlv8 = (int)('\x00'); }
    {int tlv9; tlv9 = (int)('\x00'); }
    {int tlv2; tlv2 = (int)('\x00'); }
    {int tlv17; tlv17 = (int)('\x00'); }
    {char * tlv16; tlv16 = (char *)('\x00'); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)('\x00'); }
    {char tlv14; tlv14 = (char)('\x00'); }
    {int tlv13; tlv13 = (int)('\x00'); }
    {int tlv19; tlv19 = (int)('\x00'); }
}
void fix_ingred_main_6_10(){
fix_ingred_main_6_10_0();
fix_ingred_main_6_10_1();
fix_ingred_main_6_10_2();
fix_ingred_main_6_10_3();
}
void fix_ingred_main_6_11_2(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char buf [ MAX_KTY_LENGTH ]; buf [ ( MAX_KTY_LENGTH )-1 ] = (char)(tlv2); }
    {char cgc_select [ 16 ]; cgc_select [ ( 16 )-1 ] = (char)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv2); }
    {int menu; menu = (int)(tlv2); }
    {int tlv8; tlv8 = (int)(tlv2); }
    {int tlv9; tlv9 = (int)(tlv2); }
    {int tlv17; tlv17 = (int)(tlv2); }
    {char * tlv16; tlv16 = (char *)(tlv2); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv2); }
    {char tlv14; tlv14 = (char)(tlv2); }
    {int tlv13; tlv13 = (int)(tlv2); }
    {int tlv19; tlv19 = (int)(tlv2); }
}
void fix_ingred_main_6_11(){
fix_ingred_main_6_11_2();
}
void fix_ingred_main_6(){
fix_ingred_main_6_0();
fix_ingred_main_6_1();
fix_ingred_main_6_2();
fix_ingred_main_6_4();
fix_ingred_main_6_7();
fix_ingred_main_6_10();
fix_ingred_main_6_11();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_6_0_0();
void fix_ingred_main_6_0();
void fix_ingred_main_6_1_0();
void fix_ingred_main_6_1();
void fix_ingred_main_6_2_0();
void fix_ingred_main_6_2();
void fix_ingred_main_6_4_0();
void fix_ingred_main_6_4_1();
void fix_ingred_main_6_4();
void fix_ingred_main_6_7_1();
void fix_ingred_main_6_7();
void fix_ingred_main_6_10_0();
void fix_ingred_main_6_10_1();
void fix_ingred_main_6_10_2();
void fix_ingred_main_6_10_3();
void fix_ingred_main_6_10();
void fix_ingred_main_6_11_2();
void fix_ingred_main_6_11();
void fix_ingred_main_6();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_main_0_0_0
- fix_ingred_main_0_0
- fix_ingred_main_0_1_1
- fix_ingred_main_0_1_2
- fix_ingred_main_0_1_3
- fix_ingred_main_0_1
- fix_ingred_main_0_2_0
- fix_ingred_main_0_2_1
- fix_ingred_main_0_2_2
- fix_ingred_main_0_2
- fix_ingred_main_0_3_4
- fix_ingred_main_0_3_5
- fix_ingred_main_0_3_6
- fix_ingred_main_0_3
- fix_ingred_main_0_4_4
- fix_ingred_main_0_4_5
- fix_ingred_main_0_4
- fix_ingred_main_0
- fix_ingred_main_1_3_0
- fix_ingred_main_1_3
- fix_ingred_main_1
- fix_ingred_main_2
- fix_ingred_main_3_0_0
- fix_ingred_main_3_0
- fix_ingred_main_3_2_0
- fix_ingred_main_3_2
- fix_ingred_main_3_4_2
- fix_ingred_main_3_4_3
- fix_ingred_main_3_4
- fix_ingred_main_3_6_0
- fix_ingred_main_3_6
- fix_ingred_main_3
- fix_ingred_main_4
- fix_ingred_main_5_1_0
- fix_ingred_main_5_1
- fix_ingred_main_5
- fix_ingred_main_6_0_0
- fix_ingred_main_6_0
- fix_ingred_main_6_1_0
- fix_ingred_main_6_1
- fix_ingred_main_6_2_0
- fix_ingred_main_6_2
- fix_ingred_main_6_4_0
- fix_ingred_main_6_4_1
- fix_ingred_main_6_4
- fix_ingred_main_6_7_1
- fix_ingred_main_6_7
- fix_ingred_main_6_10_0
- fix_ingred_main_6_10_1
- fix_ingred_main_6_10_2
- fix_ingred_main_6_10_3
- fix_ingred_main_6_10
- fix_ingred_main_6_11_2
- fix_ingred_main_6_11
- fix_ingred_main_6
