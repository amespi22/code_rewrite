

#include "libcgc.h"
#include "cgc_stdarg.h"
#include "cgc_stdlib.h"
#include "cgc_string.h"
#include "cgc_ctype.h"
#include "cgc_kty.h"
#define MAX_KTY_LENGTH 8192
kty_parser_t *parser;
kty_item_t *my_kty;
int cgc_read_until(int fd, char *buf, cgc_size_t len, char delim)
{
    cgc_size_t i;
    char* c;
     c = buf;
    for (i = 0; i < len; ++i) {
	cgc_size_t rx;
 int tlv1;
 {
     int tlv5;
     tlv5 = fd;
     void* tlv4;
     tlv4 = c;
     cgc_size_t tlv3;
     tlv3 = 1;
     cgc_size_t* tlv2;
     tlv2 = & rx;
     tlv1 = cgc_receive(tlv5,tlv4,tlv3,tlv2);
 }
	if (tlv1 != 0 || rx == 0) {
	    return -1;
	}
	if (*(c++) == delim) {
	    break;
	}
    }
    *(c - 1) = '\0';
    return c - buf;
}

void cgc_import_kty(char *buf)
{
    if (my_kty != NULL) {
	cgc_free_kty_item(my_kty);
	my_kty = NULL;
    }
    parser->cats = 0;
    my_kty = parser->loads(buf);
    if (my_kty == NULL) {
 {
     int tlv2;
     tlv2 = STDOUT;
     const char tlv1 [ ] = "Error!\n";
    	cgc_fdprintf(tlv2,tlv1);
 }
    }
}

void cgc_print_kty()
{
    if (my_kty == NULL) {
 {
     int tlv2;
     tlv2 = STDOUT;
     const char tlv1 [ ] = "Error!\n";
    	cgc_fdprintf(tlv2,tlv1);
 }
	return;
    }
    parser->cats = 0;
    parser->dumps(my_kty);
}

void cgc_nyan()
{
    int i;
    char *c;
    char buf[1024] = { 0 };
    char nyan_cat[] = "\n\n\
+      o     +              o\n\
    +             o     +       +\n\
o          +\n\
    o  +           +        +\n\
+        o     o       +        o\n\
-_-_-_-_-_-_-_,------,      o\n\
_-_-_-_-_-_-_-|   /\\_/\\\n\
-_-_-_-_-_-_-~|__( ^ .^)  +     +\n\
_-_-_-_-_-_-_-\"\"  \"\"\n\
+      o         o   +       o\n\
    +         +\n\
o        o         o      o     +\n\
    o           +\n\
+      +     o        o      +\n\n";
    if (my_kty == NULL) {
 {
     int tlv2;
     tlv2 = STDOUT;
     const char tlv1 [ ] = "Error!\n";
    	cgc_fdprintf(tlv2,tlv1);
 }
	return;
    }
    parser->dumps(my_kty);
    if (parser->cats < 3) {
	return;
    }
    cgc_fdprintf(STDOUT, "%s", nyan_cat);
    c = buf;
    for (i = 0; i < cgc_array_length(parser->nyan_says); ++i) {
 kty_item_t* item;
 {
     array_t* tlv6;
     tlv6 = parser -> nyan_says;
     int tlv5;
     tlv5 = i;
     item = cgc_array_get(tlv6,tlv5);
 }
 {
     char* tlv4;
      tlv4 = c;
     const char* tlv3 = item -> item . i_string . s;
    	cgc_strcpy(tlv4,tlv3);
 }
	c += item->item.i_string.len;
    }
    cgc_fdprintf(STDOUT, "NYAN SAYS...\n\"\n%s\n\"", buf);
}

void cgc_quit()
{
    {
        int tlv2;
        tlv2 = STDOUT;
        const char tlv1 [ ] = "\n\n=^.^=// Bye!\n\n";
        cgc_fdprintf(tlv2,tlv1);
    }
    cgc_exit(0);
}

void cgc_menu()
{
    {
        int tlv2;
        tlv2 = STDOUT;
        const char tlv1 [ ] = "=======================\n";
        cgc_fdprintf(tlv2,tlv1);
    }
    {
        int tlv4;
        tlv4 = STDOUT;
        const char tlv3 [ ] = " 1. Import KTY\n";
        cgc_fdprintf(tlv4,tlv3);
    }
    {
        int tlv6;
        tlv6 = STDOUT;
        const char tlv5 [ ] = " 2. Print KTY\n";
        cgc_fdprintf(tlv6,tlv5);
    }
    {
        int tlv8;
        tlv8 = STDOUT;
        const char tlv7 [ ] = " 3. Quit\n";
        cgc_fdprintf(tlv8,tlv7);
    }
    {
        int tlv10;
        tlv10 = STDOUT;
        const char tlv9 [ ] = "=======================\n";
        cgc_fdprintf(tlv10,tlv9);
    }
}

int main(int cgc_argc, char *cgc_argv[])
{
    char buf[MAX_KTY_LENGTH];
    char cgc_select[16];
    {
        int tlv4;
        tlv4 = STDOUT;
        const char tlv3 [ ] = "KTY Pretty Printer v0.1\n";
        cgc_fdprintf(tlv4,tlv3);
    }
    {
        cgc_size_t tlv6;
        tlv6 = sizeof ( kty_parser_t );
        parser = (kty_parser_t *) cgc_malloc(tlv6);
    }
    int tlv1;
    {
        kty_parser_t* tlv5;
        tlv5 = parser;
        tlv1 = cgc_kty_init(tlv5);
    }
    if (tlv1 != 0) {
 {
     int tlv8;
     tlv8 = STDOUT;
     const char tlv7 [ ] = "Error!\n";
    	cgc_fdprintf(tlv8,tlv7);
 }
	cgc_quit();
    }
    cgc_menu();
    unsigned long tlv_size_0;
    tlv_size_0 = sizeof ( cgc_select );
    while (cgc_read_until(STDIN, cgc_select, tlv_size_0, '\n') > 0) {
 int menu;
 {
     const char* tlv11 = cgc_select;
     char** tlv10;
      tlv10 = NULL;
     int tlv9;
     tlv9 = 10;
     menu = cgc_strtol(tlv11,tlv10,tlv9);
 }
	switch (menu) {
	case 1:
	    {
  int tlv2;
  {
      int tlv17;
      tlv17 = STDIN;
      char* tlv16;
       tlv16 = buf;
      cgc_size_t tlv15;
      tlv15 = MAX_KTY_LENGTH;
      char tlv14;
      tlv14 = '\x00';
      tlv2 = cgc_read_until(tlv17,tlv16,tlv15,tlv14);
  }
		if (tlv2 > 0) {
		    cgc_import_kty(buf);
		} else {
      {
          int tlv19;
          tlv19 = STDOUT;
          const char tlv18 [ ] = "Error!\n";
    		    cgc_fdprintf(tlv19,tlv18);
      }
		}
	    }
	    break;
	case 2:
	    {
		cgc_print_kty();
	    }
	    break;
	case 3:
	    {
		cgc_quit();
	    }
	    break;
	case 777:
	    {
		cgc_nyan();
	    }
	    break;
	default:
	    {
  {
      int tlv13;
      tlv13 = STDOUT;
      const char tlv12 [ ] = "Invalid menu. Try again.\n";
    		cgc_fdprintf(tlv13,tlv12);
  }
	    }
	    break;
	}
    }
    return 0;
}

