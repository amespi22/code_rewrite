[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 0
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : MAX_AC_LIST
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "acceptible"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "acceptable"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "amature"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "amateur"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "arguement"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "argument"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "beleive"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "believe"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "calender"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "calendar"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "cemetary"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "cemetery"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "collectable"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "collectible"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "concensus"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "consensus"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "equiptment"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "equipment"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "existance"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "existence"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "firey"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "fiery"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "foriegn"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "foreign"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "guage"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "gauge"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "greatful"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "grateful"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "harrass"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "harass"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "ignorence"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "ignorance"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "lisense"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "license"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "maintenence"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "maintenance"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "relevent"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "relevant"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "wierd"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "weird"
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : MAX_QUEUE
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_ac_init ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < MAX_AC_LIST
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_AC_LIST
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < MAX_AC_LIST
=> ['i', 'MAX_AC_LIST']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => word_list [ i ] . typo [ 0 ] == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => word_list [ i ] . typo [ 0 ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => word_list [ i ] . typo [ 0 ] == 0
=> ['word_list [ i ] . typo [ 0 ]', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : word_list [ i ] . typo [ 0 ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['word_list [ i ] . typo [ 0 ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['word_list [ i ] . typo [ 0 ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['word_list [ i ] . typo [ 0 ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['word_list [ i ] . typo [ 0 ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['word_list [ i ] . typo [ 0 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['word_list [ i ] . typo [ 0 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['word_list', '[', 'i', ']', '.', 'typo', '[', '0', ']']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
Resolved type: [2.3]  UNDEF : 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ word_list [ i ] . typo [ 0 ] == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { break ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_ac_init ( ) { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_ac_add_custom ( char * typo , char * correct )')]
ParameterDeclaration : type = char *, var = typo [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['typo']
[enterParameterDeclaration] char * : typo
sym_dict [typo] = char * 
ParameterDeclaration : type = char *, var = correct [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['correct']
[enterParameterDeclaration] char * : correct
sym_dict [correct] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_num_words < MAX_AC_LIST
[0] <class 'CParser.CParser.ShiftExpressionContext'> => cgc_num_words
[2] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_AC_LIST
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => cgc_num_words < MAX_AC_LIST
=> ['cgc_num_words', 'MAX_AC_LIST']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : cgc_num_words
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cgc_num_words']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cgc_num_words']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cgc_num_words']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cgc_num_words']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cgc_num_words']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cgc_num_words']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : MAX_AC_LIST
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['MAX_AC_LIST']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['MAX_AC_LIST']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['MAX_AC_LIST']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['MAX_AC_LIST']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['MAX_AC_LIST']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['MAX_AC_LIST']
Resolved type: [1.3]  UNDEF : MAX_AC_LIST
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ typo && correct && cgc_num_words < MAX_AC_LIST ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < cgc_num_words
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => cgc_num_words
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < cgc_num_words
=> ['i', 'cgc_num_words']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv13 = typo'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv12 = word_list [ i ] . typo'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = const char * 
var: tlv4 (tlv4) = cgc_strcmp ( tlv13 , tlv12 )
var: int tlv4 (tlv4) = cgc_strcmp ( tlv13 , tlv12 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; }
Assigns = [('int', 'tlv4', '', 'cgc_strcmp ( tlv13 , tlv12 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv4 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv4
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv4 == 0
=> ['tlv4', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv4
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv4']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv4']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv4']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv4']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv4']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv4']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv4']
FOUND IT! [2.2]  int : tlv4
Resolved type: [2.3]  int : tlv4
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv4 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv4 == 0 ) { return ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv4 == 0 ) { return ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = typo'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: tlv1 (tlv1) = cgc_strlen ( tlv5 )
var: cgc_size_t tlv1 (tlv1) = cgc_strlen ( tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; }
Assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = correct'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
var: tlv2 (tlv2) = cgc_strlen ( tlv6 )
var: cgc_size_t tlv2 (tlv2) = cgc_strlen ( tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 = typo'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = const char * 
var: tlv3 (tlv3) = cgc_strlen ( tlv7 )
var: cgc_size_t tlv3 (tlv3) = cgc_strlen ( tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv7 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1 < MAX_AC_LEN
[0] <class 'CParser.CParser.ShiftExpressionContext'> => tlv1
[2] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_AC_LEN
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => tlv1 < MAX_AC_LEN
=> ['tlv1', 'MAX_AC_LEN']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : tlv1
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [1.2]  cgc_size_t : tlv1
Resolved type: [1.3]  cgc_size_t : tlv1
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2 < MAX_AC_LEN
[0] <class 'CParser.CParser.ShiftExpressionContext'> => tlv2
[2] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_AC_LEN
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => tlv2 < MAX_AC_LEN
=> ['tlv2', 'MAX_AC_LEN']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : tlv2
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [1.2]  cgc_size_t : tlv2
Resolved type: [1.3]  cgc_size_t : tlv2
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => tlv3 > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => tlv3
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => tlv3 > 0
=> ['tlv3', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : tlv3
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv3']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv3']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv3']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv3']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv3']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv3']
FOUND IT! [1.2]  cgc_size_t : tlv3
Resolved type: [1.3]  cgc_size_t : tlv3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = char * 
var: tlv9 (tlv9) = word_list [ cgc_num_words ] . typo
var: char * tlv9 (tlv9) = word_list [ cgc_num_words ] . typo
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 = typo'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; }
Assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = char * 
var: tlv11 (tlv11) = word_list [ cgc_num_words ] . correct
var: char * tlv11 (tlv11) = word_list [ cgc_num_words ] . correct
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv10 = correct'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; }
Assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_ac_add_custom ( char * typo , char * correct ) { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_ac_process ( void * ud )')]
ParameterDeclaration : type = void *, var = ud [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['ud']
[enterParameterDeclaration] void * : ud
sym_dict [ud] = void * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'word [ MAX_AC_LEN ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [word] = char * 
[C-t-3] sym_dict [word [ MAX_AC_LEN ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int dummy'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [dummy] = int 
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = cgc_size_t 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int j'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [j] = int 
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ac_buffer != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ac_buffer
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ac_buffer != NULL
=> ['ac_buffer', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ac_buffer
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ac_buffer']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ac_buffer']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ac_buffer']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ac_buffer']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ac_buffer']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ac_buffer']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ac_buffer']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
Resolved type: [2.3]  UNDEF : NULL
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => ac_queue_count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => ac_queue_count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => ac_queue_count > 0
=> ['ac_queue_count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : ac_queue_count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ac_queue_count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ac_queue_count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ac_queue_count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ac_queue_count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ac_queue_count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ac_queue_count']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
Resolved type: [1.3]  UNDEF : 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = mutex_t * 
var: tlv2 (tlv2) = & ac_mutex
var: mutex_t * tlv2 (tlv2) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_lock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv2 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; }
Assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
Compares = []
var: i (i) = ac_queue_head
var: cgc_size_t i (i) = ac_queue_head
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t start'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [start] = cgc_size_t 
var: start (start) = ac_queue [ i ] . start
var: cgc_size_t start (start) = ac_queue [ i ] . start
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t end'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [end] = cgc_size_t 
var: end (end) = ac_queue [ i ] . end
var: cgc_size_t end (end) = ac_queue [ i ] . end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned long tlv_size_0'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv_size_0] = unsigned long 
var: tlv_size_0 (tlv_size_0) = sizeof ( word )
var: unsigned long tlv_size_0 (tlv_size_0) = sizeof ( word )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => end - start < tlv_size_0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => end - start
[2] <class 'CParser.CParser.ShiftExpressionContext'> => tlv_size_0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => end - start < tlv_size_0
=> ['end - start', 'tlv_size_0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : end - start
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['end - start']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.MultiplicativeExpressionContext'>] ['end', '-', 'start']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['end']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['end']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['end']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['end']
FOUND IT! [1.2]  cgc_size_t : end
Resolved type: [1.3]  cgc_size_t : end
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ end - start < tlv_size_0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = void * 
var: tlv6 (tlv6) = word
var: void * tlv6 (tlv6) = word
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = void * 
var: tlv5 (tlv5) = & ac_buffer [ start ]
var: void * tlv5 (tlv5) = & ac_buffer [ start ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = cgc_size_t 
var: tlv4 (tlv4) = end - start
var: cgc_size_t tlv4 (tlv4) = end - start
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }
Assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start')]
Compares = []
var: word  (word [ end - start ]) = 0
var: UNDEF word  (word [ end - start ]) = 0
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } ]
Assigns = [('UNDEF', 'word ', '[ end - start ]', '0')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ end - start < tlv_size_0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: word  (word [ 0 ]) = 0
var: UNDEF word  (word [ 0 ]) = 0
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { word [ 0 ] = 0 ; }
Assigns = [('UNDEF', 'word ', '[ 0 ]', '0')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { word [ 0 ] = 0 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = mutex_t * 
var: tlv3 (tlv3) = & ac_mutex
var: mutex_t * tlv3 (tlv3) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_unlock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv3 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }
Assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int diff'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [diff] = int 
var: diff (diff) = 0
var: int diff (diff) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: j (j) = 0
var: int j (j) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => j < cgc_num_words
[0] <class 'CParser.CParser.ShiftExpressionContext'> => j
[2] <class 'CParser.CParser.ShiftExpressionContext'> => cgc_num_words
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => j < cgc_num_words
=> ['j', 'cgc_num_words']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : j
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['j']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['j']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['j']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['j']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['j']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['j']
FOUND IT! [1.2]  int : j
Resolved type: [1.3]  int : j
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 = word'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 = word_list [ j ] . typo'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = const char * 
var: tlv1 (tlv1) = cgc_strcmp ( tlv8 , tlv7 )
var: int tlv1 (tlv1) = cgc_strcmp ( tlv8 , tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; }
Assigns = [('int', 'tlv1', '', 'cgc_strcmp ( tlv8 , tlv7 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * newbuf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [newbuf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv13 = word'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv11 = word_list [ j ] . correct'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = const char * 
var: diff (diff) = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )
var: int diff (diff) = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; }
Assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = mutex_t * 
var: tlv9 (tlv9) = & ac_mutex
var: mutex_t * tlv9 (tlv9) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_lock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv9 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; }
Assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => diff < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => diff
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => diff < 0
=> ['diff', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : diff
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['diff']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['diff']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['diff']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['diff']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['diff']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['diff']
FOUND IT! [1.2]  int : diff
Resolved type: [1.3]  int : diff
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ diff < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv17'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = void * 
var: tlv17 (tlv17) = & ac_buffer [ end + diff ]
var: void * tlv17 (tlv17) = & ac_buffer [ end + diff ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = void * 
var: tlv16 (tlv16) = & ac_buffer [ end ]
var: void * tlv16 (tlv16) = & ac_buffer [ end ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = cgc_size_t 
var: tlv15 (tlv15) = ac_idx - end
var: cgc_size_t tlv15 (tlv15) = ac_idx - end
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; }
Assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = void * 
var: tlv14 (tlv14) = ac_buffer
var: void * tlv14 (tlv14) = ac_buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = cgc_size_t 
var: tlv12 (tlv12) = ac_idx + 1 + diff
var: cgc_size_t tlv12 (tlv12) = ac_idx + 1 + diff
var: newbuf (newbuf) = cgc_realloc ( tlv14 , tlv12 )
var: char * newbuf (newbuf) = cgc_realloc ( tlv14 , tlv12 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }
Assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff'), ('char *', 'newbuf', '', 'cgc_realloc ( tlv14 , tlv12 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => newbuf != NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => newbuf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => newbuf != NULL
=> ['newbuf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : newbuf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['newbuf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['newbuf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['newbuf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['newbuf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['newbuf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['newbuf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['newbuf']
FOUND IT! [2.2]  char * : newbuf
Resolved type: [2.3]  char * : newbuf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ newbuf != NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ac_buffer (ac_buffer) = newbuf
var: UNDEF ac_buffer (ac_buffer) = newbuf
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => diff > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => diff
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => diff > 0
=> ['diff', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : diff
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['diff']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['diff']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['diff']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['diff']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['diff']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['diff']
FOUND IT! [1.2]  int : diff
Resolved type: [1.3]  int : diff
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ diff > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv23'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv23] = void * 
var: tlv23 (tlv23) = & ac_buffer [ end + diff ]
var: void * tlv23 (tlv23) = & ac_buffer [ end + diff ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv22'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv22] = void * 
var: tlv22 (tlv22) = & ac_buffer [ end ]
var: void * tlv22 (tlv22) = & ac_buffer [ end ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv21'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv21] = cgc_size_t 
var: tlv21 (tlv21) = ac_idx - end
var: cgc_size_t tlv21 (tlv21) = ac_idx - end
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; }
Assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv20'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv20] = void * 
var: tlv20 (tlv20) = & ac_buffer [ start ]
var: void * tlv20 (tlv20) = & ac_buffer [ start ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv19'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = void * 
var: tlv19 (tlv19) = word_list [ j ] . correct
var: void * tlv19 (tlv19) = word_list [ j ] . correct
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv18'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv18] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv24 = word_list [ j ] . correct'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv24] = const char * 
var: tlv18 (tlv18) = cgc_strlen ( tlv24 )
var: cgc_size_t tlv18 (tlv18) = cgc_strlen ( tlv24 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; }
Assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } ]
Assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
Compares = []
var: ac_idx (ac_idx) = diff
var: UNDEF ac_idx (ac_idx) = diff
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ]
Assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = mutex_t * 
var: tlv10 (tlv10) = & ac_mutex
var: mutex_t * tlv10 (tlv10) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_unlock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv10 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }
Assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: j (j) = 0
var: int j (j) = 0
var: i (i) = ac_queue_head
var: cgc_size_t i (i) = ac_queue_head
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => j < ac_queue_count
[0] <class 'CParser.CParser.ShiftExpressionContext'> => j
[2] <class 'CParser.CParser.ShiftExpressionContext'> => ac_queue_count
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => j < ac_queue_count
=> ['j', 'ac_queue_count']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : j
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['j']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['j']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['j']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['j']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['j']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['j']
FOUND IT! [1.2]  int : j
Resolved type: [1.3]  int : j
var: i (i) = ( i + 1 ) % MAX_QUEUE
var: cgc_size_t i (i) = ( i + 1 ) % MAX_QUEUE
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: ac_queue  (ac_queue [ i ] . start) = diff
var: UNDEF ac_queue  (ac_queue [ i ] . start) = diff
var: ac_queue  (ac_queue [ i ] . end) = diff
var: UNDEF ac_queue  (ac_queue [ i ] . end) = diff
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }
Assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ]
var: ac_queue_head (ac_queue_head) = ( ac_queue_head + 1 ) % MAX_QUEUE
var: UNDEF ac_queue_head (ac_queue_head) = ( ac_queue_head + 1 ) % MAX_QUEUE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } ]
 3 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } ]
 4 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ]
Assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('UNDEF', 'ac_queue_head', '', '( ac_queue_head + 1 ) % MAX_QUEUE')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_ac_process ( void * ud ) { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'char *'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_ac_read ( int fd , char term )')]
ParameterDeclaration : type = int, var = fd [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['fd']
[enterParameterDeclaration] int : fd
sym_dict [fd] = int 
ParameterDeclaration : type = char, var = term [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['term']
[enterParameterDeclaration] char : term
sym_dict [term] = char 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t rx'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rx] = cgc_size_t 
var: ac_queue_count (ac_queue_count) = ac_queue_head = ac_queue_tail = ac_idx = 0
var: UNDEF ac_queue_count (ac_queue_count) = ac_queue_head = ac_queue_tail = ac_idx = 0
var: ac_queue_head (ac_queue_head) = ac_queue_tail = ac_idx = 0
var: UNDEF ac_queue_head (ac_queue_head) = ac_queue_tail = ac_idx = 0
var: ac_queue_tail (ac_queue_tail) = ac_idx = 0
var: UNDEF ac_queue_tail (ac_queue_tail) = ac_idx = 0
var: ac_idx (ac_idx) = 0
var: UNDEF ac_idx (ac_idx) = 0
var: ac_buffer (ac_buffer) = NULL
var: UNDEF ac_buffer (ac_buffer) = NULL
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = cgc_size_t 
var: count (count) = 0
var: cgc_size_t count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'word [ MAX_AC_LEN ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [word] = char * 
[C-t-3] sym_dict [word [ MAX_AC_LEN ]] = char 
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: count (count) = 0
var: cgc_size_t count (count) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count < MAX_AC_LEN
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_AC_LEN
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count < MAX_AC_LEN
=> ['count', 'MAX_AC_LEN']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = int 
var: tlv15 (tlv15) = fd
var: int tlv15 (tlv15) = fd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = void * 
var: tlv14 (tlv14) = & word [ count ]
var: void * tlv14 (tlv14) = & word [ count ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = cgc_size_t 
var: tlv13 (tlv13) = 1
var: cgc_size_t tlv13 (tlv13) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t * tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = cgc_size_t * 
var: tlv12 (tlv12) = & rx
var: cgc_size_t * tlv12 (tlv12) = & rx
var: tlv1 (tlv1) = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 )
var: int tlv1 (tlv1) = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; }
Assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx'), ('int', 'tlv1', '', 'cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => rx == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => rx
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => rx == 0
=> ['rx', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : rx
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['rx']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['rx']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['rx']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['rx']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['rx']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['rx']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['rx']
FOUND IT! [2.2]  cgc_size_t : rx
Resolved type: [2.3]  cgc_size_t : rx
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 != 0 || rx == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { goto fail ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 != 0 || rx == 0 ) { goto fail ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { goto fail ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = int 
var: tlv16 (tlv16) = word [ count ]
var: int tlv16 (tlv16) = word [ count ]
var: tlv2 (tlv2) = cgc_isalpha ( tlv16 )
var: int tlv2 (tlv2) = cgc_isalpha ( tlv16 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; }
Assigns = [('int', 'tlv16', '', 'word [ count ]'), ('int', 'tlv2', '', 'cgc_isalpha ( tlv16 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => word [ count ] == term
[0] <class 'CParser.CParser.RelationalExpressionContext'> => word [ count ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => term
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => word [ count ] == term
=> ['word [ count ]', 'term']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : word [ count ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['word [ count ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['word [ count ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['word [ count ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['word [ count ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['word [ count ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['word [ count ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['word', '[', 'count', ']']
FOUND IT! [2.2]  char * : word
Resolved type: [2.3]  char * : word
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ word [ count ] == term || ! tlv2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { count ++ ; break ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { count ++ ; break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 != 0 || rx == 0 ) { goto fail ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * newbuf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [newbuf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = void * 
var: tlv11 (tlv11) = ac_buffer
var: void * tlv11 (tlv11) = ac_buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = cgc_size_t 
var: tlv10 (tlv10) = ac_idx + count + 1
var: cgc_size_t tlv10 (tlv10) = ac_idx + count + 1
var: newbuf (newbuf) = cgc_realloc ( tlv11 , tlv10 )
var: char * newbuf (newbuf) = cgc_realloc ( tlv11 , tlv10 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }
Assigns = [('void *', 'tlv11', '', 'ac_buffer'), ('cgc_size_t', 'tlv10', '', 'ac_idx + count + 1'), ('char *', 'newbuf', '', 'cgc_realloc ( tlv11 , tlv10 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => newbuf == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => newbuf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => newbuf == NULL
=> ['newbuf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : newbuf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['newbuf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['newbuf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['newbuf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['newbuf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['newbuf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['newbuf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['newbuf']
FOUND IT! [2.2]  char * : newbuf
Resolved type: [2.3]  char * : newbuf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ newbuf == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { goto fail ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( newbuf == NULL ) { goto fail ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { goto fail ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = mutex_t * 
var: tlv5 (tlv5) = & ac_mutex
var: mutex_t * tlv5 (tlv5) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_lock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }
Assigns = [('mutex_t *', 'tlv5', '', '& ac_mutex')]
Compares = []
var: ac_buffer (ac_buffer) = newbuf
var: UNDEF ac_buffer (ac_buffer) = newbuf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = void * 
var: tlv8 (tlv8) = & ac_buffer [ ac_idx ]
var: void * tlv8 (tlv8) = & ac_buffer [ ac_idx ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = void * 
var: tlv7 (tlv7) = word
var: void * tlv7 (tlv7) = word
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = cgc_size_t 
var: tlv6 (tlv6) = count
var: cgc_size_t tlv6 (tlv6) = count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }
Assigns = [('void *', 'tlv8', '', '& ac_buffer [ ac_idx ]'), ('void *', 'tlv7', '', 'word'), ('cgc_size_t', 'tlv6', '', 'count')]
Compares = []
var: ac_idx (ac_idx) = count
var: UNDEF ac_idx (ac_idx) = count
var: ac_buffer  (ac_buffer [ ac_idx ]) = 0
var: UNDEF ac_buffer  (ac_buffer [ ac_idx ]) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = mutex_t * 
var: tlv9 (tlv9) = & ac_mutex
var: mutex_t * tlv9 (tlv9) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_unlock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv9 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }
Assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 1
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 1
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 1
=> ['count', '1']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => ac_queue_count >= MAX_QUEUE
[0] <class 'CParser.CParser.ShiftExpressionContext'> => ac_queue_count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => MAX_QUEUE
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => ac_queue_count >= MAX_QUEUE
=> ['ac_queue_count', 'MAX_QUEUE']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : ac_queue_count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ac_queue_count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ac_queue_count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ac_queue_count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ac_queue_count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ac_queue_count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ac_queue_count']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : MAX_QUEUE
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['MAX_QUEUE']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['MAX_QUEUE']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['MAX_QUEUE']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['MAX_QUEUE']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['MAX_QUEUE']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['MAX_QUEUE']
Resolved type: [1.3]  UNDEF : MAX_QUEUE
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_filaments_yield ( ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_filaments_yield ( ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = cgc_size_t 
var: i (i) = ac_queue_tail
var: cgc_size_t i (i) = ac_queue_tail
var: ac_queue_tail (ac_queue_tail) = ( ac_queue_tail + 1 ) % MAX_QUEUE
var: UNDEF ac_queue_tail (ac_queue_tail) = ( ac_queue_tail + 1 ) % MAX_QUEUE
var: ac_queue  (ac_queue [ i ] . start) = ac_idx - count
var: UNDEF ac_queue  (ac_queue [ i ] . start) = ac_idx - count
var: ac_queue  (ac_queue [ i ] . end) = ac_idx - 1
var: UNDEF ac_queue  (ac_queue [ i ] . end) = ac_idx - 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } ]
Assigns = [('cgc_size_t', 'i', '', 'ac_queue_tail'), ('UNDEF', 'ac_queue_tail', '', '( ac_queue_tail + 1 ) % MAX_QUEUE'), ('UNDEF', 'ac_queue ', '[ i ] . start', 'ac_idx - count'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'ac_idx - 1')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ac_buffer [ ac_idx - 1 ] == term
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ac_buffer [ ac_idx - 1 ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => term
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ac_buffer [ ac_idx - 1 ] == term
=> ['ac_buffer [ ac_idx - 1 ]', 'term']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ac_buffer [ ac_idx - 1 ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ac_buffer [ ac_idx - 1 ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ac_buffer [ ac_idx - 1 ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ac_buffer [ ac_idx - 1 ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ac_buffer [ ac_idx - 1 ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ac_buffer [ ac_idx - 1 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ac_buffer [ ac_idx - 1 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['ac_buffer', '[', 'ac_idx - 1', ']']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : term
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['term']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['term']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['term']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['term']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['term']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['term']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['term']
FOUND IT! [2.2]  char : term
Resolved type: [2.3]  char : term
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ac_buffer [ ac_idx - 1 ] == term ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { break ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { break ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( newbuf == NULL ) { goto fail ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } ]
 6 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } ]
 7 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } ]
Assigns = [('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => ac_queue_count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => ac_queue_count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => ac_queue_count > 0
=> ['ac_queue_count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : ac_queue_count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ac_queue_count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ac_queue_count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ac_queue_count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ac_queue_count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ac_queue_count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ac_queue_count']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
Resolved type: [1.3]  UNDEF : 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_filaments_yield ( ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_filaments_yield ( ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [buf] = char * 
var: buf (buf) = ac_buffer
var: char * buf (buf) = ac_buffer
var: ac_buffer (ac_buffer) = NULL
var: UNDEF ac_buffer (ac_buffer) = NULL
var: buf  (buf [ ac_idx - 1 ]) = 0
var: UNDEF buf  (buf [ ac_idx - 1 ]) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.LabeledStatementContext'> [start? False]
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.LabeledStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = mutex_t * 
var: tlv4 (tlv4) = & ac_mutex
var: mutex_t * tlv4 (tlv4) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_lock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }
Assigns = [('mutex_t *', 'tlv4', '', '& ac_mutex')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( ac_buffer )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
var: ac_buffer (ac_buffer) = NULL
var: UNDEF ac_buffer (ac_buffer) = NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'mutex_t * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = mutex_t * 
var: tlv3 (tlv3) = & ac_mutex
var: mutex_t * tlv3 (tlv3) = & ac_mutex
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_mutex_unlock'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv3 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }
Assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } ]
Assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('char *', 'buf', '', 'ac_buffer'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : char * cgc_ac_read ( int fd , char term ) { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; } ]
compound scope 0 : { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; }
compound scope 1 : { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; }
compound scope 2 : { break ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; } ] 
p_decls = [('int', 'i', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'i', None)]
assigns = []
compares = []
===> context { int i ; for ( i = 0 ; i < MAX_AC_LIST ; ++ i ) { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } mutex_init ( & ac_mutex ) ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: i
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'i', None)]
assigns = []
compares = []
decls = [('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
===> context { if ( word_list [ i ] . typo [ 0 ] == 0 ) { break ; } cgc_num_words ++ ; }
ignore sibs: ['mutex_init ( & ac_mutex ) ;', '}']
0 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: MAX_AC_LIST
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'i', None)]
assigns = []
compares = []
decls = [('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { break ; }
ignore sibs: ['cgc_num_words ++ ;', '}', 'mutex_init ( & ac_mutex ) ;', '}']
0 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: MAX_AC_LIST
2 : |compare_scopes| type: UNDEF, value: word_list [ i ] . typo [ 0 ]
3 : |compare_scopes| type: UNDEF, value: 0
=======END=======
compound scope 0 : { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } }
compound scope 1 : { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } }
compound scope 2 : { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } }
compound scope 3 : { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; }
compound scope 4 : { return ; }
compound scope 5 : { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; }
compound scope 6 : { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }
compound scope 7 : { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }
compound scope 8 : { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }
compound scope 9 : { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; }
compound scope 10 : { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; }
len(compound_scope) : 11
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
===> context { if ( typo && correct && cgc_num_words < MAX_AC_LIST ) { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: typo
1 : |  decl_scope  | type: char *, var: correct
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } } ] 
p_decls = [('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = ['', '']
===> context { int i ; for ( i = 0 ; i < cgc_num_words ; ++ i ) { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } cgc_size_t tlv1 ; { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_size_t tlv2 ; { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } cgc_size_t tlv3 ; { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } }
ignore sibs: ['}']
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: cgc_size_t, var: tlv1
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: cgc_size_t, var: tlv3
4 : |  decl_scope  | type: char *, var: typo
5 : |  decl_scope  | type: char *, var: correct
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } } ] 
p_decls = [('int', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('int', 'tlv4', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('int', 'tlv4', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = ['', '']
decls = [('int', 'tlv4', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None)]
assigns = []
compares = ['', '']
decls = [('int', 'tlv4', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { int tlv4 ; { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } if ( tlv4 == 0 ) { return ; } }
ignore sibs: ['cgc_size_t tlv1 ;', '{ const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; }', 'cgc_size_t tlv2 ;', '{ const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }', 'cgc_size_t tlv3 ;', '{ const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }', 'if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }', '}', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: char *, var: typo
2 : |  decl_scope  | type: char *, var: correct
3 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: cgc_num_words
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; } ] 
p_decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv12', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('int', 'tlv4', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { const char * tlv13 = typo ; const char * tlv12 = word_list [ i ] . typo ; tlv4 = cgc_strcmp ( tlv13 , tlv12 ) ; }
ignore sibs: ['if ( tlv4 == 0 ) { return ; }', '}', 'cgc_size_t tlv1 ;', '{ const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; }', 'cgc_size_t tlv2 ;', '{ const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }', 'cgc_size_t tlv3 ;', '{ const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }', 'if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv13
1 : |  decl_scope  | type: const char *, var: tlv12
2 : |  decl_scope  | type: char *, var: typo
3 : |  decl_scope  | type: char *, var: correct
4 : |  decl_scope  | type: int, var: i
5 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: cgc_num_words
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = ['', '']
decls = [('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None)]
assigns = []
compares = ['', '']
decls = [('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('int', 'tlv4', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('int', 'tlv4', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '', '', '']
===> context { return ; }
ignore sibs: ['}', 'cgc_size_t tlv1 ;', '{ const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; }', 'cgc_size_t tlv2 ;', '{ const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }', 'cgc_size_t tlv3 ;', '{ const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }', 'if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }', '}', '}']
0 : |  decl_scope  | type: char *, var: typo
1 : |  decl_scope  | type: char *, var: correct
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: cgc_num_words
4 : |compare_scopes| type: int, value: tlv4
5 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv5', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
compares = []
decls = [('const char *', 'tlv5', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
compares = []
decls = [('const char *', 'tlv5', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
compares = ['', '']
decls = [('const char *', 'tlv5', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
compares = ['', '']
===> context { const char * tlv5 = typo ; tlv1 = cgc_strlen ( tlv5 ) ; }
ignore sibs: ['cgc_size_t tlv2 ;', '{ const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }', 'cgc_size_t tlv3 ;', '{ const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }', 'if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv5
1 : |  decl_scope  | type: char *, var: typo
2 : |  decl_scope  | type: char *, var: correct
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: cgc_size_t, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv5 )
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; } ] 
p_decls = [('const char *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
compares = []
decls = [('const char *', 'tlv6', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
compares = []
decls = [('const char *', 'tlv6', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
compares = ['', '']
decls = [('const char *', 'tlv6', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
compares = ['', '']
===> context { const char * tlv6 = correct ; tlv2 = cgc_strlen ( tlv6 ) ; }
ignore sibs: ['cgc_size_t tlv3 ;', '{ const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }', 'if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: char *, var: typo
2 : |  decl_scope  | type: char *, var: correct
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: cgc_size_t, var: tlv1
5 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv6 )
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; } ] 
p_decls = [('const char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv7', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv7 )')]
compares = []
decls = [('const char *', 'tlv7', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv7 )')]
compares = []
decls = [('const char *', 'tlv7', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv7 )')]
compares = ['', '']
decls = [('const char *', 'tlv7', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'cgc_strlen ( tlv7 )')]
compares = ['', '']
===> context { const char * tlv7 = typo ; tlv3 = cgc_strlen ( tlv7 ) ; }
ignore sibs: ['if ( tlv1 < MAX_AC_LEN && tlv2 < MAX_AC_LEN && tlv3 > 0 ) { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv7
1 : |  decl_scope  | type: char *, var: typo
2 : |  decl_scope  | type: char *, var: correct
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: cgc_size_t, var: tlv1
5 : |  decl_scope  | type: cgc_size_t, var: tlv2
6 : |  decl_scope  | type: cgc_size_t, var: tlv3
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv7 )
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = []
decls = [('char *', 'typo', None), ('char *', 'correct', None)]
assigns = []
compares = ['', '']
decls = [('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = []
compares = ['', '']
decls = [('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = []
compares = ['', '', '', '', '', '', '', '']
===> context { { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } cgc_num_words ++ ; }
ignore sibs: ['}', '}']
0 : |  decl_scope  | type: char *, var: typo
1 : |  decl_scope  | type: char *, var: correct
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: cgc_size_t, var: tlv1
4 : |  decl_scope  | type: cgc_size_t, var: tlv2
5 : |  decl_scope  | type: cgc_size_t, var: tlv3
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
2 : |compare_scopes| type: cgc_size_t, value: tlv1
3 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
4 : |compare_scopes| type: cgc_size_t, value: tlv2
5 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
6 : |compare_scopes| type: cgc_size_t, value: tlv3
7 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; } ] 
p_decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
compares = []
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
compares = []
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
compares = ['', '']
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
compares = ['', '']
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
compares = ['', '', '', '', '', '', '', '']
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('char *', 'tlv9', '', 'word_list [ cgc_num_words ] . typo')]
compares = ['', '', '', '', '', '', '', '']
===> context { char * tlv9 ; tlv9 = word_list [ cgc_num_words ] . typo ; const char * tlv8 = typo ; cgc_strcpy ( tlv9 , tlv8 ) ; }
ignore sibs: ['{ char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; }', 'cgc_num_words ++ ;', '}', '}', '}']
0 : |  decl_scope  | type: char *, var: tlv9
1 : |  decl_scope  | type: const char *, var: tlv8
2 : |  decl_scope  | type: char *, var: typo
3 : |  decl_scope  | type: char *, var: correct
4 : |  decl_scope  | type: int, var: i
5 : |  decl_scope  | type: cgc_size_t, var: tlv1
6 : |  decl_scope  | type: cgc_size_t, var: tlv2
7 : |  decl_scope  | type: cgc_size_t, var: tlv3
0 : | assign_scope | type: char *, value: word_list [ cgc_num_words ] . typo
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
2 : |compare_scopes| type: cgc_size_t, value: tlv1
3 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
4 : |compare_scopes| type: cgc_size_t, value: tlv2
5 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
6 : |compare_scopes| type: cgc_size_t, value: tlv3
7 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; } ] 
p_decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
compares = []
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
compares = []
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('char *', 'typo', None), ('char *', 'correct', None)]
assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
compares = ['', '']
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
compares = ['', '']
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
compares = ['', '', '', '', '', '', '', '']
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('char *', 'typo', None), ('char *', 'correct', None), ('int', 'i', None), ('cgc_size_t', 'tlv1', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t', 'tlv3', None)]
assigns = [('char *', 'tlv11', '', 'word_list [ cgc_num_words ] . correct')]
compares = ['', '', '', '', '', '', '', '']
===> context { char * tlv11 ; tlv11 = word_list [ cgc_num_words ] . correct ; const char * tlv10 = correct ; cgc_strcpy ( tlv11 , tlv10 ) ; }
ignore sibs: ['cgc_num_words ++ ;', '}', '}', '}']
0 : |  decl_scope  | type: char *, var: tlv11
1 : |  decl_scope  | type: const char *, var: tlv10
2 : |  decl_scope  | type: char *, var: typo
3 : |  decl_scope  | type: char *, var: correct
4 : |  decl_scope  | type: int, var: i
5 : |  decl_scope  | type: cgc_size_t, var: tlv1
6 : |  decl_scope  | type: cgc_size_t, var: tlv2
7 : |  decl_scope  | type: cgc_size_t, var: tlv3
0 : | assign_scope | type: char *, value: word_list [ cgc_num_words ] . correct
0 : |compare_scopes| type: UNDEF, value: cgc_num_words
1 : |compare_scopes| type: UNDEF, value: MAX_AC_LIST
2 : |compare_scopes| type: cgc_size_t, value: tlv1
3 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
4 : |compare_scopes| type: cgc_size_t, value: tlv2
5 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
6 : |compare_scopes| type: cgc_size_t, value: tlv3
7 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
compound scope 0 : { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } }
compound scope 1 : { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; }
compound scope 2 : { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; }
compound scope 3 : { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; }
compound scope 4 : { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; }
compound scope 5 : { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }
compound scope 6 : { word [ 0 ] = 0 ; }
compound scope 7 : { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }
compound scope 8 : { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }
compound scope 9 : { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; }
compound scope 10 : { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; }
compound scope 11 : { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; }
compound scope 12 : { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; }
compound scope 13 : { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } }
compound scope 14 : { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; }
compound scope 15 : { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }
compound scope 16 : { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }
compound scope 17 : { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } }
compound scope 18 : { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; }
compound scope 19 : { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; }
compound scope 20 : { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; }
compound scope 21 : { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }
compound scope 22 : { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }
len(compound_scope) : 23
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } } ] 
p_decls = [('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('void *', 'ud', None)]
assigns = []
compares = []
===> context { char word [ MAX_AC_LEN ] ; int dummy ; while ( 1 ) { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: word
1 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
2 : |  decl_scope  | type: int, var: dummy
3 : |  decl_scope  | type: void *, var: ud
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; } ] 
p_decls = [('cgc_size_t', 'i', None), ('int', 'j', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'i', None), ('int', 'j', None), ('void *', 'ud', None)]
assigns = []
compares = []
decls = [('cgc_size_t', 'i', None), ('int', 'j', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('cgc_size_t', 'i', None), ('int', 'j', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
===> context { cgc_size_t i ; int j ; while ( ac_buffer != NULL && ac_queue_count > 0 ) { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } cgc_filaments_yield ( ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: cgc_size_t, var: i
1 : |  decl_scope  | type: int, var: j
2 : |  decl_scope  | type: void *, var: ud
3 : |  decl_scope  | type: char *, var: word
4 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
5 : |  decl_scope  | type: int, var: dummy
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; } ] 
p_decls = [('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('void *', 'ud', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('UNDEF', 'ac_queue_head', '', '( ac_queue_head + 1 ) % MAX_QUEUE')]
compares = []
decls = [('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('UNDEF', 'ac_queue_head', '', '( ac_queue_head + 1 ) % MAX_QUEUE')]
compares = []
decls = [('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('UNDEF', 'ac_queue_head', '', '( ac_queue_head + 1 ) % MAX_QUEUE')]
compares = []
decls = [('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('UNDEF', 'ac_queue_head', '', '( ac_queue_head + 1 ) % MAX_QUEUE')]
compares = []
decls = [('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('UNDEF', 'ac_queue_head', '', '( ac_queue_head + 1 ) % MAX_QUEUE')]
compares = ['', '', '', '']
===> context { { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } i = ac_queue_head ; cgc_size_t start ; start = ac_queue [ i ] . start ; cgc_size_t end ; end = ac_queue [ i ] . end ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( word ) ; if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; } { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } int diff ; diff = 0 ; for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ; ac_queue_count -- ; }
ignore sibs: ['cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: cgc_size_t, var: start
1 : |  decl_scope  | type: cgc_size_t, var: end
2 : |  decl_scope  | type: unsigned long, var: tlv_size_0
3 : |  decl_scope  | type: int, var: diff
4 : |  decl_scope  | type: void *, var: ud
5 : |  decl_scope  | type: char *, var: word
6 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
7 : |  decl_scope  | type: int, var: dummy
8 : |  decl_scope  | type: cgc_size_t, var: i
9 : |  decl_scope  | type: int, var: j
0 : | assign_scope | type: cgc_size_t, value: ac_queue_head
1 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
3 : | assign_scope | type: unsigned long, value: sizeof ( word )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: UNDEF, value: ( ac_queue_head + 1 ) % MAX_QUEUE
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; } ] 
p_decls = [('mutex_t *', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv2', None), ('void *', 'ud', None)]
assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv2', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv2', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv2', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv2', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
compares = ['', '', '', '']
decls = [('mutex_t *', 'tlv2', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv2', '', '& ac_mutex')]
compares = ['', '', '', '']
===> context { mutex_t * tlv2 ; tlv2 = & ac_mutex ; cgc_mutex_lock ( tlv2 ) ; }
ignore sibs: ['i = ac_queue_head ;', 'cgc_size_t start ;', 'start = ac_queue [ i ] . start ;', 'cgc_size_t end ;', 'end = ac_queue [ i ] . end ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( word ) ;', 'if ( end - start < tlv_size_0 ) { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } else { word [ 0 ] = 0 ; }', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'int diff ;', 'diff = 0 ;', 'for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv2
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'ud', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('UNDEF', 'word ', '[ end - start ]', '0'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '', '', '']
===> context { { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } word [ end - start ] = 0 ; }
ignore sibs: ['else', '{ word [ 0 ] = 0 ; }', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'int diff ;', 'diff = 0 ;', 'for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: ud
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: int, var: dummy
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: int, var: j
6 : |  decl_scope  | type: cgc_size_t, var: start
7 : |  decl_scope  | type: cgc_size_t, var: end
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: UNDEF, value: 0
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: cgc_size_t, value: end - start
5 : |compare_scopes| type: cgc_size_t, value: tlv_size_0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } ] 
p_decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start')]
compares = []
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start')]
compares = []
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start')]
compares = []
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start')]
compares = []
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start')]
compares = ['', '', '', '']
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '']
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('void *', 'tlv6', '', 'word'), ('void *', 'tlv5', '', '& ac_buffer [ start ]'), ('cgc_size_t', 'tlv4', '', 'end - start'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '', '', '']
===> context { void * tlv6 ; tlv6 = word ; void * tlv5 ; tlv5 = & ac_buffer [ start ] ; cgc_size_t tlv4 ; tlv4 = end - start ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }
ignore sibs: ['word [ end - start ] = 0 ;', '}', 'else', '{ word [ 0 ] = 0 ; }', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'int diff ;', 'diff = 0 ;', 'for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: tlv6
1 : |  decl_scope  | type: void *, var: tlv5
2 : |  decl_scope  | type: cgc_size_t, var: tlv4
3 : |  decl_scope  | type: void *, var: ud
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: int, var: dummy
7 : |  decl_scope  | type: cgc_size_t, var: i
8 : |  decl_scope  | type: int, var: j
9 : |  decl_scope  | type: cgc_size_t, var: start
10 : |  decl_scope  | type: cgc_size_t, var: end
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: void *, value: word
1 : | assign_scope | type: void *, value: & ac_buffer [ start ]
2 : | assign_scope | type: cgc_size_t, value: end - start
3 : | assign_scope | type: cgc_size_t, value: ac_queue_head
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
5 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
6 : | assign_scope | type: unsigned long, value: sizeof ( word )
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: cgc_size_t, value: end - start
5 : |compare_scopes| type: cgc_size_t, value: tlv_size_0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { word [ 0 ] = 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { word [ 0 ] = 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'ud', None)]
assigns = [('UNDEF', 'word ', '[ 0 ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'word ', '[ 0 ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'word ', '[ 0 ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'word ', '[ 0 ]', '0')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'word ', '[ 0 ]', '0')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('UNDEF', 'word ', '[ 0 ]', '0'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '']
===> context { word [ 0 ] = 0 ; }
ignore sibs: ['{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'int diff ;', 'diff = 0 ;', 'for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: ud
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: int, var: dummy
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: int, var: j
6 : |  decl_scope  | type: cgc_size_t, var: start
7 : |  decl_scope  | type: cgc_size_t, var: end
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: UNDEF, value: 0
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } ] 
p_decls = [('mutex_t *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv3', None), ('void *', 'ud', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv3', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv3', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv3', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv3', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
compares = ['', '', '', '']
decls = [('mutex_t *', 'tlv3', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )')]
compares = ['', '', '', '']
===> context { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }
ignore sibs: ['int diff ;', 'diff = 0 ;', 'for ( j = 0 ; j < cgc_num_words ; ++ j ) { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv3
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
7 : |  decl_scope  | type: cgc_size_t, var: start
8 : |  decl_scope  | type: cgc_size_t, var: end
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('void *', 'ud', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = ['', '', '', '']
decls = [('int', 'tlv1', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('int', 'tlv1', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
===> context { int tlv1 ; { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } }
ignore sibs: ['for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
7 : |  decl_scope  | type: cgc_size_t, var: start
8 : |  decl_scope  | type: cgc_size_t, var: end
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: diff
0 : | assign_scope | type: cgc_size_t, value: ac_queue_head
1 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
3 : | assign_scope | type: unsigned long, value: sizeof ( word )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; } ] 
p_decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = ['', '', '', '']
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('const char *', 'tlv8', None), ('const char *', 'tlv7', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
===> context { const char * tlv8 = word ; const char * tlv7 = word_list [ j ] . typo ; tlv1 = cgc_strcmp ( tlv8 , tlv7 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; }', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv8
1 : |  decl_scope  | type: const char *, var: tlv7
2 : |  decl_scope  | type: void *, var: ud
3 : |  decl_scope  | type: char *, var: word
4 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
5 : |  decl_scope  | type: int, var: dummy
6 : |  decl_scope  | type: cgc_size_t, var: i
7 : |  decl_scope  | type: int, var: j
8 : |  decl_scope  | type: cgc_size_t, var: start
9 : |  decl_scope  | type: cgc_size_t, var: end
10 : |  decl_scope  | type: unsigned long, var: tlv_size_0
11 : |  decl_scope  | type: int, var: diff
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: ac_queue_head
1 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
3 : | assign_scope | type: unsigned long, value: sizeof ( word )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; } ] 
p_decls = [('char *', 'newbuf', None)]
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'newbuf', None), ('void *', 'ud', None)]
assigns = []
compares = []
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = []
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = ['', '', '', '']
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('char *', 'newbuf', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
===> context { char * newbuf ; { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } break ; }
ignore sibs: ['}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: char *, var: newbuf
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
7 : |  decl_scope  | type: cgc_size_t, var: start
8 : |  decl_scope  | type: cgc_size_t, var: end
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: diff
11 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: ac_queue_head
1 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
3 : | assign_scope | type: unsigned long, value: sizeof ( word )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; } ] 
p_decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )')]
compares = []
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )')]
compares = []
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )')]
compares = []
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )')]
compares = []
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('const char *', 'tlv13', None), ('const char *', 'tlv11', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('int', 'diff', '', 'cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
===> context { const char * tlv13 = word ; const char * tlv11 = word_list [ j ] . correct ; diff = cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) ; }
ignore sibs: ['{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; }', 'if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } }', '{ void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }', 'if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv13
1 : |  decl_scope  | type: const char *, var: tlv11
2 : |  decl_scope  | type: void *, var: ud
3 : |  decl_scope  | type: char *, var: word
4 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
5 : |  decl_scope  | type: int, var: dummy
6 : |  decl_scope  | type: cgc_size_t, var: i
7 : |  decl_scope  | type: int, var: j
8 : |  decl_scope  | type: cgc_size_t, var: start
9 : |  decl_scope  | type: cgc_size_t, var: end
10 : |  decl_scope  | type: unsigned long, var: tlv_size_0
11 : |  decl_scope  | type: int, var: diff
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: int, value: cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; } ] 
p_decls = [('mutex_t *', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
compares = ['', '', '', '']
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('mutex_t *', 'tlv9', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
===> context { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_lock ( tlv9 ) ; }
ignore sibs: ['if ( diff < 0 ) { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } }', '{ void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }', 'if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv9
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
7 : |  decl_scope  | type: cgc_size_t, var: start
8 : |  decl_scope  | type: cgc_size_t, var: end
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: diff
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.IterationStatementContext'>
 scope [9] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [10] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'ud', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
===> context { { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } }
ignore sibs: ['{ void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }', 'if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: ud
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: int, var: dummy
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: int, var: j
6 : |  decl_scope  | type: cgc_size_t, var: start
7 : |  decl_scope  | type: cgc_size_t, var: end
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: diff
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: cgc_size_t, value: ac_queue_head
1 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
3 : | assign_scope | type: unsigned long, value: sizeof ( word )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: int, value: diff
9 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; } ] 
p_decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.IterationStatementContext'>
 scope [10] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [11] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end')]
compares = ['', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'tlv17', None), ('void *', 'tlv16', None), ('cgc_size_t', 'tlv15', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv17', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv16', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv15', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
===> context { void * tlv17 ; tlv17 = & ac_buffer [ end + diff ] ; void * tlv16 ; tlv16 = & ac_buffer [ end ] ; cgc_size_t tlv15 ; tlv15 = ac_idx - end ; cgc_memmove ( tlv17 , tlv16 , tlv15 ) ; }
ignore sibs: ['}', '{ void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }', 'if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: tlv17
1 : |  decl_scope  | type: void *, var: tlv16
2 : |  decl_scope  | type: cgc_size_t, var: tlv15
3 : |  decl_scope  | type: void *, var: ud
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: int, var: dummy
7 : |  decl_scope  | type: cgc_size_t, var: i
8 : |  decl_scope  | type: int, var: j
9 : |  decl_scope  | type: cgc_size_t, var: start
10 : |  decl_scope  | type: cgc_size_t, var: end
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: diff
13 : |  decl_scope  | type: int, var: tlv1
14 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: void *, value: & ac_buffer [ end + diff ]
1 : | assign_scope | type: void *, value: & ac_buffer [ end ]
2 : | assign_scope | type: cgc_size_t, value: ac_idx - end
3 : | assign_scope | type: cgc_size_t, value: ac_queue_head
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
5 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
6 : | assign_scope | type: unsigned long, value: sizeof ( word )
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: int, value: diff
9 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; } ] 
p_decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff')]
compares = []
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff')]
compares = []
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff')]
compares = []
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff')]
compares = []
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff')]
compares = ['', '', '', '']
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv14', None), ('cgc_size_t', 'tlv12', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv14', '', 'ac_buffer'), ('cgc_size_t', 'tlv12', '', 'ac_idx + 1 + diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
===> context { void * tlv14 ; tlv14 = ac_buffer ; cgc_size_t tlv12 ; tlv12 = ac_idx + 1 + diff ; newbuf = cgc_realloc ( tlv14 , tlv12 ) ; }
ignore sibs: ['if ( newbuf != NULL ) { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: tlv14
1 : |  decl_scope  | type: cgc_size_t, var: tlv12
2 : |  decl_scope  | type: void *, var: ud
3 : |  decl_scope  | type: char *, var: word
4 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
5 : |  decl_scope  | type: int, var: dummy
6 : |  decl_scope  | type: cgc_size_t, var: i
7 : |  decl_scope  | type: int, var: j
8 : |  decl_scope  | type: cgc_size_t, var: start
9 : |  decl_scope  | type: cgc_size_t, var: end
10 : |  decl_scope  | type: unsigned long, var: tlv_size_0
11 : |  decl_scope  | type: int, var: diff
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: void *, value: ac_buffer
1 : | assign_scope | type: cgc_size_t, value: ac_idx + 1 + diff
2 : | assign_scope | type: cgc_size_t, value: ac_queue_head
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
5 : | assign_scope | type: unsigned long, value: sizeof ( word )
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.IterationStatementContext'>
 scope [9] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [10] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'ud', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
===> context { ac_buffer = newbuf ; if ( diff > 0 ) { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ac_idx += diff ; }
ignore sibs: ['{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: ud
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: int, var: dummy
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: int, var: j
6 : |  decl_scope  | type: cgc_size_t, var: start
7 : |  decl_scope  | type: cgc_size_t, var: end
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: diff
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: UNDEF, value: newbuf
1 : | assign_scope | type: UNDEF, value: diff
2 : | assign_scope | type: cgc_size_t, value: ac_queue_head
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
5 : | assign_scope | type: unsigned long, value: sizeof ( word )
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: char *, value: newbuf
9 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.IterationStatementContext'>
 scope [9] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [10] : <class 'CParser.CParser.IterationStatementContext'>
 scope [11] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [12] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'ud', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = []
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '', '', '']
===> context { { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } }
ignore sibs: ['{ void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; }', 'ac_idx += diff ;', '}', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: ud
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: int, var: dummy
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: int, var: j
6 : |  decl_scope  | type: cgc_size_t, var: start
7 : |  decl_scope  | type: cgc_size_t, var: end
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: diff
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: cgc_size_t, value: ac_queue_head
1 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
3 : | assign_scope | type: unsigned long, value: sizeof ( word )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: UNDEF, value: newbuf
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: char *, value: newbuf
9 : |compare_scopes| type: char *, value: NULL
10 : |compare_scopes| type: int, value: diff
11 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; } ] 
p_decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.IterationStatementContext'>
 scope [10] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [11] : <class 'CParser.CParser.IterationStatementContext'>
 scope [12] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [13] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end')]
compares = []
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end')]
compares = ['', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'tlv23', None), ('void *', 'tlv22', None), ('cgc_size_t', 'tlv21', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv23', '', '& ac_buffer [ end + diff ]'), ('void *', 'tlv22', '', '& ac_buffer [ end ]'), ('cgc_size_t', 'tlv21', '', 'ac_idx - end'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '', '', '']
===> context { void * tlv23 ; tlv23 = & ac_buffer [ end + diff ] ; void * tlv22 ; tlv22 = & ac_buffer [ end ] ; cgc_size_t tlv21 ; tlv21 = ac_idx - end ; cgc_memmove ( tlv23 , tlv22 , tlv21 ) ; }
ignore sibs: ['}', '{ void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; }', 'ac_idx += diff ;', '}', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: tlv23
1 : |  decl_scope  | type: void *, var: tlv22
2 : |  decl_scope  | type: cgc_size_t, var: tlv21
3 : |  decl_scope  | type: void *, var: ud
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: int, var: dummy
7 : |  decl_scope  | type: cgc_size_t, var: i
8 : |  decl_scope  | type: int, var: j
9 : |  decl_scope  | type: cgc_size_t, var: start
10 : |  decl_scope  | type: cgc_size_t, var: end
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: diff
13 : |  decl_scope  | type: int, var: tlv1
14 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: void *, value: & ac_buffer [ end + diff ]
1 : | assign_scope | type: void *, value: & ac_buffer [ end ]
2 : | assign_scope | type: cgc_size_t, value: ac_idx - end
3 : | assign_scope | type: cgc_size_t, value: ac_queue_head
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
5 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
6 : | assign_scope | type: unsigned long, value: sizeof ( word )
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: UNDEF, value: newbuf
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: char *, value: newbuf
9 : |compare_scopes| type: char *, value: NULL
10 : |compare_scopes| type: int, value: diff
11 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; } ] 
p_decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.IterationStatementContext'>
 scope [10] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [11] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
compares = []
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
compares = []
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
compares = []
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
compares = []
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
compares = ['', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '']
===> context { void * tlv20 ; tlv20 = & ac_buffer [ start ] ; void * tlv19 ; tlv19 = word_list [ j ] . correct ; cgc_size_t tlv18 ; { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ; }
ignore sibs: ['ac_idx += diff ;', '}', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: tlv20
1 : |  decl_scope  | type: void *, var: tlv19
2 : |  decl_scope  | type: cgc_size_t, var: tlv18
3 : |  decl_scope  | type: void *, var: ud
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: int, var: dummy
7 : |  decl_scope  | type: cgc_size_t, var: i
8 : |  decl_scope  | type: int, var: j
9 : |  decl_scope  | type: cgc_size_t, var: start
10 : |  decl_scope  | type: cgc_size_t, var: end
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: diff
13 : |  decl_scope  | type: int, var: tlv1
14 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: void *, value: & ac_buffer [ start ]
1 : | assign_scope | type: void *, value: word_list [ j ] . correct
2 : | assign_scope | type: cgc_size_t, value: ac_queue_head
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
5 : | assign_scope | type: unsigned long, value: sizeof ( word )
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: UNDEF, value: newbuf
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: char *, value: newbuf
9 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; } ] 
p_decls = [('const char *', 'tlv24', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.IterationStatementContext'>
 scope [9] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [10] : <class 'CParser.CParser.IterationStatementContext'>
 scope [11] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [12] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )')]
compares = []
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )')]
compares = []
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )')]
compares = []
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )')]
compares = []
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = ['', '', '', '', '', '', '', '', '', '']
decls = [('const char *', 'tlv24', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None), ('void *', 'tlv20', None), ('void *', 'tlv19', None), ('cgc_size_t', 'tlv18', None)]
assigns = [('cgc_size_t', 'tlv18', '', 'cgc_strlen ( tlv24 )'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('void *', 'tlv20', '', '& ac_buffer [ start ]'), ('void *', 'tlv19', '', 'word_list [ j ] . correct')]
compares = ['', '', '', '', '', '', '', '', '', '']
===> context { const char * tlv24 = word_list [ j ] . correct ; tlv18 = cgc_strlen ( tlv24 ) ; }
ignore sibs: ['cgc_memcpy ( tlv20 , tlv19 , tlv18 ) ;', '}', 'ac_idx += diff ;', '}', '{ mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }', 'break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv24
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
7 : |  decl_scope  | type: cgc_size_t, var: start
8 : |  decl_scope  | type: cgc_size_t, var: end
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: diff
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: char *, var: newbuf
13 : |  decl_scope  | type: void *, var: tlv20
14 : |  decl_scope  | type: void *, var: tlv19
15 : |  decl_scope  | type: cgc_size_t, var: tlv18
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv24 )
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: UNDEF, value: newbuf
8 : | assign_scope | type: void *, value: & ac_buffer [ start ]
9 : | assign_scope | type: void *, value: word_list [ j ] . correct
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
8 : |compare_scopes| type: char *, value: newbuf
9 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; } ] 
p_decls = [('mutex_t *', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex')]
compares = ['', '', '', '']
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '']
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
decls = [('mutex_t *', 'tlv10', None), ('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None), ('int', 'tlv1', None), ('char *', 'newbuf', None)]
assigns = [('mutex_t *', 'tlv10', '', '& ac_mutex'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0')]
compares = ['', '', '', '', '', '', '', '']
===> context { mutex_t * tlv10 ; tlv10 = & ac_mutex ; cgc_mutex_unlock ( tlv10 ) ; }
ignore sibs: ['break ;', '}', '}', 'for ( j = 0 , i = ac_queue_head ; j < ac_queue_count ; j ++ , i = ( i + 1 ) % MAX_QUEUE ) { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }', 'ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv10
1 : |  decl_scope  | type: void *, var: ud
2 : |  decl_scope  | type: char *, var: word
3 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
4 : |  decl_scope  | type: int, var: dummy
5 : |  decl_scope  | type: cgc_size_t, var: i
6 : |  decl_scope  | type: int, var: j
7 : |  decl_scope  | type: cgc_size_t, var: start
8 : |  decl_scope  | type: cgc_size_t, var: end
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: diff
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: cgc_size_t, value: ac_queue_head
2 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
4 : | assign_scope | type: unsigned long, value: sizeof ( word )
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: cgc_num_words
6 : |compare_scopes| type: int, value: tlv1
7 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'ud', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff')]
compares = []
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0')]
compares = ['', '', '', '']
decls = [('void *', 'ud', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'dummy', None), ('cgc_size_t', 'i', None), ('int', 'j', None), ('cgc_size_t', 'start', None), ('cgc_size_t', 'end', None), ('unsigned long', 'tlv_size_0', None), ('int', 'diff', None)]
assigns = [('UNDEF', 'ac_queue ', '[ i ] . start', 'diff'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'diff'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'start', '', 'ac_queue [ i ] . start'), ('cgc_size_t', 'end', '', 'ac_queue [ i ] . end'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( word )'), ('int', 'diff', '', '0'), ('int', 'j', '', '0'), ('cgc_size_t', 'i', '', 'ac_queue_head'), ('cgc_size_t', 'i', '', '( i + 1 ) % MAX_QUEUE')]
compares = ['', '', '', '', '', '']
===> context { ac_queue [ i ] . start += diff ; ac_queue [ i ] . end += diff ; }
ignore sibs: ['ac_queue_head = ( ac_queue_head + 1 ) % MAX_QUEUE ;', 'ac_queue_count -- ;', '}', 'cgc_filaments_yield ( ) ;', '}', '}']
0 : |  decl_scope  | type: void *, var: ud
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: int, var: dummy
4 : |  decl_scope  | type: cgc_size_t, var: i
5 : |  decl_scope  | type: int, var: j
6 : |  decl_scope  | type: cgc_size_t, var: start
7 : |  decl_scope  | type: cgc_size_t, var: end
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: diff
0 : | assign_scope | type: UNDEF, value: diff
1 : | assign_scope | type: UNDEF, value: diff
2 : | assign_scope | type: cgc_size_t, value: ac_queue_head
3 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . start
4 : | assign_scope | type: cgc_size_t, value: ac_queue [ i ] . end
5 : | assign_scope | type: unsigned long, value: sizeof ( word )
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: cgc_size_t, value: ac_queue_head
9 : | assign_scope | type: cgc_size_t, value: ( i + 1 ) % MAX_QUEUE
0 : |compare_scopes| type: UNDEF, value: ac_buffer
1 : |compare_scopes| type: UNDEF, value: NULL
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: 0
4 : |compare_scopes| type: int, value: j
5 : |compare_scopes| type: int, value: ac_queue_count
=======END=======
compound scope 0 : { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; }
compound scope 1 : { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } }
compound scope 2 : { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } }
compound scope 3 : { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; }
compound scope 4 : { goto fail ; }
compound scope 5 : { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; }
compound scope 6 : { count ++ ; break ; }
compound scope 7 : { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }
compound scope 8 : { goto fail ; }
compound scope 9 : { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }
compound scope 10 : { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }
compound scope 11 : { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }
compound scope 12 : { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }
compound scope 13 : { cgc_filaments_yield ( ) ; }
compound scope 14 : { break ; }
compound scope 15 : { cgc_filaments_yield ( ) ; }
compound scope 16 : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }
compound scope 17 : { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }
len(compound_scope) : 18
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; } ] 
p_decls = [('cgc_size_t', 'rx', None), ('char *', 'buf', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'rx', None), ('char *', 'buf', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('char *', 'buf', '', 'ac_buffer'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
===> context { cgc_size_t rx ; ac_queue_count = ac_queue_head = ac_queue_tail = ac_idx = 0 ; ac_buffer = NULL ; while ( 1 ) { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; } char * buf ; buf = ac_buffer ; ac_buffer = NULL ; buf [ ac_idx - 1 ] = 0 ; return buf ; fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } cgc_free ( ac_buffer ) ; ac_buffer = NULL ; { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } return NULL ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: rx
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: int, var: fd
3 : |  decl_scope  | type: char, var: term
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: char *, value: ac_buffer
6 : | assign_scope | type: UNDEF, value: NULL
7 : | assign_scope | type: UNDEF, value: 0
8 : | assign_scope | type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } } ] 
p_decls = [('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = []
decls = [('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
===> context { cgc_size_t count ; count = 0 ; char word [ MAX_AC_LEN ] ; for ( count = 0 ; count < MAX_AC_LEN ; count ++ ) { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } char * newbuf ; { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } if ( newbuf == NULL ) { goto fail ; } { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ac_buffer = newbuf ; { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ac_idx += count ; ac_buffer [ ac_idx ] = 0 ; { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; } }
ignore sibs: ['while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: count
1 : |  decl_scope  | type: char *, var: word
2 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
3 : |  decl_scope  | type: char *, var: newbuf
4 : |  decl_scope  | type: int, var: fd
5 : |  decl_scope  | type: char, var: term
6 : |  decl_scope  | type: cgc_size_t, var: rx
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: UNDEF, value: newbuf
2 : | assign_scope | type: UNDEF, value: count
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
5 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
6 : | assign_scope | type: UNDEF, value: ac_idx = 0
7 : | assign_scope | type: UNDEF, value: 0
8 : | assign_scope | type: UNDEF, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } } ] 
p_decls = [('int', 'tlv1', None), ('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
decls = [('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
===> context { int tlv1 ; { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } if ( tlv1 != 0 || rx == 0 ) { goto fail ; } int tlv2 ; { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; } }
ignore sibs: ['char * newbuf ;', '{ void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }', 'if ( newbuf == NULL ) { goto fail ; }', '{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: int, var: tlv2
2 : |  decl_scope  | type: int, var: fd
3 : |  decl_scope  | type: char, var: term
4 : |  decl_scope  | type: cgc_size_t, var: rx
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: char *, var: word
7 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; } ] 
p_decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx')]
compares = []
decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
decls = [('int', 'tlv15', None), ('void *', 'tlv14', None), ('cgc_size_t', 'tlv13', None), ('cgc_size_t *', 'tlv12', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'tlv1', None)]
assigns = [('int', 'tlv15', '', 'fd'), ('void *', 'tlv14', '', '& word [ count ]'), ('cgc_size_t', 'tlv13', '', '1'), ('cgc_size_t *', 'tlv12', '', '& rx'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
===> context { int tlv15 ; tlv15 = fd ; void * tlv14 ; tlv14 = & word [ count ] ; cgc_size_t tlv13 ; tlv13 = 1 ; cgc_size_t * tlv12 ; tlv12 = & rx ; tlv1 = cgc_receive ( tlv15 , tlv14 , tlv13 , tlv12 ) ; }
ignore sibs: ['if ( tlv1 != 0 || rx == 0 ) { goto fail ; }', 'int tlv2 ;', '{ int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; }', 'if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; }', '}', 'char * newbuf ;', '{ void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }', 'if ( newbuf == NULL ) { goto fail ; }', '{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: tlv15
1 : |  decl_scope  | type: void *, var: tlv14
2 : |  decl_scope  | type: cgc_size_t, var: tlv13
3 : |  decl_scope  | type: cgc_size_t *, var: tlv12
4 : |  decl_scope  | type: int, var: fd
5 : |  decl_scope  | type: char, var: term
6 : |  decl_scope  | type: cgc_size_t, var: rx
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: char *, var: word
9 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: fd
1 : | assign_scope | type: void *, value: & word [ count ]
2 : | assign_scope | type: cgc_size_t, value: 1
3 : | assign_scope | type: cgc_size_t *, value: & rx
4 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
5 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
6 : | assign_scope | type: UNDEF, value: ac_idx = 0
7 : | assign_scope | type: UNDEF, value: 0
8 : | assign_scope | type: UNDEF, value: NULL
9 : | assign_scope | type: cgc_size_t, value: 0
10 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { goto fail ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { goto fail ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '', '', '', '', '']
===> context { goto fail ; }
ignore sibs: ['int tlv2 ;', '{ int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; }', 'if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; }', '}', 'char * newbuf ;', '{ void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }', 'if ( newbuf == NULL ) { goto fail ; }', '{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char, var: term
2 : |  decl_scope  | type: cgc_size_t, var: rx
3 : |  decl_scope  | type: cgc_size_t, var: count
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
2 : |compare_scopes| type: int, value: tlv1
3 : |compare_scopes| type: int, value: 0
4 : |compare_scopes| type: cgc_size_t, value: rx
5 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; } ] 
p_decls = [('int', 'tlv16', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv16', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('int', 'tlv16', '', 'word [ count ]')]
compares = []
decls = [('int', 'tlv16', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('int', 'tlv16', '', 'word [ count ]'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'tlv16', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('int', 'tlv16', '', 'word [ count ]'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'tlv16', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('int', 'tlv16', '', 'word [ count ]'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
decls = [('int', 'tlv16', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('int', 'tlv16', '', 'word [ count ]'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
decls = [('int', 'tlv16', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('int', 'tlv16', '', 'word [ count ]'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
===> context { int tlv16 ; tlv16 = word [ count ] ; tlv2 = cgc_isalpha ( tlv16 ) ; }
ignore sibs: ['if ( word [ count ] == term || ! tlv2 ) { count ++ ; break ; }', '}', 'char * newbuf ;', '{ void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }', 'if ( newbuf == NULL ) { goto fail ; }', '{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: tlv16
1 : |  decl_scope  | type: int, var: fd
2 : |  decl_scope  | type: char, var: term
3 : |  decl_scope  | type: cgc_size_t, var: rx
4 : |  decl_scope  | type: cgc_size_t, var: count
5 : |  decl_scope  | type: char *, var: word
6 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: int, value: word [ count ]
1 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
3 : | assign_scope | type: UNDEF, value: ac_idx = 0
4 : | assign_scope | type: UNDEF, value: 0
5 : | assign_scope | type: UNDEF, value: NULL
6 : | assign_scope | type: cgc_size_t, value: 0
7 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { count ++ ; break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { count ++ ; break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '', '', '']
===> context { count ++ ; break ; }
ignore sibs: ['}', 'char * newbuf ;', '{ void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }', 'if ( newbuf == NULL ) { goto fail ; }', '{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char, var: term
2 : |  decl_scope  | type: cgc_size_t, var: rx
3 : |  decl_scope  | type: cgc_size_t, var: count
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: MAX_AC_LEN
2 : |compare_scopes| type: char *, value: word [ count ]
3 : |compare_scopes| type: char *, value: term
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; } ] 
p_decls = [('void *', 'tlv11', None), ('cgc_size_t', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv11', None), ('cgc_size_t', 'tlv10', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('void *', 'tlv11', '', 'ac_buffer'), ('cgc_size_t', 'tlv10', '', 'ac_idx + count + 1')]
compares = []
decls = [('void *', 'tlv11', None), ('cgc_size_t', 'tlv10', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('void *', 'tlv11', '', 'ac_buffer'), ('cgc_size_t', 'tlv10', '', 'ac_idx + count + 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('void *', 'tlv11', None), ('cgc_size_t', 'tlv10', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('void *', 'tlv11', '', 'ac_buffer'), ('cgc_size_t', 'tlv10', '', 'ac_idx + count + 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('void *', 'tlv11', None), ('cgc_size_t', 'tlv10', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv11', '', 'ac_buffer'), ('cgc_size_t', 'tlv10', '', 'ac_idx + count + 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
===> context { void * tlv11 ; tlv11 = ac_buffer ; cgc_size_t tlv10 ; tlv10 = ac_idx + count + 1 ; newbuf = cgc_realloc ( tlv11 , tlv10 ) ; }
ignore sibs: ['if ( newbuf == NULL ) { goto fail ; }', '{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: void *, var: tlv11
1 : |  decl_scope  | type: cgc_size_t, var: tlv10
2 : |  decl_scope  | type: int, var: fd
3 : |  decl_scope  | type: char, var: term
4 : |  decl_scope  | type: cgc_size_t, var: rx
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: char *, var: word
7 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
8 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: void *, value: ac_buffer
1 : | assign_scope | type: cgc_size_t, value: ac_idx + count + 1
2 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
3 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
4 : | assign_scope | type: UNDEF, value: ac_idx = 0
5 : | assign_scope | type: UNDEF, value: 0
6 : | assign_scope | type: UNDEF, value: NULL
7 : | assign_scope | type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { goto fail ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { goto fail ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = ['', '']
===> context { goto fail ; }
ignore sibs: ['{ mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }', 'ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char, var: term
2 : |  decl_scope  | type: cgc_size_t, var: rx
3 : |  decl_scope  | type: cgc_size_t, var: count
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: char *, value: newbuf
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; } ] 
p_decls = [('mutex_t *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv5', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('mutex_t *', 'tlv5', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv5', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('mutex_t *', 'tlv5', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('mutex_t *', 'tlv5', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('mutex_t *', 'tlv5', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('mutex_t *', 'tlv5', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('mutex_t *', 'tlv5', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0')]
compares = []
===> context { mutex_t * tlv5 ; tlv5 = & ac_mutex ; cgc_mutex_lock ( tlv5 ) ; }
ignore sibs: ['ac_buffer = newbuf ;', '{ void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }', 'ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv5
1 : |  decl_scope  | type: int, var: fd
2 : |  decl_scope  | type: char, var: term
3 : |  decl_scope  | type: cgc_size_t, var: rx
4 : |  decl_scope  | type: cgc_size_t, var: count
5 : |  decl_scope  | type: char *, var: word
6 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
7 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
3 : | assign_scope | type: UNDEF, value: ac_idx = 0
4 : | assign_scope | type: UNDEF, value: 0
5 : | assign_scope | type: UNDEF, value: NULL
6 : | assign_scope | type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; } ] 
p_decls = [('void *', 'tlv8', None), ('void *', 'tlv7', None), ('cgc_size_t', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv8', None), ('void *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('void *', 'tlv8', '', '& ac_buffer [ ac_idx ]'), ('void *', 'tlv7', '', 'word'), ('cgc_size_t', 'tlv6', '', 'count')]
compares = []
decls = [('void *', 'tlv8', None), ('void *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('void *', 'tlv8', '', '& ac_buffer [ ac_idx ]'), ('void *', 'tlv7', '', 'word'), ('cgc_size_t', 'tlv6', '', 'count'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('void *', 'tlv8', None), ('void *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('void *', 'tlv8', '', '& ac_buffer [ ac_idx ]'), ('void *', 'tlv7', '', 'word'), ('cgc_size_t', 'tlv6', '', 'count'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('void *', 'tlv8', None), ('void *', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('void *', 'tlv8', '', '& ac_buffer [ ac_idx ]'), ('void *', 'tlv7', '', 'word'), ('cgc_size_t', 'tlv6', '', 'count'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf')]
compares = []
===> context { void * tlv8 ; tlv8 = & ac_buffer [ ac_idx ] ; void * tlv7 ; tlv7 = word ; cgc_size_t tlv6 ; tlv6 = count ; cgc_memcpy ( tlv8 , tlv7 , tlv6 ) ; }
ignore sibs: ['ac_idx += count ;', 'ac_buffer [ ac_idx ] = 0 ;', '{ mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }', 'if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: void *, var: tlv8
1 : |  decl_scope  | type: void *, var: tlv7
2 : |  decl_scope  | type: cgc_size_t, var: tlv6
3 : |  decl_scope  | type: int, var: fd
4 : |  decl_scope  | type: char, var: term
5 : |  decl_scope  | type: cgc_size_t, var: rx
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: char *, var: word
8 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
9 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: void *, value: & ac_buffer [ ac_idx ]
1 : | assign_scope | type: void *, value: word
2 : | assign_scope | type: cgc_size_t, value: count
3 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
4 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
5 : | assign_scope | type: UNDEF, value: ac_idx = 0
6 : | assign_scope | type: UNDEF, value: 0
7 : | assign_scope | type: UNDEF, value: NULL
8 : | assign_scope | type: cgc_size_t, value: 0
9 : | assign_scope | type: UNDEF, value: newbuf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; } ] 
p_decls = [('mutex_t *', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv9', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('mutex_t *', 'tlv9', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('mutex_t *', 'tlv9', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = []
===> context { mutex_t * tlv9 ; tlv9 = & ac_mutex ; cgc_mutex_unlock ( tlv9 ) ; }
ignore sibs: ['if ( count > 1 ) { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv9
1 : |  decl_scope  | type: int, var: fd
2 : |  decl_scope  | type: char, var: term
3 : |  decl_scope  | type: cgc_size_t, var: rx
4 : |  decl_scope  | type: cgc_size_t, var: count
5 : |  decl_scope  | type: char *, var: word
6 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
7 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
3 : | assign_scope | type: UNDEF, value: ac_idx = 0
4 : | assign_scope | type: UNDEF, value: 0
5 : | assign_scope | type: UNDEF, value: NULL
6 : | assign_scope | type: cgc_size_t, value: 0
7 : | assign_scope | type: UNDEF, value: newbuf
8 : | assign_scope | type: UNDEF, value: count
9 : | assign_scope | type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; } ] 
p_decls = [('cgc_size_t', 'i', None)]
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'i', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_tail'), ('UNDEF', 'ac_queue_tail', '', '( ac_queue_tail + 1 ) % MAX_QUEUE'), ('UNDEF', 'ac_queue ', '[ i ] . start', 'ac_idx - count'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'ac_idx - 1')]
compares = []
decls = [('cgc_size_t', 'i', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_tail'), ('UNDEF', 'ac_queue_tail', '', '( ac_queue_tail + 1 ) % MAX_QUEUE'), ('UNDEF', 'ac_queue ', '[ i ] . start', 'ac_idx - count'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'ac_idx - 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('cgc_size_t', 'i', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_tail'), ('UNDEF', 'ac_queue_tail', '', '( ac_queue_tail + 1 ) % MAX_QUEUE'), ('UNDEF', 'ac_queue ', '[ i ] . start', 'ac_idx - count'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'ac_idx - 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('cgc_size_t', 'i', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_tail'), ('UNDEF', 'ac_queue_tail', '', '( ac_queue_tail + 1 ) % MAX_QUEUE'), ('UNDEF', 'ac_queue ', '[ i ] . start', 'ac_idx - count'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'ac_idx - 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = []
decls = [('cgc_size_t', 'i', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('cgc_size_t', 'i', '', 'ac_queue_tail'), ('UNDEF', 'ac_queue_tail', '', '( ac_queue_tail + 1 ) % MAX_QUEUE'), ('UNDEF', 'ac_queue ', '[ i ] . start', 'ac_idx - count'), ('UNDEF', 'ac_queue ', '[ i ] . end', 'ac_idx - 1'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = ['', '']
===> context { while ( ac_queue_count >= MAX_QUEUE ) { cgc_filaments_yield ( ) ; } cgc_size_t i ; i = ac_queue_tail ; ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ; ac_queue_count ++ ; ac_queue [ i ] . start = ac_idx - count ; ac_queue [ i ] . end = ac_idx - 1 ; }
ignore sibs: ['if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: i
1 : |  decl_scope  | type: int, var: fd
2 : |  decl_scope  | type: char, var: term
3 : |  decl_scope  | type: cgc_size_t, var: rx
4 : |  decl_scope  | type: cgc_size_t, var: count
5 : |  decl_scope  | type: char *, var: word
6 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
7 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: cgc_size_t, value: ac_queue_tail
1 : | assign_scope | type: UNDEF, value: ( ac_queue_tail + 1 ) % MAX_QUEUE
2 : | assign_scope | type: UNDEF, value: ac_idx - count
3 : | assign_scope | type: UNDEF, value: ac_idx - 1
4 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
5 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
6 : | assign_scope | type: UNDEF, value: ac_idx = 0
7 : | assign_scope | type: UNDEF, value: 0
8 : | assign_scope | type: UNDEF, value: NULL
9 : | assign_scope | type: cgc_size_t, value: 0
10 : | assign_scope | type: UNDEF, value: newbuf
11 : | assign_scope | type: UNDEF, value: count
12 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_filaments_yield ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_filaments_yield ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = ['', '']
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = ['', '', '', '']
===> context { cgc_filaments_yield ( ) ; }
ignore sibs: ['cgc_size_t i ;', 'i = ac_queue_tail ;', 'ac_queue_tail = ( ac_queue_tail + 1 ) % MAX_QUEUE ;', 'ac_queue_count ++ ;', 'ac_queue [ i ] . start = ac_idx - count ;', 'ac_queue [ i ] . end = ac_idx - 1 ;', '}', 'if ( ac_buffer [ ac_idx - 1 ] == term ) { break ; }', '}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char, var: term
2 : |  decl_scope  | type: cgc_size_t, var: rx
3 : |  decl_scope  | type: cgc_size_t, var: count
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: UNDEF, value: newbuf
7 : | assign_scope | type: UNDEF, value: count
8 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 1
2 : |compare_scopes| type: UNDEF, value: ac_queue_count
3 : |compare_scopes| type: UNDEF, value: MAX_QUEUE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('cgc_size_t', 'count', None), ('char *', 'word', ' [ MAX_AC_LEN ]'), ('char', 'word [ MAX_AC_LEN ]', None), ('char *', 'newbuf', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('cgc_size_t', 'count', '', '0'), ('UNDEF', 'ac_buffer', '', 'newbuf'), ('UNDEF', 'ac_idx', '', 'count'), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', '0')]
compares = ['', '']
===> context { break ; }
ignore sibs: ['}', 'while ( ac_queue_count > 0 ) { cgc_filaments_yield ( ) ; }', 'char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char, var: term
2 : |  decl_scope  | type: cgc_size_t, var: rx
3 : |  decl_scope  | type: cgc_size_t, var: count
4 : |  decl_scope  | type: char *, var: word
5 : |  decl_scope  | type: char, var: word [ MAX_AC_LEN ]
6 : |  decl_scope  | type: char *, var: newbuf
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: UNDEF, value: newbuf
7 : | assign_scope | type: UNDEF, value: count
8 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: char, value: ac_buffer [ ac_idx - 1 ]
1 : |compare_scopes| type: char, value: term
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_filaments_yield ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_filaments_yield ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'fd', None), ('char', 'term', None)]
assigns = []
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
decls = [('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None)]
assigns = [('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = ['', '']
===> context { cgc_filaments_yield ( ) ; }
ignore sibs: ['char * buf ;', 'buf = ac_buffer ;', 'ac_buffer = NULL ;', 'buf [ ac_idx - 1 ] = 0 ;', 'return buf ;', 'fail : { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }', 'cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: int, var: fd
1 : |  decl_scope  | type: char, var: term
2 : |  decl_scope  | type: cgc_size_t, var: rx
0 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
1 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_idx = 0
3 : | assign_scope | type: UNDEF, value: 0
4 : | assign_scope | type: UNDEF, value: NULL
0 : |compare_scopes| type: UNDEF, value: ac_queue_count
1 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; } ] 
p_decls = [('mutex_t *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv4', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('mutex_t *', 'tlv4', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv4', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('char *', 'buf', None)]
assigns = [('mutex_t *', 'tlv4', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('char *', 'buf', '', 'ac_buffer'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', '0')]
compares = []
===> context { mutex_t * tlv4 ; tlv4 = & ac_mutex ; cgc_mutex_lock ( tlv4 ) ; }
ignore sibs: ['cgc_free ( ac_buffer ) ;', 'ac_buffer = NULL ;', '{ mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }', 'return NULL ;', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv4
1 : |  decl_scope  | type: int, var: fd
2 : |  decl_scope  | type: char, var: term
3 : |  decl_scope  | type: cgc_size_t, var: rx
4 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
3 : | assign_scope | type: UNDEF, value: ac_idx = 0
4 : | assign_scope | type: UNDEF, value: 0
5 : | assign_scope | type: UNDEF, value: NULL
6 : | assign_scope | type: char *, value: ac_buffer
7 : | assign_scope | type: UNDEF, value: NULL
8 : | assign_scope | type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; } ] 
p_decls = [('mutex_t *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('mutex_t *', 'tlv3', None), ('int', 'fd', None), ('char', 'term', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex')]
compares = []
decls = [('mutex_t *', 'tlv3', None), ('int', 'fd', None), ('char', 'term', None), ('cgc_size_t', 'rx', None), ('char *', 'buf', None)]
assigns = [('mutex_t *', 'tlv3', '', '& ac_mutex'), ('UNDEF', 'ac_queue_count', '', 'ac_queue_head = ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_head', '', 'ac_queue_tail = ac_idx = 0'), ('UNDEF', 'ac_queue_tail', '', 'ac_idx = 0'), ('UNDEF', 'ac_idx', '', '0'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('char *', 'buf', '', 'ac_buffer'), ('UNDEF', 'ac_buffer', '', 'NULL'), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', '0'), ('UNDEF', 'ac_buffer', '', 'NULL')]
compares = []
===> context { mutex_t * tlv3 ; tlv3 = & ac_mutex ; cgc_mutex_unlock ( tlv3 ) ; }
ignore sibs: ['return NULL ;', '}']
0 : |  decl_scope  | type: mutex_t *, var: tlv3
1 : |  decl_scope  | type: int, var: fd
2 : |  decl_scope  | type: char, var: term
3 : |  decl_scope  | type: cgc_size_t, var: rx
4 : |  decl_scope  | type: char *, var: buf
0 : | assign_scope | type: mutex_t *, value: & ac_mutex
1 : | assign_scope | type: UNDEF, value: ac_queue_head = ac_queue_tail = ac_idx = 0
2 : | assign_scope | type: UNDEF, value: ac_queue_tail = ac_idx = 0
3 : | assign_scope | type: UNDEF, value: ac_idx = 0
4 : | assign_scope | type: UNDEF, value: 0
5 : | assign_scope | type: UNDEF, value: NULL
6 : | assign_scope | type: char *, value: ac_buffer
7 : | assign_scope | type: UNDEF, value: NULL
8 : | assign_scope | type: UNDEF, value: 0
9 : | assign_scope | type: UNDEF, value: NULL
=======END=======
def_vars[0]: [cgc_ac_init] : <class 'CParser.CParser.DeclarationContext'> : int i ;
sym_lut=>'{'i': 'int'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3dcba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3dc668>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b5e0898>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/4][j=1/3][dd=0/1][k=0/3] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=0/4][j=1/3][dd=0/1][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LIST' - False OR  False
[i=0/4][j=1/3][dd=0/1][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : MAX_AC_LIST (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LIST
 => is literal (False) | is operator (False) MAX_AC_LIST [vtype=None]
----
UNIQ_INIT: ('int','i','None','None');

not valid - int i; i = ((int)i);

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_ac_0_1_0(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(0); }
}
void fix_ingred_ac_0_1_2(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(MAX_AC_LIST); }
}
void fix_ingred_ac_0_1(){
fix_ingred_ac_0_1_0();
fix_ingred_ac_0_1_2();
}

sym_lut=>'{'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3dcba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3dc668>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b5e0898>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b780e48>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b3966d8>)]'
==== Scope 2 ====
void fix_ingred_ac_0_1_0(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(0); }
}
void fix_ingred_ac_0_1_2(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(MAX_AC_LIST); }
}
void fix_ingred_ac_0_1(){
fix_ingred_ac_0_1_0();
fix_ingred_ac_0_1_2();
}
void fix_ingred_ac_0(){
fix_ingred_ac_0_1();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_ac_0_1_0();
void fix_ingred_ac_0_1_2();
void fix_ingred_ac_0_1();
void fix_ingred_ac_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[1]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[2]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[3]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[4]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = typo ;
def_vars[5]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = correct ;
def_vars[6]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv7 = typo ;
def_vars[7]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[8]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv13 = typo ;
def_vars[9]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv12 = word_list [ i ] . typo ;
def_vars[10]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : char * tlv9 ;
def_vars[11]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv8 = typo ;
def_vars[12]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : char * tlv11 ;
def_vars[13]: [cgc_ac_add_custom] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv10 = correct ;
sym_lut=>'{'typo': 'char *', 'correct': 'char *'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int'}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>)]'
sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv4': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b32fba8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3a8438>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3a8198>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=0/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=2/11][dd=1/14][k=0/5] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=1/4][j=2/11][dd=1/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=1/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=2/11][dd=2/14][k=0/5] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=1/4][j=2/11][dd=2/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=2/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=2/11][dd=3/14][k=0/5] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=1/4][j=2/11][dd=3/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=3/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=2/11][dd=7/14][k=0/5] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=1/4][j=2/11][dd=7/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=7/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=2/11][dd=10/14][k=0/5] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=1/4][j=2/11][dd=10/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=10/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=2/11][dd=12/14][k=0/5] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=1/4][j=2/11][dd=12/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=1/4][j=2/11][dd=12/14][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
----
UNIQ_INIT: ('int','i','None','None');

----
UNIQ_INIT: ('int','i','None','None');

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_2_0(){
int i;
    bzero(&i,sizeof(int));
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {char * tlv11; tlv11 = (char *)(0); }
}
void fix_ingred_ac_1_2_3(){
int i;
    bzero(&i,sizeof(int));
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(i); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
    {int tlv4; tlv4 = (int)(i); }
    {char * tlv9; tlv9 = (char *)(i); }
    {char * tlv11; tlv11 = (char *)(i); }
}
void fix_ingred_ac_1_2_4(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(cgc_num_words); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_num_words); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_num_words); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_num_words); }
    {int tlv4; tlv4 = (int)(cgc_num_words); }
    {char * tlv9; tlv9 = (char *)(cgc_num_words); }
    {char * tlv11; tlv11 = (char *)(cgc_num_words); }
}
void fix_ingred_ac_1_2(){
fix_ingred_ac_1_2_0();
fix_ingred_ac_1_2_3();
fix_ingred_ac_1_2_4();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv4': 'int', 'tlv13': 'const char *', 'tlv12': 'const char *'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b32fba8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3a8438>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3a8198>)]'
sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv4': 'int', 'tlv13': 'const char *', 'tlv12': 'const char *'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b32fba8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3a8438>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3a8198>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b271ba8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b271eb8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=0/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
unique : ('int', 'tlv4', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=1/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=2/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=3/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=7/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=10/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=1/4][j=4/11][dd=12/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
not valid - int tlv4; tlv4 = ((int)tlv4);

----
UNIQ_INIT: ('int','tlv4','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_4_5(){
int tlv4;
    bzero(&tlv4,sizeof(int));
    {int i; i = (int)(tlv4); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(tlv4); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv4); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv4); }
    {char * tlv9; tlv9 = (char *)(tlv4); }
    {char * tlv11; tlv11 = (char *)(tlv4); }
}
void fix_ingred_ac_1_4(){
fix_ingred_ac_1_4_5();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4776d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>)]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=0/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
unique : ('const char *', 'tlv5', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=1/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=2/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=3/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=7/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=10/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=1/4][j=5/11][dd=12/14][k=0/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_5_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {int i; i = (int)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv5 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv5 )); }
    {char * tlv11; tlv11 = (char *)(cgc_strlen ( tlv5 )); }
}
void fix_ingred_ac_1_5(){
fix_ingred_ac_1_5_0();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *', 'tlv2': 'cgc_size_t', 'tlv6': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b289908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>)]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=0/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
unique : ('const char *', 'tlv6', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=1/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=2/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=3/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=7/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=10/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=1/4][j=6/11][dd=12/14][k=0/3] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv6','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_6_0(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
    {int i; i = (int)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv6 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv6 )); }
    {char * tlv11; tlv11 = (char *)(cgc_strlen ( tlv6 )); }
}
void fix_ingred_ac_1_6(){
fix_ingred_ac_1_6_0();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *', 'tlv2': 'cgc_size_t', 'tlv6': 'const char *', 'tlv3': 'cgc_size_t', 'tlv7': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3814a8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>)]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=0/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
unique : ('const char *', 'tlv7', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=1/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=2/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=3/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=7/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=10/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=1/4][j=7/11][dd=12/14][k=0/3] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv7','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_7_0(){
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
const char * tlv7 = &tlv7_ref;
    {int i; i = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv7 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv7 )); }
    {char * tlv11; tlv11 = (char *)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_ac_1_7(){
fix_ingred_ac_1_7_0();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *', 'tlv2': 'cgc_size_t', 'tlv6': 'const char *', 'tlv3': 'cgc_size_t', 'tlv7': 'const char *'}'
val_s=>'[]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b366048>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601358>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601c18>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601ba8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601d68>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b506f98>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=0/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
unique : ('cgc_size_t', 'tlv1', None)
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=0/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=0/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
unique : ('cgc_size_t', 'tlv2', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=0/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
unique : ('cgc_size_t', 'tlv3', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=0/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=1/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv1', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=1/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=1/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=1/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv3', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=1/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=2/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv1', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=2/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=2/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=2/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv3', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=2/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=3/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv1', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=3/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=3/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=3/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv3', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=3/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=7/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv1', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=7/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=7/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=7/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv3', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=7/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=10/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv1', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=10/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=10/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=10/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv3', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=10/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/4][j=8/11][dd=12/14][k=2/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv1', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=1/4][j=8/11][dd=12/14][k=3/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=1/4][j=8/11][dd=12/14][k=4/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=1/4][j=8/11][dd=12/14][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'tlv3', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/4][j=8/11][dd=12/14][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
not valid - cgc_size_t tlv1; tlv1 = ((cgc_size_t)tlv1);

----
UNIQ_INIT: ('cgc_size_t','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

UNIQ_INIT: ('cgc_size_t','tlv3','None','None');

----
UNIQ_INIT: ('cgc_size_t','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

UNIQ_INIT: ('cgc_size_t','tlv3','None','None');

not valid - cgc_size_t tlv2; tlv2 = ((cgc_size_t)tlv2);

----
UNIQ_INIT: ('cgc_size_t','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

UNIQ_INIT: ('cgc_size_t','tlv3','None','None');

not valid - cgc_size_t tlv3; tlv3 = ((cgc_size_t)tlv3);

----
UNIQ_INIT: ('cgc_size_t','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

UNIQ_INIT: ('cgc_size_t','tlv3','None','None');

----
UNIQ_INIT: ('cgc_size_t','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','tlv2','None','None');

UNIQ_INIT: ('cgc_size_t','tlv3','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_8_2(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(tlv1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {char * tlv9; tlv9 = (char *)(tlv1); }
    {char * tlv11; tlv11 = (char *)(tlv1); }
}
void fix_ingred_ac_1_8_3(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(MAX_AC_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(MAX_AC_LEN); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(MAX_AC_LEN); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv4; tlv4 = (int)(MAX_AC_LEN); }
    {char * tlv9; tlv9 = (char *)(MAX_AC_LEN); }
    {char * tlv11; tlv11 = (char *)(MAX_AC_LEN); }
}
void fix_ingred_ac_1_8_4(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(tlv2); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(tlv2); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {char * tlv9; tlv9 = (char *)(tlv2); }
    {char * tlv11; tlv11 = (char *)(tlv2); }
}
void fix_ingred_ac_1_8_6(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(tlv3); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(tlv3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv3); }
    {int tlv4; tlv4 = (int)(tlv3); }
    {char * tlv9; tlv9 = (char *)(tlv3); }
    {char * tlv11; tlv11 = (char *)(tlv3); }
}
void fix_ingred_ac_1_8_7(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {char * tlv11; tlv11 = (char *)(0); }
}
void fix_ingred_ac_1_8(){
fix_ingred_ac_1_8_2();
fix_ingred_ac_1_8_3();
fix_ingred_ac_1_8_4();
fix_ingred_ac_1_8_6();
fix_ingred_ac_1_8_7();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *', 'tlv2': 'cgc_size_t', 'tlv6': 'const char *', 'tlv3': 'cgc_size_t', 'tlv7': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *'}'
val_s=>'[('char *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b001668>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b366048>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601358>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601c18>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601ba8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601d68>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b506f98>)]'
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=0/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
unique : ('char *', 'typo', None)
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=1/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
not unique: ('char *', 'typo', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=2/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
not unique: ('char *', 'typo', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=3/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
not unique: ('char *', 'typo', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=7/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
not unique: ('char *', 'typo', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=10/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
not unique: ('char *', 'typo', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].typo' - False OR  False
[i=1/4][j=9/11][dd=12/14][k=0/9] | type: char * ; var : tlv9 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . typo (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,typo
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) typo [vtype=char *]
not unique: ('char *', 'typo', None) ... continue!
----
UNIQ_INIT: ('char *','typo','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_9_0(){
char typo_ref;
    bzero(&typo_ref,1*sizeof(char));
char * typo = &typo_ref;
    {if (word_list){int i; i = (int)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){cgc_size_t tlv1; tlv1 = (cgc_size_t)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){cgc_size_t tlv2; tlv2 = (cgc_size_t)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){cgc_size_t tlv3; tlv3 = (cgc_size_t)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){int tlv4; tlv4 = (int)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){char * tlv9; tlv9 = (char *)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){char * tlv11; tlv11 = (char *)(word_list [ cgc_num_words ] . typo); }}
}
void fix_ingred_ac_1_9(){
fix_ingred_ac_1_9_0();
}

sym_lut=>'{'typo': 'char *', 'correct': 'char *', 'i': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *', 'tlv2': 'cgc_size_t', 'tlv6': 'const char *', 'tlv3': 'cgc_size_t', 'tlv7': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *'}'
val_s=>'[('char *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3f76d8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b048>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b23b7b8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b366048>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601358>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601c18>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601ba8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b601d68>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b506f98>)]'
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=0/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
unique : ('char *', 'correct', None)
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=1/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
not unique: ('char *', 'correct', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=2/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
not unique: ('char *', 'correct', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=3/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
not unique: ('char *', 'correct', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=7/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
not unique: ('char *', 'correct', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=10/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
not unique: ('char *', 'correct', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[cgc_num_words].correct' - False OR  False
[i=1/4][j=10/11][dd=12/14][k=0/9] | type: char * ; var : tlv11 ; varinfo :  ; value_node : word_list [ cgc_num_words ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,cgc_num_words,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=char *]
not unique: ('char *', 'correct', None) ... continue!
----
UNIQ_INIT: ('char *','correct','None','None');

==== Scope 1 ====
void fix_ingred_ac_1_10_0(){
char correct_ref;
    bzero(&correct_ref,1*sizeof(char));
char * correct = &correct_ref;
    {if (word_list){int i; i = (int)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){cgc_size_t tlv1; tlv1 = (cgc_size_t)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){cgc_size_t tlv2; tlv2 = (cgc_size_t)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){cgc_size_t tlv3; tlv3 = (cgc_size_t)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){int tlv4; tlv4 = (int)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){char * tlv9; tlv9 = (char *)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){char * tlv11; tlv11 = (char *)(word_list [ cgc_num_words ] . correct); }}
}
void fix_ingred_ac_1_10(){
fix_ingred_ac_1_10_0();
}

==== Scope 2 ====
void fix_ingred_ac_1_2_0(){
int i;
    bzero(&i,sizeof(int));
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {char * tlv11; tlv11 = (char *)(0); }
}
void fix_ingred_ac_1_2_3(){
int i;
    bzero(&i,sizeof(int));
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(i); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
    {int tlv4; tlv4 = (int)(i); }
    {char * tlv9; tlv9 = (char *)(i); }
    {char * tlv11; tlv11 = (char *)(i); }
}
void fix_ingred_ac_1_2_4(){
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)(cgc_num_words); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_num_words); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_num_words); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_num_words); }
    {int tlv4; tlv4 = (int)(cgc_num_words); }
    {char * tlv9; tlv9 = (char *)(cgc_num_words); }
    {char * tlv11; tlv11 = (char *)(cgc_num_words); }
}
void fix_ingred_ac_1_2(){
fix_ingred_ac_1_2_0();
fix_ingred_ac_1_2_3();
fix_ingred_ac_1_2_4();
}
void fix_ingred_ac_1_4_5(){
int tlv4;
    bzero(&tlv4,sizeof(int));
    {int i; i = (int)(tlv4); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(tlv4); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv4); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv4); }
    {char * tlv9; tlv9 = (char *)(tlv4); }
    {char * tlv11; tlv11 = (char *)(tlv4); }
}
void fix_ingred_ac_1_4(){
fix_ingred_ac_1_4_5();
}
void fix_ingred_ac_1_5_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {int i; i = (int)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv5 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv5 )); }
    {char * tlv11; tlv11 = (char *)(cgc_strlen ( tlv5 )); }
}
void fix_ingred_ac_1_5(){
fix_ingred_ac_1_5_0();
}
void fix_ingred_ac_1_6_0(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
    {int i; i = (int)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv6 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv6 )); }
    {char * tlv11; tlv11 = (char *)(cgc_strlen ( tlv6 )); }
}
void fix_ingred_ac_1_6(){
fix_ingred_ac_1_6_0();
}
void fix_ingred_ac_1_7_0(){
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
const char * tlv7 = &tlv7_ref;
    {int i; i = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv7 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv7 )); }
    {char * tlv11; tlv11 = (char *)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_ac_1_7(){
fix_ingred_ac_1_7_0();
}
void fix_ingred_ac_1_8_2(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(tlv1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {char * tlv9; tlv9 = (char *)(tlv1); }
    {char * tlv11; tlv11 = (char *)(tlv1); }
}
void fix_ingred_ac_1_8_3(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(MAX_AC_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(MAX_AC_LEN); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(MAX_AC_LEN); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv4; tlv4 = (int)(MAX_AC_LEN); }
    {char * tlv9; tlv9 = (char *)(MAX_AC_LEN); }
    {char * tlv11; tlv11 = (char *)(MAX_AC_LEN); }
}
void fix_ingred_ac_1_8_4(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(tlv2); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(tlv2); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {char * tlv9; tlv9 = (char *)(tlv2); }
    {char * tlv11; tlv11 = (char *)(tlv2); }
}
void fix_ingred_ac_1_8_6(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(tlv3); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(tlv3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv3); }
    {int tlv4; tlv4 = (int)(tlv3); }
    {char * tlv9; tlv9 = (char *)(tlv3); }
    {char * tlv11; tlv11 = (char *)(tlv3); }
}
void fix_ingred_ac_1_8_7(){
cgc_size_t tlv1;
    bzero(&tlv1,sizeof(cgc_size_t));
cgc_size_t tlv2;
    bzero(&tlv2,sizeof(cgc_size_t));
cgc_size_t tlv3;
    bzero(&tlv3,sizeof(cgc_size_t));
    {int i; i = (int)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {char * tlv11; tlv11 = (char *)(0); }
}
void fix_ingred_ac_1_8(){
fix_ingred_ac_1_8_2();
fix_ingred_ac_1_8_3();
fix_ingred_ac_1_8_4();
fix_ingred_ac_1_8_6();
fix_ingred_ac_1_8_7();
}
void fix_ingred_ac_1_9_0(){
char typo_ref;
    bzero(&typo_ref,1*sizeof(char));
char * typo = &typo_ref;
    {if (word_list){int i; i = (int)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){cgc_size_t tlv1; tlv1 = (cgc_size_t)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){cgc_size_t tlv2; tlv2 = (cgc_size_t)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){cgc_size_t tlv3; tlv3 = (cgc_size_t)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){int tlv4; tlv4 = (int)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){char * tlv9; tlv9 = (char *)(word_list [ cgc_num_words ] . typo); }}
    {if (word_list){char * tlv11; tlv11 = (char *)(word_list [ cgc_num_words ] . typo); }}
}
void fix_ingred_ac_1_9(){
fix_ingred_ac_1_9_0();
}
void fix_ingred_ac_1_10_0(){
char correct_ref;
    bzero(&correct_ref,1*sizeof(char));
char * correct = &correct_ref;
    {if (word_list){int i; i = (int)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){cgc_size_t tlv1; tlv1 = (cgc_size_t)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){cgc_size_t tlv2; tlv2 = (cgc_size_t)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){cgc_size_t tlv3; tlv3 = (cgc_size_t)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){int tlv4; tlv4 = (int)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){char * tlv9; tlv9 = (char *)(word_list [ cgc_num_words ] . correct); }}
    {if (word_list){char * tlv11; tlv11 = (char *)(word_list [ cgc_num_words ] . correct); }}
}
void fix_ingred_ac_1_10(){
fix_ingred_ac_1_10_0();
}
void fix_ingred_ac_1(){
fix_ingred_ac_1_2();
fix_ingred_ac_1_4();
fix_ingred_ac_1_5();
fix_ingred_ac_1_6();
fix_ingred_ac_1_7();
fix_ingred_ac_1_8();
fix_ingred_ac_1_9();
fix_ingred_ac_1_10();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_ac_1_2_0();
void fix_ingred_ac_1_2_3();
void fix_ingred_ac_1_2_4();
void fix_ingred_ac_1_2();
void fix_ingred_ac_1_4_5();
void fix_ingred_ac_1_4();
void fix_ingred_ac_1_5_0();
void fix_ingred_ac_1_5();
void fix_ingred_ac_1_6_0();
void fix_ingred_ac_1_6();
void fix_ingred_ac_1_7_0();
void fix_ingred_ac_1_7();
void fix_ingred_ac_1_8_2();
void fix_ingred_ac_1_8_3();
void fix_ingred_ac_1_8_4();
void fix_ingred_ac_1_8_6();
void fix_ingred_ac_1_8_7();
void fix_ingred_ac_1_8();
void fix_ingred_ac_1_9_0();
void fix_ingred_ac_1_9();
void fix_ingred_ac_1_10_0();
void fix_ingred_ac_1_10();
void fix_ingred_ac_1();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : char word [ MAX_AC_LEN ] ;
def_vars[1]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : int dummy ;
def_vars[2]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t i ;
def_vars[3]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : int j ;
def_vars[4]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t start ;
def_vars[5]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t end ;
def_vars[6]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : unsigned long tlv_size_0 ;
def_vars[7]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : int diff ;
def_vars[8]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv2 ;
def_vars[9]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_lock ( tlv2 ) ;
def_vars[10]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv3 ;
def_vars[11]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_unlock ( tlv3 ) ;
def_vars[12]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[13]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv6 ;
def_vars[14]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv5 ;
def_vars[15]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv4 ;
def_vars[16]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv8 = word ;
def_vars[17]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv7 = word_list [ j ] . typo ;
def_vars[18]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : char * newbuf ;
def_vars[19]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv13 = word ;
def_vars[20]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv11 = word_list [ j ] . correct ;
def_vars[21]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv9 ;
def_vars[22]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_lock ( tlv9 ) ;
def_vars[23]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv14 ;
def_vars[24]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv12 ;
def_vars[25]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv10 ;
def_vars[26]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_unlock ( tlv10 ) ;
def_vars[27]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv17 ;
def_vars[28]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv16 ;
def_vars[29]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv15 ;
def_vars[30]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv20 ;
def_vars[31]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv19 ;
def_vars[32]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv18 ;
def_vars[33]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv24 = word_list [ j ] . correct ;
def_vars[34]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv23 ;
def_vars[35]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : void * tlv22 ;
def_vars[36]: [cgc_ac_process] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv21 ;
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b50a3c8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=0/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=0/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
unique : ('cgc_size_t', 'i', None)
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
unique : ('cgc_size_t', 'start', None)
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=0/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
unique : ('cgc_size_t', 'end', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=0/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
unique : ('char', 'word [ MAX_AC_LEN ]', None)
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=0/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=1/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=1/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=1/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=1/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=1/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=2/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=2/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=2/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=2/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=2/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=3/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=3/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=3/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=3/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=3/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=4/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=4/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=4/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=4/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=4/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=5/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=5/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=5/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=5/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=5/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=6/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=6/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=6/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=6/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=6/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=7/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=7/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=7/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=7/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=7/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=10/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=10/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=10/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=10/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=10/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=11/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=11/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=11/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=11/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=11/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=12/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=12/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=12/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=12/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=12/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=13/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=13/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=13/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=13/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=13/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=16/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=16/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=16/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=16/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=16/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=20/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=20/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=20/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=20/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=20/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=21/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=21/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=21/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=21/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=21/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=23/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=23/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=23/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=23/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=23/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=24/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=24/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=24/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=24/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=24/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=25/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=25/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=25/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=25/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=25/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=26/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=26/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=26/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=26/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=26/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=27/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=27/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=27/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=27/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=27/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=28/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=28/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=28/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=28/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=28/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=30/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=30/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=30/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=30/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=30/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=31/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=31/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=31/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=31/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=31/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_head' - False OR  False
[i=2/4][j=2/23][dd=32/37][k=0/10] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_head (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_head
 => is literal (False) | is operator (False) ac_queue_head [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].start' - False OR  False
[i=2/4][j=2/23][dd=32/37][k=1/10] | type: cgc_size_t ; var : start ; varinfo :  ; value_node : ac_queue [ i ] . start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,start
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue[i].end' - False OR  False
[i=2/4][j=2/23][dd=32/37][k=2/10] | type: cgc_size_t ; var : end ; varinfo :  ; value_node : ac_queue [ i ] . end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue,[,i,],.,end
 => is literal (False) | is operator (False) ac_queue [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(word)' - False OR  False
[i=2/4][j=2/23][dd=32/37][k=3/10] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( word ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,word,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/4][j=2/23][dd=32/37][k=4/10] | type: int ; var : diff ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

not valid - cgc_size_t i; i = ((cgc_size_t)ac_queue [ i ] . start);

not valid - cgc_size_t start; start = ((cgc_size_t)ac_queue [ i ] . start);

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

not valid - cgc_size_t i; i = ((cgc_size_t)ac_queue [ i ] . end);

not valid - cgc_size_t end; end = ((cgc_size_t)ac_queue [ i ] . end);

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_2_0(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue_head); }
    {int dummy; dummy = (int)(ac_queue_head); }
    {cgc_size_t i; i = (cgc_size_t)(ac_queue_head); }
    {int j; j = (int)(ac_queue_head); }
    {cgc_size_t start; start = (cgc_size_t)(ac_queue_head); }
    {cgc_size_t end; end = (cgc_size_t)(ac_queue_head); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue_head); }
    {int diff; diff = (int)(ac_queue_head); }
    {int tlv1; tlv1 = (int)(ac_queue_head); }
    {void * tlv6; tlv6 = (void *)(ac_queue_head); }
    {void * tlv5; tlv5 = (void *)(ac_queue_head); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue_head); }
    {char * newbuf; newbuf = (char *)(ac_queue_head); }
    {void * tlv14; tlv14 = (void *)(ac_queue_head); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue_head); }
    {void * tlv17; tlv17 = (void *)(ac_queue_head); }
    {void * tlv16; tlv16 = (void *)(ac_queue_head); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue_head); }
    {void * tlv20; tlv20 = (void *)(ac_queue_head); }
    {void * tlv19; tlv19 = (void *)(ac_queue_head); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue_head); }
    {void * tlv23; tlv23 = (void *)(ac_queue_head); }
    {void * tlv22; tlv22 = (void *)(ac_queue_head); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue_head); }
}
void fix_ingred_ac_2_2_1(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {if (ac_queue){    i = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int dummy; dummy = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int j; j = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t end; end = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int diff; diff = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int tlv1; tlv1 = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv6; tlv6 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv5; tlv5 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         char * newbuf; newbuf = (char *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv14; tlv14 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv17; tlv17 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv16; tlv16 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv20; tlv20 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv19; tlv19 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv23; tlv23 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv22; tlv22 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue [ i ] . start); }}
}
void fix_ingred_ac_2_2_2(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {if (ac_queue){    i = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int dummy; dummy = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int j; j = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t start; start = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int diff; diff = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int tlv1; tlv1 = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv6; tlv6 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv5; tlv5 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         char * newbuf; newbuf = (char *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv14; tlv14 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv17; tlv17 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv16; tlv16 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv20; tlv20 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv19; tlv19 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv23; tlv23 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv22; tlv22 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue [ i ] . end); }}
}
void fix_ingred_ac_2_2_3(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(sizeof ( word )); }
    {int dummy; dummy = (int)(sizeof ( word )); }
    {cgc_size_t i; i = (cgc_size_t)(sizeof ( word )); }
    {int j; j = (int)(sizeof ( word )); }
    {cgc_size_t start; start = (cgc_size_t)(sizeof ( word )); }
    {cgc_size_t end; end = (cgc_size_t)(sizeof ( word )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( word )); }
    {int diff; diff = (int)(sizeof ( word )); }
    {int tlv1; tlv1 = (int)(sizeof ( word )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( word )); }
    {void * tlv5; tlv5 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(sizeof ( word )); }
    {char * newbuf; newbuf = (char *)(sizeof ( word )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(sizeof ( word )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( word )); }
    {void * tlv16; tlv16 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( word )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( word )); }
    {void * tlv19; tlv19 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(sizeof ( word )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( word )); }
    {void * tlv22; tlv22 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(sizeof ( word )); }
}
void fix_ingred_ac_2_2_4(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(0); }
    {int dummy; dummy = (int)(0); }
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {int j; j = (int)(0); }
    {cgc_size_t start; start = (cgc_size_t)(0); }
    {cgc_size_t end; end = (cgc_size_t)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {int diff; diff = (int)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv6; tlv6 = (void *)(0); }
    {void * tlv5; tlv5 = (void *)(0); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(0); }
    {char * newbuf; newbuf = (char *)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(0); }
    {void * tlv17; tlv17 = (void *)(0); }
    {void * tlv16; tlv16 = (void *)(0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {void * tlv19; tlv19 = (void *)(0); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(0); }
    {void * tlv23; tlv23 = (void *)(0); }
    {void * tlv22; tlv22 = (void *)(0); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(0); }
}
void fix_ingred_ac_2_2(){
fix_ingred_ac_2_2_0();
fix_ingred_ac_2_2_1();
fix_ingred_ac_2_2_2();
fix_ingred_ac_2_2_3();
fix_ingred_ac_2_2_4();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f3358>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long'}'
val_s=>'[('UNDEF', 'word ', '[ end - start ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b29d048>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3eca58>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b018f98>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=0/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
unique : ('cgc_size_t', 'end', None)
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
unique : ('cgc_size_t', 'start', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=0/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
unique : ('unsigned long', 'tlv_size_0', None)
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=1/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=1/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=2/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=2/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=3/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=3/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=4/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=4/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=5/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=5/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=6/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=6/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=7/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=7/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=10/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=10/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=11/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=11/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=12/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=12/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=13/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=13/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=16/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=16/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=20/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=20/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=21/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=21/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=23/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=23/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=24/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=24/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=25/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=25/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=26/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=26/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=27/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=27/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=28/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=28/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=30/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=30/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=31/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=31/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [e] => '[False, False, False]'
has_multiptr_refs 'end-start' - False OR  False
[i=2/4][j=4/23][dd=32/37][k=9/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : end - start (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : end,-,start
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=2/4][j=4/23][dd=32/37][k=10/11] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
not valid - cgc_size_t start; start = ((cgc_size_t)end - start);

not valid - cgc_size_t end; end = ((cgc_size_t)end - start);

----
UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('unsigned long','tlv_size_0','None','None');

not valid - unsigned long tlv_size_0; tlv_size_0 = ((unsigned long)tlv_size_0);

----
UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

UNIQ_INIT: ('unsigned long','tlv_size_0','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_4_9(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(end - start); }
    {int dummy; dummy = (int)(end - start); }
    {cgc_size_t i; i = (cgc_size_t)(end - start); }
    {int j; j = (int)(end - start); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(end - start); }
    {int diff; diff = (int)(end - start); }
    {int tlv1; tlv1 = (int)(end - start); }
    {void * tlv6; tlv6 = (void *)(end - start); }
    {void * tlv5; tlv5 = (void *)(end - start); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(end - start); }
    {char * newbuf; newbuf = (char *)(end - start); }
    {void * tlv14; tlv14 = (void *)(end - start); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(end - start); }
    {void * tlv17; tlv17 = (void *)(end - start); }
    {void * tlv16; tlv16 = (void *)(end - start); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(end - start); }
    {void * tlv20; tlv20 = (void *)(end - start); }
    {void * tlv19; tlv19 = (void *)(end - start); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(end - start); }
    {void * tlv23; tlv23 = (void *)(end - start); }
    {void * tlv22; tlv22 = (void *)(end - start); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(end - start); }
}
void fix_ingred_ac_2_4_10(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(tlv_size_0); }
    {int dummy; dummy = (int)(tlv_size_0); }
    {cgc_size_t i; i = (cgc_size_t)(tlv_size_0); }
    {int j; j = (int)(tlv_size_0); }
    {cgc_size_t start; start = (cgc_size_t)(tlv_size_0); }
    {cgc_size_t end; end = (cgc_size_t)(tlv_size_0); }
    {int diff; diff = (int)(tlv_size_0); }
    {int tlv1; tlv1 = (int)(tlv_size_0); }
    {void * tlv6; tlv6 = (void *)(tlv_size_0); }
    {void * tlv5; tlv5 = (void *)(tlv_size_0); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv_size_0); }
    {char * newbuf; newbuf = (char *)(tlv_size_0); }
    {void * tlv14; tlv14 = (void *)(tlv_size_0); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv_size_0); }
    {void * tlv17; tlv17 = (void *)(tlv_size_0); }
    {void * tlv16; tlv16 = (void *)(tlv_size_0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv_size_0); }
    {void * tlv20; tlv20 = (void *)(tlv_size_0); }
    {void * tlv19; tlv19 = (void *)(tlv_size_0); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(tlv_size_0); }
    {void * tlv23; tlv23 = (void *)(tlv_size_0); }
    {void * tlv22; tlv22 = (void *)(tlv_size_0); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(tlv_size_0); }
}
void fix_ingred_ac_2_4(){
fix_ingred_ac_2_4_9();
fix_ingred_ac_2_4_10();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv6': 'void *', 'tlv5': 'void *', 'tlv4': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5df518>), ('void *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4622e8>), ('cgc_size_t', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b678dd8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b3eca58>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b018f98>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=0/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
unique : ('char', 'word [ MAX_AC_LEN ]', None)
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=0/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
unique : ('cgc_size_t', 'start', None)
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=1/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=1/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=2/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=2/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=3/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=3/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=4/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=4/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=5/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=5/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=6/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=6/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=7/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=7/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=10/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=10/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=11/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=11/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=12/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=12/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=13/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=13/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=16/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=16/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=20/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=20/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=21/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=21/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=23/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=23/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=24/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=24/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=25/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=25/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=26/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=26/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=27/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=27/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=28/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=28/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=30/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=30/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=31/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=31/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=2/4][j=5/23][dd=32/37][k=0/13] | type: void * ; var : tlv6 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[start]' - False OR  False
[i=2/4][j=5/23][dd=32/37][k=1/13] | type: void * ; var : tlv5 ; varinfo :  ; value_node : & ac_buffer [ start ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,start,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) start [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'start', None) ... continue!
 => is literal (False) | is operator (True) ]
----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

not valid - cgc_size_t start; start = ((cgc_size_t)& ac_buffer [ start ]);

----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','start','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_5_0(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word); }
    {int dummy; dummy = (int)(word); }
    {cgc_size_t i; i = (cgc_size_t)(word); }
    {int j; j = (int)(word); }
    {cgc_size_t start; start = (cgc_size_t)(word); }
    {cgc_size_t end; end = (cgc_size_t)(word); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(word); }
    {int diff; diff = (int)(word); }
    {int tlv1; tlv1 = (int)(word); }
    {void * tlv6; tlv6 = (void *)(word); }
    {void * tlv5; tlv5 = (void *)(word); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(word); }
    {char * newbuf; newbuf = (char *)(word); }
    {void * tlv14; tlv14 = (void *)(word); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(word); }
    {void * tlv17; tlv17 = (void *)(word); }
    {void * tlv16; tlv16 = (void *)(word); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(word); }
    {void * tlv20; tlv20 = (void *)(word); }
    {void * tlv19; tlv19 = (void *)(word); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(word); }
    {void * tlv23; tlv23 = (void *)(word); }
    {void * tlv22; tlv22 = (void *)(word); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(word); }
}
void fix_ingred_ac_2_5_1(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
    {if (ac_buffer){    start = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int dummy; dummy = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t i; i = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int j; j = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t end; end = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int diff; diff = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int tlv1; tlv1 = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv6; tlv6 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv5; tlv5 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         char * newbuf; newbuf = (char *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv14; tlv14 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv17; tlv17 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv16; tlv16 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv20; tlv20 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv19; tlv19 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv23; tlv23 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv22; tlv22 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(& ac_buffer [ start ]); }}
}
void fix_ingred_ac_2_5(){
fix_ingred_ac_2_5_0();
fix_ingred_ac_2_5_1();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long'}'
val_s=>'[('UNDEF', 'word ', '[ 0 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b265ba8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b70deb8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=0/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
unique : ('int', 'j', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=0/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=1/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=1/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=2/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=2/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=3/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=3/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=4/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=4/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=5/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=5/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=6/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=6/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=7/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=7/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=10/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=10/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=11/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=11/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=12/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=12/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=13/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=13/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=16/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=16/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=20/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=20/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=21/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=21/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=23/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=23/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=24/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=24/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=25/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=25/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=26/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=26/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=27/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=27/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=28/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=28/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=30/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=30/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=31/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=31/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
is_func_ [j] => '[False, False, False]'
has_multiptr_refs 'j' - False OR  False
[i=2/4][j=8/23][dd=32/37][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : j (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : j
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_num_words' - False OR  False
[i=2/4][j=8/23][dd=32/37][k=11/12] | type: int ; var :  ; varinfo :  ; value_node : cgc_num_words (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_num_words
 => is literal (False) | is operator (False) cgc_num_words [vtype=None]
not valid - int j; j = ((int)j);

----
UNIQ_INIT: ('int','j','None','None');

----
UNIQ_INIT: ('int','j','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_8_10(){
int j;
    bzero(&j,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(j); }
    {int dummy; dummy = (int)(j); }
    {cgc_size_t i; i = (cgc_size_t)(j); }
    {cgc_size_t start; start = (cgc_size_t)(j); }
    {cgc_size_t end; end = (cgc_size_t)(j); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(j); }
    {int diff; diff = (int)(j); }
    {int tlv1; tlv1 = (int)(j); }
    {void * tlv6; tlv6 = (void *)(j); }
    {void * tlv5; tlv5 = (void *)(j); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(j); }
    {char * newbuf; newbuf = (char *)(j); }
    {void * tlv14; tlv14 = (void *)(j); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(j); }
    {void * tlv17; tlv17 = (void *)(j); }
    {void * tlv16; tlv16 = (void *)(j); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(j); }
    {void * tlv20; tlv20 = (void *)(j); }
    {void * tlv19; tlv19 = (void *)(j); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(j); }
    {void * tlv23; tlv23 = (void *)(j); }
    {void * tlv22; tlv22 = (void *)(j); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(j); }
}
void fix_ingred_ac_2_8_11(){
int j;
    bzero(&j,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(cgc_num_words); }
    {int dummy; dummy = (int)(cgc_num_words); }
    {cgc_size_t i; i = (cgc_size_t)(cgc_num_words); }
    {int j; j = (int)(cgc_num_words); }
    {cgc_size_t start; start = (cgc_size_t)(cgc_num_words); }
    {cgc_size_t end; end = (cgc_size_t)(cgc_num_words); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(cgc_num_words); }
    {int diff; diff = (int)(cgc_num_words); }
    {int tlv1; tlv1 = (int)(cgc_num_words); }
    {void * tlv6; tlv6 = (void *)(cgc_num_words); }
    {void * tlv5; tlv5 = (void *)(cgc_num_words); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_num_words); }
    {char * newbuf; newbuf = (char *)(cgc_num_words); }
    {void * tlv14; tlv14 = (void *)(cgc_num_words); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(cgc_num_words); }
    {void * tlv17; tlv17 = (void *)(cgc_num_words); }
    {void * tlv16; tlv16 = (void *)(cgc_num_words); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(cgc_num_words); }
    {void * tlv20; tlv20 = (void *)(cgc_num_words); }
    {void * tlv19; tlv19 = (void *)(cgc_num_words); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(cgc_num_words); }
    {void * tlv23; tlv23 = (void *)(cgc_num_words); }
    {void * tlv22; tlv22 = (void *)(cgc_num_words); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(cgc_num_words); }
}
void fix_ingred_ac_2_8(){
fix_ingred_ac_2_8_10();
fix_ingred_ac_2_8_11();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=0/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=1/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=2/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=3/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=4/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=5/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=6/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=7/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=10/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=11/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=12/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=13/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=16/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=20/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=21/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=23/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=24/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=25/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=26/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=27/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=28/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=30/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=31/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/4][j=10/23][dd=32/37][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
not valid - int tlv1; tlv1 = ((int)tlv1);

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_10_12(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(tlv1); }
    {int dummy; dummy = (int)(tlv1); }
    {cgc_size_t i; i = (cgc_size_t)(tlv1); }
    {int j; j = (int)(tlv1); }
    {cgc_size_t start; start = (cgc_size_t)(tlv1); }
    {cgc_size_t end; end = (cgc_size_t)(tlv1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv1); }
    {int diff; diff = (int)(tlv1); }
    {void * tlv6; tlv6 = (void *)(tlv1); }
    {void * tlv5; tlv5 = (void *)(tlv1); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv1); }
    {char * newbuf; newbuf = (char *)(tlv1); }
    {void * tlv14; tlv14 = (void *)(tlv1); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv1); }
    {void * tlv17; tlv17 = (void *)(tlv1); }
    {void * tlv16; tlv16 = (void *)(tlv1); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv1); }
    {void * tlv20; tlv20 = (void *)(tlv1); }
    {void * tlv19; tlv19 = (void *)(tlv1); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(tlv1); }
    {void * tlv23; tlv23 = (void *)(tlv1); }
    {void * tlv22; tlv22 = (void *)(tlv1); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(tlv1); }
}
void fix_ingred_ac_2_10(){
fix_ingred_ac_2_10_12();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *'}'
val_s=>'[('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b23aac8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=0/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
unique : ('const char *', 'tlv11', None)
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
unique : ('const char *', 'tlv13', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=1/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=2/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=3/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=4/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=5/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=6/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=7/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=10/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=11/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=12/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=13/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=16/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=20/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=21/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=23/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=24/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=25/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=26/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=27/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=28/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=30/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=31/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv11)-cgc_strlen(tlv13)' - False OR  False
[i=2/4][j=11/23][dd=32/37][k=0/15] | type: int ; var : diff ; varinfo :  ; value_node : cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv11,),-,cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv11 [vtype=const char *]
not unique: ('const char *', 'tlv11', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv11','None','None');

UNIQ_INIT: ('const char *','tlv13','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_11_0(){
char tlv11_ref;
    bzero(&tlv11_ref,1*sizeof(char));
const char * tlv11 = &tlv11_ref;
char tlv13_ref;
    bzero(&tlv13_ref,1*sizeof(char));
const char * tlv13 = &tlv13_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int dummy; dummy = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t i; i = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int j; j = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t start; start = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t end; end = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int diff; diff = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv6; tlv6 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv5; tlv5 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {char * newbuf; newbuf = (char *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv14; tlv14 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv17; tlv17 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv16; tlv16 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv20; tlv20 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv19; tlv19 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv23; tlv23 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv22; tlv22 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
}
void fix_ingred_ac_2_11(){
fix_ingred_ac_2_11_0();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b1300b8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b12d358>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b12df98>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=0/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
unique : ('int', 'diff', None)
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=1/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=2/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=3/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=4/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=5/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=6/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=7/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=10/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=11/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=12/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=13/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=16/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=20/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=21/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=23/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=24/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=25/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=26/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=27/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=28/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=30/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=31/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'diff' - False OR  False
[i=2/4][j=13/23][dd=32/37][k=14/16] | type: int ; var :  ; varinfo :  ; value_node : diff (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : diff
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
not valid - int diff; diff = ((int)diff);

----
UNIQ_INIT: ('int','diff','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_13_14(){
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(diff); }
    {int dummy; dummy = (int)(diff); }
    {cgc_size_t i; i = (cgc_size_t)(diff); }
    {int j; j = (int)(diff); }
    {cgc_size_t start; start = (cgc_size_t)(diff); }
    {cgc_size_t end; end = (cgc_size_t)(diff); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(diff); }
    {int tlv1; tlv1 = (int)(diff); }
    {void * tlv6; tlv6 = (void *)(diff); }
    {void * tlv5; tlv5 = (void *)(diff); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(diff); }
    {char * newbuf; newbuf = (char *)(diff); }
    {void * tlv14; tlv14 = (void *)(diff); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(diff); }
    {void * tlv17; tlv17 = (void *)(diff); }
    {void * tlv16; tlv16 = (void *)(diff); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(diff); }
    {void * tlv20; tlv20 = (void *)(diff); }
    {void * tlv19; tlv19 = (void *)(diff); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(diff); }
    {void * tlv23; tlv23 = (void *)(diff); }
    {void * tlv22; tlv22 = (void *)(diff); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(diff); }
}
void fix_ingred_ac_2_13(){
fix_ingred_ac_2_13_14();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv17': 'void *', 'tlv16': 'void *', 'tlv15': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv17', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3a1828>), ('void *', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b24e198>), ('cgc_size_t', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2a9dd8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b12d358>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b12df98>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=0/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
unique : ('cgc_size_t', 'end', None)
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
unique : ('int', 'diff', None)
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=0/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=0/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=1/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=1/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=1/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=2/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=2/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=2/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=3/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=3/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=3/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=4/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=4/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=4/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=5/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=5/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=5/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=6/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=6/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=6/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=7/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=7/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=7/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=10/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=10/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=10/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=11/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=11/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=11/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=12/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=12/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=12/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=13/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=13/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=13/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=16/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=16/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=16/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=20/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=20/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=20/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=21/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=21/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=21/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=23/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=23/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=23/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=24/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=24/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=24/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=25/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=25/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=25/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=26/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=26/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=26/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=27/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=27/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=27/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=28/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=28/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=28/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=30/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=30/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=30/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=31/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=31/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=31/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end+diff]' - False OR  False
[i=2/4][j=14/23][dd=32/37][k=0/19] | type: void * ; var : tlv17 ; varinfo :  ; value_node : & ac_buffer [ end + diff ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,+,diff,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[end]' - False OR  False
[i=2/4][j=14/23][dd=32/37][k=1/19] | type: void * ; var : tlv16 ; varinfo :  ; value_node : & ac_buffer [ end ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,end,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx-end' - False OR  False
[i=2/4][j=14/23][dd=32/37][k=2/19] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : ac_idx - end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,-,end
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) end [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'end', None) ... continue!
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
not valid - cgc_size_t end; end = ((cgc_size_t)& ac_buffer [ end + diff ]);

 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
not valid - int diff; diff = ((int)& ac_buffer [ end + diff ]);

 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
 =====> [('end + diff ', 'end + diff ', 'end + diff ')] '& ac_buffer [ end + diff ]' => [True, False, False, False] 
 === FOUND IT ===> [('end + diff ', 'end + diff ', 'end + diff ')] [& ac_buffer [ end + diff ]] 
not valid - cgc_size_t end; end = ((cgc_size_t)& ac_buffer [ end ]);

----
UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('int','diff','None','None');

not valid - cgc_size_t end; end = ((cgc_size_t)ac_idx - end);

----
UNIQ_INIT: ('cgc_size_t','end','None','None');

UNIQ_INIT: ('int','diff','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_14_1(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
int diff;
    bzero(&diff,sizeof(int));
    {if (ac_buffer){    end = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int dummy; dummy = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t i; i = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int j; j = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t start; start = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int diff; diff = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int tlv1; tlv1 = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv6; tlv6 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv5; tlv5 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         char * newbuf; newbuf = (char *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv14; tlv14 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv17; tlv17 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv16; tlv16 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv20; tlv20 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv19; tlv19 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv23; tlv23 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv22; tlv22 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(& ac_buffer [ end ]); }}
}
void fix_ingred_ac_2_14_2(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_idx - end); }
    {int dummy; dummy = (int)(ac_idx - end); }
    {cgc_size_t i; i = (cgc_size_t)(ac_idx - end); }
    {int j; j = (int)(ac_idx - end); }
    {cgc_size_t start; start = (cgc_size_t)(ac_idx - end); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_idx - end); }
    {int diff; diff = (int)(ac_idx - end); }
    {int tlv1; tlv1 = (int)(ac_idx - end); }
    {void * tlv6; tlv6 = (void *)(ac_idx - end); }
    {void * tlv5; tlv5 = (void *)(ac_idx - end); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_idx - end); }
    {char * newbuf; newbuf = (char *)(ac_idx - end); }
    {void * tlv14; tlv14 = (void *)(ac_idx - end); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_idx - end); }
    {void * tlv17; tlv17 = (void *)(ac_idx - end); }
    {void * tlv16; tlv16 = (void *)(ac_idx - end); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_idx - end); }
    {void * tlv20; tlv20 = (void *)(ac_idx - end); }
    {void * tlv19; tlv19 = (void *)(ac_idx - end); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_idx - end); }
    {void * tlv23; tlv23 = (void *)(ac_idx - end); }
    {void * tlv22; tlv22 = (void *)(ac_idx - end); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_idx - end); }
}
void fix_ingred_ac_2_14(){
fix_ingred_ac_2_14_1();
fix_ingred_ac_2_14_2();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b10d438>), ('cgc_size_t', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b03d208>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=0/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=0/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
unique : ('int', 'diff', None)
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=1/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=1/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=2/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=2/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=3/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=3/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=4/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=4/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=5/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=5/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=6/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=6/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=7/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=7/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=10/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=10/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=11/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=11/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=12/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=12/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=13/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=13/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=16/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=16/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=20/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=20/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=21/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=21/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=23/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=23/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=24/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=24/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=25/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=25/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=26/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=26/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=27/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=27/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=28/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=28/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=30/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=30/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=31/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=31/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=2/4][j=15/23][dd=32/37][k=0/16] | type: void * ; var : tlv14 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+1+diff' - False OR  False
[i=2/4][j=15/23][dd=32/37][k=1/16] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : ac_idx + 1 + diff (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,1,+,diff
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) diff [vtype=int]
not unique: ('int', 'diff', None) ... continue!
----
UNIQ_INIT: ('int','diff','None','None');

not valid - int diff; diff = ((int)ac_idx + 1 + diff);

----
UNIQ_INIT: ('int','diff','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_15_0(){
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_buffer); }
    {int dummy; dummy = (int)(ac_buffer); }
    {cgc_size_t i; i = (cgc_size_t)(ac_buffer); }
    {int j; j = (int)(ac_buffer); }
    {cgc_size_t start; start = (cgc_size_t)(ac_buffer); }
    {cgc_size_t end; end = (cgc_size_t)(ac_buffer); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_buffer); }
    {int diff; diff = (int)(ac_buffer); }
    {int tlv1; tlv1 = (int)(ac_buffer); }
    {void * tlv6; tlv6 = (void *)(ac_buffer); }
    {void * tlv5; tlv5 = (void *)(ac_buffer); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_buffer); }
    {char * newbuf; newbuf = (char *)(ac_buffer); }
    {void * tlv14; tlv14 = (void *)(ac_buffer); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_buffer); }
    {void * tlv17; tlv17 = (void *)(ac_buffer); }
    {void * tlv16; tlv16 = (void *)(ac_buffer); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_buffer); }
    {void * tlv20; tlv20 = (void *)(ac_buffer); }
    {void * tlv19; tlv19 = (void *)(ac_buffer); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_buffer); }
    {void * tlv23; tlv23 = (void *)(ac_buffer); }
    {void * tlv22; tlv22 = (void *)(ac_buffer); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_buffer); }
}
void fix_ingred_ac_2_15_1(){
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_idx + 1 + diff); }
    {int dummy; dummy = (int)(ac_idx + 1 + diff); }
    {cgc_size_t i; i = (cgc_size_t)(ac_idx + 1 + diff); }
    {int j; j = (int)(ac_idx + 1 + diff); }
    {cgc_size_t start; start = (cgc_size_t)(ac_idx + 1 + diff); }
    {cgc_size_t end; end = (cgc_size_t)(ac_idx + 1 + diff); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_idx + 1 + diff); }
    {int tlv1; tlv1 = (int)(ac_idx + 1 + diff); }
    {void * tlv6; tlv6 = (void *)(ac_idx + 1 + diff); }
    {void * tlv5; tlv5 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_idx + 1 + diff); }
    {char * newbuf; newbuf = (char *)(ac_idx + 1 + diff); }
    {void * tlv14; tlv14 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_idx + 1 + diff); }
    {void * tlv17; tlv17 = (void *)(ac_idx + 1 + diff); }
    {void * tlv16; tlv16 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_idx + 1 + diff); }
    {void * tlv20; tlv20 = (void *)(ac_idx + 1 + diff); }
    {void * tlv19; tlv19 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_idx + 1 + diff); }
    {void * tlv23; tlv23 = (void *)(ac_idx + 1 + diff); }
    {void * tlv22; tlv22 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_idx + 1 + diff); }
}
void fix_ingred_ac_2_15(){
fix_ingred_ac_2_15_0();
fix_ingred_ac_2_15_1();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t'}'
val_s=>'[('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394afadeb8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394afe6e48>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b371748>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b3719e8>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=0/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
unique : ('char *', 'newbuf', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=0/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=1/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=1/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=2/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=2/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=3/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=3/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=4/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=4/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=5/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=5/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=6/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=6/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=7/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=7/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=10/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=10/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=11/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=11/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=12/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=12/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=13/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=13/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=16/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=16/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=20/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=20/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=21/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=21/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=23/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=23/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=24/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=24/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=25/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=25/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=26/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=26/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=27/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=27/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=28/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=28/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=30/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=30/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=31/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=31/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=2/4][j=16/23][dd=32/37][k=16/18] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/4][j=16/23][dd=32/37][k=17/18] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
not valid - char * newbuf; newbuf = ((char *)newbuf);

----
UNIQ_INIT: ('char *','newbuf','None','None');

----
UNIQ_INIT: ('char *','newbuf','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_16_16(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(newbuf); }
    {int dummy; dummy = (int)(newbuf); }
    {cgc_size_t i; i = (cgc_size_t)(newbuf); }
    {int j; j = (int)(newbuf); }
    {cgc_size_t start; start = (cgc_size_t)(newbuf); }
    {cgc_size_t end; end = (cgc_size_t)(newbuf); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(newbuf); }
    {int diff; diff = (int)(newbuf); }
    {int tlv1; tlv1 = (int)(newbuf); }
    {void * tlv6; tlv6 = (void *)(newbuf); }
    {void * tlv5; tlv5 = (void *)(newbuf); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(newbuf); }
    {void * tlv14; tlv14 = (void *)(newbuf); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(newbuf); }
    {void * tlv17; tlv17 = (void *)(newbuf); }
    {void * tlv16; tlv16 = (void *)(newbuf); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(newbuf); }
    {void * tlv20; tlv20 = (void *)(newbuf); }
    {void * tlv19; tlv19 = (void *)(newbuf); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(newbuf); }
    {void * tlv23; tlv23 = (void *)(newbuf); }
    {void * tlv22; tlv22 = (void *)(newbuf); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(newbuf); }
}
void fix_ingred_ac_2_16_17(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(NULL); }
    {int dummy; dummy = (int)(NULL); }
    {cgc_size_t i; i = (cgc_size_t)(NULL); }
    {int j; j = (int)(NULL); }
    {cgc_size_t start; start = (cgc_size_t)(NULL); }
    {cgc_size_t end; end = (cgc_size_t)(NULL); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(NULL); }
    {int diff; diff = (int)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
    {void * tlv6; tlv6 = (void *)(NULL); }
    {void * tlv5; tlv5 = (void *)(NULL); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(NULL); }
    {char * newbuf; newbuf = (char *)(NULL); }
    {void * tlv14; tlv14 = (void *)(NULL); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(NULL); }
    {void * tlv17; tlv17 = (void *)(NULL); }
    {void * tlv16; tlv16 = (void *)(NULL); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(NULL); }
    {void * tlv20; tlv20 = (void *)(NULL); }
    {void * tlv19; tlv19 = (void *)(NULL); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(NULL); }
    {void * tlv23; tlv23 = (void *)(NULL); }
    {void * tlv22; tlv22 = (void *)(NULL); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(NULL); }
}
void fix_ingred_ac_2_16(){
fix_ingred_ac_2_16_16();
fix_ingred_ac_2_16_17();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394afadeb8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b371748>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b3719e8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394afdf828>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394afdf128>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t', 'tlv23': 'void *', 'tlv22': 'void *', 'tlv21': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv23', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4d89e8>), ('void *', 'tlv22', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b075e48>), ('cgc_size_t', 'tlv21', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3f0438>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394afadeb8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b371748>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b3719e8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394afdf828>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394afdf128>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'void *', 'tlv18': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv20', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b091978>), ('void *', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5a5eb8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394afadeb8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b371748>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b3719e8>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=0/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
unique : ('int', 'j', None)
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=1/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=2/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=3/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=4/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=5/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=6/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=7/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=10/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=11/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=12/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=13/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=16/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=20/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=21/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=23/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=24/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=25/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=26/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=27/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=28/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=30/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=31/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word_list[j].correct' - False OR  False
[i=2/4][j=19/23][dd=32/37][k=1/19] | type: void * ; var : tlv19 ; varinfo :  ; value_node : word_list [ j ] . correct (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word_list,[,j,],.,correct
 => is literal (False) | is operator (False) word_list [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) j [vtype=int]
not unique: ('int', 'j', None) ... continue!
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) correct [vtype=None]
not valid - int j; j = ((int)word_list [ j ] . correct);

----
UNIQ_INIT: ('int','j','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_19_1(){
int j;
    bzero(&j,sizeof(int));
    {if (word_list){    j = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         int dummy; dummy = (int)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t i; i = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t start; start = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t end; end = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         int diff; diff = (int)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         int tlv1; tlv1 = (int)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv6; tlv6 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv5; tlv5 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         char * newbuf; newbuf = (char *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv14; tlv14 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv17; tlv17 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv16; tlv16 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv20; tlv20 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv19; tlv19 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv23; tlv23 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv22; tlv22 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(word_list [ j ] . correct); }}
}
void fix_ingred_ac_2_19(){
fix_ingred_ac_2_19_1();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'void *', 'tlv18': 'cgc_size_t', 'tlv24': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv18', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4b6a58>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394afadeb8>), ('void *', 'tlv20', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b091978>), ('void *', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5a5eb8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b371748>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b3719e8>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=0/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
unique : ('const char *', 'tlv24', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=1/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=2/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=3/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=4/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=5/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=6/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=7/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=10/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=11/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=12/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=13/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=16/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=20/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=21/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=23/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=24/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=25/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=26/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=27/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=28/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=30/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=31/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv24)' - False OR  False
[i=2/4][j=20/23][dd=32/37][k=0/20] | type: cgc_size_t ; var : tlv18 ; varinfo :  ; value_node : cgc_strlen ( tlv24 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv24,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv24 [vtype=const char *]
not unique: ('const char *', 'tlv24', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv24','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_20_0(){
char tlv24_ref;
    bzero(&tlv24_ref,1*sizeof(char));
const char * tlv24 = &tlv24_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(cgc_strlen ( tlv24 )); }
    {int dummy; dummy = (int)(cgc_strlen ( tlv24 )); }
    {cgc_size_t i; i = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {int j; j = (int)(cgc_strlen ( tlv24 )); }
    {cgc_size_t start; start = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {cgc_size_t end; end = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(cgc_strlen ( tlv24 )); }
    {int diff; diff = (int)(cgc_strlen ( tlv24 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv24 )); }
    {void * tlv6; tlv6 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv5; tlv5 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {char * newbuf; newbuf = (char *)(cgc_strlen ( tlv24 )); }
    {void * tlv14; tlv14 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {void * tlv17; tlv17 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv16; tlv16 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {void * tlv20; tlv20 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv19; tlv19 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {void * tlv23; tlv23 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv22; tlv22 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
}
void fix_ingred_ac_2_20(){
fix_ingred_ac_2_20_0();
}

sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int', 'tlv1': 'int', 'tlv8': 'const char *', 'tlv7': 'const char *', 'newbuf': 'char *', 'tlv13': 'const char *', 'tlv11': 'const char *', 'tlv9': 'mutex_t *', 'tlv14': 'void *', 'tlv12': 'cgc_size_t', 'tlv10': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0110b8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0c5908>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b4dc2e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288eb8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b288198>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'ud': 'void *', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'dummy': 'int', 'i': 'cgc_size_t', 'j': 'int', 'tlv2': 'mutex_t *', 'start': 'cgc_size_t', 'end': 'cgc_size_t', 'tlv_size_0': 'unsigned long', 'tlv3': 'mutex_t *', 'diff': 'int'}'
val_s=>'[('UNDEF', 'ac_queue ', '[ i ] . start', <CParser.CParser.AssignmentExpressionContext object at 0x15394b077f28>), ('UNDEF', 'ac_queue ', '[ i ] . end', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3fd6d8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b5ed588>), ('cgc_size_t', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b658048>), ('cgc_size_t', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b28c3c8>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b2f6278>), ('int', 'diff', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b3993c8>), ('int', 'j', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4bb4a8>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4bb978>), ('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b352f28>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34c5f8>), ('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b34ce48>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1dab38>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b1da748>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b35c0b8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b35c668>)]'
Checking 'cgc_mutex_lock( tlv2 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv2 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv9 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv10 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv10 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=0/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
unique : ('cgc_size_t', 'i', None)
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=0/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=1/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=1/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=2/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=2/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=3/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=3/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=4/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=4/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=5/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=5/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=6/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=6/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=7/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=7/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=10/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=10/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=11/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=11/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=12/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=12/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=13/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=13/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=16/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=16/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=20/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=20/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=21/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=21/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=23/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=23/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=24/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=24/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=25/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=25/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=26/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=26/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=27/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=27/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=28/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=28/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=30/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=30/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=31/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=31/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(i+1)%MAX_QUEUE' - False OR  False
[i=2/4][j=22/23][dd=32/37][k=9/16] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ( i + 1 ) % MAX_QUEUE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,i,+,1,),%,MAX_QUEUE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) i [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) MAX_QUEUE [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_count' - False OR  False
[i=2/4][j=22/23][dd=32/37][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : ac_queue_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_count
 => is literal (False) | is operator (False) ac_queue_count [vtype=None]
not valid - cgc_size_t i; i = ((cgc_size_t)( i + 1 ) % MAX_QUEUE);

----
UNIQ_INIT: ('cgc_size_t','i','None','None');

==== Scope 1 ====
void fix_ingred_ac_2_22_15(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue_count); }
    {int dummy; dummy = (int)(ac_queue_count); }
    {cgc_size_t i; i = (cgc_size_t)(ac_queue_count); }
    {int j; j = (int)(ac_queue_count); }
    {cgc_size_t start; start = (cgc_size_t)(ac_queue_count); }
    {cgc_size_t end; end = (cgc_size_t)(ac_queue_count); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue_count); }
    {int diff; diff = (int)(ac_queue_count); }
    {int tlv1; tlv1 = (int)(ac_queue_count); }
    {void * tlv6; tlv6 = (void *)(ac_queue_count); }
    {void * tlv5; tlv5 = (void *)(ac_queue_count); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue_count); }
    {char * newbuf; newbuf = (char *)(ac_queue_count); }
    {void * tlv14; tlv14 = (void *)(ac_queue_count); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue_count); }
    {void * tlv17; tlv17 = (void *)(ac_queue_count); }
    {void * tlv16; tlv16 = (void *)(ac_queue_count); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue_count); }
    {void * tlv20; tlv20 = (void *)(ac_queue_count); }
    {void * tlv19; tlv19 = (void *)(ac_queue_count); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue_count); }
    {void * tlv23; tlv23 = (void *)(ac_queue_count); }
    {void * tlv22; tlv22 = (void *)(ac_queue_count); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue_count); }
}
void fix_ingred_ac_2_22(){
fix_ingred_ac_2_22_15();
}

==== Scope 2 ====
void fix_ingred_ac_2_2_0(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue_head); }
    {int dummy; dummy = (int)(ac_queue_head); }
    {cgc_size_t i; i = (cgc_size_t)(ac_queue_head); }
    {int j; j = (int)(ac_queue_head); }
    {cgc_size_t start; start = (cgc_size_t)(ac_queue_head); }
    {cgc_size_t end; end = (cgc_size_t)(ac_queue_head); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue_head); }
    {int diff; diff = (int)(ac_queue_head); }
    {int tlv1; tlv1 = (int)(ac_queue_head); }
    {void * tlv6; tlv6 = (void *)(ac_queue_head); }
    {void * tlv5; tlv5 = (void *)(ac_queue_head); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue_head); }
    {char * newbuf; newbuf = (char *)(ac_queue_head); }
    {void * tlv14; tlv14 = (void *)(ac_queue_head); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue_head); }
    {void * tlv17; tlv17 = (void *)(ac_queue_head); }
    {void * tlv16; tlv16 = (void *)(ac_queue_head); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue_head); }
    {void * tlv20; tlv20 = (void *)(ac_queue_head); }
    {void * tlv19; tlv19 = (void *)(ac_queue_head); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue_head); }
    {void * tlv23; tlv23 = (void *)(ac_queue_head); }
    {void * tlv22; tlv22 = (void *)(ac_queue_head); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue_head); }
}
void fix_ingred_ac_2_2_1(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {if (ac_queue){    i = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int dummy; dummy = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int j; j = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t end; end = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int diff; diff = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         int tlv1; tlv1 = (int)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv6; tlv6 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv5; tlv5 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         char * newbuf; newbuf = (char *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv14; tlv14 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv17; tlv17 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv16; tlv16 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv20; tlv20 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv19; tlv19 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv23; tlv23 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         void * tlv22; tlv22 = (void *)(ac_queue [ i ] . start); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue [ i ] . start); }}
}
void fix_ingred_ac_2_2_2(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {if (ac_queue){    i = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int dummy; dummy = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int j; j = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t start; start = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int diff; diff = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         int tlv1; tlv1 = (int)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv6; tlv6 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv5; tlv5 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         char * newbuf; newbuf = (char *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv14; tlv14 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv17; tlv17 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv16; tlv16 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv20; tlv20 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv19; tlv19 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv23; tlv23 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         void * tlv22; tlv22 = (void *)(ac_queue [ i ] . end); }}
    {if (ac_queue){    i = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue [ i ] . end); }}
}
void fix_ingred_ac_2_2_3(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(sizeof ( word )); }
    {int dummy; dummy = (int)(sizeof ( word )); }
    {cgc_size_t i; i = (cgc_size_t)(sizeof ( word )); }
    {int j; j = (int)(sizeof ( word )); }
    {cgc_size_t start; start = (cgc_size_t)(sizeof ( word )); }
    {cgc_size_t end; end = (cgc_size_t)(sizeof ( word )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( word )); }
    {int diff; diff = (int)(sizeof ( word )); }
    {int tlv1; tlv1 = (int)(sizeof ( word )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( word )); }
    {void * tlv5; tlv5 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(sizeof ( word )); }
    {char * newbuf; newbuf = (char *)(sizeof ( word )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(sizeof ( word )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( word )); }
    {void * tlv16; tlv16 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( word )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( word )); }
    {void * tlv19; tlv19 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(sizeof ( word )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( word )); }
    {void * tlv22; tlv22 = (void *)(sizeof ( word )); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(sizeof ( word )); }
}
void fix_ingred_ac_2_2_4(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(0); }
    {int dummy; dummy = (int)(0); }
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {int j; j = (int)(0); }
    {cgc_size_t start; start = (cgc_size_t)(0); }
    {cgc_size_t end; end = (cgc_size_t)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {int diff; diff = (int)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv6; tlv6 = (void *)(0); }
    {void * tlv5; tlv5 = (void *)(0); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(0); }
    {char * newbuf; newbuf = (char *)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(0); }
    {void * tlv17; tlv17 = (void *)(0); }
    {void * tlv16; tlv16 = (void *)(0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {void * tlv19; tlv19 = (void *)(0); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(0); }
    {void * tlv23; tlv23 = (void *)(0); }
    {void * tlv22; tlv22 = (void *)(0); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(0); }
}
void fix_ingred_ac_2_2(){
fix_ingred_ac_2_2_0();
fix_ingred_ac_2_2_1();
fix_ingred_ac_2_2_2();
fix_ingred_ac_2_2_3();
fix_ingred_ac_2_2_4();
}
void fix_ingred_ac_2_4_9(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(end - start); }
    {int dummy; dummy = (int)(end - start); }
    {cgc_size_t i; i = (cgc_size_t)(end - start); }
    {int j; j = (int)(end - start); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(end - start); }
    {int diff; diff = (int)(end - start); }
    {int tlv1; tlv1 = (int)(end - start); }
    {void * tlv6; tlv6 = (void *)(end - start); }
    {void * tlv5; tlv5 = (void *)(end - start); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(end - start); }
    {char * newbuf; newbuf = (char *)(end - start); }
    {void * tlv14; tlv14 = (void *)(end - start); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(end - start); }
    {void * tlv17; tlv17 = (void *)(end - start); }
    {void * tlv16; tlv16 = (void *)(end - start); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(end - start); }
    {void * tlv20; tlv20 = (void *)(end - start); }
    {void * tlv19; tlv19 = (void *)(end - start); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(end - start); }
    {void * tlv23; tlv23 = (void *)(end - start); }
    {void * tlv22; tlv22 = (void *)(end - start); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(end - start); }
}
void fix_ingred_ac_2_4_10(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(tlv_size_0); }
    {int dummy; dummy = (int)(tlv_size_0); }
    {cgc_size_t i; i = (cgc_size_t)(tlv_size_0); }
    {int j; j = (int)(tlv_size_0); }
    {cgc_size_t start; start = (cgc_size_t)(tlv_size_0); }
    {cgc_size_t end; end = (cgc_size_t)(tlv_size_0); }
    {int diff; diff = (int)(tlv_size_0); }
    {int tlv1; tlv1 = (int)(tlv_size_0); }
    {void * tlv6; tlv6 = (void *)(tlv_size_0); }
    {void * tlv5; tlv5 = (void *)(tlv_size_0); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv_size_0); }
    {char * newbuf; newbuf = (char *)(tlv_size_0); }
    {void * tlv14; tlv14 = (void *)(tlv_size_0); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv_size_0); }
    {void * tlv17; tlv17 = (void *)(tlv_size_0); }
    {void * tlv16; tlv16 = (void *)(tlv_size_0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv_size_0); }
    {void * tlv20; tlv20 = (void *)(tlv_size_0); }
    {void * tlv19; tlv19 = (void *)(tlv_size_0); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(tlv_size_0); }
    {void * tlv23; tlv23 = (void *)(tlv_size_0); }
    {void * tlv22; tlv22 = (void *)(tlv_size_0); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(tlv_size_0); }
}
void fix_ingred_ac_2_4(){
fix_ingred_ac_2_4_9();
fix_ingred_ac_2_4_10();
}
void fix_ingred_ac_2_5_0(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word); }
    {int dummy; dummy = (int)(word); }
    {cgc_size_t i; i = (cgc_size_t)(word); }
    {int j; j = (int)(word); }
    {cgc_size_t start; start = (cgc_size_t)(word); }
    {cgc_size_t end; end = (cgc_size_t)(word); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(word); }
    {int diff; diff = (int)(word); }
    {int tlv1; tlv1 = (int)(word); }
    {void * tlv6; tlv6 = (void *)(word); }
    {void * tlv5; tlv5 = (void *)(word); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(word); }
    {char * newbuf; newbuf = (char *)(word); }
    {void * tlv14; tlv14 = (void *)(word); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(word); }
    {void * tlv17; tlv17 = (void *)(word); }
    {void * tlv16; tlv16 = (void *)(word); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(word); }
    {void * tlv20; tlv20 = (void *)(word); }
    {void * tlv19; tlv19 = (void *)(word); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(word); }
    {void * tlv23; tlv23 = (void *)(word); }
    {void * tlv22; tlv22 = (void *)(word); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(word); }
}
void fix_ingred_ac_2_5_1(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t start;
    bzero(&start,sizeof(cgc_size_t));
    {if (ac_buffer){    start = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int dummy; dummy = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t i; i = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int j; j = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t end; end = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int diff; diff = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         int tlv1; tlv1 = (int)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv6; tlv6 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv5; tlv5 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         char * newbuf; newbuf = (char *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv14; tlv14 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv17; tlv17 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv16; tlv16 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv20; tlv20 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv19; tlv19 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv23; tlv23 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         void * tlv22; tlv22 = (void *)(& ac_buffer [ start ]); }}
    {if (ac_buffer){    start = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(& ac_buffer [ start ]); }}
}
void fix_ingred_ac_2_5(){
fix_ingred_ac_2_5_0();
fix_ingred_ac_2_5_1();
}
void fix_ingred_ac_2_8_10(){
int j;
    bzero(&j,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(j); }
    {int dummy; dummy = (int)(j); }
    {cgc_size_t i; i = (cgc_size_t)(j); }
    {cgc_size_t start; start = (cgc_size_t)(j); }
    {cgc_size_t end; end = (cgc_size_t)(j); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(j); }
    {int diff; diff = (int)(j); }
    {int tlv1; tlv1 = (int)(j); }
    {void * tlv6; tlv6 = (void *)(j); }
    {void * tlv5; tlv5 = (void *)(j); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(j); }
    {char * newbuf; newbuf = (char *)(j); }
    {void * tlv14; tlv14 = (void *)(j); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(j); }
    {void * tlv17; tlv17 = (void *)(j); }
    {void * tlv16; tlv16 = (void *)(j); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(j); }
    {void * tlv20; tlv20 = (void *)(j); }
    {void * tlv19; tlv19 = (void *)(j); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(j); }
    {void * tlv23; tlv23 = (void *)(j); }
    {void * tlv22; tlv22 = (void *)(j); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(j); }
}
void fix_ingred_ac_2_8_11(){
int j;
    bzero(&j,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(cgc_num_words); }
    {int dummy; dummy = (int)(cgc_num_words); }
    {cgc_size_t i; i = (cgc_size_t)(cgc_num_words); }
    {int j; j = (int)(cgc_num_words); }
    {cgc_size_t start; start = (cgc_size_t)(cgc_num_words); }
    {cgc_size_t end; end = (cgc_size_t)(cgc_num_words); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(cgc_num_words); }
    {int diff; diff = (int)(cgc_num_words); }
    {int tlv1; tlv1 = (int)(cgc_num_words); }
    {void * tlv6; tlv6 = (void *)(cgc_num_words); }
    {void * tlv5; tlv5 = (void *)(cgc_num_words); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_num_words); }
    {char * newbuf; newbuf = (char *)(cgc_num_words); }
    {void * tlv14; tlv14 = (void *)(cgc_num_words); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(cgc_num_words); }
    {void * tlv17; tlv17 = (void *)(cgc_num_words); }
    {void * tlv16; tlv16 = (void *)(cgc_num_words); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(cgc_num_words); }
    {void * tlv20; tlv20 = (void *)(cgc_num_words); }
    {void * tlv19; tlv19 = (void *)(cgc_num_words); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(cgc_num_words); }
    {void * tlv23; tlv23 = (void *)(cgc_num_words); }
    {void * tlv22; tlv22 = (void *)(cgc_num_words); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(cgc_num_words); }
}
void fix_ingred_ac_2_8(){
fix_ingred_ac_2_8_10();
fix_ingred_ac_2_8_11();
}
void fix_ingred_ac_2_10_12(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(tlv1); }
    {int dummy; dummy = (int)(tlv1); }
    {cgc_size_t i; i = (cgc_size_t)(tlv1); }
    {int j; j = (int)(tlv1); }
    {cgc_size_t start; start = (cgc_size_t)(tlv1); }
    {cgc_size_t end; end = (cgc_size_t)(tlv1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv1); }
    {int diff; diff = (int)(tlv1); }
    {void * tlv6; tlv6 = (void *)(tlv1); }
    {void * tlv5; tlv5 = (void *)(tlv1); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(tlv1); }
    {char * newbuf; newbuf = (char *)(tlv1); }
    {void * tlv14; tlv14 = (void *)(tlv1); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv1); }
    {void * tlv17; tlv17 = (void *)(tlv1); }
    {void * tlv16; tlv16 = (void *)(tlv1); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv1); }
    {void * tlv20; tlv20 = (void *)(tlv1); }
    {void * tlv19; tlv19 = (void *)(tlv1); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(tlv1); }
    {void * tlv23; tlv23 = (void *)(tlv1); }
    {void * tlv22; tlv22 = (void *)(tlv1); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(tlv1); }
}
void fix_ingred_ac_2_10(){
fix_ingred_ac_2_10_12();
}
void fix_ingred_ac_2_11_0(){
char tlv11_ref;
    bzero(&tlv11_ref,1*sizeof(char));
const char * tlv11 = &tlv11_ref;
char tlv13_ref;
    bzero(&tlv13_ref,1*sizeof(char));
const char * tlv13 = &tlv13_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int dummy; dummy = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t i; i = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int j; j = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t start; start = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t end; end = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int diff; diff = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv6; tlv6 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv5; tlv5 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {char * newbuf; newbuf = (char *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv14; tlv14 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv17; tlv17 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv16; tlv16 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv20; tlv20 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv19; tlv19 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv23; tlv23 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {void * tlv22; tlv22 = (void *)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(cgc_strlen ( tlv11 ) - cgc_strlen ( tlv13 )); }
}
void fix_ingred_ac_2_11(){
fix_ingred_ac_2_11_0();
}
void fix_ingred_ac_2_13_14(){
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(diff); }
    {int dummy; dummy = (int)(diff); }
    {cgc_size_t i; i = (cgc_size_t)(diff); }
    {int j; j = (int)(diff); }
    {cgc_size_t start; start = (cgc_size_t)(diff); }
    {cgc_size_t end; end = (cgc_size_t)(diff); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(diff); }
    {int tlv1; tlv1 = (int)(diff); }
    {void * tlv6; tlv6 = (void *)(diff); }
    {void * tlv5; tlv5 = (void *)(diff); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(diff); }
    {char * newbuf; newbuf = (char *)(diff); }
    {void * tlv14; tlv14 = (void *)(diff); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(diff); }
    {void * tlv17; tlv17 = (void *)(diff); }
    {void * tlv16; tlv16 = (void *)(diff); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(diff); }
    {void * tlv20; tlv20 = (void *)(diff); }
    {void * tlv19; tlv19 = (void *)(diff); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(diff); }
    {void * tlv23; tlv23 = (void *)(diff); }
    {void * tlv22; tlv22 = (void *)(diff); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(diff); }
}
void fix_ingred_ac_2_13(){
fix_ingred_ac_2_13_14();
}
void fix_ingred_ac_2_14_1(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
int diff;
    bzero(&diff,sizeof(int));
    {if (ac_buffer){    end = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int dummy; dummy = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t i; i = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int j; j = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t start; start = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int diff; diff = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         int tlv1; tlv1 = (int)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv6; tlv6 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv5; tlv5 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         char * newbuf; newbuf = (char *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv14; tlv14 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv17; tlv17 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv16; tlv16 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv20; tlv20 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv19; tlv19 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv23; tlv23 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         void * tlv22; tlv22 = (void *)(& ac_buffer [ end ]); }}
    {if (ac_buffer){    end = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(& ac_buffer [ end ]); }}
}
void fix_ingred_ac_2_14_2(){
cgc_size_t end;
    bzero(&end,sizeof(cgc_size_t));
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_idx - end); }
    {int dummy; dummy = (int)(ac_idx - end); }
    {cgc_size_t i; i = (cgc_size_t)(ac_idx - end); }
    {int j; j = (int)(ac_idx - end); }
    {cgc_size_t start; start = (cgc_size_t)(ac_idx - end); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_idx - end); }
    {int diff; diff = (int)(ac_idx - end); }
    {int tlv1; tlv1 = (int)(ac_idx - end); }
    {void * tlv6; tlv6 = (void *)(ac_idx - end); }
    {void * tlv5; tlv5 = (void *)(ac_idx - end); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_idx - end); }
    {char * newbuf; newbuf = (char *)(ac_idx - end); }
    {void * tlv14; tlv14 = (void *)(ac_idx - end); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_idx - end); }
    {void * tlv17; tlv17 = (void *)(ac_idx - end); }
    {void * tlv16; tlv16 = (void *)(ac_idx - end); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_idx - end); }
    {void * tlv20; tlv20 = (void *)(ac_idx - end); }
    {void * tlv19; tlv19 = (void *)(ac_idx - end); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_idx - end); }
    {void * tlv23; tlv23 = (void *)(ac_idx - end); }
    {void * tlv22; tlv22 = (void *)(ac_idx - end); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_idx - end); }
}
void fix_ingred_ac_2_14(){
fix_ingred_ac_2_14_1();
fix_ingred_ac_2_14_2();
}
void fix_ingred_ac_2_15_0(){
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_buffer); }
    {int dummy; dummy = (int)(ac_buffer); }
    {cgc_size_t i; i = (cgc_size_t)(ac_buffer); }
    {int j; j = (int)(ac_buffer); }
    {cgc_size_t start; start = (cgc_size_t)(ac_buffer); }
    {cgc_size_t end; end = (cgc_size_t)(ac_buffer); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_buffer); }
    {int diff; diff = (int)(ac_buffer); }
    {int tlv1; tlv1 = (int)(ac_buffer); }
    {void * tlv6; tlv6 = (void *)(ac_buffer); }
    {void * tlv5; tlv5 = (void *)(ac_buffer); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_buffer); }
    {char * newbuf; newbuf = (char *)(ac_buffer); }
    {void * tlv14; tlv14 = (void *)(ac_buffer); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_buffer); }
    {void * tlv17; tlv17 = (void *)(ac_buffer); }
    {void * tlv16; tlv16 = (void *)(ac_buffer); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_buffer); }
    {void * tlv20; tlv20 = (void *)(ac_buffer); }
    {void * tlv19; tlv19 = (void *)(ac_buffer); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_buffer); }
    {void * tlv23; tlv23 = (void *)(ac_buffer); }
    {void * tlv22; tlv22 = (void *)(ac_buffer); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_buffer); }
}
void fix_ingred_ac_2_15_1(){
int diff;
    bzero(&diff,sizeof(int));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_idx + 1 + diff); }
    {int dummy; dummy = (int)(ac_idx + 1 + diff); }
    {cgc_size_t i; i = (cgc_size_t)(ac_idx + 1 + diff); }
    {int j; j = (int)(ac_idx + 1 + diff); }
    {cgc_size_t start; start = (cgc_size_t)(ac_idx + 1 + diff); }
    {cgc_size_t end; end = (cgc_size_t)(ac_idx + 1 + diff); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_idx + 1 + diff); }
    {int tlv1; tlv1 = (int)(ac_idx + 1 + diff); }
    {void * tlv6; tlv6 = (void *)(ac_idx + 1 + diff); }
    {void * tlv5; tlv5 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_idx + 1 + diff); }
    {char * newbuf; newbuf = (char *)(ac_idx + 1 + diff); }
    {void * tlv14; tlv14 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_idx + 1 + diff); }
    {void * tlv17; tlv17 = (void *)(ac_idx + 1 + diff); }
    {void * tlv16; tlv16 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_idx + 1 + diff); }
    {void * tlv20; tlv20 = (void *)(ac_idx + 1 + diff); }
    {void * tlv19; tlv19 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_idx + 1 + diff); }
    {void * tlv23; tlv23 = (void *)(ac_idx + 1 + diff); }
    {void * tlv22; tlv22 = (void *)(ac_idx + 1 + diff); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_idx + 1 + diff); }
}
void fix_ingred_ac_2_15(){
fix_ingred_ac_2_15_0();
fix_ingred_ac_2_15_1();
}
void fix_ingred_ac_2_16_16(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(newbuf); }
    {int dummy; dummy = (int)(newbuf); }
    {cgc_size_t i; i = (cgc_size_t)(newbuf); }
    {int j; j = (int)(newbuf); }
    {cgc_size_t start; start = (cgc_size_t)(newbuf); }
    {cgc_size_t end; end = (cgc_size_t)(newbuf); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(newbuf); }
    {int diff; diff = (int)(newbuf); }
    {int tlv1; tlv1 = (int)(newbuf); }
    {void * tlv6; tlv6 = (void *)(newbuf); }
    {void * tlv5; tlv5 = (void *)(newbuf); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(newbuf); }
    {void * tlv14; tlv14 = (void *)(newbuf); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(newbuf); }
    {void * tlv17; tlv17 = (void *)(newbuf); }
    {void * tlv16; tlv16 = (void *)(newbuf); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(newbuf); }
    {void * tlv20; tlv20 = (void *)(newbuf); }
    {void * tlv19; tlv19 = (void *)(newbuf); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(newbuf); }
    {void * tlv23; tlv23 = (void *)(newbuf); }
    {void * tlv22; tlv22 = (void *)(newbuf); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(newbuf); }
}
void fix_ingred_ac_2_16_17(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(NULL); }
    {int dummy; dummy = (int)(NULL); }
    {cgc_size_t i; i = (cgc_size_t)(NULL); }
    {int j; j = (int)(NULL); }
    {cgc_size_t start; start = (cgc_size_t)(NULL); }
    {cgc_size_t end; end = (cgc_size_t)(NULL); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(NULL); }
    {int diff; diff = (int)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
    {void * tlv6; tlv6 = (void *)(NULL); }
    {void * tlv5; tlv5 = (void *)(NULL); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(NULL); }
    {char * newbuf; newbuf = (char *)(NULL); }
    {void * tlv14; tlv14 = (void *)(NULL); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(NULL); }
    {void * tlv17; tlv17 = (void *)(NULL); }
    {void * tlv16; tlv16 = (void *)(NULL); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(NULL); }
    {void * tlv20; tlv20 = (void *)(NULL); }
    {void * tlv19; tlv19 = (void *)(NULL); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(NULL); }
    {void * tlv23; tlv23 = (void *)(NULL); }
    {void * tlv22; tlv22 = (void *)(NULL); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(NULL); }
}
void fix_ingred_ac_2_16(){
fix_ingred_ac_2_16_16();
fix_ingred_ac_2_16_17();
}
void fix_ingred_ac_2_19_1(){
int j;
    bzero(&j,sizeof(int));
    {if (word_list){    j = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         int dummy; dummy = (int)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t i; i = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t start; start = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t end; end = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         int diff; diff = (int)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         int tlv1; tlv1 = (int)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv6; tlv6 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv5; tlv5 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv4; tlv4 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         char * newbuf; newbuf = (char *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv14; tlv14 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv12; tlv12 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv17; tlv17 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv16; tlv16 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv15; tlv15 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv20; tlv20 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv19; tlv19 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv18; tlv18 = (cgc_size_t)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv23; tlv23 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         void * tlv22; tlv22 = (void *)(word_list [ j ] . correct); }}
    {if (word_list){    j = 0;
         cgc_size_t tlv21; tlv21 = (cgc_size_t)(word_list [ j ] . correct); }}
}
void fix_ingred_ac_2_19(){
fix_ingred_ac_2_19_1();
}
void fix_ingred_ac_2_20_0(){
char tlv24_ref;
    bzero(&tlv24_ref,1*sizeof(char));
const char * tlv24 = &tlv24_ref;
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(cgc_strlen ( tlv24 )); }
    {int dummy; dummy = (int)(cgc_strlen ( tlv24 )); }
    {cgc_size_t i; i = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {int j; j = (int)(cgc_strlen ( tlv24 )); }
    {cgc_size_t start; start = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {cgc_size_t end; end = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(cgc_strlen ( tlv24 )); }
    {int diff; diff = (int)(cgc_strlen ( tlv24 )); }
    {int tlv1; tlv1 = (int)(cgc_strlen ( tlv24 )); }
    {void * tlv6; tlv6 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv5; tlv5 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {char * newbuf; newbuf = (char *)(cgc_strlen ( tlv24 )); }
    {void * tlv14; tlv14 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {void * tlv17; tlv17 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv16; tlv16 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {void * tlv20; tlv20 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv19; tlv19 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
    {void * tlv23; tlv23 = (void *)(cgc_strlen ( tlv24 )); }
    {void * tlv22; tlv22 = (void *)(cgc_strlen ( tlv24 )); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(cgc_strlen ( tlv24 )); }
}
void fix_ingred_ac_2_20(){
fix_ingred_ac_2_20_0();
}
void fix_ingred_ac_2_22_15(){
cgc_size_t i;
    bzero(&i,sizeof(cgc_size_t));
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue_count); }
    {int dummy; dummy = (int)(ac_queue_count); }
    {cgc_size_t i; i = (cgc_size_t)(ac_queue_count); }
    {int j; j = (int)(ac_queue_count); }
    {cgc_size_t start; start = (cgc_size_t)(ac_queue_count); }
    {cgc_size_t end; end = (cgc_size_t)(ac_queue_count); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ac_queue_count); }
    {int diff; diff = (int)(ac_queue_count); }
    {int tlv1; tlv1 = (int)(ac_queue_count); }
    {void * tlv6; tlv6 = (void *)(ac_queue_count); }
    {void * tlv5; tlv5 = (void *)(ac_queue_count); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(ac_queue_count); }
    {char * newbuf; newbuf = (char *)(ac_queue_count); }
    {void * tlv14; tlv14 = (void *)(ac_queue_count); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(ac_queue_count); }
    {void * tlv17; tlv17 = (void *)(ac_queue_count); }
    {void * tlv16; tlv16 = (void *)(ac_queue_count); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(ac_queue_count); }
    {void * tlv20; tlv20 = (void *)(ac_queue_count); }
    {void * tlv19; tlv19 = (void *)(ac_queue_count); }
    {cgc_size_t tlv18; tlv18 = (cgc_size_t)(ac_queue_count); }
    {void * tlv23; tlv23 = (void *)(ac_queue_count); }
    {void * tlv22; tlv22 = (void *)(ac_queue_count); }
    {cgc_size_t tlv21; tlv21 = (cgc_size_t)(ac_queue_count); }
}
void fix_ingred_ac_2_22(){
fix_ingred_ac_2_22_15();
}
void fix_ingred_ac_2(){
fix_ingred_ac_2_2();
fix_ingred_ac_2_4();
fix_ingred_ac_2_5();
fix_ingred_ac_2_8();
fix_ingred_ac_2_10();
fix_ingred_ac_2_11();
fix_ingred_ac_2_13();
fix_ingred_ac_2_14();
fix_ingred_ac_2_15();
fix_ingred_ac_2_16();
fix_ingred_ac_2_19();
fix_ingred_ac_2_20();
fix_ingred_ac_2_22();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_ac_2_2_0();
void fix_ingred_ac_2_2_1();
void fix_ingred_ac_2_2_2();
void fix_ingred_ac_2_2_3();
void fix_ingred_ac_2_2_4();
void fix_ingred_ac_2_2();
void fix_ingred_ac_2_4_9();
void fix_ingred_ac_2_4_10();
void fix_ingred_ac_2_4();
void fix_ingred_ac_2_5_0();
void fix_ingred_ac_2_5_1();
void fix_ingred_ac_2_5();
void fix_ingred_ac_2_8_10();
void fix_ingred_ac_2_8_11();
void fix_ingred_ac_2_8();
void fix_ingred_ac_2_10_12();
void fix_ingred_ac_2_10();
void fix_ingred_ac_2_11_0();
void fix_ingred_ac_2_11();
void fix_ingred_ac_2_13_14();
void fix_ingred_ac_2_13();
void fix_ingred_ac_2_14_1();
void fix_ingred_ac_2_14_2();
void fix_ingred_ac_2_14();
void fix_ingred_ac_2_15_0();
void fix_ingred_ac_2_15_1();
void fix_ingred_ac_2_15();
void fix_ingred_ac_2_16_16();
void fix_ingred_ac_2_16_17();
void fix_ingred_ac_2_16();
void fix_ingred_ac_2_19_1();
void fix_ingred_ac_2_19();
void fix_ingred_ac_2_20_0();
void fix_ingred_ac_2_20();
void fix_ingred_ac_2_22_15();
void fix_ingred_ac_2_22();
void fix_ingred_ac_2();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t rx ;
def_vars[1]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : char * buf ;
def_vars[2]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( ac_buffer ) ;
def_vars[3]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv3 ;
def_vars[4]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_unlock ( tlv3 ) ;
def_vars[5]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t count ;
def_vars[6]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : char word [ MAX_AC_LEN ] ;
def_vars[7]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : char * newbuf ;
def_vars[8]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv4 ;
def_vars[9]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_lock ( tlv4 ) ;
def_vars[10]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : void * tlv11 ;
def_vars[11]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv10 ;
def_vars[12]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv5 ;
def_vars[13]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_lock ( tlv5 ) ;
def_vars[14]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : void * tlv8 ;
def_vars[15]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : void * tlv7 ;
def_vars[16]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv6 ;
def_vars[17]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : mutex_t * tlv9 ;
def_vars[18]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_mutex_unlock ( tlv9 ) ;
def_vars[19]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[20]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[21]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t i ;
def_vars[22]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : int tlv15 ;
def_vars[23]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : void * tlv14 ;
def_vars[24]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv13 ;
def_vars[25]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t * tlv12 ;
def_vars[26]: [cgc_ac_read] : <class 'CParser.CParser.DeclarationContext'> : int tlv16 ;
sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('char *', 'buf', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b055278>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b055d68>), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b067278>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b071518>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=0/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=1/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=3/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
Skipping MAX_AC_LEN => #define
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=4/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=5/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=7/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=8/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=10/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=11/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=12/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=14/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=15/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=16/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=17/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=18/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=19/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=0/18][dd=21/27][k=5/9] | type: char * ; var : buf ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
----
==== Scope 1 ====
void fix_ingred_ac_3_0_5(){
    {cgc_size_t rx; rx = (cgc_size_t)(ac_buffer); }
    {char * buf; buf = (char *)(ac_buffer); }
    {cgc_size_t count; count = (cgc_size_t)(ac_buffer); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_buffer); }
    {char * newbuf; newbuf = (char *)(ac_buffer); }
    {void * tlv11; tlv11 = (void *)(ac_buffer); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_buffer); }
    {void * tlv8; tlv8 = (void *)(ac_buffer); }
    {void * tlv7; tlv7 = (void *)(ac_buffer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_buffer); }
    {int tlv1; tlv1 = (int)(ac_buffer); }
    {int tlv2; tlv2 = (int)(ac_buffer); }
    {cgc_size_t i; i = (cgc_size_t)(ac_buffer); }
    {int tlv15; tlv15 = (int)(ac_buffer); }
    {void * tlv14; tlv14 = (void *)(ac_buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_buffer); }
    {int tlv16; tlv16 = (int)(ac_buffer); }
}
void fix_ingred_ac_3_0(){
fix_ingred_ac_3_0_5();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char'}'
val_s=>'[('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef69e8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b06dc88>), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b04ff28>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=0/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=1/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=3/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
Skipping MAX_AC_LEN => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=4/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=5/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=7/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=8/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=10/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=11/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=12/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=14/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=15/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=16/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=17/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=18/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=19/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=1/18][dd=21/27][k=0/9] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_ac_3_1_0(){
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {char * buf; buf = (char *)(0); }
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(0); }
    {char * newbuf; newbuf = (char *)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
    {void * tlv8; tlv8 = (void *)(0); }
    {void * tlv7; tlv7 = (void *)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {int tlv15; tlv15 = (int)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv16; tlv16 = (int)(0); }
}
void fix_ingred_ac_3_1(){
fix_ingred_ac_3_1_0();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'tlv1': 'int'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad013c8>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394ad01f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394acfd278>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=0/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=0/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=1/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=1/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=3/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=3/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
Skipping MAX_AC_LEN => #define
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=4/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=4/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=5/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=5/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=7/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=7/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=8/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=8/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=10/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=10/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=11/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=11/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=12/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=12/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=14/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=14/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=15/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=15/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=16/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=16/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=17/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=17/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=18/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=18/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=19/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=19/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/4][j=2/18][dd=21/27][k=7/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [M] => '[False, False, False]'
has_multiptr_refs 'MAX_AC_LEN' - False OR  False
[i=3/4][j=2/18][dd=21/27][k=8/9] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : MAX_AC_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : MAX_AC_LEN
 => is literal (False) | is operator (False) MAX_AC_LEN [vtype=None]
not valid - cgc_size_t count; count = ((cgc_size_t)count);

----
UNIQ_INIT: ('cgc_size_t','count','None','None');

----
UNIQ_INIT: ('cgc_size_t','count','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_2_7(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(count); }
    {char * buf; buf = (char *)(count); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(count); }
    {char * newbuf; newbuf = (char *)(count); }
    {void * tlv11; tlv11 = (void *)(count); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(count); }
    {void * tlv8; tlv8 = (void *)(count); }
    {void * tlv7; tlv7 = (void *)(count); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(count); }
    {int tlv1; tlv1 = (int)(count); }
    {int tlv2; tlv2 = (int)(count); }
    {cgc_size_t i; i = (cgc_size_t)(count); }
    {int tlv15; tlv15 = (int)(count); }
    {void * tlv14; tlv14 = (void *)(count); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(count); }
    {int tlv16; tlv16 = (int)(count); }
}
void fix_ingred_ac_3_2_8(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(MAX_AC_LEN); }
    {char * buf; buf = (char *)(MAX_AC_LEN); }
    {cgc_size_t count; count = (cgc_size_t)(MAX_AC_LEN); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(MAX_AC_LEN); }
    {char * newbuf; newbuf = (char *)(MAX_AC_LEN); }
    {void * tlv11; tlv11 = (void *)(MAX_AC_LEN); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(MAX_AC_LEN); }
    {void * tlv8; tlv8 = (void *)(MAX_AC_LEN); }
    {void * tlv7; tlv7 = (void *)(MAX_AC_LEN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv1; tlv1 = (int)(MAX_AC_LEN); }
    {int tlv2; tlv2 = (int)(MAX_AC_LEN); }
    {cgc_size_t i; i = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv15; tlv15 = (int)(MAX_AC_LEN); }
    {void * tlv14; tlv14 = (void *)(MAX_AC_LEN); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv16; tlv16 = (int)(MAX_AC_LEN); }
}
void fix_ingred_ac_3_2(){
fix_ingred_ac_3_2_7();
fix_ingred_ac_3_2_8();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'tlv1': 'int', 'tlv15': 'int', 'tlv14': 'void *', 'tlv13': 'cgc_size_t', 'tlv12': 'cgc_size_t *'}'
val_s=>'[('int', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad00b38>), ('void *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ace5ac8>), ('cgc_size_t', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ace92e8>), ('cgc_size_t *', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394acf72e8>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad013c8>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394ad01f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394acfd278>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=0/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
unique : ('int', 'fd', None)
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=0/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
unique : ('char', 'word [ MAX_AC_LEN ]', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=0/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=1/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=1/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=1/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=3/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=3/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=3/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
Skipping MAX_AC_LEN => #define
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=4/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=4/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=4/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=5/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=5/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=5/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=7/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=7/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=7/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=8/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=8/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=8/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=10/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=10/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=10/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=11/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=11/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=11/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=12/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=12/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=12/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=14/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=14/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=14/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=15/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=15/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=15/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=16/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=16/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=16/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=17/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=17/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=17/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=18/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=18/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=18/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=19/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=19/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=19/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [f] => '[False, False, False]'
has_multiptr_refs 'fd' - False OR  False
[i=3/4][j=3/18][dd=21/27][k=0/13] | type: int ; var : tlv15 ; varinfo :  ; value_node : fd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : fd
 => is literal (False) | is operator (False) fd [vtype=int]
not unique: ('int', 'fd', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&word[count]' - False OR  False
[i=3/4][j=3/18][dd=21/27][k=1/13] | type: void * ; var : tlv14 ; varinfo :  ; value_node : & word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,word,[,count,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=3/4][j=3/18][dd=21/27][k=2/13] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('int','fd','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

not valid - cgc_size_t count; count = ((cgc_size_t)& word [ count ]);

----
UNIQ_INIT: ('int','fd','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

----
UNIQ_INIT: ('int','fd','None','None');

UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_3_0(){
int fd;
    bzero(&fd,sizeof(int));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(fd); }
    {char * buf; buf = (char *)(fd); }
    {cgc_size_t count; count = (cgc_size_t)(fd); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(fd); }
    {char * newbuf; newbuf = (char *)(fd); }
    {void * tlv11; tlv11 = (void *)(fd); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(fd); }
    {void * tlv8; tlv8 = (void *)(fd); }
    {void * tlv7; tlv7 = (void *)(fd); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(fd); }
    {int tlv1; tlv1 = (int)(fd); }
    {int tlv2; tlv2 = (int)(fd); }
    {cgc_size_t i; i = (cgc_size_t)(fd); }
    {int tlv15; tlv15 = (int)(fd); }
    {void * tlv14; tlv14 = (void *)(fd); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(fd); }
    {int tlv16; tlv16 = (int)(fd); }
}
void fix_ingred_ac_3_3_1(){
int fd;
    bzero(&fd,sizeof(int));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {if (word){    count = 0;
         cgc_size_t rx; rx = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         char * buf; buf = (char *)(& word [ count ]); }}
    {if (word){    count = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& word [ count ]); }}
    {if (word){    count = 0;
         char * newbuf; newbuf = (char *)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv11; tlv11 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv10; tlv10 = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv8; tlv8 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv7; tlv7 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv1; tlv1 = (int)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv2; tlv2 = (int)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t i; i = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv15; tlv15 = (int)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv14; tlv14 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv13; tlv13 = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv16; tlv16 = (int)(& word [ count ]); }}
}
void fix_ingred_ac_3_3_2(){
int fd;
    bzero(&fd,sizeof(int));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(1); }
    {char * buf; buf = (char *)(1); }
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(1); }
    {char * newbuf; newbuf = (char *)(1); }
    {void * tlv11; tlv11 = (void *)(1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(1); }
    {void * tlv8; tlv8 = (void *)(1); }
    {void * tlv7; tlv7 = (void *)(1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(1); }
    {int tlv1; tlv1 = (int)(1); }
    {int tlv2; tlv2 = (int)(1); }
    {cgc_size_t i; i = (cgc_size_t)(1); }
    {int tlv15; tlv15 = (int)(1); }
    {void * tlv14; tlv14 = (void *)(1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(1); }
    {int tlv16; tlv16 = (int)(1); }
}
void fix_ingred_ac_3_3(){
fix_ingred_ac_3_3_0();
fix_ingred_ac_3_3_1();
fix_ingred_ac_3_3_2();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'tlv1': 'int', 'tlv15': 'int', 'tlv14': 'void *', 'tlv13': 'cgc_size_t', 'tlv12': 'cgc_size_t *'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad013c8>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394ad01f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394acfd278>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394acf5358>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394acf56d8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394acf5c88>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394acff048>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=0/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=0/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=0/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
unique : ('cgc_size_t', 'rx', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=1/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=1/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=1/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=3/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=3/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=3/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
Skipping MAX_AC_LEN => #define
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=4/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=5/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=7/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=7/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=7/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=8/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=8/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=8/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=10/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=10/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=10/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=11/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=11/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=11/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=12/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=12/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=12/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=14/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=15/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=15/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=15/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=16/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=17/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=17/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=17/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=18/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=19/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=19/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=19/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/4][j=4/18][dd=21/27][k=9/13] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/4][j=4/18][dd=21/27][k=10/13] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx' - False OR  False
[i=3/4][j=4/18][dd=21/27][k=11/13] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx
 => is literal (False) | is operator (False) rx [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx', None) ... continue!
----
UNIQ_INIT: ('int','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','rx','None','None');

----
UNIQ_INIT: ('int','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','rx','None','None');

not valid - cgc_size_t rx; rx = ((cgc_size_t)rx);

----
UNIQ_INIT: ('int','tlv1','None','None');

UNIQ_INIT: ('cgc_size_t','rx','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_4_9(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(tlv1); }
    {char * buf; buf = (char *)(tlv1); }
    {cgc_size_t count; count = (cgc_size_t)(tlv1); }
    {void * tlv11; tlv11 = (void *)(tlv1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv1); }
    {void * tlv8; tlv8 = (void *)(tlv1); }
    {void * tlv7; tlv7 = (void *)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {int tlv15; tlv15 = (int)(tlv1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(tlv1); }
    {int tlv16; tlv16 = (int)(tlv1); }
}
void fix_ingred_ac_3_4_10(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {char * buf; buf = (char *)(0); }
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
    {void * tlv8; tlv8 = (void *)(0); }
    {void * tlv7; tlv7 = (void *)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {int tlv15; tlv15 = (int)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv16; tlv16 = (int)(0); }
}
void fix_ingred_ac_3_4_11(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {char * buf; buf = (char *)(rx); }
    {cgc_size_t count; count = (cgc_size_t)(rx); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(rx); }
    {char * newbuf; newbuf = (char *)(rx); }
    {void * tlv11; tlv11 = (void *)(rx); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(rx); }
    {void * tlv8; tlv8 = (void *)(rx); }
    {void * tlv7; tlv7 = (void *)(rx); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(rx); }
    {int tlv1; tlv1 = (int)(rx); }
    {int tlv2; tlv2 = (int)(rx); }
    {cgc_size_t i; i = (cgc_size_t)(rx); }
    {int tlv15; tlv15 = (int)(rx); }
    {void * tlv14; tlv14 = (void *)(rx); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(rx); }
    {int tlv16; tlv16 = (int)(rx); }
}
void fix_ingred_ac_3_4(){
fix_ingred_ac_3_4_9();
fix_ingred_ac_3_4_10();
fix_ingred_ac_3_4_11();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'tlv1': 'int', 'tlv15': 'int', 'tlv14': 'void *', 'tlv13': 'cgc_size_t', 'tlv12': 'cgc_size_t *', 'tlv2': 'int', 'tlv16': 'int'}'
val_s=>'[('int', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad02358>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad013c8>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394ad01f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394acfd278>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=0/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
unique : ('char', 'word [ MAX_AC_LEN ]', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=1/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=3/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
Skipping MAX_AC_LEN => #define
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=4/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=5/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=7/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=8/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=10/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=11/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=12/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=14/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=15/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=16/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=17/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=18/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=19/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=5/18][dd=21/27][k=0/10] | type: int ; var : tlv16 ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
not valid - cgc_size_t count; count = ((cgc_size_t)word [ count ]);

----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_5_0(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {if (word){    count = 0;
         cgc_size_t rx; rx = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         char * buf; buf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word [ count ]); }}
    {if (word){    count = 0;
         char * newbuf; newbuf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv11; tlv11 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv10; tlv10 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv8; tlv8 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv7; tlv7 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv1; tlv1 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv2; tlv2 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t i; i = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv15; tlv15 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv14; tlv14 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv13; tlv13 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv16; tlv16 = (int)(word [ count ]); }}
}
void fix_ingred_ac_3_5(){
fix_ingred_ac_3_5_0();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'tlv1': 'int', 'tlv15': 'int', 'tlv14': 'void *', 'tlv13': 'cgc_size_t', 'tlv12': 'cgc_size_t *', 'tlv2': 'int', 'tlv16': 'int'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394ad013c8>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394ad01f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394acfd278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394aece4a8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394aecef98>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=0/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
unique : ('char', 'word [ MAX_AC_LEN ]', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=0/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
unique : ('char', 'term', None)
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=1/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=1/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=3/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=3/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
Skipping MAX_AC_LEN => #define
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=4/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=4/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=5/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=5/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=7/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=7/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=8/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=8/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=10/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=10/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=11/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=11/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=12/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=12/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=14/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=14/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=15/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=15/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=16/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=16/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=17/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=17/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=18/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=18/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=19/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=19/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word[count]' - False OR  False
[i=3/4][j=6/18][dd=21/27][k=9/11] | type: char * ; var :  ; varinfo :  ; value_node : word [ count ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word,[,count,]
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=6/18][dd=21/27][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
not valid - cgc_size_t count; count = ((cgc_size_t)word [ count ]);

----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

UNIQ_INIT: ('char','term','None','None');

----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

UNIQ_INIT: ('char','term','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_6_9(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
char term;
    bzero(&term,sizeof(char));
    {if (word){    count = 0;
         cgc_size_t rx; rx = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         char * buf; buf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word [ count ]); }}
    {if (word){    count = 0;
         char * newbuf; newbuf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv11; tlv11 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv10; tlv10 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv8; tlv8 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv7; tlv7 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv1; tlv1 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv2; tlv2 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t i; i = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv15; tlv15 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv14; tlv14 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv13; tlv13 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv16; tlv16 = (int)(word [ count ]); }}
}
void fix_ingred_ac_3_6_10(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
char term;
    bzero(&term,sizeof(char));
    {cgc_size_t rx; rx = (cgc_size_t)(term); }
    {char * buf; buf = (char *)(term); }
    {cgc_size_t count; count = (cgc_size_t)(term); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(term); }
    {char * newbuf; newbuf = (char *)(term); }
    {void * tlv11; tlv11 = (void *)(term); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(term); }
    {void * tlv8; tlv8 = (void *)(term); }
    {void * tlv7; tlv7 = (void *)(term); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(term); }
    {int tlv1; tlv1 = (int)(term); }
    {int tlv2; tlv2 = (int)(term); }
    {cgc_size_t i; i = (cgc_size_t)(term); }
    {int tlv15; tlv15 = (int)(term); }
    {void * tlv14; tlv14 = (void *)(term); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(term); }
    {int tlv16; tlv16 = (int)(term); }
}
void fix_ingred_ac_3_6(){
fix_ingred_ac_3_6_9();
fix_ingred_ac_3_6_10();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aee84a8>), ('cgc_size_t', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aefb3c8>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=0/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=0/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=1/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=1/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=3/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=3/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
Skipping MAX_AC_LEN => #define
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=4/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=5/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=7/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=7/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=8/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=8/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=10/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=10/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=11/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=11/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=12/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=12/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=14/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=15/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=15/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=16/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=17/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=17/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=18/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=19/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=19/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer' - False OR  False
[i=3/4][j=7/18][dd=21/27][k=0/8] | type: void * ; var : tlv11 ; varinfo :  ; value_node : ac_buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_idx+count+1' - False OR  False
[i=3/4][j=7/18][dd=21/27][k=1/8] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : ac_idx + count + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_idx,+,count,+,1
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('cgc_size_t','count','None','None');

not valid - cgc_size_t count; count = ((cgc_size_t)ac_idx + count + 1);

----
UNIQ_INIT: ('cgc_size_t','count','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_7_0(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(ac_buffer); }
    {char * buf; buf = (char *)(ac_buffer); }
    {cgc_size_t count; count = (cgc_size_t)(ac_buffer); }
    {void * tlv11; tlv11 = (void *)(ac_buffer); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_buffer); }
    {void * tlv8; tlv8 = (void *)(ac_buffer); }
    {void * tlv7; tlv7 = (void *)(ac_buffer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_buffer); }
    {int tlv2; tlv2 = (int)(ac_buffer); }
    {int tlv15; tlv15 = (int)(ac_buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_buffer); }
    {int tlv16; tlv16 = (int)(ac_buffer); }
}
void fix_ingred_ac_3_7_1(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(ac_idx + count + 1); }
    {char * buf; buf = (char *)(ac_idx + count + 1); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_idx + count + 1); }
    {char * newbuf; newbuf = (char *)(ac_idx + count + 1); }
    {void * tlv11; tlv11 = (void *)(ac_idx + count + 1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_idx + count + 1); }
    {void * tlv8; tlv8 = (void *)(ac_idx + count + 1); }
    {void * tlv7; tlv7 = (void *)(ac_idx + count + 1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_idx + count + 1); }
    {int tlv1; tlv1 = (int)(ac_idx + count + 1); }
    {int tlv2; tlv2 = (int)(ac_idx + count + 1); }
    {cgc_size_t i; i = (cgc_size_t)(ac_idx + count + 1); }
    {int tlv15; tlv15 = (int)(ac_idx + count + 1); }
    {void * tlv14; tlv14 = (void *)(ac_idx + count + 1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_idx + count + 1); }
    {int tlv16; tlv16 = (int)(ac_idx + count + 1); }
}
void fix_ingred_ac_3_7(){
fix_ingred_ac_3_7_0();
fix_ingred_ac_3_7_1();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394aeda3c8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394aeda748>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=0/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
unique : ('char *', 'newbuf', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=0/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=1/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=1/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=3/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=3/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
Skipping MAX_AC_LEN => #define
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=7/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=7/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=8/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=8/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=10/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=10/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=11/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=11/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=12/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=12/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=15/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=15/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=17/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=17/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=19/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=19/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'newbuf' - False OR  False
[i=3/4][j=8/18][dd=21/27][k=6/8] | type: char * ; var :  ; varinfo :  ; value_node : newbuf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : newbuf
 => is literal (False) | is operator (False) newbuf [vtype=char *]
not unique: ('char *', 'newbuf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/4][j=8/18][dd=21/27][k=7/8] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
UNIQ_INIT: ('char *','newbuf','None','None');

----
UNIQ_INIT: ('char *','newbuf','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_8_6(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {cgc_size_t rx; rx = (cgc_size_t)(newbuf); }
    {char * buf; buf = (char *)(newbuf); }
    {cgc_size_t count; count = (cgc_size_t)(newbuf); }
    {void * tlv11; tlv11 = (void *)(newbuf); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(newbuf); }
    {void * tlv8; tlv8 = (void *)(newbuf); }
    {void * tlv7; tlv7 = (void *)(newbuf); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(newbuf); }
    {int tlv2; tlv2 = (int)(newbuf); }
    {int tlv15; tlv15 = (int)(newbuf); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(newbuf); }
    {int tlv16; tlv16 = (int)(newbuf); }
}
void fix_ingred_ac_3_8_7(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {cgc_size_t rx; rx = (cgc_size_t)(NULL); }
    {char * buf; buf = (char *)(NULL); }
    {cgc_size_t count; count = (cgc_size_t)(NULL); }
    {void * tlv11; tlv11 = (void *)(NULL); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(NULL); }
    {void * tlv8; tlv8 = (void *)(NULL); }
    {void * tlv7; tlv7 = (void *)(NULL); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NULL); }
    {int tlv2; tlv2 = (int)(NULL); }
    {int tlv15; tlv15 = (int)(NULL); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(NULL); }
    {int tlv16; tlv16 = (int)(NULL); }
}
void fix_ingred_ac_3_8(){
fix_ingred_ac_3_8_6();
fix_ingred_ac_3_8_7();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t', 'tlv5': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef4828>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t', 'tlv5': 'mutex_t *', 'tlv8': 'void *', 'tlv7': 'void *', 'tlv6': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aee3b38>), ('void *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef93c8>), ('cgc_size_t', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0742e8>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef69e8>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=0/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=0/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
unique : ('char', 'word [ MAX_AC_LEN ]', None)
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=1/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=1/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=3/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=3/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
Skipping MAX_AC_LEN => #define
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=4/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=5/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=7/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=7/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=8/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=8/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=10/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=10/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=11/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=11/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=12/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=12/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=14/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=15/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=15/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=16/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=17/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=17/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=18/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=19/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=19/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&ac_buffer[ac_idx]' - False OR  False
[i=3/4][j=10/18][dd=21/27][k=0/10] | type: void * ; var : tlv8 ; varinfo :  ; value_node : & ac_buffer [ ac_idx ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,ac_buffer,[,ac_idx,]
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) ]
is_func_ [w] => '[False, False, False]'
has_multiptr_refs 'word' - False OR  False
[i=3/4][j=10/18][dd=21/27][k=1/10] | type: void * ; var : tlv7 ; varinfo :  ; value_node : word (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : word
 => is literal (False) | is operator (False) word [vtype=char *]
BEFORE => literal (False) word => char *
AFTER => literal (False) word [ MAX_AC_LEN ] => char [size=MAX_AC_LEN]
Array size is variable => 'MAX_AC_LEN'
not unique: ('char', 'word [ MAX_AC_LEN ]', None) ... continue!
----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

----
UNIQ_INIT: ('char','word [ MAX_AC_LEN ]','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_10_0(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {if (ac_buffer){cgc_size_t rx; rx = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){char * buf; buf = (char *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t count; count = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){char * newbuf; newbuf = (char *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv11; tlv11 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t tlv10; tlv10 = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv8; tlv8 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv7; tlv7 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t tlv6; tlv6 = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv1; tlv1 = (int)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv2; tlv2 = (int)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t i; i = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv15; tlv15 = (int)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv14; tlv14 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t tlv13; tlv13 = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv16; tlv16 = (int)(& ac_buffer [ ac_idx ]); }}
}
void fix_ingred_ac_3_10_1(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {cgc_size_t rx; rx = (cgc_size_t)(word); }
    {char * buf; buf = (char *)(word); }
    {cgc_size_t count; count = (cgc_size_t)(word); }
    {void * tlv11; tlv11 = (void *)(word); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(word); }
    {void * tlv8; tlv8 = (void *)(word); }
    {void * tlv7; tlv7 = (void *)(word); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(word); }
    {int tlv2; tlv2 = (int)(word); }
    {int tlv15; tlv15 = (int)(word); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(word); }
    {int tlv16; tlv16 = (int)(word); }
}
void fix_ingred_ac_3_10(){
fix_ingred_ac_3_10_0();
fix_ingred_ac_3_10_1();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t', 'tlv5': 'mutex_t *', 'tlv8': 'void *', 'tlv7': 'void *', 'tlv6': 'cgc_size_t', 'tlv9': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b052128>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef69e8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b06dc88>), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b04ff28>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t', 'tlv5': 'mutex_t *', 'tlv8': 'void *', 'tlv7': 'void *', 'tlv6': 'cgc_size_t', 'tlv9': 'mutex_t *'}'
val_s=>'[('cgc_size_t', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b06ba58>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b07b588>), ('UNDEF', 'ac_queue ', '[ i ] . start', <CParser.CParser.AssignmentExpressionContext object at 0x15394b060c88>), ('UNDEF', 'ac_queue ', '[ i ] . end', <CParser.CParser.AssignmentExpressionContext object at 0x15394b05b198>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef69e8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b06dc88>), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b04ff28>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b05a4a8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b05a7b8>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=0/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=1/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=3/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
Skipping MAX_AC_LEN => #define
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=4/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=5/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=7/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=8/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=10/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=11/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=12/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=14/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=15/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=16/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=17/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=18/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=19/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_queue_tail' - False OR  False
[i=3/4][j=12/18][dd=21/27][k=0/15] | type: cgc_size_t ; var : i ; varinfo :  ; value_node : ac_queue_tail (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_queue_tail
 => is literal (False) | is operator (False) ac_queue_tail [vtype=None]
----
==== Scope 1 ====
void fix_ingred_ac_3_12_0(){
    {cgc_size_t rx; rx = (cgc_size_t)(ac_queue_tail); }
    {char * buf; buf = (char *)(ac_queue_tail); }
    {cgc_size_t count; count = (cgc_size_t)(ac_queue_tail); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue_tail); }
    {char * newbuf; newbuf = (char *)(ac_queue_tail); }
    {void * tlv11; tlv11 = (void *)(ac_queue_tail); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_queue_tail); }
    {void * tlv8; tlv8 = (void *)(ac_queue_tail); }
    {void * tlv7; tlv7 = (void *)(ac_queue_tail); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_queue_tail); }
    {int tlv1; tlv1 = (int)(ac_queue_tail); }
    {int tlv2; tlv2 = (int)(ac_queue_tail); }
    {cgc_size_t i; i = (cgc_size_t)(ac_queue_tail); }
    {int tlv15; tlv15 = (int)(ac_queue_tail); }
    {void * tlv14; tlv14 = (void *)(ac_queue_tail); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_queue_tail); }
    {int tlv16; tlv16 = (int)(ac_queue_tail); }
}
void fix_ingred_ac_3_12(){
fix_ingred_ac_3_12_0();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t', 'tlv5': 'mutex_t *', 'tlv8': 'void *', 'tlv7': 'void *', 'tlv6': 'cgc_size_t', 'tlv9': 'mutex_t *'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef69e8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b06dc88>), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b04ff28>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b05a4a8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b05a7b8>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b07f208>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b07f518>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'count': 'cgc_size_t', 'word': 'char *', 'word [ MAX_AC_LEN ]': 'char', 'newbuf': 'char *', 'tlv11': 'void *', 'tlv10': 'cgc_size_t', 'tlv5': 'mutex_t *', 'tlv8': 'void *', 'tlv7': 'void *', 'tlv6': 'cgc_size_t', 'tlv9': 'mutex_t *'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b49ec88>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394aef69e8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b06dc88>), ('UNDEF', 'ac_buffer ', '[ ac_idx ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b04ff28>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b0575f8>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15394b057c88>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=0/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=0/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
unique : ('char', 'term', None)
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=1/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=1/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=3/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=3/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
Skipping MAX_AC_LEN => #define
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=4/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=4/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=5/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=5/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=7/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=7/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=8/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=8/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=10/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=10/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=11/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=11/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=12/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=12/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=14/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=14/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=15/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=15/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=16/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=16/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=17/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=17/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=18/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=18/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=19/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=19/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'ac_buffer[ac_idx-1]' - False OR  False
[i=3/4][j=14/18][dd=21/27][k=9/11] | type: char ; var :  ; varinfo :  ; value_node : ac_buffer [ ac_idx - 1 ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ac_buffer,[,ac_idx,-,1,]
 => is literal (False) | is operator (False) ac_buffer [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ac_idx [vtype=None]
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'term' - False OR  False
[i=3/4][j=14/18][dd=21/27][k=10/11] | type: char ; var :  ; varinfo :  ; value_node : term (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : term
 => is literal (False) | is operator (False) term [vtype=char]
not unique: ('char', 'term', None) ... continue!
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
 =====> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] 'ac_buffer [ ac_idx - 1 ]' => [False, True, False, False] 
 === FOUND IT ===> [('ac_idx - 1 ', 'ac_idx - 1 ', 'ac_idx - 1 ')] [ac_buffer [ ac_idx - 1 ]] 
----
UNIQ_INIT: ('char','term','None','None');

==== Scope 1 ====
void fix_ingred_ac_3_14_10(){
char term;
    bzero(&term,sizeof(char));
    {cgc_size_t rx; rx = (cgc_size_t)(term); }
    {char * buf; buf = (char *)(term); }
    {cgc_size_t count; count = (cgc_size_t)(term); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(term); }
    {char * newbuf; newbuf = (char *)(term); }
    {void * tlv11; tlv11 = (void *)(term); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(term); }
    {void * tlv8; tlv8 = (void *)(term); }
    {void * tlv7; tlv7 = (void *)(term); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(term); }
    {int tlv1; tlv1 = (int)(term); }
    {int tlv2; tlv2 = (int)(term); }
    {cgc_size_t i; i = (cgc_size_t)(term); }
    {int tlv15; tlv15 = (int)(term); }
    {void * tlv14; tlv14 = (void *)(term); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(term); }
    {int tlv16; tlv16 = (int)(term); }
}
void fix_ingred_ac_3_14(){
fix_ingred_ac_3_14_10();
}

sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t'}'
val_s=>'[('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b078978>), ('UNDEF', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15394b078c88>)]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'buf': 'char *', 'tlv4': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b059dd8>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('char *', 'buf', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b055278>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b055d68>), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b067278>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
sym_lut=>'{'fd': 'int', 'term': 'char', 'rx': 'cgc_size_t', 'buf': 'char *', 'tlv4': 'mutex_t *', 'tlv3': 'mutex_t *'}'
val_s=>'[('mutex_t *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b0656d8>), ('UNDEF', 'ac_queue_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493198>), ('UNDEF', 'ac_queue_head', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4933c8>), ('UNDEF', 'ac_queue_tail', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b4935f8>), ('UNDEF', 'ac_idx', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b493828>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b490358>), ('char *', 'buf', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b055278>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b055d68>), ('UNDEF', 'buf ', '[ ac_idx - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15394b067278>), ('UNDEF', 'ac_buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x15394b071518>)]'
cval_s=>'[]'
Checking 'cgc_free( ac_buffer )' - is_func=True, is_func_ptr=False
cgc_free( ac_buffer ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv3 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv3 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv4 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv4 ) is a function.
Skipping.
Checking 'cgc_mutex_lock( tlv5 )' - is_func=True, is_func_ptr=False
cgc_mutex_lock( tlv5 ) is a function.
Skipping.
Checking 'cgc_mutex_unlock( tlv9 )' - is_func=True, is_func_ptr=False
cgc_mutex_unlock( tlv9 ) is a function.
Skipping.
Skipping MAX_AC_LEN => #define
==== Scope 2 ====
void fix_ingred_ac_3_0_5(){
    {cgc_size_t rx; rx = (cgc_size_t)(ac_buffer); }
    {char * buf; buf = (char *)(ac_buffer); }
    {cgc_size_t count; count = (cgc_size_t)(ac_buffer); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_buffer); }
    {char * newbuf; newbuf = (char *)(ac_buffer); }
    {void * tlv11; tlv11 = (void *)(ac_buffer); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_buffer); }
    {void * tlv8; tlv8 = (void *)(ac_buffer); }
    {void * tlv7; tlv7 = (void *)(ac_buffer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_buffer); }
    {int tlv1; tlv1 = (int)(ac_buffer); }
    {int tlv2; tlv2 = (int)(ac_buffer); }
    {cgc_size_t i; i = (cgc_size_t)(ac_buffer); }
    {int tlv15; tlv15 = (int)(ac_buffer); }
    {void * tlv14; tlv14 = (void *)(ac_buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_buffer); }
    {int tlv16; tlv16 = (int)(ac_buffer); }
}
void fix_ingred_ac_3_0(){
fix_ingred_ac_3_0_5();
}
void fix_ingred_ac_3_1_0(){
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {char * buf; buf = (char *)(0); }
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(0); }
    {char * newbuf; newbuf = (char *)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
    {void * tlv8; tlv8 = (void *)(0); }
    {void * tlv7; tlv7 = (void *)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t i; i = (cgc_size_t)(0); }
    {int tlv15; tlv15 = (int)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv16; tlv16 = (int)(0); }
}
void fix_ingred_ac_3_1(){
fix_ingred_ac_3_1_0();
}
void fix_ingred_ac_3_2_7(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(count); }
    {char * buf; buf = (char *)(count); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(count); }
    {char * newbuf; newbuf = (char *)(count); }
    {void * tlv11; tlv11 = (void *)(count); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(count); }
    {void * tlv8; tlv8 = (void *)(count); }
    {void * tlv7; tlv7 = (void *)(count); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(count); }
    {int tlv1; tlv1 = (int)(count); }
    {int tlv2; tlv2 = (int)(count); }
    {cgc_size_t i; i = (cgc_size_t)(count); }
    {int tlv15; tlv15 = (int)(count); }
    {void * tlv14; tlv14 = (void *)(count); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(count); }
    {int tlv16; tlv16 = (int)(count); }
}
void fix_ingred_ac_3_2_8(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(MAX_AC_LEN); }
    {char * buf; buf = (char *)(MAX_AC_LEN); }
    {cgc_size_t count; count = (cgc_size_t)(MAX_AC_LEN); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(MAX_AC_LEN); }
    {char * newbuf; newbuf = (char *)(MAX_AC_LEN); }
    {void * tlv11; tlv11 = (void *)(MAX_AC_LEN); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(MAX_AC_LEN); }
    {void * tlv8; tlv8 = (void *)(MAX_AC_LEN); }
    {void * tlv7; tlv7 = (void *)(MAX_AC_LEN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv1; tlv1 = (int)(MAX_AC_LEN); }
    {int tlv2; tlv2 = (int)(MAX_AC_LEN); }
    {cgc_size_t i; i = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv15; tlv15 = (int)(MAX_AC_LEN); }
    {void * tlv14; tlv14 = (void *)(MAX_AC_LEN); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(MAX_AC_LEN); }
    {int tlv16; tlv16 = (int)(MAX_AC_LEN); }
}
void fix_ingred_ac_3_2(){
fix_ingred_ac_3_2_7();
fix_ingred_ac_3_2_8();
}
void fix_ingred_ac_3_3_0(){
int fd;
    bzero(&fd,sizeof(int));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(fd); }
    {char * buf; buf = (char *)(fd); }
    {cgc_size_t count; count = (cgc_size_t)(fd); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(fd); }
    {char * newbuf; newbuf = (char *)(fd); }
    {void * tlv11; tlv11 = (void *)(fd); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(fd); }
    {void * tlv8; tlv8 = (void *)(fd); }
    {void * tlv7; tlv7 = (void *)(fd); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(fd); }
    {int tlv1; tlv1 = (int)(fd); }
    {int tlv2; tlv2 = (int)(fd); }
    {cgc_size_t i; i = (cgc_size_t)(fd); }
    {int tlv15; tlv15 = (int)(fd); }
    {void * tlv14; tlv14 = (void *)(fd); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(fd); }
    {int tlv16; tlv16 = (int)(fd); }
}
void fix_ingred_ac_3_3_1(){
int fd;
    bzero(&fd,sizeof(int));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {if (word){    count = 0;
         cgc_size_t rx; rx = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         char * buf; buf = (char *)(& word [ count ]); }}
    {if (word){    count = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& word [ count ]); }}
    {if (word){    count = 0;
         char * newbuf; newbuf = (char *)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv11; tlv11 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv10; tlv10 = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv8; tlv8 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv7; tlv7 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv1; tlv1 = (int)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv2; tlv2 = (int)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t i; i = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv15; tlv15 = (int)(& word [ count ]); }}
    {if (word){    count = 0;
         void * tlv14; tlv14 = (void *)(& word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv13; tlv13 = (cgc_size_t)(& word [ count ]); }}
    {if (word){    count = 0;
         int tlv16; tlv16 = (int)(& word [ count ]); }}
}
void fix_ingred_ac_3_3_2(){
int fd;
    bzero(&fd,sizeof(int));
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(1); }
    {char * buf; buf = (char *)(1); }
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(1); }
    {char * newbuf; newbuf = (char *)(1); }
    {void * tlv11; tlv11 = (void *)(1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(1); }
    {void * tlv8; tlv8 = (void *)(1); }
    {void * tlv7; tlv7 = (void *)(1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(1); }
    {int tlv1; tlv1 = (int)(1); }
    {int tlv2; tlv2 = (int)(1); }
    {cgc_size_t i; i = (cgc_size_t)(1); }
    {int tlv15; tlv15 = (int)(1); }
    {void * tlv14; tlv14 = (void *)(1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(1); }
    {int tlv16; tlv16 = (int)(1); }
}
void fix_ingred_ac_3_3(){
fix_ingred_ac_3_3_0();
fix_ingred_ac_3_3_1();
fix_ingred_ac_3_3_2();
}
void fix_ingred_ac_3_4_9(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(tlv1); }
    {char * buf; buf = (char *)(tlv1); }
    {cgc_size_t count; count = (cgc_size_t)(tlv1); }
    {void * tlv11; tlv11 = (void *)(tlv1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(tlv1); }
    {void * tlv8; tlv8 = (void *)(tlv1); }
    {void * tlv7; tlv7 = (void *)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {int tlv15; tlv15 = (int)(tlv1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(tlv1); }
    {int tlv16; tlv16 = (int)(tlv1); }
}
void fix_ingred_ac_3_4_10(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(0); }
    {char * buf; buf = (char *)(0); }
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
    {void * tlv8; tlv8 = (void *)(0); }
    {void * tlv7; tlv7 = (void *)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {int tlv15; tlv15 = (int)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv16; tlv16 = (int)(0); }
}
void fix_ingred_ac_3_4_11(){
int tlv1;
    bzero(&tlv1,sizeof(int));
cgc_size_t rx;
    bzero(&rx,sizeof(cgc_size_t));
    {char * buf; buf = (char *)(rx); }
    {cgc_size_t count; count = (cgc_size_t)(rx); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(rx); }
    {char * newbuf; newbuf = (char *)(rx); }
    {void * tlv11; tlv11 = (void *)(rx); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(rx); }
    {void * tlv8; tlv8 = (void *)(rx); }
    {void * tlv7; tlv7 = (void *)(rx); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(rx); }
    {int tlv1; tlv1 = (int)(rx); }
    {int tlv2; tlv2 = (int)(rx); }
    {cgc_size_t i; i = (cgc_size_t)(rx); }
    {int tlv15; tlv15 = (int)(rx); }
    {void * tlv14; tlv14 = (void *)(rx); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(rx); }
    {int tlv16; tlv16 = (int)(rx); }
}
void fix_ingred_ac_3_4(){
fix_ingred_ac_3_4_9();
fix_ingred_ac_3_4_10();
fix_ingred_ac_3_4_11();
}
void fix_ingred_ac_3_5_0(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {if (word){    count = 0;
         cgc_size_t rx; rx = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         char * buf; buf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word [ count ]); }}
    {if (word){    count = 0;
         char * newbuf; newbuf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv11; tlv11 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv10; tlv10 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv8; tlv8 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv7; tlv7 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv1; tlv1 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv2; tlv2 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t i; i = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv15; tlv15 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv14; tlv14 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv13; tlv13 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv16; tlv16 = (int)(word [ count ]); }}
}
void fix_ingred_ac_3_5(){
fix_ingred_ac_3_5_0();
}
void fix_ingred_ac_3_6_9(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
char term;
    bzero(&term,sizeof(char));
    {if (word){    count = 0;
         cgc_size_t rx; rx = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         char * buf; buf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(word [ count ]); }}
    {if (word){    count = 0;
         char * newbuf; newbuf = (char *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv11; tlv11 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv10; tlv10 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv8; tlv8 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv7; tlv7 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv1; tlv1 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv2; tlv2 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t i; i = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv15; tlv15 = (int)(word [ count ]); }}
    {if (word){    count = 0;
         void * tlv14; tlv14 = (void *)(word [ count ]); }}
    {if (word){    count = 0;
         cgc_size_t tlv13; tlv13 = (cgc_size_t)(word [ count ]); }}
    {if (word){    count = 0;
         int tlv16; tlv16 = (int)(word [ count ]); }}
}
void fix_ingred_ac_3_6_10(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
char term;
    bzero(&term,sizeof(char));
    {cgc_size_t rx; rx = (cgc_size_t)(term); }
    {char * buf; buf = (char *)(term); }
    {cgc_size_t count; count = (cgc_size_t)(term); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(term); }
    {char * newbuf; newbuf = (char *)(term); }
    {void * tlv11; tlv11 = (void *)(term); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(term); }
    {void * tlv8; tlv8 = (void *)(term); }
    {void * tlv7; tlv7 = (void *)(term); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(term); }
    {int tlv1; tlv1 = (int)(term); }
    {int tlv2; tlv2 = (int)(term); }
    {cgc_size_t i; i = (cgc_size_t)(term); }
    {int tlv15; tlv15 = (int)(term); }
    {void * tlv14; tlv14 = (void *)(term); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(term); }
    {int tlv16; tlv16 = (int)(term); }
}
void fix_ingred_ac_3_6(){
fix_ingred_ac_3_6_9();
fix_ingred_ac_3_6_10();
}
void fix_ingred_ac_3_7_0(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(ac_buffer); }
    {char * buf; buf = (char *)(ac_buffer); }
    {cgc_size_t count; count = (cgc_size_t)(ac_buffer); }
    {void * tlv11; tlv11 = (void *)(ac_buffer); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_buffer); }
    {void * tlv8; tlv8 = (void *)(ac_buffer); }
    {void * tlv7; tlv7 = (void *)(ac_buffer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_buffer); }
    {int tlv2; tlv2 = (int)(ac_buffer); }
    {int tlv15; tlv15 = (int)(ac_buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_buffer); }
    {int tlv16; tlv16 = (int)(ac_buffer); }
}
void fix_ingred_ac_3_7_1(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {cgc_size_t rx; rx = (cgc_size_t)(ac_idx + count + 1); }
    {char * buf; buf = (char *)(ac_idx + count + 1); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_idx + count + 1); }
    {char * newbuf; newbuf = (char *)(ac_idx + count + 1); }
    {void * tlv11; tlv11 = (void *)(ac_idx + count + 1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_idx + count + 1); }
    {void * tlv8; tlv8 = (void *)(ac_idx + count + 1); }
    {void * tlv7; tlv7 = (void *)(ac_idx + count + 1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_idx + count + 1); }
    {int tlv1; tlv1 = (int)(ac_idx + count + 1); }
    {int tlv2; tlv2 = (int)(ac_idx + count + 1); }
    {cgc_size_t i; i = (cgc_size_t)(ac_idx + count + 1); }
    {int tlv15; tlv15 = (int)(ac_idx + count + 1); }
    {void * tlv14; tlv14 = (void *)(ac_idx + count + 1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_idx + count + 1); }
    {int tlv16; tlv16 = (int)(ac_idx + count + 1); }
}
void fix_ingred_ac_3_7(){
fix_ingred_ac_3_7_0();
fix_ingred_ac_3_7_1();
}
void fix_ingred_ac_3_8_6(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {cgc_size_t rx; rx = (cgc_size_t)(newbuf); }
    {char * buf; buf = (char *)(newbuf); }
    {cgc_size_t count; count = (cgc_size_t)(newbuf); }
    {void * tlv11; tlv11 = (void *)(newbuf); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(newbuf); }
    {void * tlv8; tlv8 = (void *)(newbuf); }
    {void * tlv7; tlv7 = (void *)(newbuf); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(newbuf); }
    {int tlv2; tlv2 = (int)(newbuf); }
    {int tlv15; tlv15 = (int)(newbuf); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(newbuf); }
    {int tlv16; tlv16 = (int)(newbuf); }
}
void fix_ingred_ac_3_8_7(){
char newbuf_ref;
    bzero(&newbuf_ref,1*sizeof(char));
char * newbuf = &newbuf_ref;
    {cgc_size_t rx; rx = (cgc_size_t)(NULL); }
    {char * buf; buf = (char *)(NULL); }
    {cgc_size_t count; count = (cgc_size_t)(NULL); }
    {void * tlv11; tlv11 = (void *)(NULL); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(NULL); }
    {void * tlv8; tlv8 = (void *)(NULL); }
    {void * tlv7; tlv7 = (void *)(NULL); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NULL); }
    {int tlv2; tlv2 = (int)(NULL); }
    {int tlv15; tlv15 = (int)(NULL); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(NULL); }
    {int tlv16; tlv16 = (int)(NULL); }
}
void fix_ingred_ac_3_8(){
fix_ingred_ac_3_8_6();
fix_ingred_ac_3_8_7();
}
void fix_ingred_ac_3_10_0(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {if (ac_buffer){cgc_size_t rx; rx = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){char * buf; buf = (char *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t count; count = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){char * newbuf; newbuf = (char *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv11; tlv11 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t tlv10; tlv10 = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv8; tlv8 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv7; tlv7 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t tlv6; tlv6 = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv1; tlv1 = (int)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv2; tlv2 = (int)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t i; i = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv15; tlv15 = (int)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){void * tlv14; tlv14 = (void *)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){cgc_size_t tlv13; tlv13 = (cgc_size_t)(& ac_buffer [ ac_idx ]); }}
    {if (ac_buffer){int tlv16; tlv16 = (int)(& ac_buffer [ ac_idx ]); }}
}
void fix_ingred_ac_3_10_1(){
char word [ MAX_AC_LEN ];
    bzero(&word,( MAX_AC_LEN *sizeof(char) ) );
    {cgc_size_t rx; rx = (cgc_size_t)(word); }
    {char * buf; buf = (char *)(word); }
    {cgc_size_t count; count = (cgc_size_t)(word); }
    {void * tlv11; tlv11 = (void *)(word); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(word); }
    {void * tlv8; tlv8 = (void *)(word); }
    {void * tlv7; tlv7 = (void *)(word); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(word); }
    {int tlv2; tlv2 = (int)(word); }
    {int tlv15; tlv15 = (int)(word); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(word); }
    {int tlv16; tlv16 = (int)(word); }
}
void fix_ingred_ac_3_10(){
fix_ingred_ac_3_10_0();
fix_ingred_ac_3_10_1();
}
void fix_ingred_ac_3_12_0(){
    {cgc_size_t rx; rx = (cgc_size_t)(ac_queue_tail); }
    {char * buf; buf = (char *)(ac_queue_tail); }
    {cgc_size_t count; count = (cgc_size_t)(ac_queue_tail); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(ac_queue_tail); }
    {char * newbuf; newbuf = (char *)(ac_queue_tail); }
    {void * tlv11; tlv11 = (void *)(ac_queue_tail); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(ac_queue_tail); }
    {void * tlv8; tlv8 = (void *)(ac_queue_tail); }
    {void * tlv7; tlv7 = (void *)(ac_queue_tail); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ac_queue_tail); }
    {int tlv1; tlv1 = (int)(ac_queue_tail); }
    {int tlv2; tlv2 = (int)(ac_queue_tail); }
    {cgc_size_t i; i = (cgc_size_t)(ac_queue_tail); }
    {int tlv15; tlv15 = (int)(ac_queue_tail); }
    {void * tlv14; tlv14 = (void *)(ac_queue_tail); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ac_queue_tail); }
    {int tlv16; tlv16 = (int)(ac_queue_tail); }
}
void fix_ingred_ac_3_12(){
fix_ingred_ac_3_12_0();
}
void fix_ingred_ac_3_14_10(){
char term;
    bzero(&term,sizeof(char));
    {cgc_size_t rx; rx = (cgc_size_t)(term); }
    {char * buf; buf = (char *)(term); }
    {cgc_size_t count; count = (cgc_size_t)(term); }
    {char word [ MAX_AC_LEN ]; word [ ( MAX_AC_LEN )-1 ] = (char)(term); }
    {char * newbuf; newbuf = (char *)(term); }
    {void * tlv11; tlv11 = (void *)(term); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(term); }
    {void * tlv8; tlv8 = (void *)(term); }
    {void * tlv7; tlv7 = (void *)(term); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(term); }
    {int tlv1; tlv1 = (int)(term); }
    {int tlv2; tlv2 = (int)(term); }
    {cgc_size_t i; i = (cgc_size_t)(term); }
    {int tlv15; tlv15 = (int)(term); }
    {void * tlv14; tlv14 = (void *)(term); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(term); }
    {int tlv16; tlv16 = (int)(term); }
}
void fix_ingred_ac_3_14(){
fix_ingred_ac_3_14_10();
}
void fix_ingred_ac_3(){
fix_ingred_ac_3_0();
fix_ingred_ac_3_1();
fix_ingred_ac_3_2();
fix_ingred_ac_3_3();
fix_ingred_ac_3_4();
fix_ingred_ac_3_5();
fix_ingred_ac_3_6();
fix_ingred_ac_3_7();
fix_ingred_ac_3_8();
fix_ingred_ac_3_10();
fix_ingred_ac_3_12();
fix_ingred_ac_3_14();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_ac_3_0_5();
void fix_ingred_ac_3_0();
void fix_ingred_ac_3_1_0();
void fix_ingred_ac_3_1();
void fix_ingred_ac_3_2_7();
void fix_ingred_ac_3_2_8();
void fix_ingred_ac_3_2();
void fix_ingred_ac_3_3_0();
void fix_ingred_ac_3_3_1();
void fix_ingred_ac_3_3_2();
void fix_ingred_ac_3_3();
void fix_ingred_ac_3_4_9();
void fix_ingred_ac_3_4_10();
void fix_ingred_ac_3_4_11();
void fix_ingred_ac_3_4();
void fix_ingred_ac_3_5_0();
void fix_ingred_ac_3_5();
void fix_ingred_ac_3_6_9();
void fix_ingred_ac_3_6_10();
void fix_ingred_ac_3_6();
void fix_ingred_ac_3_7_0();
void fix_ingred_ac_3_7_1();
void fix_ingred_ac_3_7();
void fix_ingred_ac_3_8_6();
void fix_ingred_ac_3_8_7();
void fix_ingred_ac_3_8();
void fix_ingred_ac_3_10_0();
void fix_ingred_ac_3_10_1();
void fix_ingred_ac_3_10();
void fix_ingred_ac_3_12_0();
void fix_ingred_ac_3_12();
void fix_ingred_ac_3_14_10();
void fix_ingred_ac_3_14();
void fix_ingred_ac_3();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_ac_0_1_0
- fix_ingred_ac_0_1_2
- fix_ingred_ac_0_1
- fix_ingred_ac_0
- fix_ingred_ac_1_2_0
- fix_ingred_ac_1_2_3
- fix_ingred_ac_1_2_4
- fix_ingred_ac_1_2
- fix_ingred_ac_1_4_5
- fix_ingred_ac_1_4
- fix_ingred_ac_1_5_0
- fix_ingred_ac_1_5
- fix_ingred_ac_1_6_0
- fix_ingred_ac_1_6
- fix_ingred_ac_1_7_0
- fix_ingred_ac_1_7
- fix_ingred_ac_1_8_2
- fix_ingred_ac_1_8_3
- fix_ingred_ac_1_8_4
- fix_ingred_ac_1_8_6
- fix_ingred_ac_1_8_7
- fix_ingred_ac_1_8
- fix_ingred_ac_1_9_0
- fix_ingred_ac_1_9
- fix_ingred_ac_1_10_0
- fix_ingred_ac_1_10
- fix_ingred_ac_1
- fix_ingred_ac_2_2_0
- fix_ingred_ac_2_2_1
- fix_ingred_ac_2_2_2
- fix_ingred_ac_2_2_3
- fix_ingred_ac_2_2_4
- fix_ingred_ac_2_2
- fix_ingred_ac_2_4_9
- fix_ingred_ac_2_4_10
- fix_ingred_ac_2_4
- fix_ingred_ac_2_5_0
- fix_ingred_ac_2_5_1
- fix_ingred_ac_2_5
- fix_ingred_ac_2_8_10
- fix_ingred_ac_2_8_11
- fix_ingred_ac_2_8
- fix_ingred_ac_2_10_12
- fix_ingred_ac_2_10
- fix_ingred_ac_2_11_0
- fix_ingred_ac_2_11
- fix_ingred_ac_2_13_14
- fix_ingred_ac_2_13
- fix_ingred_ac_2_14_1
- fix_ingred_ac_2_14_2
- fix_ingred_ac_2_14
- fix_ingred_ac_2_15_0
- fix_ingred_ac_2_15_1
- fix_ingred_ac_2_15
- fix_ingred_ac_2_16_16
- fix_ingred_ac_2_16_17
- fix_ingred_ac_2_16
- fix_ingred_ac_2_19_1
- fix_ingred_ac_2_19
- fix_ingred_ac_2_20_0
- fix_ingred_ac_2_20
- fix_ingred_ac_2_22_15
- fix_ingred_ac_2_22
- fix_ingred_ac_2
- fix_ingred_ac_3_0_5
- fix_ingred_ac_3_0
- fix_ingred_ac_3_1_0
- fix_ingred_ac_3_1
- fix_ingred_ac_3_2_7
- fix_ingred_ac_3_2_8
- fix_ingred_ac_3_2
- fix_ingred_ac_3_3_0
- fix_ingred_ac_3_3_1
- fix_ingred_ac_3_3_2
- fix_ingred_ac_3_3
- fix_ingred_ac_3_4_9
- fix_ingred_ac_3_4_10
- fix_ingred_ac_3_4_11
- fix_ingred_ac_3_4
- fix_ingred_ac_3_5_0
- fix_ingred_ac_3_5
- fix_ingred_ac_3_6_9
- fix_ingred_ac_3_6_10
- fix_ingred_ac_3_6
- fix_ingred_ac_3_7_0
- fix_ingred_ac_3_7_1
- fix_ingred_ac_3_7
- fix_ingred_ac_3_8_6
- fix_ingred_ac_3_8_7
- fix_ingred_ac_3_8
- fix_ingred_ac_3_10_0
- fix_ingred_ac_3_10_1
- fix_ingred_ac_3_10
- fix_ingred_ac_3_12_0
- fix_ingred_ac_3_12
- fix_ingred_ac_3_14_10
- fix_ingred_ac_3_14
- fix_ingred_ac_3
