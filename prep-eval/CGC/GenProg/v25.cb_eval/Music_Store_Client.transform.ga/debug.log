[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'char *'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_setValue ( char * buffer , char * value )')]
ParameterDeclaration : type = char *, var = buffer [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buffer']
[enterParameterDeclaration] char * : buffer
sym_dict [buffer] = char * 
ParameterDeclaration : type = char *, var = value [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['value']
[enterParameterDeclaration] char * : value
sym_dict [value] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * ptr'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ptr] = char * 
var: ptr (ptr) = NULL
var: char * ptr (ptr) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = int 
var: count (count) = 0
var: int count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * delim'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [delim] = char * 
var: delim (delim) = PARAM_DELIM
var: char * delim (delim) = PARAM_DELIM
var: ptr (ptr) = buffer
var: char * ptr (ptr) = buffer
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => * ptr != * delim
[0] <class 'CParser.CParser.RelationalExpressionContext'> => * ptr
[2] <class 'CParser.CParser.RelationalExpressionContext'> => * delim
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => * ptr != * delim
=> ['* ptr', '* delim']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : * ptr
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['* ptr']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['* ptr']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['* ptr']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['* ptr']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['* ptr']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.UnaryOperatorContext'>, <class 'CParser.CParser.CastExpressionContext'>] ['*', 'ptr']
-------<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ptr']
--------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ptr']
---------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ptr']
FOUND IT! [2.2]  char * : ptr
Resolved type: [2.3]  char : ptr
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count < RESULT_VALUE_SIZE
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => RESULT_VALUE_SIZE
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count < RESULT_VALUE_SIZE
=> ['count', 'RESULT_VALUE_SIZE']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  int : count
Resolved type: [1.3]  int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ptr ++ , count ++ ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ptr ++ , count ++ ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = value
var: void * tlv3 (tlv3) = value
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = void * 
var: tlv2 (tlv2) = buffer
var: void * tlv2 (tlv2) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = count
var: cgc_size_t tlv1 (tlv1) = count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('void *', 'tlv3', '', 'value'), ('void *', 'tlv2', '', 'buffer'), ('cgc_size_t', 'tlv1', '', 'count')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } ]
Assigns = [('char *', 'ptr', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'PARAM_DELIM'), ('char *', 'ptr', '', 'buffer')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : char * cgc_setValue ( char * buffer , char * value ) { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_parseResultSize ( char * buffer )')]
ParameterDeclaration : type = char *, var = buffer [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buffer']
[enterParameterDeclaration] char * : buffer
sym_dict [buffer] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * start'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [start] = char * 
var: start (start) = NULL
var: char * start (start) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * end'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [end] = char * 
var: end (end) = NULL
var: char * end (end) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'key [ KEY_SIZE ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [key] = char * 
[C-t-3] sym_dict [key [ KEY_SIZE ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'value [ RESULT_VALUE_SIZE ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [value] = char * 
[C-t-3] sym_dict [value [ RESULT_VALUE_SIZE ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = int 
var: count (count) = 0
var: int count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * delim'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [delim] = char * 
var: delim (delim) = KEYVAL_DELIM
var: char * delim (delim) = KEYVAL_DELIM
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int num_results'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [num_results] = int 
var: num_results (num_results) = 0
var: int num_results (num_results) = 0
var: start (start) = buffer
var: char * start (start) = buffer
var: end (end) = start
var: char * end (end) = start
var: count (count) = 0
var: int count (count) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => * end != * delim
[0] <class 'CParser.CParser.RelationalExpressionContext'> => * end
[2] <class 'CParser.CParser.RelationalExpressionContext'> => * delim
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => * end != * delim
=> ['* end', '* delim']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : * end
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['* end']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['* end']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['* end']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['* end']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['* end']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.UnaryOperatorContext'>, <class 'CParser.CParser.CastExpressionContext'>] ['*', 'end']
-------<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['end']
--------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['end']
---------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['end']
FOUND IT! [2.2]  char * : end
Resolved type: [2.3]  char : end
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count < KEY_SIZE
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => KEY_SIZE
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count < KEY_SIZE
=> ['count', 'KEY_SIZE']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  int : count
Resolved type: [1.3]  int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { end ++ , count ++ ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { end ++ , count ++ ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = key
var: void * tlv4 (tlv4) = key
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = start
var: void * tlv3 (tlv3) = start
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = count
var: cgc_size_t tlv2 (tlv2) = count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('void *', 'tlv4', '', 'key'), ('void *', 'tlv3', '', 'start'), ('cgc_size_t', 'tlv2', '', 'count')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = NUM_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: tlv1 (tlv1) = cgc_strcmp ( tlv6 , tlv5 )
var: int tlv1 (tlv1) = cgc_strcmp ( tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }
Assigns = [('int', 'tlv1', '', 'cgc_strcmp ( tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = char * 
var: tlv8 (tlv8) = ++ end
var: char * tlv8 (tlv8) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = value
var: char * tlv7 (tlv7) = value
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; }
Assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 = value'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = const char * 
var: num_results (num_results) = cgc_str2int ( tlv9 )
var: int num_results (num_results) = cgc_str2int ( tlv9 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; }
Assigns = [('int', 'num_results', '', 'cgc_str2int ( tlv9 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } ]
Assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_parseResultSize ( char * buffer ) { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_parseBalanceResult ( char * buffer )')]
ParameterDeclaration : type = char *, var = buffer [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buffer']
[enterParameterDeclaration] char * : buffer
sym_dict [buffer] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * start'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [start] = char * 
var: start (start) = NULL
var: char * start (start) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * end'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [end] = char * 
var: end (end) = NULL
var: char * end (end) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'key [ KEY_SIZE ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [key] = char * 
[C-t-3] sym_dict [key [ KEY_SIZE ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'value [ RESULT_VALUE_SIZE ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [value] = char * 
[C-t-3] sym_dict [value [ RESULT_VALUE_SIZE ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = int 
var: count (count) = 0
var: int count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * delim'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [delim] = char * 
var: delim (delim) = KEYVAL_DELIM
var: char * delim (delim) = KEYVAL_DELIM
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int balance'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [balance] = int 
var: balance (balance) = 0
var: int balance (balance) = 0
var: start (start) = buffer
var: char * start (start) = buffer
var: end (end) = start
var: char * end (end) = start
var: count (count) = 0
var: int count (count) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => * end != * delim
[0] <class 'CParser.CParser.RelationalExpressionContext'> => * end
[2] <class 'CParser.CParser.RelationalExpressionContext'> => * delim
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => * end != * delim
=> ['* end', '* delim']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : * end
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['* end']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['* end']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['* end']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['* end']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['* end']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.UnaryOperatorContext'>, <class 'CParser.CParser.CastExpressionContext'>] ['*', 'end']
-------<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['end']
--------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['end']
---------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['end']
FOUND IT! [2.2]  char * : end
Resolved type: [2.3]  char : end
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count < KEY_SIZE
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => KEY_SIZE
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count < KEY_SIZE
=> ['count', 'KEY_SIZE']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  int : count
Resolved type: [1.3]  int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { end ++ , count ++ ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { end ++ , count ++ ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = key
var: void * tlv4 (tlv4) = key
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = start
var: void * tlv3 (tlv3) = start
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = count
var: cgc_size_t tlv2 (tlv2) = count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('void *', 'tlv4', '', 'key'), ('void *', 'tlv3', '', 'start'), ('cgc_size_t', 'tlv2', '', 'count')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = BAL_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: tlv1 (tlv1) = cgc_strcmp ( tlv6 , tlv5 )
var: int tlv1 (tlv1) = cgc_strcmp ( tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }
Assigns = [('int', 'tlv1', '', 'cgc_strcmp ( tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = char * 
var: tlv8 (tlv8) = ++ end
var: char * tlv8 (tlv8) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = value
var: char * tlv7 (tlv7) = value
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; }
Assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 = value'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = const char * 
var: balance (balance) = cgc_str2int ( tlv9 )
var: int balance (balance) = cgc_str2int ( tlv9 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; }
Assigns = [('int', 'balance', '', 'cgc_str2int ( tlv9 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => balance < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => balance
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => balance < 0
=> ['balance', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : balance
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['balance']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['balance']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['balance']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['balance']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['balance']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['balance']
FOUND IT! [1.2]  int : balance
Resolved type: [1.3]  int : balance
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => balance > 255
[0] <class 'CParser.CParser.ShiftExpressionContext'> => balance
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 255
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => balance > 255
=> ['balance', '255']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : balance
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['balance']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['balance']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['balance']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['balance']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['balance']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['balance']
FOUND IT! [1.2]  int : balance
Resolved type: [1.3]  int : balance
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ balance < 0 || balance > 255 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( balance < 0 || balance > 255 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( balance < 0 || balance > 255 ) { return 0 ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } ]
Assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_parseBalanceResult ( char * buffer ) { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_parseSearchResult ( char * buffer , Song * song )')]
ParameterDeclaration : type = char *, var = buffer [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buffer']
[enterParameterDeclaration] char * : buffer
sym_dict [buffer] = char * 
ParameterDeclaration : type = Song *, var = song [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['song']
[enterParameterDeclaration] Song * : song
sym_dict [song] = Song * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * start'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [start] = char * 
var: start (start) = NULL
var: char * start (start) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * end'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [end] = char * 
var: end (end) = NULL
var: char * end (end) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'key [ KEY_SIZE ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [key] = char * 
[C-t-3] sym_dict [key [ KEY_SIZE ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = int 
var: count (count) = 0
var: int count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * delim'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [delim] = char * 
var: delim (delim) = KEYVAL_DELIM
var: char * delim (delim) = KEYVAL_DELIM
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = void * 
var: tlv8 (tlv8) = song
var: void * tlv8 (tlv8) = song
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = int 
var: tlv7 (tlv7) = 0
var: int tlv7 (tlv7) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = cgc_size_t 
var: tlv6 (tlv6) = SONG_SIZE
var: cgc_size_t tlv6 (tlv6) = SONG_SIZE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; }
Assigns = [('void *', 'tlv8', '', 'song'), ('int', 'tlv7', '', '0'), ('cgc_size_t', 'tlv6', '', 'SONG_SIZE')]
Compares = []
var: start (start) = buffer
var: char * start (start) = buffer
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: end (end) = start
var: char * end (end) = start
var: count (count) = 0
var: int count (count) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => * end != * delim
[0] <class 'CParser.CParser.RelationalExpressionContext'> => * end
[2] <class 'CParser.CParser.RelationalExpressionContext'> => * delim
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => * end != * delim
=> ['* end', '* delim']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : * end
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['* end']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['* end']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['* end']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['* end']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['* end']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.UnaryOperatorContext'>, <class 'CParser.CParser.CastExpressionContext'>] ['*', 'end']
-------<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['end']
--------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['end']
---------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['end']
FOUND IT! [2.2]  char * : end
Resolved type: [2.3]  char : end
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count < KEY_SIZE
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => KEY_SIZE
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count < KEY_SIZE
=> ['count', 'KEY_SIZE']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  int : count
Resolved type: [1.3]  int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { end ++ , count ++ ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { end ++ , count ++ ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = void * 
var: tlv11 (tlv11) = key
var: void * tlv11 (tlv11) = key
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = void * 
var: tlv10 (tlv10) = start
var: void * tlv10 (tlv10) = start
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = cgc_size_t 
var: tlv9 (tlv9) = count
var: cgc_size_t tlv9 (tlv9) = count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; }
Assigns = [('void *', 'tlv11', '', 'key'), ('void *', 'tlv10', '', 'start'), ('cgc_size_t', 'tlv9', '', 'count')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv16 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv15 = SONG_ID_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = const char * 
var: tlv1 (tlv1) = cgc_strcmp ( tlv16 , tlv15 )
var: int tlv1 (tlv1) = cgc_strcmp ( tlv16 , tlv15 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; }
Assigns = [('int', 'tlv1', '', 'cgc_strcmp ( tlv16 , tlv15 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 == 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv18'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv18] = char * 
var: tlv18 (tlv18) = ++ end
var: char * tlv18 (tlv18) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv17'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = char * 
var: tlv17 (tlv17) = song -> id
var: char * tlv17 (tlv17) = song -> id
var: start (start) = cgc_setValue ( tlv18 , tlv17 )
var: char * start (start) = cgc_setValue ( tlv18 , tlv17 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; }
Assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id'), ('char *', 'start', '', 'cgc_setValue ( tlv18 , tlv17 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv20 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv20] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv19 = PRICE_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = const char * 
var: tlv2 (tlv2) = cgc_strcmp ( tlv20 , tlv19 )
var: int tlv2 (tlv2) = cgc_strcmp ( tlv20 , tlv19 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; }
Assigns = [('int', 'tlv2', '', 'cgc_strcmp ( tlv20 , tlv19 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 == 0
=> ['tlv2', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [2.2]  int : tlv2
Resolved type: [2.3]  int : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv22'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv22] = char * 
var: tlv22 (tlv22) = ++ end
var: char * tlv22 (tlv22) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv21'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv21] = char * 
var: tlv21 (tlv21) = song -> price
var: char * tlv21 (tlv21) = song -> price
var: start (start) = cgc_setValue ( tlv22 , tlv21 )
var: char * start (start) = cgc_setValue ( tlv22 , tlv21 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; }
Assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'cgc_setValue ( tlv22 , tlv21 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv24 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv24] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv23 = ARTIST_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv23] = const char * 
var: tlv3 (tlv3) = cgc_strcmp ( tlv24 , tlv23 )
var: int tlv3 (tlv3) = cgc_strcmp ( tlv24 , tlv23 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; }
Assigns = [('int', 'tlv3', '', 'cgc_strcmp ( tlv24 , tlv23 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv3
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 == 0
=> ['tlv3', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv3
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv3']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv3']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv3']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv3']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv3']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv3']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv3']
FOUND IT! [2.2]  int : tlv3
Resolved type: [2.3]  int : tlv3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv26'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv26] = char * 
var: tlv26 (tlv26) = ++ end
var: char * tlv26 (tlv26) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv25'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv25] = char * 
var: tlv25 (tlv25) = song -> artist
var: char * tlv25 (tlv25) = song -> artist
var: start (start) = cgc_setValue ( tlv26 , tlv25 )
var: char * start (start) = cgc_setValue ( tlv26 , tlv25 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; }
Assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'cgc_setValue ( tlv26 , tlv25 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv28 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv28] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv27 = ALBUM_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv27] = const char * 
var: tlv4 (tlv4) = cgc_strcmp ( tlv28 , tlv27 )
var: int tlv4 (tlv4) = cgc_strcmp ( tlv28 , tlv27 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; }
Assigns = [('int', 'tlv4', '', 'cgc_strcmp ( tlv28 , tlv27 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv4 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv4
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv4 == 0
=> ['tlv4', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv4
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv4']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv4']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv4']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv4']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv4']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv4']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv4']
FOUND IT! [2.2]  int : tlv4
Resolved type: [2.3]  int : tlv4
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv4 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv30'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv30] = char * 
var: tlv30 (tlv30) = ++ end
var: char * tlv30 (tlv30) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv29'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv29] = char * 
var: tlv29 (tlv29) = song -> album
var: char * tlv29 (tlv29) = song -> album
var: start (start) = cgc_setValue ( tlv30 , tlv29 )
var: char * start (start) = cgc_setValue ( tlv30 , tlv29 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; }
Assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'cgc_setValue ( tlv30 , tlv29 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv4 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv32 = key'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv32] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv31 = SONG_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv31] = const char * 
var: tlv5 (tlv5) = cgc_strcmp ( tlv32 , tlv31 )
var: int tlv5 (tlv5) = cgc_strcmp ( tlv32 , tlv31 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; }
Assigns = [('int', 'tlv5', '', 'cgc_strcmp ( tlv32 , tlv31 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv5 == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv5
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv5 == 0
=> ['tlv5', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv5
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv5']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv5']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv5']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv5']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv5']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv5']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv5']
FOUND IT! [2.2]  int : tlv5
Resolved type: [2.3]  int : tlv5
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv5 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv34'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv34] = char * 
var: tlv34 (tlv34) = ++ end
var: char * tlv34 (tlv34) = ++ end
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv33'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv33] = char * 
var: tlv33 (tlv33) = song -> song
var: char * tlv33 (tlv33) = song -> song
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; }
Assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv5 == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = void * 
var: tlv14 (tlv14) = key
var: void * tlv14 (tlv14) = key
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = int 
var: tlv13 (tlv13) = 0
var: int tlv13 (tlv13) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = cgc_size_t 
var: tlv12 (tlv12) = KEY_SIZE
var: cgc_size_t tlv12 (tlv12) = KEY_SIZE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }
Assigns = [('void *', 'tlv14', '', 'key'), ('int', 'tlv13', '', '0'), ('cgc_size_t', 'tlv12', '', 'KEY_SIZE')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } ]
Assigns = [('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } ]
Assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_parseSearchResult ( char * buffer , Song * song ) { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_receiveBalance ( int socket )')]
ParameterDeclaration : type = int, var = socket [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['socket']
[enterParameterDeclaration] int : socket
sym_dict [socket] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ 1024 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int bytes_read'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_read] = int 
var: bytes_read (bytes_read) = 0
var: int bytes_read (bytes_read) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int balance'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [balance] = int 
var: balance (balance) = 0
var: int balance (balance) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
var: tlv3 (tlv3) = socket
var: int tlv3 (tlv3) = socket
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = buf
var: char * tlv2 (tlv2) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = sizeof ( buf ) - 1
var: cgc_size_t tlv1 (tlv1) = sizeof ( buf ) - 1
var: bytes_read (bytes_read) = cgc_recvline ( tlv3 , tlv2 , tlv1 )
var: int bytes_read (bytes_read) = cgc_recvline ( tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv3', '', 'socket'), ('char *', 'tlv2', '', 'buf'), ('cgc_size_t', 'tlv1', '', 'sizeof ( buf ) - 1'), ('int', 'bytes_read', '', 'cgc_recvline ( tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_read
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read < 0
=> ['bytes_read', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_read
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_read']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_read']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_read']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_read']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_read']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_read']
FOUND IT! [1.2]  int : bytes_read
Resolved type: [1.3]  int : bytes_read
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_read < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 2
var: unsigned int tlv5 (tlv5) = 2
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '2')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => bytes_read == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => bytes_read == 0
=> ['bytes_read', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : bytes_read
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['bytes_read']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_read']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_read']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_read']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_read']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_read']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_read']
FOUND IT! [2.2]  int : bytes_read
Resolved type: [2.3]  int : bytes_read
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_read == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_read == 0 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = char * 
var: tlv4 (tlv4) = buf
var: char * tlv4 (tlv4) = buf
var: balance (balance) = cgc_parseBalanceResult ( tlv4 )
var: int balance (balance) = cgc_parseBalanceResult ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }
Assigns = [('char *', 'tlv4', '', 'buf'), ('int', 'balance', '', 'cgc_parseBalanceResult ( tlv4 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_read == 0 ) { return 0 ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } ]
Assigns = [('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_receiveBalance ( int socket ) { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_receiveNumResults ( int socket )')]
ParameterDeclaration : type = int, var = socket [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['socket']
[enterParameterDeclaration] int : socket
sym_dict [socket] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ 1024 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int bytes_read'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_read] = int 
var: bytes_read (bytes_read) = 0
var: int bytes_read (bytes_read) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int num_results'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [num_results] = int 
var: num_results (num_results) = 0
var: int num_results (num_results) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
var: tlv3 (tlv3) = socket
var: int tlv3 (tlv3) = socket
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char * 
var: tlv2 (tlv2) = buf
var: char * tlv2 (tlv2) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = sizeof ( buf ) - 1
var: cgc_size_t tlv1 (tlv1) = sizeof ( buf ) - 1
var: bytes_read (bytes_read) = cgc_recvline ( tlv3 , tlv2 , tlv1 )
var: int bytes_read (bytes_read) = cgc_recvline ( tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv3', '', 'socket'), ('char *', 'tlv2', '', 'buf'), ('cgc_size_t', 'tlv1', '', 'sizeof ( buf ) - 1'), ('int', 'bytes_read', '', 'cgc_recvline ( tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_read
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read < 0
=> ['bytes_read', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_read
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_read']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_read']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_read']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_read']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_read']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_read']
FOUND IT! [1.2]  int : bytes_read
Resolved type: [1.3]  int : bytes_read
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_read < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 2
var: unsigned int tlv5 (tlv5) = 2
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '2')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => bytes_read == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => bytes_read == 0
=> ['bytes_read', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : bytes_read
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['bytes_read']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_read']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_read']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_read']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_read']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_read']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_read']
FOUND IT! [2.2]  int : bytes_read
Resolved type: [2.3]  int : bytes_read
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_read == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_read == 0 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = char * 
var: tlv4 (tlv4) = buf
var: char * tlv4 (tlv4) = buf
var: num_results (num_results) = cgc_parseResultSize ( tlv4 )
var: int num_results (num_results) = cgc_parseResultSize ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }
Assigns = [('char *', 'tlv4', '', 'buf'), ('int', 'num_results', '', 'cgc_parseResultSize ( tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => num_results > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => num_results
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => num_results > 0
=> ['num_results', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : num_results
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['num_results']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['num_results']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['num_results']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['num_results']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['num_results']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['num_results']
FOUND IT! [1.2]  int : num_results
Resolved type: [1.3]  int : num_results
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ num_results > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return num_results ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( num_results > 0 ) { return num_results ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return num_results ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_read == 0 ) { return 0 ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( num_results > 0 ) { return num_results ; } ]
Assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_receiveNumResults ( int socket ) { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_receiveSearchResults ( int socket , SongList * songList , int limit )')]
ParameterDeclaration : type = int, var = socket [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['socket']
[enterParameterDeclaration] int : socket
sym_dict [socket] = int 
ParameterDeclaration : type = SongList *, var = songList [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['songList']
[enterParameterDeclaration] SongList * : songList
sym_dict [songList] = SongList * 
ParameterDeclaration : type = int, var = limit [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['limit']
[enterParameterDeclaration] int : limit
sym_dict [limit] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ 1024 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int bytes_read'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_read] = int 
var: bytes_read (bytes_read) = 0
var: int bytes_read (bytes_read) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int num_results'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [num_results] = int 
var: num_results (num_results) = 0
var: int num_results (num_results) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
var: tlv1 (tlv1) = socket
var: int tlv1 (tlv1) = socket
var: num_results (num_results) = cgc_receiveNumResults ( tlv1 )
var: int num_results (num_results) = cgc_receiveNumResults ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; }
Assigns = [('int', 'tlv1', '', 'socket'), ('int', 'num_results', '', 'cgc_receiveNumResults ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = socket
var: int tlv4 (tlv4) = socket
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = char * 
var: tlv3 (tlv3) = buf
var: char * tlv3 (tlv3) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = sizeof ( buf ) - 1
var: cgc_size_t tlv2 (tlv2) = sizeof ( buf ) - 1
var: bytes_read (bytes_read) = cgc_recvline ( tlv4 , tlv3 , tlv2 )
var: int bytes_read (bytes_read) = cgc_recvline ( tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('int', 'tlv4', '', 'socket'), ('char *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'sizeof ( buf ) - 1'), ('int', 'bytes_read', '', 'cgc_recvline ( tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read < 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_read
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read < 0
=> ['bytes_read', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_read
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_read']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_read']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_read']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_read']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_read']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_read']
FOUND IT! [1.2]  int : bytes_read
Resolved type: [1.3]  int : bytes_read
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_read < 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 2
var: unsigned int tlv5 (tlv5) = 2
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '2')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => bytes_read == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_read
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => bytes_read == 0
=> ['bytes_read', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : bytes_read
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['bytes_read']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_read']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_read']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_read']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_read']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_read']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_read']
FOUND IT! [2.2]  int : bytes_read
Resolved type: [2.3]  int : bytes_read
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_read == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_read == 0 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => songList -> size < limit
[0] <class 'CParser.CParser.ShiftExpressionContext'> => songList -> size
[2] <class 'CParser.CParser.ShiftExpressionContext'> => limit
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => songList -> size < limit
=> ['songList -> size', 'limit']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : songList -> size
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['songList -> size']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['songList -> size']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['songList -> size']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['songList -> size']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['songList -> size']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['songList', '->', 'size']
FOUND IT! [1.2]  SongList * : songList
Resolved type: [1.3]  SongList * : songList
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ songList -> size < limit ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = buf
var: char * tlv7 (tlv7) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Song * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = Song * 
var: tlv6 (tlv6) = & songList -> songs [ songList -> size ]
var: Song * tlv6 (tlv6) = & songList -> songs [ songList -> size ]
var: ret (ret) = cgc_parseSearchResult ( tlv7 , tlv6 )
var: int ret (ret) = cgc_parseSearchResult ( tlv7 , tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; }
Assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]'), ('int', 'ret', '', 'cgc_parseSearchResult ( tlv7 , tlv6 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = unsigned int 
var: tlv8 (tlv8) = 10
var: unsigned int tlv8 (tlv8) = 10
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv8 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; }
Assigns = [('unsigned int', 'tlv8', '', '10')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_read == 0 ) { return 0 ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } ]
Assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_receiveSearchResults ( int socket , SongList * songList , int limit ) { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'char *'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_createSearchString ( Request request )')]
ParameterDeclaration : type = Request, var = request [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['request']
[enterParameterDeclaration] Request : request
sym_dict [request] = Request 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [buffer] = char * 
var: buffer (buffer) = NULL
var: char * buffer (buffer) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv30'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv30] = cgc_size_t 
var: tlv30 (tlv30) = sizeof ( request ) + cgc_MIN_REQ_LEN
var: cgc_size_t tlv30 (tlv30) = sizeof ( request ) + cgc_MIN_REQ_LEN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv29'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv29] = int 
var: tlv29 (tlv29) = 0
var: int tlv29 (tlv29) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * * tlv28'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv28] = void * * 
var: tlv28 (tlv28) = ( void * * ) & buffer
var: void * * tlv28 (tlv28) = ( void * * ) & buffer
var: ret (ret) = cgc_allocate ( tlv30 , tlv29 , tlv28 )
var: int ret (ret) = cgc_allocate ( tlv30 , tlv29 , tlv28 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; }
Assigns = [('cgc_size_t', 'tlv30', '', 'sizeof ( request ) + cgc_MIN_REQ_LEN'), ('int', 'tlv29', '', '0'), ('void * *', 'tlv28', '', '( void * * ) & buffer'), ('int', 'ret', '', 'cgc_allocate ( tlv30 , tlv29 , tlv28 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv31'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv31] = unsigned int 
var: tlv31 (tlv31) = 3
var: unsigned int tlv31 (tlv31) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv31 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; }
Assigns = [('unsigned int', 'tlv31', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = buffer
var: void * tlv3 (tlv3) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = 0
var: int tlv2 (tlv2) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = sizeof ( request ) + cgc_MIN_REQ_LEN
var: cgc_size_t tlv1 (tlv1) = sizeof ( request ) + cgc_MIN_REQ_LEN
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('void *', 'tlv3', '', 'buffer'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'sizeof ( request ) + cgc_MIN_REQ_LEN')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = char * 
var: tlv5 (tlv5) = buffer
var: char * tlv5 (tlv5) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 = TERM_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }
Assigns = [('char *', 'tlv5', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = buffer
var: char * tlv7 (tlv7) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = KEYVAL_DELIM'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }
Assigns = [('char *', 'tlv7', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = char * 
var: tlv9 (tlv9) = buffer
var: char * tlv9 (tlv9) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 = request . term'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }
Assigns = [('char *', 'tlv9', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = char * 
var: tlv11 (tlv11) = buffer
var: char * tlv11 (tlv11) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv10 = PARAM_DELIM'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }
Assigns = [('char *', 'tlv11', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = char * 
var: tlv13 (tlv13) = buffer
var: char * tlv13 (tlv13) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv12 = ATTRIBUTE_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }
Assigns = [('char *', 'tlv13', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = char * 
var: tlv15 (tlv15) = buffer
var: char * tlv15 (tlv15) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv14 = KEYVAL_DELIM'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }
Assigns = [('char *', 'tlv15', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv17'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = char * 
var: tlv17 (tlv17) = buffer
var: char * tlv17 (tlv17) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv16 = request . attribute'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }
Assigns = [('char *', 'tlv17', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv19'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = char * 
var: tlv19 (tlv19) = buffer
var: char * tlv19 (tlv19) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv18 = PARAM_DELIM'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv18] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }
Assigns = [('char *', 'tlv19', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv21'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv21] = char * 
var: tlv21 (tlv21) = buffer
var: char * tlv21 (tlv21) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv20 = LIMIT_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv20] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }
Assigns = [('char *', 'tlv21', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv23'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv23] = char * 
var: tlv23 (tlv23) = buffer
var: char * tlv23 (tlv23) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv22 = KEYVAL_DELIM'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv22] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }
Assigns = [('char *', 'tlv23', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv25'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv25] = char * 
var: tlv25 (tlv25) = buffer
var: char * tlv25 (tlv25) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv24 = request . limit'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv24] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }
Assigns = [('char *', 'tlv25', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv27'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv27] = char * 
var: tlv27 (tlv27) = buffer
var: char * tlv27 (tlv27) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv26 = EOL_STR'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv26] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }
Assigns = [('char *', 'tlv27', '', 'buffer')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } ]
 6 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } ]
 7 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } ]
 8 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } ]
 9 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } ]
 10 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } ]
 11 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } ]
 12 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } ]
 13 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } ]
 14 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } ]
Assigns = [('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : char * cgc_createSearchString ( Request request ) { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'unsigned int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_getRandomNumber ( unsigned int max )')]
ParameterDeclaration : type = unsigned int, var = max [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['max']
[enterParameterDeclaration] unsigned int : max
sym_dict [max] = unsigned int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t bytes_written'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_written] = cgc_size_t 
var: bytes_written (bytes_written) = 0
var: cgc_size_t bytes_written (bytes_written) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int index'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [index] = unsigned int 
var: index (index) = 0
var: unsigned int index (index) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = & index
var: void * tlv3 (tlv3) = & index
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = sizeof ( index )
var: cgc_size_t tlv2 (tlv2) = sizeof ( index )
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t * 
var: tlv1 (tlv1) = & bytes_written
var: cgc_size_t * tlv1 (tlv1) = & bytes_written
var: ret (ret) = cgc_random ( tlv3 , tlv2 , tlv1 )
var: int ret (ret) = cgc_random ( tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('void *', 'tlv3', '', '& index'), ('cgc_size_t', 'tlv2', '', 'sizeof ( index )'), ('cgc_size_t *', 'tlv1', '', '& bytes_written'), ('int', 'ret', '', 'cgc_random ( tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = unsigned int 
var: tlv4 (tlv4) = 1
var: unsigned int tlv4 (tlv4) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; }
Assigns = [('unsigned int', 'tlv4', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned long tlv_size_0'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv_size_0] = unsigned long 
var: tlv_size_0 (tlv_size_0) = sizeof ( index )
var: unsigned long tlv_size_0 (tlv_size_0) = sizeof ( index )
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => bytes_written != tlv_size_0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => bytes_written
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv_size_0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => bytes_written != tlv_size_0
=> ['bytes_written', 'tlv_size_0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : bytes_written
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['bytes_written']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_written']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_written']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_written']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_written']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_written']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_written']
FOUND IT! [2.2]  cgc_size_t : bytes_written
Resolved type: [2.3]  cgc_size_t : bytes_written
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ bytes_written != tlv_size_0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 2
var: unsigned int tlv5 (tlv5) = 2
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '2')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
var: index (index) = index % max
var: unsigned int index (index) = index % max
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ]
Assigns = [('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )'), ('unsigned int', 'index', '', 'index % max')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : unsigned int cgc_getRandomNumber ( unsigned int max ) { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_getRandomAttribute ( Request * request )')]
ParameterDeclaration : type = Request *, var = request [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['request']
[enterParameterDeclaration] Request * : request
sym_dict [request] = Request * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int index'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [index] = int 
var: index (index) = 0
var: int index (index) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = unsigned int 
var: tlv4 (tlv4) = ATTR_NUM
var: unsigned int tlv4 (tlv4) = ATTR_NUM
var: index (index) = cgc_getRandomNumber ( tlv4 )
var: int index (index) = cgc_getRandomNumber ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; }
Assigns = [('unsigned int', 'tlv4', '', 'ATTR_NUM'), ('int', 'index', '', 'cgc_getRandomNumber ( tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = request -> attribute
var: void * tlv3 (tlv3) = request -> attribute
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = void * 
var: tlv2 (tlv2) = attributes [ index ]
var: void * tlv2 (tlv2) = attributes [ index ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = attributes [ index ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: tlv1 (tlv1) = cgc_strlen ( tlv5 )
var: cgc_size_t tlv1 (tlv1) = cgc_strlen ( tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; }
Assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } ]
Assigns = [('void *', 'tlv3', '', 'request -> attribute'), ('void *', 'tlv2', '', 'attributes [ index ]')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } ]
Assigns = [('int', 'index', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_getRandomAttribute ( Request * request ) { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_getRandomTerm ( Request * request )')]
ParameterDeclaration : type = Request *, var = request [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['request']
[enterParameterDeclaration] Request * : request
sym_dict [request] = Request * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int size'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [size] = unsigned int 
var: size (size) = 0
var: unsigned int size (size) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int charset_size'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [charset_size] = unsigned int 
var: charset_size (charset_size) = 0
var: unsigned int charset_size (charset_size) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int index'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [index] = int 
var: index (index) = 0
var: int index (index) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => size == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => size
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => size == 0
=> ['size', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : size
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['size']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['size']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['size']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['size']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['size']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['size']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['size']
FOUND IT! [2.2]  unsigned int : size
Resolved type: [2.3]  unsigned int : size
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = unsigned int 
var: tlv2 (tlv2) = RESULT_VALUE_SIZE
var: unsigned int tlv2 (tlv2) = RESULT_VALUE_SIZE
var: size (size) = cgc_getRandomNumber ( tlv2 )
var: unsigned int size (size) = cgc_getRandomNumber ( tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; }
Assigns = [('unsigned int', 'tlv2', '', 'RESULT_VALUE_SIZE'), ('unsigned int', 'size', '', 'cgc_getRandomNumber ( tlv2 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 = cgc_charset'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = const char * 
var: charset_size (charset_size) = cgc_strlen ( tlv1 )
var: unsigned int charset_size (charset_size) = cgc_strlen ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; }
Assigns = [('unsigned int', 'charset_size', '', 'cgc_strlen ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: index (index) = 0
var: int index (index) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => index < size
[0] <class 'CParser.CParser.ShiftExpressionContext'> => index
[2] <class 'CParser.CParser.ShiftExpressionContext'> => size
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => index < size
=> ['index', 'size']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : index
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['index']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['index']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['index']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['index']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['index']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['index']
FOUND IT! [1.2]  int : index
Resolved type: [1.3]  int : index
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int letter'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [letter] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = unsigned int 
var: tlv3 (tlv3) = charset_size
var: unsigned int tlv3 (tlv3) = charset_size
var: letter (letter) = cgc_getRandomNumber ( tlv3 )
var: int letter (letter) = cgc_getRandomNumber ( tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; }
Assigns = [('unsigned int', 'tlv3', '', 'charset_size'), ('int', 'letter', '', 'cgc_getRandomNumber ( tlv3 )')]
Compares = []
var: request -> term  (request -> term [ index ]) = cgc_charset [ letter ]
var: UNDEF request -> term  (request -> term [ index ]) = cgc_charset [ letter ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } ]
Assigns = [('UNDEF', 'request -> term ', '[ index ]', 'cgc_charset [ letter ]')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } ]
var: request -> term  (request -> term [ size ]) = '\0'
var: UNDEF request -> term  (request -> term [ size ]) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } ]
Assigns = [('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('UNDEF', 'request -> term ', '[ size ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_getRandomTerm ( Request * request ) { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_createRandomRequest ( Request * request )')]
ParameterDeclaration : type = Request *, var = request [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['request']
[enterParameterDeclaration] Request * : request
sym_dict [request] = Request * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = request
var: void * tlv3 (tlv3) = request
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = 0
var: int tlv2 (tlv2) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = REQUEST_SIZE
var: cgc_size_t tlv1 (tlv1) = REQUEST_SIZE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('void *', 'tlv3', '', 'request'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'REQUEST_SIZE')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_getRandomTerm'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( request )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_getRandomAttribute'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( request )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = void * 
var: tlv6 (tlv6) = request -> limit
var: void * tlv6 (tlv6) = request -> limit
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = void * 
var: tlv5 (tlv5) = RESULT_LIMIT_STR
var: void * tlv5 (tlv5) = RESULT_LIMIT_STR
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = cgc_size_t 
var: tlv4 (tlv4) = sizeof ( RESULT_LIMIT_STR )
var: cgc_size_t tlv4 (tlv4) = sizeof ( RESULT_LIMIT_STR )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }
Assigns = [('void *', 'tlv6', '', 'request -> limit'), ('void *', 'tlv5', '', 'RESULT_LIMIT_STR'), ('cgc_size_t', 'tlv4', '', 'sizeof ( RESULT_LIMIT_STR )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_createRandomRequest ( Request * request ) { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_getRandomGiftCard ( char * * gift_card )')]
ParameterDeclaration : type = char * *, var = gift_card [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['gift_card']
[enterParameterDeclaration] char * * : gift_card
sym_dict [gift_card] = char * * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int charset_size'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [charset_size] = unsigned int 
var: charset_size (charset_size) = 0
var: unsigned int charset_size (charset_size) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int index'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [index] = int 
var: index (index) = 0
var: int index (index) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int section'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [section] = int 
var: section (section) = 0
var: int section (section) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = cgc_size_t 
var: tlv6 (tlv6) = GIFT_CARD_LEN + 1
var: cgc_size_t tlv6 (tlv6) = GIFT_CARD_LEN + 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
var: tlv5 (tlv5) = 0
var: int tlv5 (tlv5) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * * 
var: tlv4 (tlv4) = ( void * * ) gift_card
var: void * * tlv4 (tlv4) = ( void * * ) gift_card
var: ret (ret) = cgc_allocate ( tlv6 , tlv5 , tlv4 )
var: int ret (ret) = cgc_allocate ( tlv6 , tlv5 , tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }
Assigns = [('cgc_size_t', 'tlv6', '', 'GIFT_CARD_LEN + 1'), ('int', 'tlv5', '', '0'), ('void * *', 'tlv4', '', '( void * * ) gift_card'), ('int', 'ret', '', 'cgc_allocate ( tlv6 , tlv5 , tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = unsigned int 
var: tlv8 (tlv8) = 3
var: unsigned int tlv8 (tlv8) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv8 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; }
Assigns = [('unsigned int', 'tlv8', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = * gift_card
var: void * tlv3 (tlv3) = * gift_card
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = 0
var: int tlv2 (tlv2) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = GIFT_CARD_LEN
var: cgc_size_t tlv1 (tlv1) = GIFT_CARD_LEN
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('void *', 'tlv3', '', '* gift_card'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'GIFT_CARD_LEN')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 = cgc_charset'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = const char * 
var: charset_size (charset_size) = cgc_strlen ( tlv7 )
var: unsigned int charset_size (charset_size) = cgc_strlen ( tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }
Assigns = [('unsigned int', 'charset_size', '', 'cgc_strlen ( tlv7 )')]
Compares = []
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: index (index) = 0
var: int index (index) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => index < GIFT_CARD_LEN
[0] <class 'CParser.CParser.ShiftExpressionContext'> => index
[2] <class 'CParser.CParser.ShiftExpressionContext'> => GIFT_CARD_LEN
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => index < GIFT_CARD_LEN
=> ['index', 'GIFT_CARD_LEN']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : index
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['index']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['index']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['index']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['index']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['index']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['index']
FOUND IT! [1.2]  int : index
Resolved type: [1.3]  int : index
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int letter'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [letter] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = unsigned int 
var: tlv9 (tlv9) = charset_size
var: unsigned int tlv9 (tlv9) = charset_size
var: letter (letter) = cgc_getRandomNumber ( tlv9 )
var: int letter (letter) = cgc_getRandomNumber ( tlv9 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; }
Assigns = [('unsigned int', 'tlv9', '', 'charset_size'), ('int', 'letter', '', 'cgc_getRandomNumber ( tlv9 )')]
Compares = []
var: ( * gift_card )  (( * gift_card ) [ index ]) = cgc_charset [ letter ]
var: UNDEF ( * gift_card )  (( * gift_card ) [ index ]) = cgc_charset [ letter ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ]
Assigns = [('UNDEF', '( * gift_card ) ', '[ index ]', 'cgc_charset [ letter ]')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ]
var: ( * gift_card )  (( * gift_card ) [ GIFT_CARD_LEN ]) = '\0'
var: UNDEF ( * gift_card )  (( * gift_card ) [ GIFT_CARD_LEN ]) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } ]
 4 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ]
Assigns = [('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0'), ('UNDEF', '( * gift_card ) ', '[ GIFT_CARD_LEN ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_getRandomGiftCard ( char * * gift_card ) { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_purchaseSong ( int socket , Song * selectedSong , SongList * mySongList )')]
ParameterDeclaration : type = int, var = socket [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['socket']
[enterParameterDeclaration] int : socket
sym_dict [socket] = int 
ParameterDeclaration : type = Song *, var = selectedSong [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['selectedSong']
[enterParameterDeclaration] Song * : selectedSong
sym_dict [selectedSong] = Song * 
ParameterDeclaration : type = SongList *, var = mySongList [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['mySongList']
[enterParameterDeclaration] SongList * : mySongList
sym_dict [mySongList] = SongList * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char price'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [price] = char 
var: price (price) = 0
var: char price (price) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 = selectedSong -> price'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = const char * 
var: price (price) = cgc_str2int ( tlv1 )
var: char price (price) = cgc_str2int ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; }
Assigns = [('char', 'price', '', 'cgc_str2int ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => mySongList -> balance >= price
[0] <class 'CParser.CParser.ShiftExpressionContext'> => mySongList -> balance
[2] <class 'CParser.CParser.ShiftExpressionContext'> => price
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => mySongList -> balance >= price
=> ['mySongList -> balance', 'price']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : mySongList -> balance
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['mySongList -> balance']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['mySongList -> balance']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['mySongList -> balance']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['mySongList -> balance']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['mySongList -> balance']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['mySongList', '->', 'balance']
FOUND IT! [1.2]  SongList * : mySongList
Resolved type: [1.3]  SongList * : mySongList
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ mySongList -> balance >= price ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: mySongList -> balance (mySongList -> balance) = price
var: UNDEF mySongList -> balance (mySongList -> balance) = price
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = & mySongList -> songs [ mySongList -> size - 1 ]
var: void * tlv4 (tlv4) = & mySongList -> songs [ mySongList -> size - 1 ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = selectedSong
var: void * tlv3 (tlv3) = selectedSong
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = RESULT_VALUE_SIZE * 3
var: cgc_size_t tlv2 (tlv2) = RESULT_VALUE_SIZE * 3
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('void *', 'tlv4', '', '& mySongList -> songs [ mySongList -> size - 1 ]'), ('void *', 'tlv3', '', 'selectedSong'), ('cgc_size_t', 'tlv2', '', 'RESULT_VALUE_SIZE * 3')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = int 
var: tlv7 (tlv7) = socket
var: int tlv7 (tlv7) = socket
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = const char * 
var: tlv5 (tlv5) = cgc_strlen ( tlv13 )
var: cgc_size_t tlv5 (tlv5) = cgc_strlen ( tlv13 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; }
Assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv13 )')]
Compares = []
var: ret (ret) = cgc_transmit_all ( tlv7 , tlv6 , tlv5 )
var: int ret (ret) = cgc_transmit_all ( tlv7 , tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ]
Assigns = [('int', 'tlv7', '', 'socket'), ('int', 'ret', '', 'cgc_transmit_all ( tlv7 , tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = unsigned int 
var: tlv11 (tlv11) = 10
var: unsigned int tlv11 (tlv11) = 10
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv11 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; }
Assigns = [('unsigned int', 'tlv11', '', '10')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = int 
var: tlv10 (tlv10) = socket
var: int tlv10 (tlv10) = socket
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv9 [ ] = "\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv9] = const char * 
[C-t-2] sym_dict [tlv9 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv14 [ ] = "\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv14] = const char * 
[C-t-2] sym_dict [tlv14 [ ]] = const char 
var: tlv8 (tlv8) = cgc_strlen ( tlv14 )
var: cgc_size_t tlv8 (tlv8) = cgc_strlen ( tlv14 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; }
Assigns = [('cgc_size_t', 'tlv8', '', 'cgc_strlen ( tlv14 )')]
Compares = []
var: ret (ret) = cgc_transmit_all ( tlv10 , tlv9 , tlv8 )
var: int ret (ret) = cgc_transmit_all ( tlv10 , tlv9 , tlv8 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ]
Assigns = [('int', 'tlv10', '', 'socket'), ('int', 'ret', '', 'cgc_transmit_all ( tlv10 , tlv9 , tlv8 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = unsigned int 
var: tlv12 (tlv12) = 10
var: unsigned int tlv12 (tlv12) = 10
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv12 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; }
Assigns = [('unsigned int', 'tlv12', '', '10')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } ]
Assigns = [('UNDEF', 'mySongList -> balance', '', 'price')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } ]
Assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_purchaseSong ( int socket , Song * selectedSong , SongList * mySongList ) { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_sendSearchString ( int socket , Request request )')]
ParameterDeclaration : type = int, var = socket [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['socket']
[enterParameterDeclaration] int : socket
sym_dict [socket] = int 
ParameterDeclaration : type = Request, var = request [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['request']
[enterParameterDeclaration] Request : request
sym_dict [request] = Request 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * search_string'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [search_string] = char * 
var: search_string (search_string) = NULL
var: char * search_string (search_string) = NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Request tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = Request 
var: tlv1 (tlv1) = request
var: Request tlv1 (tlv1) = request
var: search_string (search_string) = cgc_createSearchString ( tlv1 )
var: char * search_string (search_string) = cgc_createSearchString ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; }
Assigns = [('Request', 'tlv1', '', 'request'), ('char *', 'search_string', '', 'cgc_createSearchString ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = socket
var: int tlv4 (tlv4) = socket
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 = search_string'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = search_string'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
var: tlv2 (tlv2) = cgc_strlen ( tlv6 )
var: cgc_size_t tlv2 (tlv2) = cgc_strlen ( tlv6 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; }
Assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
Compares = []
var: ret (ret) = cgc_transmit_all ( tlv4 , tlv3 , tlv2 )
var: int ret (ret) = cgc_transmit_all ( tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ]
Assigns = [('int', 'tlv4', '', 'socket'), ('int', 'ret', '', 'cgc_transmit_all ( tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 4
var: unsigned int tlv5 (tlv5) = 4
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '4')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } ]
Assigns = [('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_sendSearchString ( int socket , Request request ) { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_getBalance ( SongList * mySongList )')]
ParameterDeclaration : type = SongList *, var = mySongList [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['mySongList']
[enterParameterDeclaration] SongList * : mySongList
sym_dict [mySongList] = SongList * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t size'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [size] = cgc_size_t 
var: size (size) = 0
var: cgc_size_t size (size) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * gift_card'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [gift_card] = char * 
var: gift_card (gift_card) = NULL
var: char * gift_card (gift_card) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [buffer] = char * 
var: buffer (buffer) = NULL
var: char * buffer (buffer) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = char * * 
var: tlv10 (tlv10) = & gift_card
var: char * * tlv10 (tlv10) = & gift_card
var: size (size) = cgc_getRandomGiftCard ( tlv10 )
var: cgc_size_t size (size) = cgc_getRandomGiftCard ( tlv10 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; }
Assigns = [('char * *', 'tlv10', '', '& gift_card'), ('cgc_size_t', 'size', '', 'cgc_getRandomGiftCard ( tlv10 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = cgc_size_t 
var: tlv13 (tlv13) = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
var: cgc_size_t tlv13 (tlv13) = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = int 
var: tlv12 (tlv12) = 0
var: int tlv12 (tlv12) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = void * * 
var: tlv11 (tlv11) = ( void * * ) & buffer
var: void * * tlv11 (tlv11) = ( void * * ) & buffer
var: ret (ret) = cgc_allocate ( tlv13 , tlv12 , tlv11 )
var: int ret (ret) = cgc_allocate ( tlv13 , tlv12 , tlv11 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; }
Assigns = [('cgc_size_t', 'tlv13', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1'), ('int', 'tlv12', '', '0'), ('void * *', 'tlv11', '', '( void * * ) & buffer'), ('int', 'ret', '', 'cgc_allocate ( tlv13 , tlv12 , tlv11 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv25'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv25] = unsigned int 
var: tlv25 (tlv25) = 3
var: unsigned int tlv25 (tlv25) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv25 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; }
Assigns = [('unsigned int', 'tlv25', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = buffer
var: void * tlv3 (tlv3) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = 0
var: int tlv2 (tlv2) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t 
var: tlv1 (tlv1) = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
var: cgc_size_t tlv1 (tlv1) = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('void *', 'tlv3', '', 'buffer'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = char * 
var: tlv5 (tlv5) = buffer
var: char * tlv5 (tlv5) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 [ ] = "ID="'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv4] = const char * 
[C-t-2] sym_dict [tlv4 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }
Assigns = [('char *', 'tlv5', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = buffer
var: char * tlv7 (tlv7) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = gift_card'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }
Assigns = [('char *', 'tlv7', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = char * 
var: tlv9 (tlv9) = buffer
var: char * tlv9 (tlv9) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 [ ] = "\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv8] = const char * 
[C-t-2] sym_dict [tlv8 [ ]] = const char 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }
Assigns = [('char *', 'tlv9', '', 'buffer')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = void * 
var: tlv15 (tlv15) = gift_card
var: void * tlv15 (tlv15) = gift_card
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = cgc_size_t 
var: tlv14 (tlv14) = size
var: cgc_size_t tlv14 (tlv14) = size
var: ret (ret) = cgc_deallocate ( tlv15 , tlv14 )
var: int ret (ret) = cgc_deallocate ( tlv15 , tlv14 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }
Assigns = [('void *', 'tlv15', '', 'gift_card'), ('cgc_size_t', 'tlv14', '', 'size'), ('int', 'ret', '', 'cgc_deallocate ( tlv15 , tlv14 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv26'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv26] = unsigned int 
var: tlv26 (tlv26) = 3
var: unsigned int tlv26 (tlv26) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv26 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; }
Assigns = [('unsigned int', 'tlv26', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv18'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv18] = int 
var: tlv18 (tlv18) = STDOUT
var: int tlv18 (tlv18) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv17 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv30 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv30] = const char * 
var: tlv16 (tlv16) = cgc_strlen ( tlv30 )
var: cgc_size_t tlv16 (tlv16) = cgc_strlen ( tlv30 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; }
Assigns = [('cgc_size_t', 'tlv16', '', 'cgc_strlen ( tlv30 )')]
Compares = []
var: ret (ret) = cgc_transmit_all ( tlv18 , tlv17 , tlv16 )
var: int ret (ret) = cgc_transmit_all ( tlv18 , tlv17 , tlv16 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ]
Assigns = [('int', 'tlv18', '', 'STDOUT'), ('int', 'ret', '', 'cgc_transmit_all ( tlv18 , tlv17 , tlv16 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv27'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv27] = unsigned int 
var: tlv27 (tlv27) = 10
var: unsigned int tlv27 (tlv27) = 10
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv27 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; }
Assigns = [('unsigned int', 'tlv27', '', '10')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv20'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv20] = void * 
var: tlv20 (tlv20) = buffer
var: void * tlv20 (tlv20) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv19'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = cgc_size_t 
var: tlv19 (tlv19) = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
var: cgc_size_t tlv19 (tlv19) = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
var: ret (ret) = cgc_deallocate ( tlv20 , tlv19 )
var: int ret (ret) = cgc_deallocate ( tlv20 , tlv19 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }
Assigns = [('void *', 'tlv20', '', 'buffer'), ('cgc_size_t', 'tlv19', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1'), ('int', 'ret', '', 'cgc_deallocate ( tlv20 , tlv19 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv28'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv28] = unsigned int 
var: tlv28 (tlv28) = 3
var: unsigned int tlv28 (tlv28) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv28 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; }
Assigns = [('unsigned int', 'tlv28', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv21'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv21] = int 
var: tlv21 (tlv21) = STDIN
var: int tlv21 (tlv21) = STDIN
var: mySongList -> balance (mySongList -> balance) = cgc_receiveBalance ( tlv21 )
var: UNDEF mySongList -> balance (mySongList -> balance) = cgc_receiveBalance ( tlv21 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }
Assigns = [('int', 'tlv21', '', 'STDIN'), ('UNDEF', 'mySongList -> balance', '', 'cgc_receiveBalance ( tlv21 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv24'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv24] = cgc_size_t 
var: tlv24 (tlv24) = sizeof ( Song ) * mySongList -> balance
var: cgc_size_t tlv24 (tlv24) = sizeof ( Song ) * mySongList -> balance
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv23'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv23] = int 
var: tlv23 (tlv23) = 0
var: int tlv23 (tlv23) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * * tlv22'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv22] = void * * 
var: tlv22 (tlv22) = ( void * * ) & mySongList -> songs
var: void * * tlv22 (tlv22) = ( void * * ) & mySongList -> songs
var: ret (ret) = cgc_allocate ( tlv24 , tlv23 , tlv22 )
var: int ret (ret) = cgc_allocate ( tlv24 , tlv23 , tlv22 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }
Assigns = [('cgc_size_t', 'tlv24', '', 'sizeof ( Song ) * mySongList -> balance'), ('int', 'tlv23', '', '0'), ('void * *', 'tlv22', '', '( void * * ) & mySongList -> songs'), ('int', 'ret', '', 'cgc_allocate ( tlv24 , tlv23 , tlv22 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv29'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv29] = unsigned int 
var: tlv29 (tlv29) = 3
var: unsigned int tlv29 (tlv29) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv29 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; }
Assigns = [('unsigned int', 'tlv29', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } ]
 6 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } ]
 7 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } ]
 8 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } ]
 9 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } ]
 10 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } ]
 11 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } ]
 12 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } ]
 13 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } ]
 14 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } ]
 15 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } ]
Assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_getBalance ( SongList * mySongList ) { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'Song *'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_selectSong ( SongList results , Request request )')]
ParameterDeclaration : type = SongList, var = results [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['results']
[enterParameterDeclaration] SongList : results
sym_dict [results] = SongList 
ParameterDeclaration : type = Request, var = request [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['request']
[enterParameterDeclaration] Request : request
sym_dict [request] = Request 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return & results . songs [ 0 ] ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : Song * cgc_selectSong ( SongList results , Request request ) { return & results . songs [ 0 ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return & results . songs [ 0 ] ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'main ( int cgc_argc , char * cgc_argv [ ] )')]
ParameterDeclaration : type = int, var = cgc_argc [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cgc_argc']
[enterParameterDeclaration] int : cgc_argc
sym_dict [cgc_argc] = int 
ParameterDeclaration : type = char *, var = cgc_argv [ ] [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cgc_argv [ ]']
[enterParameterDeclaration] char * : cgc_argv [ ]
sym_dict [cgc_argv] = char * * 
sym_dict [cgc_argv [ ]] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int starting_balance'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [starting_balance] = int 
var: starting_balance (starting_balance) = 0
var: int starting_balance (starting_balance) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SongList'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'mySongList = { 0 , NULL , 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [mySongList] = SongList 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SongList'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'results = { 0 , NULL , 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [results] = SongList 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Request'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'request = { 0 , 0 , 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [request] = Request 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Song'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'songs [ RESULT_LIMIT ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [songs] = Song * 
[C-t-3] sym_dict [songs [ RESULT_LIMIT ]] = Song 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Song * selectedSong'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [selectedSong] = Song * 
var: selectedSong (selectedSong) = NULL
var: Song * selectedSong (selectedSong) = NULL
var: results . songs (results . songs) = songs
var: UNDEF results . songs (results . songs) = songs
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SongList * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = SongList * 
var: tlv1 (tlv1) = & mySongList
var: SongList * tlv1 (tlv1) = & mySongList
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_getBalance'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv1 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; }
Assigns = [('SongList *', 'tlv1', '', '& mySongList')]
Compares = []
var: starting_balance (starting_balance) = mySongList . balance
var: int starting_balance (starting_balance) = mySongList . balance
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => mySongList . balance > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => mySongList . balance
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => mySongList . balance > 0
=> ['mySongList . balance', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : mySongList . balance
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['mySongList . balance']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['mySongList . balance']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['mySongList . balance']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['mySongList . balance']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['mySongList . balance']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['mySongList', '.', 'balance']
FOUND IT! [1.2]  SongList : mySongList
Resolved type: [1.3]  SongList : mySongList
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: results . size (results . size) = 0
var: UNDEF results . size (results . size) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Request * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = Request * 
var: tlv4 (tlv4) = & request
var: Request * tlv4 (tlv4) = & request
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_createRandomRequest'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; }
Assigns = [('Request *', 'tlv4', '', '& request')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = int 
var: tlv6 (tlv6) = STDOUT
var: int tlv6 (tlv6) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Request tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = Request 
var: tlv5 (tlv5) = request
var: Request tlv5 (tlv5) = request
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; }
Assigns = [('int', 'tlv6', '', 'STDOUT'), ('Request', 'tlv5', '', 'request')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = int 
var: tlv9 (tlv9) = STDIN
var: int tlv9 (tlv9) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SongList * tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = SongList * 
var: tlv8 (tlv8) = & results
var: SongList * tlv8 (tlv8) = & results
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = int 
var: tlv7 (tlv7) = RESULT_LIMIT
var: int tlv7 (tlv7) = RESULT_LIMIT
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; }
Assigns = [('int', 'tlv9', '', 'STDIN'), ('SongList *', 'tlv8', '', '& results'), ('int', 'tlv7', '', 'RESULT_LIMIT')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SongList tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = SongList 
var: tlv12 (tlv12) = results
var: SongList tlv12 (tlv12) = results
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Request tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = Request 
var: tlv11 (tlv11) = request
var: Request tlv11 (tlv11) = request
var: selectedSong (selectedSong) = cgc_selectSong ( tlv12 , tlv11 )
var: Song * selectedSong (selectedSong) = cgc_selectSong ( tlv12 , tlv11 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; }
Assigns = [('SongList', 'tlv12', '', 'results'), ('Request', 'tlv11', '', 'request'), ('Song *', 'selectedSong', '', 'cgc_selectSong ( tlv12 , tlv11 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = int 
var: tlv15 (tlv15) = STDOUT
var: int tlv15 (tlv15) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Song * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = Song * 
var: tlv14 (tlv14) = selectedSong
var: Song * tlv14 (tlv14) = selectedSong
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'SongList * tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = SongList * 
var: tlv13 (tlv13) = & mySongList
var: SongList * tlv13 (tlv13) = & mySongList
var: ret (ret) = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 )
var: int ret (ret) = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }
Assigns = [('int', 'tlv15', '', 'STDOUT'), ('Song *', 'tlv14', '', 'selectedSong'), ('SongList *', 'tlv13', '', '& mySongList'), ('int', 'ret', '', 'cgc_purchaseSong ( tlv15 , tlv14 , tlv13 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret == LOW_BALANCE
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => LOW_BALANCE
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret == LOW_BALANCE
=> ['ret', 'LOW_BALANCE']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret == LOW_BALANCE ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { break ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret == LOW_BALANCE ) { break ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { break ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_receiveBalance'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( STDIN )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } ]
 5 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret == LOW_BALANCE ) { break ; } ]
Assigns = [('UNDEF', 'results . size', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = mySongList . songs
var: void * tlv3 (tlv3) = mySongList . songs
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = sizeof ( Song ) * starting_balance
var: cgc_size_t tlv2 (tlv2) = sizeof ( Song ) * starting_balance
var: ret (ret) = cgc_deallocate ( tlv3 , tlv2 )
var: int ret (ret) = cgc_deallocate ( tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }
Assigns = [('void *', 'tlv3', '', 'mySongList . songs'), ('cgc_size_t', 'tlv2', '', 'sizeof ( Song ) * starting_balance'), ('int', 'ret', '', 'cgc_deallocate ( tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = unsigned int 
var: tlv10 (tlv10) = 3
var: unsigned int tlv10 (tlv10) = 3
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv10 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; }
Assigns = [('unsigned int', 'tlv10', '', '3')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } ]
Assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int main ( int cgc_argc , char * cgc_argv [ ] ) { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; } ]
compound scope 0 : { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; }
compound scope 1 : { ptr ++ , count ++ ; }
compound scope 2 : { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; } ] 
p_decls = [('char *', 'ptr', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'ptr', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('char *', 'buffer', None), ('char *', 'value', None)]
assigns = [('char *', 'ptr', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'PARAM_DELIM'), ('char *', 'ptr', '', 'buffer')]
compares = []
===> context { char * ptr ; ptr = NULL ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = PARAM_DELIM ; ptr = buffer ; while ( * ptr && ( * ptr != * delim ) && count < RESULT_VALUE_SIZE ) { ptr ++ , count ++ ; } { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } return ++ ptr ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: ptr
1 : |  decl_scope  | type: int, var: count
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: char *, var: delim
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: char *, var: value
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: char *, value: PARAM_DELIM
4 : | assign_scope | type: char *, value: buffer
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ptr ++ , count ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ptr ++ , count ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('char *', 'value', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('char *', 'value', None), ('char *', 'ptr', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None)]
assigns = [('char *', 'ptr', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'PARAM_DELIM'), ('char *', 'ptr', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('char *', 'value', None), ('char *', 'ptr', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None)]
assigns = [('char *', 'ptr', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'PARAM_DELIM'), ('char *', 'ptr', '', 'buffer')]
compares = ['', '', '', '']
===> context { ptr ++ , count ++ ; }
ignore sibs: ['{ void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }', 'return ++ ptr ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char *, var: value
2 : |  decl_scope  | type: char *, var: ptr
3 : |  decl_scope  | type: int, var: count
4 : |  decl_scope  | type: int, var: i
5 : |  decl_scope  | type: char *, var: delim
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: char *, value: PARAM_DELIM
4 : | assign_scope | type: char *, value: buffer
0 : |compare_scopes| type: char, value: * ptr
1 : |compare_scopes| type: char, value: * delim
2 : |compare_scopes| type: int, value: count
3 : |compare_scopes| type: int, value: RESULT_VALUE_SIZE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('char *', 'buffer', None), ('char *', 'value', None)]
assigns = [('void *', 'tlv3', '', 'value'), ('void *', 'tlv2', '', 'buffer'), ('cgc_size_t', 'tlv1', '', 'count')]
compares = []
decls = [('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('char *', 'buffer', None), ('char *', 'value', None), ('char *', 'ptr', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None)]
assigns = [('void *', 'tlv3', '', 'value'), ('void *', 'tlv2', '', 'buffer'), ('cgc_size_t', 'tlv1', '', 'count'), ('char *', 'ptr', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'PARAM_DELIM'), ('char *', 'ptr', '', 'buffer')]
compares = []
===> context { void * tlv3 ; tlv3 = value ; void * tlv2 ; tlv2 = buffer ; cgc_size_t tlv1 ; tlv1 = count ; cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['return ++ ptr ;', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: void *, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char *, var: value
5 : |  decl_scope  | type: char *, var: ptr
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
0 : | assign_scope | type: void *, value: value
1 : | assign_scope | type: void *, value: buffer
2 : | assign_scope | type: cgc_size_t, value: count
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: PARAM_DELIM
7 : | assign_scope | type: char *, value: buffer
=======END=======
compound scope 0 : { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; }
compound scope 1 : { end ++ , count ++ ; }
compound scope 2 : { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 3 : { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }
compound scope 4 : { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }
compound scope 5 : { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; }
compound scope 6 : { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; } ] 
p_decls = [('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None), ('char *', 'buffer', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int num_results ; num_results = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: start
1 : |  decl_scope  | type: char *, var: end
2 : |  decl_scope  | type: char *, var: key
3 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
4 : |  decl_scope  | type: char *, var: value
5 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: num_results
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: char *, var: buffer
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { end ++ , count ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { end ++ , count ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '', '', '']
===> context { end ++ , count ++ ; }
ignore sibs: ['{ void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }', 'int tlv1 ;', '{ const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char *, var: start
2 : |  decl_scope  | type: char *, var: end
3 : |  decl_scope  | type: char *, var: key
4 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
5 : |  decl_scope  | type: char *, var: value
6 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char, value: * end
1 : |compare_scopes| type: char, value: * delim
2 : |compare_scopes| type: int, value: count
3 : |compare_scopes| type: int, value: KEY_SIZE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('char *', 'buffer', None)]
assigns = [('void *', 'tlv4', '', 'key'), ('void *', 'tlv3', '', 'start'), ('cgc_size_t', 'tlv2', '', 'count')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None)]
assigns = [('void *', 'tlv4', '', 'key'), ('void *', 'tlv3', '', 'start'), ('cgc_size_t', 'tlv2', '', 'count'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['int tlv1 ;', '{ const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: char *, var: value
9 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
10 : |  decl_scope  | type: int, var: count
11 : |  decl_scope  | type: int, var: i
12 : |  decl_scope  | type: char *, var: delim
13 : |  decl_scope  | type: int, var: ret
14 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: void *, value: key
1 : | assign_scope | type: void *, value: start
2 : | assign_scope | type: cgc_size_t, value: count
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: KEYVAL_DELIM
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: int, value: 0
10 : | assign_scope | type: char *, value: buffer
11 : | assign_scope | type: char *, value: start
12 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', None), ('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv6 = key ; const char * tlv5 = NUM_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: const char *, var: tlv5
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: char *, var: value
8 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
13 : |  decl_scope  | type: int, var: num_results
14 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } return num_results ; }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char *, var: start
2 : |  decl_scope  | type: char *, var: end
3 : |  decl_scope  | type: char *, var: key
4 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
5 : |  decl_scope  | type: char *, var: value
6 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: num_results
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } ] 
p_decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value')]
compares = []
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; }
ignore sibs: ['{ const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; }', 'return num_results ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv8
1 : |  decl_scope  | type: char *, var: tlv7
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: char *, var: value
8 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
13 : |  decl_scope  | type: int, var: num_results
14 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: value
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: char *, value: buffer
10 : | assign_scope | type: char *, value: start
11 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; } ] 
p_decls = [('const char *', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'num_results', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'num_results', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { const char * tlv9 = value ; num_results = cgc_str2int ( tlv9 ) ; }
ignore sibs: ['return num_results ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv9
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: char *, var: value
7 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: num_results
13 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; }
compound scope 1 : { end ++ , count ++ ; }
compound scope 2 : { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 3 : { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }
compound scope 4 : { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }
compound scope 5 : { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; }
compound scope 6 : { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; }
compound scope 7 : { return 0 ; }
len(compound_scope) : 8
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; } ] 
p_decls = [('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None), ('char *', 'buffer', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; char value [ RESULT_VALUE_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; int balance ; balance = 0 ; start = buffer ; end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } int tlv1 ; { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: start
1 : |  decl_scope  | type: char *, var: end
2 : |  decl_scope  | type: char *, var: key
3 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
4 : |  decl_scope  | type: char *, var: value
5 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: balance
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: char *, var: buffer
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { end ++ , count ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { end ++ , count ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '', '', '']
===> context { end ++ , count ++ ; }
ignore sibs: ['{ void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }', 'int tlv1 ;', '{ const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char *, var: start
2 : |  decl_scope  | type: char *, var: end
3 : |  decl_scope  | type: char *, var: key
4 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
5 : |  decl_scope  | type: char *, var: value
6 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char, value: * end
1 : |compare_scopes| type: char, value: * delim
2 : |compare_scopes| type: int, value: count
3 : |compare_scopes| type: int, value: KEY_SIZE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('char *', 'buffer', None)]
assigns = [('void *', 'tlv4', '', 'key'), ('void *', 'tlv3', '', 'start'), ('cgc_size_t', 'tlv2', '', 'count')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None)]
assigns = [('void *', 'tlv4', '', 'key'), ('void *', 'tlv3', '', 'start'), ('cgc_size_t', 'tlv2', '', 'count'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { void * tlv4 ; tlv4 = key ; void * tlv3 ; tlv3 = start ; cgc_size_t tlv2 ; tlv2 = count ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['int tlv1 ;', '{ const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }', 'if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: char *, var: value
9 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
10 : |  decl_scope  | type: int, var: count
11 : |  decl_scope  | type: int, var: i
12 : |  decl_scope  | type: char *, var: delim
13 : |  decl_scope  | type: int, var: ret
14 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: void *, value: key
1 : | assign_scope | type: void *, value: start
2 : | assign_scope | type: cgc_size_t, value: count
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: KEYVAL_DELIM
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: int, value: 0
10 : | assign_scope | type: char *, value: buffer
11 : | assign_scope | type: char *, value: start
12 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', None), ('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv6', None), ('const char *', 'tlv5', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv6 = key ; const char * tlv5 = BAL_STR ; tlv1 = cgc_strcmp ( tlv6 , tlv5 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: const char *, var: tlv5
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: char *, var: value
8 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
13 : |  decl_scope  | type: int, var: balance
14 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } if ( balance < 0 || balance > 255 ) { return 0 ; } return balance ; }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char *, var: start
2 : |  decl_scope  | type: char *, var: end
3 : |  decl_scope  | type: char *, var: key
4 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
5 : |  decl_scope  | type: char *, var: value
6 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: balance
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; } ] 
p_decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value')]
compares = []
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv8', None), ('char *', 'tlv7', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv8', '', '++ end'), ('char *', 'tlv7', '', 'value'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv8 ; tlv8 = ++ end ; char * tlv7 ; tlv7 = value ; cgc_setValue ( tlv8 , tlv7 ) ; }
ignore sibs: ['{ const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; }', 'if ( balance < 0 || balance > 255 ) { return 0 ; }', 'return balance ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv8
1 : |  decl_scope  | type: char *, var: tlv7
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: char *, var: value
8 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
13 : |  decl_scope  | type: int, var: balance
14 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: value
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: char *, value: buffer
10 : | assign_scope | type: char *, value: start
11 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; } ] 
p_decls = [('const char *', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv9', None), ('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { const char * tlv9 = value ; balance = cgc_str2int ( tlv9 ) ; }
ignore sibs: ['if ( balance < 0 || balance > 255 ) { return 0 ; }', 'return balance ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv9
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: char *, var: value
7 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: balance
13 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'buffer', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('char *', 'value', ' [ RESULT_VALUE_SIZE ]'), ('char', 'value [ RESULT_VALUE_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'balance', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('int', 'balance', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '', '', '', '', '']
===> context { return 0 ; }
ignore sibs: ['return balance ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char *, var: start
2 : |  decl_scope  | type: char *, var: end
3 : |  decl_scope  | type: char *, var: key
4 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
5 : |  decl_scope  | type: char *, var: value
6 : |  decl_scope  | type: char, var: value [ RESULT_VALUE_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: balance
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: buffer
8 : | assign_scope | type: char *, value: start
9 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: int, value: balance
3 : |compare_scopes| type: int, value: 0
4 : |compare_scopes| type: int, value: balance
5 : |compare_scopes| type: int, value: 255
=======END=======
compound scope 0 : { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; }
compound scope 1 : { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; }
compound scope 2 : { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } }
compound scope 3 : { end ++ , count ++ ; }
compound scope 4 : { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; }
compound scope 5 : { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; }
compound scope 6 : { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } }
compound scope 7 : { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; }
compound scope 8 : { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }
compound scope 9 : { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; }
compound scope 10 : { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } }
compound scope 11 : { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; }
compound scope 12 : { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }
compound scope 13 : { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; }
compound scope 14 : { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } }
compound scope 15 : { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; }
compound scope 16 : { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }
compound scope 17 : { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; }
compound scope 18 : { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } }
compound scope 19 : { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; }
compound scope 20 : { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }
compound scope 21 : { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; }
compound scope 22 : { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; }
compound scope 23 : { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; }
compound scope 24 : { return 0 ; }
compound scope 25 : { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }
len(compound_scope) : 26
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; } ] 
p_decls = [('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
===> context { char * start ; start = NULL ; char * end ; end = NULL ; char key [ KEY_SIZE ] = { 0 } ; int count ; count = 0 ; int i ; i = 0 ; char * delim ; delim = KEYVAL_DELIM ; int ret ; ret = 0 ; { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } start = buffer ; while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: start
1 : |  decl_scope  | type: char *, var: end
2 : |  decl_scope  | type: char *, var: key
3 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
4 : |  decl_scope  | type: int, var: count
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: char *, var: delim
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: char *, var: buffer
9 : |  decl_scope  | type: Song *, var: song
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; } ] 
p_decls = [('void *', 'tlv8', None), ('int', 'tlv7', None), ('cgc_size_t', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv8', None), ('int', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('void *', 'tlv8', '', 'song'), ('int', 'tlv7', '', '0'), ('cgc_size_t', 'tlv6', '', 'SONG_SIZE')]
compares = []
decls = [('void *', 'tlv8', None), ('int', 'tlv7', None), ('cgc_size_t', 'tlv6', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv8', '', 'song'), ('int', 'tlv7', '', '0'), ('cgc_size_t', 'tlv6', '', 'SONG_SIZE'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv8 ; tlv8 = song ; int tlv7 ; tlv7 = 0 ; cgc_size_t tlv6 ; tlv6 = SONG_SIZE ; cgc_memset ( tlv8 , tlv7 , tlv6 ) ; }
ignore sibs: ['start = buffer ;', 'while ( 1 ) { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv8
1 : |  decl_scope  | type: int, var: tlv7
2 : |  decl_scope  | type: cgc_size_t, var: tlv6
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: Song *, var: song
5 : |  decl_scope  | type: char *, var: start
6 : |  decl_scope  | type: char *, var: end
7 : |  decl_scope  | type: char *, var: key
8 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: song
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: SONG_SIZE
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: KEYVAL_DELIM
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv1', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'end', '', 'start'), ('int', 'count', '', '0'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv1', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'end', '', 'start'), ('int', 'count', '', '0'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
===> context { end = start ; count = 0 ; while ( * end && ( * end != * delim ) && count < KEY_SIZE ) { end ++ , count ++ ; } { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } int tlv1 ; { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: Song *, var: song
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: start
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: char *, value: buffer
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { end ++ , count ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { end ++ , count ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '', '', '']
===> context { end ++ , count ++ ; }
ignore sibs: ['{ void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; }', 'int tlv1 ;', '{ const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char, value: * end
1 : |compare_scopes| type: char, value: * delim
2 : |compare_scopes| type: int, value: count
3 : |compare_scopes| type: int, value: KEY_SIZE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; } ] 
p_decls = [('void *', 'tlv11', None), ('void *', 'tlv10', None), ('cgc_size_t', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv11', None), ('void *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('void *', 'tlv11', '', 'key'), ('void *', 'tlv10', '', 'start'), ('cgc_size_t', 'tlv9', '', 'count')]
compares = []
decls = [('void *', 'tlv11', None), ('void *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv11', '', 'key'), ('void *', 'tlv10', '', 'start'), ('cgc_size_t', 'tlv9', '', 'count'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('void *', 'tlv11', None), ('void *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv11', '', 'key'), ('void *', 'tlv10', '', 'start'), ('cgc_size_t', 'tlv9', '', 'count'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('void *', 'tlv11', None), ('void *', 'tlv10', None), ('cgc_size_t', 'tlv9', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv11', '', 'key'), ('void *', 'tlv10', '', 'start'), ('cgc_size_t', 'tlv9', '', 'count'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { void * tlv11 ; tlv11 = key ; void * tlv10 ; tlv10 = start ; cgc_size_t tlv9 ; tlv9 = count ; cgc_memcpy ( tlv11 , tlv10 , tlv9 ) ; }
ignore sibs: ['int tlv1 ;', '{ const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv11
1 : |  decl_scope  | type: void *, var: tlv10
2 : |  decl_scope  | type: cgc_size_t, var: tlv9
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: Song *, var: song
5 : |  decl_scope  | type: char *, var: start
6 : |  decl_scope  | type: char *, var: end
7 : |  decl_scope  | type: char *, var: key
8 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: key
1 : | assign_scope | type: void *, value: start
2 : | assign_scope | type: cgc_size_t, value: count
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: KEYVAL_DELIM
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: char *, value: buffer
10 : | assign_scope | type: char *, value: start
11 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; } ] 
p_decls = [('const char *', 'tlv16', None), ('const char *', 'tlv15', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv16', None), ('const char *', 'tlv15', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv16', None), ('const char *', 'tlv15', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv16', None), ('const char *', 'tlv15', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv16', None), ('const char *', 'tlv15', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv16 = key ; const char * tlv15 = SONG_ID_STR ; tlv1 = cgc_strcmp ( tlv16 , tlv15 ) ; }
ignore sibs: ['if ( tlv1 == 0 ) { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } else { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv16
1 : |  decl_scope  | type: const char *, var: tlv15
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } }
ignore sibs: ['else', '{ int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; } ] 
p_decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id')]
compares = []
decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv18', None), ('char *', 'tlv17', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv18', '', '++ end'), ('char *', 'tlv17', '', 'song -> id'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv18 ; tlv18 = ++ end ; char * tlv17 ; tlv17 = song -> id ; start = cgc_setValue ( tlv18 , tlv17 ) ; }
ignore sibs: ['}', 'else', '{ int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv18
1 : |  decl_scope  | type: char *, var: tlv17
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: song -> id
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: char *, value: buffer
9 : | assign_scope | type: char *, value: start
10 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } } ] 
p_decls = [('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('int', 'tlv2', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv2', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv2', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { int tlv2 ; { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } }
ignore sibs: ['{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: Song *, var: song
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; } ] 
p_decls = [('const char *', 'tlv20', None), ('const char *', 'tlv19', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv20', None), ('const char *', 'tlv19', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv20', None), ('const char *', 'tlv19', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv20', None), ('const char *', 'tlv19', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv20', None), ('const char *', 'tlv19', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv20', None), ('const char *', 'tlv19', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv20 = key ; const char * tlv19 = PRICE_STR ; tlv2 = cgc_strcmp ( tlv20 , tlv19 ) ; }
ignore sibs: ['if ( tlv2 == 0 ) { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } else { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv20
1 : |  decl_scope  | type: const char *, var: tlv19
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } }
ignore sibs: ['else', '{ int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv2
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; } ] 
p_decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price')]
compares = []
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv22', None), ('char *', 'tlv21', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv22', '', '++ end'), ('char *', 'tlv21', '', 'song -> price'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv22 ; tlv22 = ++ end ; char * tlv21 ; tlv21 = song -> price ; start = cgc_setValue ( tlv22 , tlv21 ) ; }
ignore sibs: ['}', 'else', '{ int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv22
1 : |  decl_scope  | type: char *, var: tlv21
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: song -> price
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: char *, value: buffer
9 : | assign_scope | type: char *, value: start
10 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv2
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } } ] 
p_decls = [('int', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('int', 'tlv3', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { int tlv3 ; { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } }
ignore sibs: ['}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: Song *, var: song
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; } ] 
p_decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv24', None), ('const char *', 'tlv23', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv24 = key ; const char * tlv23 = ARTIST_STR ; tlv3 = cgc_strcmp ( tlv24 , tlv23 ) ; }
ignore sibs: ['if ( tlv3 == 0 ) { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } else { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv24
1 : |  decl_scope  | type: const char *, var: tlv23
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
14 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } }
ignore sibs: ['else', '{ int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
12 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv3
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; } ] 
p_decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist')]
compares = []
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv26', None), ('char *', 'tlv25', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv26', '', '++ end'), ('char *', 'tlv25', '', 'song -> artist'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv26 ; tlv26 = ++ end ; char * tlv25 ; tlv25 = song -> artist ; start = cgc_setValue ( tlv26 , tlv25 ) ; }
ignore sibs: ['}', 'else', '{ int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv26
1 : |  decl_scope  | type: char *, var: tlv25
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
14 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: song -> artist
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: char *, value: buffer
9 : | assign_scope | type: char *, value: start
10 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv3
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } } ] 
p_decls = [('int', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('int', 'tlv4', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { int tlv4 ; { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } }
ignore sibs: ['}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: Song *, var: song
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: int, var: tlv2
13 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; } ] 
p_decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv28', None), ('const char *', 'tlv27', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv28 = key ; const char * tlv27 = ALBUM_STR ; tlv4 = cgc_strcmp ( tlv28 , tlv27 ) ; }
ignore sibs: ['if ( tlv4 == 0 ) { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } else { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv28
1 : |  decl_scope  | type: const char *, var: tlv27
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
14 : |  decl_scope  | type: int, var: tlv3
15 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } }
ignore sibs: ['else', '{ int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
12 : |  decl_scope  | type: int, var: tlv3
13 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv4
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; } ] 
p_decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv30', None), ('char *', 'tlv29', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'tlv30', '', '++ end'), ('char *', 'tlv29', '', 'song -> album'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv30 ; tlv30 = ++ end ; char * tlv29 ; tlv29 = song -> album ; start = cgc_setValue ( tlv30 , tlv29 ) ; }
ignore sibs: ['}', 'else', '{ int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv30
1 : |  decl_scope  | type: char *, var: tlv29
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
14 : |  decl_scope  | type: int, var: tlv3
15 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: song -> album
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: char *, value: buffer
9 : | assign_scope | type: char *, value: start
10 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv4
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } } ] 
p_decls = [('int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { int tlv5 ; { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; } }
ignore sibs: ['}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv5
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: Song *, var: song
3 : |  decl_scope  | type: char *, var: start
4 : |  decl_scope  | type: char *, var: end
5 : |  decl_scope  | type: char *, var: key
6 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
7 : |  decl_scope  | type: int, var: count
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: char *, var: delim
10 : |  decl_scope  | type: int, var: ret
11 : |  decl_scope  | type: int, var: tlv1
12 : |  decl_scope  | type: int, var: tlv2
13 : |  decl_scope  | type: int, var: tlv3
14 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; } ] 
p_decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('const char *', 'tlv32', None), ('const char *', 'tlv31', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { const char * tlv32 = key ; const char * tlv31 = SONG_STR ; tlv5 = cgc_strcmp ( tlv32 , tlv31 ) ; }
ignore sibs: ['if ( tlv5 == 0 ) { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } else { return 0 ; }', '}', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv32
1 : |  decl_scope  | type: const char *, var: tlv31
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
14 : |  decl_scope  | type: int, var: tlv3
15 : |  decl_scope  | type: int, var: tlv4
16 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.IterationStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } return 0 ; }
ignore sibs: ['else', '{ return 0 ; }', '}', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
12 : |  decl_scope  | type: int, var: tlv3
13 : |  decl_scope  | type: int, var: tlv4
14 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv5
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; } ] 
p_decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.IterationStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv34', None), ('char *', 'tlv33', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'tlv34', '', '++ end'), ('char *', 'tlv33', '', 'song -> song'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = ['', '']
===> context { char * tlv34 ; tlv34 = ++ end ; char * tlv33 ; tlv33 = song -> song ; cgc_setValue ( tlv34 , tlv33 ) ; }
ignore sibs: ['return 0 ;', '}', 'else', '{ return 0 ; }', '}', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv34
1 : |  decl_scope  | type: char *, var: tlv33
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: Song *, var: song
4 : |  decl_scope  | type: char *, var: start
5 : |  decl_scope  | type: char *, var: end
6 : |  decl_scope  | type: char *, var: key
7 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
8 : |  decl_scope  | type: int, var: count
9 : |  decl_scope  | type: int, var: i
10 : |  decl_scope  | type: char *, var: delim
11 : |  decl_scope  | type: int, var: ret
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
14 : |  decl_scope  | type: int, var: tlv3
15 : |  decl_scope  | type: int, var: tlv4
16 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: char *, value: ++ end
1 : | assign_scope | type: char *, value: song -> song
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: KEYVAL_DELIM
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: char *, value: buffer
9 : | assign_scope | type: char *, value: start
10 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: tlv5
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = []
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
decls = [('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { return 0 ; }
ignore sibs: ['}', '}', '}', '}', '{ void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: Song *, var: song
2 : |  decl_scope  | type: char *, var: start
3 : |  decl_scope  | type: char *, var: end
4 : |  decl_scope  | type: char *, var: key
5 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
6 : |  decl_scope  | type: int, var: count
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: char *, var: delim
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
12 : |  decl_scope  | type: int, var: tlv3
13 : |  decl_scope  | type: int, var: tlv4
14 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char *, value: KEYVAL_DELIM
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char *, value: buffer
7 : | assign_scope | type: char *, value: start
8 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; } ] 
p_decls = [('void *', 'tlv14', None), ('int', 'tlv13', None), ('cgc_size_t', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv14', None), ('int', 'tlv13', None), ('cgc_size_t', 'tlv12', None), ('char *', 'buffer', None), ('Song *', 'song', None)]
assigns = [('void *', 'tlv14', '', 'key'), ('int', 'tlv13', '', '0'), ('cgc_size_t', 'tlv12', '', 'KEY_SIZE')]
compares = []
decls = [('void *', 'tlv14', None), ('int', 'tlv13', None), ('cgc_size_t', 'tlv12', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv14', '', 'key'), ('int', 'tlv13', '', '0'), ('cgc_size_t', 'tlv12', '', 'KEY_SIZE'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('void *', 'tlv14', None), ('int', 'tlv13', None), ('cgc_size_t', 'tlv12', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv14', '', 'key'), ('int', 'tlv13', '', '0'), ('cgc_size_t', 'tlv12', '', 'KEY_SIZE'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer')]
compares = []
decls = [('void *', 'tlv14', None), ('int', 'tlv13', None), ('cgc_size_t', 'tlv12', None), ('char *', 'buffer', None), ('Song *', 'song', None), ('char *', 'start', None), ('char *', 'end', None), ('char *', 'key', ' [ KEY_SIZE ]'), ('char', 'key [ KEY_SIZE ]', None), ('int', 'count', None), ('int', 'i', None), ('char *', 'delim', None), ('int', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv14', '', 'key'), ('int', 'tlv13', '', '0'), ('cgc_size_t', 'tlv12', '', 'KEY_SIZE'), ('char *', 'start', '', 'NULL'), ('char *', 'end', '', 'NULL'), ('int', 'count', '', '0'), ('int', 'i', '', '0'), ('char *', 'delim', '', 'KEYVAL_DELIM'), ('int', 'ret', '', '0'), ('char *', 'start', '', 'buffer'), ('char *', 'end', '', 'start'), ('int', 'count', '', '0')]
compares = []
===> context { void * tlv14 ; tlv14 = key ; int tlv13 ; tlv13 = 0 ; cgc_size_t tlv12 ; tlv12 = KEY_SIZE ; cgc_memset ( tlv14 , tlv13 , tlv12 ) ; }
ignore sibs: ['}', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv14
1 : |  decl_scope  | type: int, var: tlv13
2 : |  decl_scope  | type: cgc_size_t, var: tlv12
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: Song *, var: song
5 : |  decl_scope  | type: char *, var: start
6 : |  decl_scope  | type: char *, var: end
7 : |  decl_scope  | type: char *, var: key
8 : |  decl_scope  | type: char, var: key [ KEY_SIZE ]
9 : |  decl_scope  | type: int, var: count
10 : |  decl_scope  | type: int, var: i
11 : |  decl_scope  | type: char *, var: delim
12 : |  decl_scope  | type: int, var: ret
13 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: void *, value: key
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: KEY_SIZE
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: char *, value: KEYVAL_DELIM
8 : | assign_scope | type: int, value: 0
9 : | assign_scope | type: char *, value: buffer
10 : | assign_scope | type: char *, value: start
11 : | assign_scope | type: int, value: 0
=======END=======
compound scope 0 : { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; }
compound scope 1 : { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
compound scope 3 : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
compound scope 4 : { return 0 ; }
compound scope 5 : { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; } ] 
p_decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None), ('int', 'socket', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = []
===> context { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int balance ; balance = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } return balance ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: char, var: buf [ 1024 ]
2 : |  decl_scope  | type: int, var: bytes_read
3 : |  decl_scope  | type: int, var: balance
4 : |  decl_scope  | type: int, var: socket
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('int', 'socket', None)]
assigns = [('int', 'tlv3', '', 'socket'), ('char *', 'tlv2', '', 'buf'), ('cgc_size_t', 'tlv1', '', 'sizeof ( buf ) - 1')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('int', 'tlv3', '', 'socket'), ('char *', 'tlv2', '', 'buf'), ('cgc_size_t', 'tlv1', '', 'sizeof ( buf ) - 1'), ('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = []
===> context { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }', 'if ( bytes_read == 0 ) { return 0 ; }', '{ char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }', 'return balance ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: char *, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: int, var: socket
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: cgc_size_t, value: sizeof ( buf ) - 1
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['if ( bytes_read == 0 ) { return 0 ; }', '{ char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }', 'return balance ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: bytes_read
4 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None)]
assigns = [('unsigned int', 'tlv5', '', '2')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = ['', '']
===> context { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'if ( bytes_read == 0 ) { return 0 ; }', '{ char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }', 'return balance ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: int, var: bytes_read
5 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: unsigned int, value: 2
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = ['', '']
===> context { return 0 ; }
ignore sibs: ['{ char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }', 'return balance ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: bytes_read
4 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; } ] 
p_decls = [('char *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv4', None), ('int', 'socket', None)]
assigns = [('char *', 'tlv4', '', 'buf')]
compares = []
decls = [('char *', 'tlv4', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'balance', None)]
assigns = [('char *', 'tlv4', '', 'buf'), ('int', 'bytes_read', '', '0'), ('int', 'balance', '', '0')]
compares = []
===> context { char * tlv4 ; tlv4 = buf ; balance = cgc_parseBalanceResult ( tlv4 ) ; }
ignore sibs: ['return balance ;', '}']
0 : |  decl_scope  | type: char *, var: tlv4
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: int, var: bytes_read
5 : |  decl_scope  | type: int, var: balance
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
compound scope 0 : { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; }
compound scope 1 : { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
compound scope 3 : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
compound scope 4 : { return 0 ; }
compound scope 5 : { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }
compound scope 6 : { return num_results ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; } ] 
p_decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None), ('int', 'socket', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { char buf [ 1024 ] = { 0 } ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } if ( num_results > 0 ) { return num_results ; } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: char, var: buf [ 1024 ]
2 : |  decl_scope  | type: int, var: bytes_read
3 : |  decl_scope  | type: int, var: num_results
4 : |  decl_scope  | type: int, var: socket
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('int', 'socket', None)]
assigns = [('int', 'tlv3', '', 'socket'), ('char *', 'tlv2', '', 'buf'), ('cgc_size_t', 'tlv1', '', 'sizeof ( buf ) - 1')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'tlv3', '', 'socket'), ('char *', 'tlv2', '', 'buf'), ('cgc_size_t', 'tlv1', '', 'sizeof ( buf ) - 1'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { int tlv3 ; tlv3 = socket ; char * tlv2 ; tlv2 = buf ; cgc_size_t tlv1 ; tlv1 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }', 'if ( bytes_read == 0 ) { return 0 ; }', '{ char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }', 'if ( num_results > 0 ) { return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: char *, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: int, var: socket
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: cgc_size_t, value: sizeof ( buf ) - 1
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['if ( bytes_read == 0 ) { return 0 ; }', '{ char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }', 'if ( num_results > 0 ) { return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: bytes_read
4 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None)]
assigns = [('unsigned int', 'tlv5', '', '2')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'if ( bytes_read == 0 ) { return 0 ; }', '{ char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }', 'if ( num_results > 0 ) { return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: int, var: bytes_read
5 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: unsigned int, value: 2
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { return 0 ; }
ignore sibs: ['{ char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }', 'if ( num_results > 0 ) { return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: bytes_read
4 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; } ] 
p_decls = [('char *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv4', None), ('int', 'socket', None)]
assigns = [('char *', 'tlv4', '', 'buf')]
compares = []
decls = [('char *', 'tlv4', None), ('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('char *', 'tlv4', '', 'buf'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { char * tlv4 ; tlv4 = buf ; num_results = cgc_parseResultSize ( tlv4 ) ; }
ignore sibs: ['if ( num_results > 0 ) { return num_results ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv4
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: int, var: bytes_read
5 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return num_results ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return num_results ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { return num_results ; }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: bytes_read
4 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: num_results
1 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; }
compound scope 1 : { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; }
compound scope 2 : { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; }
compound scope 3 : { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 4 : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
compound scope 5 : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
compound scope 6 : { return 0 ; }
compound scope 7 : { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }
compound scope 8 : { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; }
compound scope 9 : { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } }
compound scope 10 : { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; }
len(compound_scope) : 11
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; } ] 
p_decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { char buf [ 1024 ] = { 0 } ; int ret ; ret = 0 ; int bytes_read ; bytes_read = 0 ; int num_results ; num_results = 0 ; { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: char, var: buf [ 1024 ]
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: int, var: bytes_read
4 : |  decl_scope  | type: int, var: num_results
5 : |  decl_scope  | type: int, var: socket
6 : |  decl_scope  | type: SongList *, var: songList
7 : |  decl_scope  | type: int, var: limit
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; } ] 
p_decls = [('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv1', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = [('int', 'tlv1', '', 'socket')]
compares = []
decls = [('int', 'tlv1', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'tlv1', '', 'socket'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { int tlv1 ; tlv1 = socket ; num_results = cgc_receiveNumResults ( tlv1 ) ; }
ignore sibs: ['while ( num_results ) { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv1
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: SongList *, var: songList
3 : |  decl_scope  | type: int, var: limit
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: bytes_read
8 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } if ( bytes_read == 0 ) { return 0 ; } if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } num_results -- ; }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: SongList *, var: songList
2 : |  decl_scope  | type: int, var: limit
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = [('int', 'tlv4', '', 'socket'), ('char *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'sizeof ( buf ) - 1')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'tlv4', '', 'socket'), ('char *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'sizeof ( buf ) - 1'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'tlv4', '', 'socket'), ('char *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'sizeof ( buf ) - 1'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'tlv4', '', 'socket'), ('char *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'sizeof ( buf ) - 1'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
===> context { int tlv4 ; tlv4 = socket ; char * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = sizeof ( buf ) - 1 ; bytes_read = cgc_recvline ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( bytes_read < 0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }', 'if ( bytes_read == 0 ) { return 0 ; }', 'if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: char *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: int, var: socket
4 : |  decl_scope  | type: SongList *, var: songList
5 : |  decl_scope  | type: int, var: limit
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ 1024 ]
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: bytes_read
10 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: char *, value: buf
2 : | assign_scope | type: cgc_size_t, value: sizeof ( buf ) - 1
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['if ( bytes_read == 0 ) { return 0 ; }', 'if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: SongList *, var: songList
2 : |  decl_scope  | type: int, var: limit
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = [('unsigned int', 'tlv5', '', '2')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'if ( bytes_read == 0 ) { return 0 ; }', 'if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: SongList *, var: songList
3 : |  decl_scope  | type: int, var: limit
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: bytes_read
8 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: unsigned int, value: 2
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { return 0 ; }
ignore sibs: ['if ( songList -> size < limit ) { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: SongList *, var: songList
2 : |  decl_scope  | type: int, var: limit
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: bytes_read
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } songList -> size ++ ; }
ignore sibs: ['num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: SongList *, var: songList
2 : |  decl_scope  | type: int, var: limit
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: SongList *, value: songList -> size
1 : |compare_scopes| type: SongList *, value: limit
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; } ] 
p_decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]')]
compares = []
decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv7', None), ('Song *', 'tlv6', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('Song *', 'tlv6', '', '& songList -> songs [ songList -> size ]'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
===> context { char * tlv7 ; tlv7 = buf ; Song * tlv6 ; tlv6 = & songList -> songs [ songList -> size ] ; ret = cgc_parseSearchResult ( tlv7 , tlv6 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } }', 'songList -> size ++ ;', '}', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv7
1 : |  decl_scope  | type: Song *, var: tlv6
2 : |  decl_scope  | type: int, var: socket
3 : |  decl_scope  | type: SongList *, var: songList
4 : |  decl_scope  | type: int, var: limit
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ 1024 ]
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: int, var: bytes_read
9 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: Song *, value: & songList -> songs [ songList -> size ]
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: SongList *, value: songList -> size
1 : |compare_scopes| type: SongList *, value: limit
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '', '', '']
===> context { { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } }
ignore sibs: ['songList -> size ++ ;', '}', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: SongList *, var: songList
2 : |  decl_scope  | type: int, var: limit
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: bytes_read
7 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: SongList *, value: songList -> size
1 : |compare_scopes| type: SongList *, value: limit
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; } ] 
p_decls = [('unsigned int', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.IterationStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None)]
assigns = [('unsigned int', 'tlv8', '', '10')]
compares = []
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = []
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '', '', '']
decls = [('unsigned int', 'tlv8', None), ('int', 'socket', None), ('SongList *', 'songList', None), ('int', 'limit', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'ret', None), ('int', 'bytes_read', None), ('int', 'num_results', None)]
assigns = [('unsigned int', 'tlv8', '', '10'), ('int', 'ret', '', '0'), ('int', 'bytes_read', '', '0'), ('int', 'num_results', '', '0')]
compares = ['', '', '', '']
===> context { unsigned int tlv8 ; tlv8 = 10 ; cgc__terminate ( tlv8 ) ; }
ignore sibs: ['}', 'songList -> size ++ ;', '}', 'num_results -- ;', '}', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv8
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: SongList *, var: songList
3 : |  decl_scope  | type: int, var: limit
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ 1024 ]
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: bytes_read
8 : |  decl_scope  | type: int, var: num_results
0 : | assign_scope | type: unsigned int, value: 10
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: SongList *, value: songList -> size
1 : |compare_scopes| type: SongList *, value: limit
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; }
compound scope 1 : { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; }
compound scope 2 : { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } }
compound scope 3 : { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; }
compound scope 4 : { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 5 : { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }
compound scope 6 : { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }
compound scope 7 : { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }
compound scope 8 : { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }
compound scope 9 : { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }
compound scope 10 : { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }
compound scope 11 : { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }
compound scope 12 : { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }
compound scope 13 : { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }
compound scope 14 : { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }
compound scope 15 : { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }
compound scope 16 : { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }
len(compound_scope) : 17
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; } ] 
p_decls = [('char *', 'buffer', None), ('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', None), ('int', 'ret', None), ('Request', 'request', None)]
assigns = [('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } return buffer ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: Request, var: request
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv30', None), ('int', 'tlv29', None), ('void * *', 'tlv28', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv30', None), ('int', 'tlv29', None), ('void * *', 'tlv28', None), ('Request', 'request', None)]
assigns = [('cgc_size_t', 'tlv30', '', 'sizeof ( request ) + cgc_MIN_REQ_LEN'), ('int', 'tlv29', '', '0'), ('void * *', 'tlv28', '', '( void * * ) & buffer')]
compares = []
decls = [('cgc_size_t', 'tlv30', None), ('int', 'tlv29', None), ('void * *', 'tlv28', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'tlv30', '', 'sizeof ( request ) + cgc_MIN_REQ_LEN'), ('int', 'tlv29', '', '0'), ('void * *', 'tlv28', '', '( void * * ) & buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t tlv30 ; tlv30 = sizeof ( request ) + cgc_MIN_REQ_LEN ; int tlv29 ; tlv29 = 0 ; void * * tlv28 ; tlv28 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv30 , tlv29 , tlv28 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } }', '{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv30
1 : |  decl_scope  | type: int, var: tlv29
2 : |  decl_scope  | type: void * *, var: tlv28
3 : |  decl_scope  | type: Request, var: request
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: sizeof ( request ) + cgc_MIN_REQ_LEN
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void * *, value: ( void * * ) & buffer
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Request', 'request', None)]
assigns = []
compares = []
decls = [('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } }
ignore sibs: ['{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: Request, var: request
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: NULL
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; } ] 
p_decls = [('unsigned int', 'tlv31', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv31', None), ('Request', 'request', None)]
assigns = [('unsigned int', 'tlv31', '', '3')]
compares = []
decls = [('unsigned int', 'tlv31', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv31', '', '3'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv31', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv31', '', '3'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv31', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv31', '', '3'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv31 ; tlv31 = 3 ; cgc__terminate ( tlv31 ) ; }
ignore sibs: ['}', '{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv31
1 : |  decl_scope  | type: Request, var: request
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('Request', 'request', None)]
assigns = [('void *', 'tlv3', '', 'buffer'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'sizeof ( request ) + cgc_MIN_REQ_LEN')]
compares = []
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv3', '', 'buffer'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'sizeof ( request ) + cgc_MIN_REQ_LEN'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = sizeof ( request ) + cgc_MIN_REQ_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['{ char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: int, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: Request, var: request
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: buffer
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: sizeof ( request ) + cgc_MIN_REQ_LEN
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; } ] 
p_decls = [('char *', 'tlv5', None), ('const char *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv5', None), ('const char *', 'tlv4', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv5', '', 'buffer')]
compares = []
decls = [('char *', 'tlv5', None), ('const char *', 'tlv4', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv5', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv5 ; tlv5 = buffer ; const char * tlv4 = TERM_STR ; cgc_strcat ( tlv5 , tlv4 ) ; }
ignore sibs: ['{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv5
1 : |  decl_scope  | type: const char *, var: tlv4
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; } ] 
p_decls = [('char *', 'tlv7', None), ('const char *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv7', None), ('const char *', 'tlv6', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv7', '', 'buffer')]
compares = []
decls = [('char *', 'tlv7', None), ('const char *', 'tlv6', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv7', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = KEYVAL_DELIM ; cgc_strcat ( tlv7 , tlv6 ) ; }
ignore sibs: ['{ char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv7
1 : |  decl_scope  | type: const char *, var: tlv6
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; } ] 
p_decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv9', '', 'buffer')]
compares = []
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv9', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv9 ; tlv9 = buffer ; const char * tlv8 = request . term ; cgc_strcat ( tlv9 , tlv8 ) ; }
ignore sibs: ['{ char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }', '{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv9
1 : |  decl_scope  | type: const char *, var: tlv8
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; } ] 
p_decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv11', '', 'buffer')]
compares = []
decls = [('char *', 'tlv11', None), ('const char *', 'tlv10', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv11', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv11 ; tlv11 = buffer ; const char * tlv10 = PARAM_DELIM ; cgc_strcat ( tlv11 , tlv10 ) ; }
ignore sibs: ['{ char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }', '{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv11
1 : |  decl_scope  | type: const char *, var: tlv10
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; } ] 
p_decls = [('char *', 'tlv13', None), ('const char *', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv13', None), ('const char *', 'tlv12', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv13', '', 'buffer')]
compares = []
decls = [('char *', 'tlv13', None), ('const char *', 'tlv12', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv13', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv13 ; tlv13 = buffer ; const char * tlv12 = ATTRIBUTE_STR ; cgc_strcat ( tlv13 , tlv12 ) ; }
ignore sibs: ['{ char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }', '{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv13
1 : |  decl_scope  | type: const char *, var: tlv12
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; } ] 
p_decls = [('char *', 'tlv15', None), ('const char *', 'tlv14', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv15', None), ('const char *', 'tlv14', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv15', '', 'buffer')]
compares = []
decls = [('char *', 'tlv15', None), ('const char *', 'tlv14', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv15', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv15 ; tlv15 = buffer ; const char * tlv14 = KEYVAL_DELIM ; cgc_strcat ( tlv15 , tlv14 ) ; }
ignore sibs: ['{ char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }', '{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv15
1 : |  decl_scope  | type: const char *, var: tlv14
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; } ] 
p_decls = [('char *', 'tlv17', None), ('const char *', 'tlv16', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv17', None), ('const char *', 'tlv16', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv17', '', 'buffer')]
compares = []
decls = [('char *', 'tlv17', None), ('const char *', 'tlv16', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv17', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv17 ; tlv17 = buffer ; const char * tlv16 = request . attribute ; cgc_strcat ( tlv17 , tlv16 ) ; }
ignore sibs: ['{ char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }', '{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv17
1 : |  decl_scope  | type: const char *, var: tlv16
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; } ] 
p_decls = [('char *', 'tlv19', None), ('const char *', 'tlv18', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv19', None), ('const char *', 'tlv18', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv19', '', 'buffer')]
compares = []
decls = [('char *', 'tlv19', None), ('const char *', 'tlv18', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv19', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv19 ; tlv19 = buffer ; const char * tlv18 = PARAM_DELIM ; cgc_strcat ( tlv19 , tlv18 ) ; }
ignore sibs: ['{ char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }', '{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv19
1 : |  decl_scope  | type: const char *, var: tlv18
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; } ] 
p_decls = [('char *', 'tlv21', None), ('const char *', 'tlv20', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv21', None), ('const char *', 'tlv20', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv21', '', 'buffer')]
compares = []
decls = [('char *', 'tlv21', None), ('const char *', 'tlv20', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv21', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv21 ; tlv21 = buffer ; const char * tlv20 = LIMIT_STR ; cgc_strcat ( tlv21 , tlv20 ) ; }
ignore sibs: ['{ char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }', '{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv21
1 : |  decl_scope  | type: const char *, var: tlv20
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; } ] 
p_decls = [('char *', 'tlv23', None), ('const char *', 'tlv22', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv23', None), ('const char *', 'tlv22', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv23', '', 'buffer')]
compares = []
decls = [('char *', 'tlv23', None), ('const char *', 'tlv22', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv23', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv23 ; tlv23 = buffer ; const char * tlv22 = KEYVAL_DELIM ; cgc_strcat ( tlv23 , tlv22 ) ; }
ignore sibs: ['{ char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }', '{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv23
1 : |  decl_scope  | type: const char *, var: tlv22
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; } ] 
p_decls = [('char *', 'tlv25', None), ('const char *', 'tlv24', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv25', None), ('const char *', 'tlv24', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv25', '', 'buffer')]
compares = []
decls = [('char *', 'tlv25', None), ('const char *', 'tlv24', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv25', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv25 ; tlv25 = buffer ; const char * tlv24 = request . limit ; cgc_strcat ( tlv25 , tlv24 ) ; }
ignore sibs: ['{ char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }', 'return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv25
1 : |  decl_scope  | type: const char *, var: tlv24
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; } ] 
p_decls = [('char *', 'tlv27', None), ('const char *', 'tlv26', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv27', None), ('const char *', 'tlv26', None), ('Request', 'request', None)]
assigns = [('char *', 'tlv27', '', 'buffer')]
compares = []
decls = [('char *', 'tlv27', None), ('const char *', 'tlv26', None), ('Request', 'request', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv27', '', 'buffer'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv27 ; tlv27 = buffer ; const char * tlv26 = EOL_STR ; cgc_strcat ( tlv27 , tlv26 ) ; }
ignore sibs: ['return buffer ;', '}']
0 : |  decl_scope  | type: char *, var: tlv27
1 : |  decl_scope  | type: const char *, var: tlv26
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: int, value: 0
=======END=======
compound scope 0 : { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; }
compound scope 1 : { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } }
compound scope 3 : { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; }
compound scope 4 : { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
compound scope 5 : { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; } ] 
p_decls = [('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None), ('unsigned int', 'max', None)]
assigns = [('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )'), ('unsigned int', 'index', '', 'index % max')]
compares = []
===> context { cgc_size_t bytes_written ; bytes_written = 0 ; unsigned int index ; index = 0 ; int ret ; ret = 0 ; { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( index ) ; if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } index = index % max ; return index ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: bytes_written
1 : |  decl_scope  | type: unsigned int, var: index
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: unsigned long, var: tlv_size_0
4 : |  decl_scope  | type: unsigned int, var: max
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: unsigned long, value: sizeof ( index )
4 : | assign_scope | type: unsigned int, value: index % max
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('unsigned int', 'max', None)]
assigns = [('void *', 'tlv3', '', '& index'), ('cgc_size_t', 'tlv2', '', 'sizeof ( index )'), ('cgc_size_t *', 'tlv1', '', '& bytes_written')]
compares = []
decls = [('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv3', '', '& index'), ('cgc_size_t', 'tlv2', '', 'sizeof ( index )'), ('cgc_size_t *', 'tlv1', '', '& bytes_written'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv3 ; tlv3 = & index ; cgc_size_t tlv2 ; tlv2 = sizeof ( index ) ; cgc_size_t * tlv1 ; tlv1 = & bytes_written ; ret = cgc_random ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } }', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( index ) ;', 'if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }', 'index = index % max ;', 'return index ;', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: cgc_size_t, var: tlv2
2 : |  decl_scope  | type: cgc_size_t *, var: tlv1
3 : |  decl_scope  | type: unsigned int, var: max
4 : |  decl_scope  | type: cgc_size_t, var: bytes_written
5 : |  decl_scope  | type: unsigned int, var: index
6 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: & index
1 : | assign_scope | type: cgc_size_t, value: sizeof ( index )
2 : | assign_scope | type: cgc_size_t *, value: & bytes_written
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: unsigned int, value: 0
5 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'max', None)]
assigns = []
compares = []
decls = [('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } }
ignore sibs: ['unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( index ) ;', 'if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }', 'index = index % max ;', 'return index ;', '}']
0 : |  decl_scope  | type: unsigned int, var: max
1 : |  decl_scope  | type: cgc_size_t, var: bytes_written
2 : |  decl_scope  | type: unsigned int, var: index
3 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; } ] 
p_decls = [('unsigned int', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv4', None), ('unsigned int', 'max', None)]
assigns = [('unsigned int', 'tlv4', '', '1')]
compares = []
decls = [('unsigned int', 'tlv4', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv4', '', '1'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv4', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv4', '', '1'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv4', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv4', '', '1'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv4 ; tlv4 = 1 ; cgc__terminate ( tlv4 ) ; }
ignore sibs: ['}', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( index ) ;', 'if ( bytes_written != tlv_size_0 ) { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }', 'index = index % max ;', 'return index ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv4
1 : |  decl_scope  | type: unsigned int, var: max
2 : |  decl_scope  | type: cgc_size_t, var: bytes_written
3 : |  decl_scope  | type: unsigned int, var: index
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 1
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'max', None)]
assigns = []
compares = []
decls = [('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )')]
compares = []
decls = [('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )')]
compares = ['', '']
===> context { { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['index = index % max ;', 'return index ;', '}']
0 : |  decl_scope  | type: unsigned int, var: max
1 : |  decl_scope  | type: cgc_size_t, var: bytes_written
2 : |  decl_scope  | type: unsigned int, var: index
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: unsigned long, value: sizeof ( index )
0 : |compare_scopes| type: cgc_size_t, value: bytes_written
1 : |compare_scopes| type: cgc_size_t, value: tlv_size_0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('unsigned int', 'max', None)]
assigns = [('unsigned int', 'tlv5', '', '2')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )')]
compares = ['', '']
decls = [('unsigned int', 'tlv5', None), ('unsigned int', 'max', None), ('cgc_size_t', 'bytes_written', None), ('unsigned int', 'index', None), ('int', 'ret', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('unsigned int', 'tlv5', '', '2'), ('cgc_size_t', 'bytes_written', '', '0'), ('unsigned int', 'index', '', '0'), ('int', 'ret', '', '0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( index )')]
compares = ['', '']
===> context { unsigned int tlv5 ; tlv5 = 2 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'index = index % max ;', 'return index ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: unsigned int, var: max
2 : |  decl_scope  | type: cgc_size_t, var: bytes_written
3 : |  decl_scope  | type: unsigned int, var: index
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: unsigned int, value: 2
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: unsigned long, value: sizeof ( index )
0 : |compare_scopes| type: cgc_size_t, value: bytes_written
1 : |compare_scopes| type: cgc_size_t, value: tlv_size_0
=======END=======
compound scope 0 : { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } }
compound scope 1 : { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; }
compound scope 2 : { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 3 : { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } } ] 
p_decls = [('int', 'index', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'index', None), ('Request *', 'request', None)]
assigns = [('int', 'index', '', '0')]
compares = []
===> context { int index ; index = 0 ; { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: int, var: index
1 : |  decl_scope  | type: Request *, var: request
0 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; } ] 
p_decls = [('unsigned int', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv4', None), ('Request *', 'request', None)]
assigns = [('unsigned int', 'tlv4', '', 'ATTR_NUM')]
compares = []
decls = [('unsigned int', 'tlv4', None), ('Request *', 'request', None), ('int', 'index', None)]
assigns = [('unsigned int', 'tlv4', '', 'ATTR_NUM'), ('int', 'index', '', '0')]
compares = []
===> context { unsigned int tlv4 ; tlv4 = ATTR_NUM ; index = cgc_getRandomNumber ( tlv4 ) ; }
ignore sibs: ['{ void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv4
1 : |  decl_scope  | type: Request *, var: request
2 : |  decl_scope  | type: int, var: index
0 : | assign_scope | type: unsigned int, value: ATTR_NUM
1 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('Request *', 'request', None)]
assigns = [('void *', 'tlv3', '', 'request -> attribute'), ('void *', 'tlv2', '', 'attributes [ index ]')]
compares = []
decls = [('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('Request *', 'request', None), ('int', 'index', None)]
assigns = [('void *', 'tlv3', '', 'request -> attribute'), ('void *', 'tlv2', '', 'attributes [ index ]'), ('int', 'index', '', '0')]
compares = []
===> context { void * tlv3 ; tlv3 = request -> attribute ; void * tlv2 ; tlv2 = attributes [ index ] ; cgc_size_t tlv1 ; { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: void *, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: Request *, var: request
4 : |  decl_scope  | type: int, var: index
0 : | assign_scope | type: void *, value: request -> attribute
1 : | assign_scope | type: void *, value: attributes [ index ]
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv5', None), ('Request *', 'request', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )')]
compares = []
decls = [('const char *', 'tlv5', None), ('Request *', 'request', None), ('int', 'index', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )'), ('int', 'index', '', '0')]
compares = []
decls = [('const char *', 'tlv5', None), ('Request *', 'request', None), ('int', 'index', None), ('void *', 'tlv3', None), ('void *', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
assigns = [('cgc_size_t', 'tlv1', '', 'cgc_strlen ( tlv5 )'), ('int', 'index', '', '0'), ('void *', 'tlv3', '', 'request -> attribute'), ('void *', 'tlv2', '', 'attributes [ index ]')]
compares = []
===> context { const char * tlv5 = attributes [ index ] ; tlv1 = cgc_strlen ( tlv5 ) ; }
ignore sibs: ['cgc_memcpy ( tlv3 , tlv2 , tlv1 ) ;', '}', '}']
0 : |  decl_scope  | type: const char *, var: tlv5
1 : |  decl_scope  | type: Request *, var: request
2 : |  decl_scope  | type: int, var: index
3 : |  decl_scope  | type: void *, var: tlv3
4 : |  decl_scope  | type: void *, var: tlv2
5 : |  decl_scope  | type: cgc_size_t, var: tlv1
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv5 )
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void *, value: request -> attribute
3 : | assign_scope | type: void *, value: attributes [ index ]
=======END=======
compound scope 0 : { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; }
compound scope 1 : { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } }
compound scope 2 : { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; }
compound scope 3 : { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; }
compound scope 4 : { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }
compound scope 5 : { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; } ] 
p_decls = [('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('Request *', 'request', None)]
assigns = [('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('UNDEF', 'request -> term ', '[ size ]', "'\\0'")]
compares = []
===> context { unsigned int size ; size = 0 ; unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; while ( size == 0 ) { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } request -> term [ size ] = '\0' ; }
ignore sibs: []
0 : |  decl_scope  | type: unsigned int, var: size
1 : |  decl_scope  | type: unsigned int, var: charset_size
2 : |  decl_scope  | type: int, var: index
3 : |  decl_scope  | type: Request *, var: request
0 : | assign_scope | type: unsigned int, value: 0
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Request *', 'request', None)]
assigns = []
compares = []
decls = [('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = []
decls = [('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } }
ignore sibs: ['{ const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; }', 'for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }', "request -> term [ size ] = '\\0' ;", '}']
0 : |  decl_scope  | type: Request *, var: request
1 : |  decl_scope  | type: unsigned int, var: size
2 : |  decl_scope  | type: unsigned int, var: charset_size
3 : |  decl_scope  | type: int, var: index
0 : | assign_scope | type: unsigned int, value: 0
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: unsigned int, value: size
1 : |compare_scopes| type: unsigned int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; } ] 
p_decls = [('unsigned int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv2', None), ('Request *', 'request', None)]
assigns = [('unsigned int', 'tlv2', '', 'RESULT_VALUE_SIZE')]
compares = []
decls = [('unsigned int', 'tlv2', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'tlv2', '', 'RESULT_VALUE_SIZE'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = []
decls = [('unsigned int', 'tlv2', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'tlv2', '', 'RESULT_VALUE_SIZE'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv2', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'tlv2', '', 'RESULT_VALUE_SIZE'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
===> context { unsigned int tlv2 ; tlv2 = RESULT_VALUE_SIZE ; size = cgc_getRandomNumber ( tlv2 ) ; }
ignore sibs: ['}', '{ const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; }', 'for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }', "request -> term [ size ] = '\\0' ;", '}']
0 : |  decl_scope  | type: unsigned int, var: tlv2
1 : |  decl_scope  | type: Request *, var: request
2 : |  decl_scope  | type: unsigned int, var: size
3 : |  decl_scope  | type: unsigned int, var: charset_size
4 : |  decl_scope  | type: int, var: index
0 : | assign_scope | type: unsigned int, value: RESULT_VALUE_SIZE
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: unsigned int, value: size
1 : |compare_scopes| type: unsigned int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; } ] 
p_decls = [('const char *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv1', None), ('Request *', 'request', None)]
assigns = [('unsigned int', 'charset_size', '', 'cgc_strlen ( tlv1 )')]
compares = []
decls = [('const char *', 'tlv1', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'charset_size', '', 'cgc_strlen ( tlv1 )'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = []
===> context { const char * tlv1 = cgc_charset ; charset_size = cgc_strlen ( tlv1 ) ; }
ignore sibs: ['for ( index = 0 ; index < size ; index ++ ) { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }', "request -> term [ size ] = '\\0' ;", '}']
0 : |  decl_scope  | type: const char *, var: tlv1
1 : |  decl_scope  | type: Request *, var: request
2 : |  decl_scope  | type: unsigned int, var: size
3 : |  decl_scope  | type: unsigned int, var: charset_size
4 : |  decl_scope  | type: int, var: index
0 : | assign_scope | type: unsigned int, value: cgc_strlen ( tlv1 )
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; } ] 
p_decls = [('int', 'letter', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'letter', None), ('Request *', 'request', None)]
assigns = [('UNDEF', 'request -> term ', '[ index ]', 'cgc_charset [ letter ]')]
compares = []
decls = [('int', 'letter', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('UNDEF', 'request -> term ', '[ index ]', 'cgc_charset [ letter ]'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = []
decls = [('int', 'letter', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('UNDEF', 'request -> term ', '[ index ]', 'cgc_charset [ letter ]'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
===> context { int letter ; { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } request -> term [ index ] = cgc_charset [ letter ] ; }
ignore sibs: ["request -> term [ size ] = '\\0' ;", '}']
0 : |  decl_scope  | type: int, var: letter
1 : |  decl_scope  | type: Request *, var: request
2 : |  decl_scope  | type: unsigned int, var: size
3 : |  decl_scope  | type: unsigned int, var: charset_size
4 : |  decl_scope  | type: int, var: index
0 : | assign_scope | type: UNDEF, value: cgc_charset [ letter ]
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: index
1 : |compare_scopes| type: int, value: size
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; } ] 
p_decls = [('unsigned int', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv3', None), ('Request *', 'request', None)]
assigns = [('unsigned int', 'tlv3', '', 'charset_size')]
compares = []
decls = [('unsigned int', 'tlv3', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'tlv3', '', 'charset_size'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0')]
compares = []
decls = [('unsigned int', 'tlv3', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None)]
assigns = [('unsigned int', 'tlv3', '', 'charset_size'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv3', None), ('Request *', 'request', None), ('unsigned int', 'size', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'letter', None)]
assigns = [('unsigned int', 'tlv3', '', 'charset_size'), ('unsigned int', 'size', '', '0'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
===> context { unsigned int tlv3 ; tlv3 = charset_size ; letter = cgc_getRandomNumber ( tlv3 ) ; }
ignore sibs: ['request -> term [ index ] = cgc_charset [ letter ] ;', '}', "request -> term [ size ] = '\\0' ;", '}']
0 : |  decl_scope  | type: unsigned int, var: tlv3
1 : |  decl_scope  | type: Request *, var: request
2 : |  decl_scope  | type: unsigned int, var: size
3 : |  decl_scope  | type: unsigned int, var: charset_size
4 : |  decl_scope  | type: int, var: index
5 : |  decl_scope  | type: int, var: letter
0 : | assign_scope | type: unsigned int, value: charset_size
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: index
1 : |compare_scopes| type: int, value: size
=======END=======
compound scope 0 : { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } }
compound scope 1 : { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Request *', 'request', None)]
assigns = []
compares = []
===> context { { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } cgc_getRandomTerm ( request ) ; cgc_getRandomAttribute ( request ) ; { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } }
ignore sibs: []
0 : |  decl_scope  | type: Request *, var: request
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('Request *', 'request', None)]
assigns = [('void *', 'tlv3', '', 'request'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'REQUEST_SIZE')]
compares = []
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('Request *', 'request', None)]
assigns = [('void *', 'tlv3', '', 'request'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'REQUEST_SIZE')]
compares = []
===> context { void * tlv3 ; tlv3 = request ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = REQUEST_SIZE ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['cgc_getRandomTerm ( request ) ;', 'cgc_getRandomAttribute ( request ) ;', '{ void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: int, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: Request *, var: request
0 : | assign_scope | type: void *, value: request
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: REQUEST_SIZE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; } ] 
p_decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('Request *', 'request', None)]
assigns = [('void *', 'tlv6', '', 'request -> limit'), ('void *', 'tlv5', '', 'RESULT_LIMIT_STR'), ('cgc_size_t', 'tlv4', '', 'sizeof ( RESULT_LIMIT_STR )')]
compares = []
decls = [('void *', 'tlv6', None), ('void *', 'tlv5', None), ('cgc_size_t', 'tlv4', None), ('Request *', 'request', None)]
assigns = [('void *', 'tlv6', '', 'request -> limit'), ('void *', 'tlv5', '', 'RESULT_LIMIT_STR'), ('cgc_size_t', 'tlv4', '', 'sizeof ( RESULT_LIMIT_STR )')]
compares = []
===> context { void * tlv6 ; tlv6 = request -> limit ; void * tlv5 ; tlv5 = RESULT_LIMIT_STR ; cgc_size_t tlv4 ; tlv4 = sizeof ( RESULT_LIMIT_STR ) ; cgc_memcpy ( tlv6 , tlv5 , tlv4 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: void *, var: tlv6
1 : |  decl_scope  | type: void *, var: tlv5
2 : |  decl_scope  | type: cgc_size_t, var: tlv4
3 : |  decl_scope  | type: Request *, var: request
0 : | assign_scope | type: void *, value: request -> limit
1 : | assign_scope | type: void *, value: RESULT_LIMIT_STR
2 : | assign_scope | type: cgc_size_t, value: sizeof ( RESULT_LIMIT_STR )
=======END=======
compound scope 0 : { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; }
compound scope 1 : { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }
compound scope 2 : { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } }
compound scope 3 : { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; }
compound scope 4 : { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 5 : { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }
compound scope 6 : { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }
compound scope 7 : { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; }
len(compound_scope) : 8
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; } ] 
p_decls = [('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None), ('char * *', 'gift_card', None)]
assigns = [('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0'), ('UNDEF', '( * gift_card ) ', '[ GIFT_CARD_LEN ]', "'\\0'")]
compares = []
===> context { unsigned int charset_size ; charset_size = 0 ; int index ; index = 0 ; int section ; section = 0 ; int ret ; ret = 0 ; { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ( * gift_card ) [ GIFT_CARD_LEN ] = '\0' ; return GIFT_CARD_LEN + 1 ; }
ignore sibs: []
0 : |  decl_scope  | type: unsigned int, var: charset_size
1 : |  decl_scope  | type: int, var: index
2 : |  decl_scope  | type: int, var: section
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char * *, var: gift_card
0 : | assign_scope | type: unsigned int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv6', None), ('int', 'tlv5', None), ('void * *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv6', None), ('int', 'tlv5', None), ('void * *', 'tlv4', None), ('char * *', 'gift_card', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'GIFT_CARD_LEN + 1'), ('int', 'tlv5', '', '0'), ('void * *', 'tlv4', '', '( void * * ) gift_card')]
compares = []
decls = [('cgc_size_t', 'tlv6', None), ('int', 'tlv5', None), ('void * *', 'tlv4', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'GIFT_CARD_LEN + 1'), ('int', 'tlv5', '', '0'), ('void * *', 'tlv4', '', '( void * * ) gift_card'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t tlv6 ; tlv6 = GIFT_CARD_LEN + 1 ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) gift_card ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } }', '{ void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }', 'for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }', "( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv6
1 : |  decl_scope  | type: int, var: tlv5
2 : |  decl_scope  | type: void * *, var: tlv4
3 : |  decl_scope  | type: char * *, var: gift_card
4 : |  decl_scope  | type: unsigned int, var: charset_size
5 : |  decl_scope  | type: int, var: index
6 : |  decl_scope  | type: int, var: section
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: GIFT_CARD_LEN + 1
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void * *, value: ( void * * ) gift_card
3 : | assign_scope | type: unsigned int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'gift_card', None)]
assigns = []
compares = []
decls = [('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } }
ignore sibs: ['{ void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }', 'for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }', "( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: char * *, var: gift_card
1 : |  decl_scope  | type: unsigned int, var: charset_size
2 : |  decl_scope  | type: int, var: index
3 : |  decl_scope  | type: int, var: section
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; } ] 
p_decls = [('unsigned int', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv8', None), ('char * *', 'gift_card', None)]
assigns = [('unsigned int', 'tlv8', '', '3')]
compares = []
decls = [('unsigned int', 'tlv8', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv8', '', '3'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv8', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv8', '', '3'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv8', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv8', '', '3'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv8 ; tlv8 = 3 ; cgc__terminate ( tlv8 ) ; }
ignore sibs: ['}', '{ void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }', 'for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }', "( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv8
1 : |  decl_scope  | type: char * *, var: gift_card
2 : |  decl_scope  | type: unsigned int, var: charset_size
3 : |  decl_scope  | type: int, var: index
4 : |  decl_scope  | type: int, var: section
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('char * *', 'gift_card', None)]
assigns = [('void *', 'tlv3', '', '* gift_card'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'GIFT_CARD_LEN')]
compares = []
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv3', '', '* gift_card'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'GIFT_CARD_LEN'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv3 ; tlv3 = * gift_card ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = GIFT_CARD_LEN ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['{ const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }', 'for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }', "( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: int, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: char * *, var: gift_card
4 : |  decl_scope  | type: unsigned int, var: charset_size
5 : |  decl_scope  | type: int, var: index
6 : |  decl_scope  | type: int, var: section
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: * gift_card
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: GIFT_CARD_LEN
3 : | assign_scope | type: unsigned int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; } ] 
p_decls = [('const char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv7', None), ('char * *', 'gift_card', None)]
assigns = [('unsigned int', 'charset_size', '', 'cgc_strlen ( tlv7 )')]
compares = []
decls = [('const char *', 'tlv7', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'charset_size', '', 'cgc_strlen ( tlv7 )'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { const char * tlv7 = cgc_charset ; charset_size = cgc_strlen ( tlv7 ) ; }
ignore sibs: ['for ( index = 0 ; index < GIFT_CARD_LEN ; index ++ ) { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }', "( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv7
1 : |  decl_scope  | type: char * *, var: gift_card
2 : |  decl_scope  | type: unsigned int, var: charset_size
3 : |  decl_scope  | type: int, var: index
4 : |  decl_scope  | type: int, var: section
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: cgc_strlen ( tlv7 )
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; } ] 
p_decls = [('int', 'letter', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'letter', None), ('char * *', 'gift_card', None)]
assigns = [('UNDEF', '( * gift_card ) ', '[ index ]', 'cgc_charset [ letter ]')]
compares = []
decls = [('int', 'letter', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('UNDEF', '( * gift_card ) ', '[ index ]', 'cgc_charset [ letter ]'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('int', 'letter', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('UNDEF', '( * gift_card ) ', '[ index ]', 'cgc_charset [ letter ]'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
===> context { int letter ; { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ( * gift_card ) [ index ] = cgc_charset [ letter ] ; }
ignore sibs: ["( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: int, var: letter
1 : |  decl_scope  | type: char * *, var: gift_card
2 : |  decl_scope  | type: unsigned int, var: charset_size
3 : |  decl_scope  | type: int, var: index
4 : |  decl_scope  | type: int, var: section
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: UNDEF, value: cgc_charset [ letter ]
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: index
1 : |compare_scopes| type: int, value: GIFT_CARD_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; } ] 
p_decls = [('unsigned int', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv9', None), ('char * *', 'gift_card', None)]
assigns = [('unsigned int', 'tlv9', '', 'charset_size')]
compares = []
decls = [('unsigned int', 'tlv9', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv9', '', 'charset_size'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv9', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv9', '', 'charset_size'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv9', None), ('char * *', 'gift_card', None), ('unsigned int', 'charset_size', None), ('int', 'index', None), ('int', 'section', None), ('int', 'ret', None), ('int', 'letter', None)]
assigns = [('unsigned int', 'tlv9', '', 'charset_size'), ('unsigned int', 'charset_size', '', '0'), ('int', 'index', '', '0'), ('int', 'section', '', '0'), ('int', 'ret', '', '0'), ('int', 'index', '', '0')]
compares = ['', '']
===> context { unsigned int tlv9 ; tlv9 = charset_size ; letter = cgc_getRandomNumber ( tlv9 ) ; }
ignore sibs: ['( * gift_card ) [ index ] = cgc_charset [ letter ] ;', '}', "( * gift_card ) [ GIFT_CARD_LEN ] = '\\0' ;", 'return GIFT_CARD_LEN + 1 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv9
1 : |  decl_scope  | type: char * *, var: gift_card
2 : |  decl_scope  | type: unsigned int, var: charset_size
3 : |  decl_scope  | type: int, var: index
4 : |  decl_scope  | type: int, var: section
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: letter
0 : | assign_scope | type: unsigned int, value: charset_size
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: index
1 : |compare_scopes| type: int, value: GIFT_CARD_LEN
=======END=======
compound scope 0 : { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; }
compound scope 1 : { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; }
compound scope 2 : { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; }
compound scope 3 : { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 4 : { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; }
compound scope 5 : { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; }
compound scope 6 : { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }
compound scope 7 : { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; }
compound scope 8 : { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }
compound scope 9 : { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; }
compound scope 10 : { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }
compound scope 11 : { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; }
len(compound_scope) : 12
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; } ] 
p_decls = [('int', 'ret', None), ('char', 'price', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('char', 'price', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
===> context { int ret ; ret = 0 ; char price ; price = 0 ; { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } return LOW_BALANCE ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: char, var: price
2 : |  decl_scope  | type: int, var: socket
3 : |  decl_scope  | type: Song *, var: selectedSong
4 : |  decl_scope  | type: SongList *, var: mySongList
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: char, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; } ] 
p_decls = [('const char *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv1', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv1', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
===> context { const char * tlv1 = selectedSong -> price ; price = cgc_str2int ( tlv1 ) ; }
ignore sibs: ['if ( mySongList -> balance >= price ) { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; }', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv1
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Song *, var: selectedSong
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: char, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('UNDEF', 'mySongList -> balance', '', 'price')]
compares = []
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('UNDEF', 'mySongList -> balance', '', 'price'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('UNDEF', 'mySongList -> balance', '', 'price'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
===> context { mySongList -> balance -= price ; mySongList -> size ++ ; { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } return SUCCESS ; }
ignore sibs: ['return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: Song *, var: selectedSong
2 : |  decl_scope  | type: SongList *, var: mySongList
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: UNDEF, value: price
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('void *', 'tlv4', '', '& mySongList -> songs [ mySongList -> size - 1 ]'), ('void *', 'tlv3', '', 'selectedSong'), ('cgc_size_t', 'tlv2', '', 'RESULT_VALUE_SIZE * 3')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('void *', 'tlv4', '', '& mySongList -> songs [ mySongList -> size - 1 ]'), ('void *', 'tlv3', '', 'selectedSong'), ('cgc_size_t', 'tlv2', '', 'RESULT_VALUE_SIZE * 3'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('void *', 'tlv4', '', '& mySongList -> songs [ mySongList -> size - 1 ]'), ('void *', 'tlv3', '', 'selectedSong'), ('cgc_size_t', 'tlv2', '', 'RESULT_VALUE_SIZE * 3'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('void *', 'tlv4', '', '& mySongList -> songs [ mySongList -> size - 1 ]'), ('void *', 'tlv3', '', 'selectedSong'), ('cgc_size_t', 'tlv2', '', 'RESULT_VALUE_SIZE * 3'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
===> context { void * tlv4 ; tlv4 = & mySongList -> songs [ mySongList -> size - 1 ] ; void * tlv3 ; tlv3 = selectedSong ; cgc_size_t tlv2 ; tlv2 = RESULT_VALUE_SIZE * 3 ; cgc_memcpy ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['{ int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }', '{ int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: void *, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: int, var: socket
4 : |  decl_scope  | type: Song *, var: selectedSong
5 : |  decl_scope  | type: SongList *, var: mySongList
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: void *, value: & mySongList -> songs [ mySongList -> size - 1 ]
1 : | assign_scope | type: void *, value: selectedSong
2 : | assign_scope | type: cgc_size_t, value: RESULT_VALUE_SIZE * 3
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: char, value: 0
5 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; } ] 
p_decls = [('int', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('int', 'tlv7', '', 'socket')]
compares = []
decls = [('int', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'tlv7', '', 'socket'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('int', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'tlv7', '', 'socket'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('int', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'tlv7', '', 'socket'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
===> context { int tlv7 ; tlv7 = socket ; const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ; cgc_size_t tlv5 ; { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }', '{ int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: int, var: tlv7
1 : |  decl_scope  | type: const char *, var: tlv6
2 : |  decl_scope  | type: cgc_size_t, var: tlv5
3 : |  decl_scope  | type: int, var: socket
4 : |  decl_scope  | type: Song *, var: selectedSong
5 : |  decl_scope  | type: SongList *, var: mySongList
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; } ] 
p_decls = [('const char *', 'tlv13', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv13', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv13 )')]
compares = []
decls = [('const char *', 'tlv13', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv13 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('const char *', 'tlv13', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv13 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv13', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv13 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
decls = [('const char *', 'tlv13', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None), ('int', 'tlv7', None), ('const char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
assigns = [('cgc_size_t', 'tlv5', '', 'cgc_strlen ( tlv13 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price'), ('int', 'tlv7', '', 'socket')]
compares = ['', '']
===> context { const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ; tlv5 = cgc_strlen ( tlv13 ) ; }
ignore sibs: ['ret = cgc_transmit_all ( tlv7 , tlv6 , tlv5 ) ;', '}', 'if ( ret != 0 ) { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }', '{ int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv13
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Song *, var: selectedSong
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: char, var: price
6 : |  decl_scope  | type: int, var: tlv7
7 : |  decl_scope  | type: const char *, var: tlv6
8 : |  decl_scope  | type: cgc_size_t, var: tlv5
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv13 )
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: UNDEF, value: price
4 : | assign_scope | type: int, value: socket
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '', '', '']
===> context { { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } }
ignore sibs: ['{ int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: Song *, var: selectedSong
2 : |  decl_scope  | type: SongList *, var: mySongList
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: char, value: 0
2 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; } ] 
p_decls = [('unsigned int', 'tlv11', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv11', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv11', '', '10')]
compares = []
decls = [('unsigned int', 'tlv11', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv11', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('unsigned int', 'tlv11', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv11', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv11', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv11', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
decls = [('unsigned int', 'tlv11', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv11', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '', '', '']
decls = [('unsigned int', 'tlv11', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv11', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '', '', '']
===> context { unsigned int tlv11 ; tlv11 = 10 ; cgc__terminate ( tlv11 ) ; }
ignore sibs: ['}', '{ int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv11
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Song *, var: selectedSong
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: unsigned int, value: 10
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; } ] 
p_decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None), ('cgc_size_t', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None), ('cgc_size_t', 'tlv8', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('int', 'tlv10', '', 'socket')]
compares = []
decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None), ('cgc_size_t', 'tlv8', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'tlv10', '', 'socket'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None), ('cgc_size_t', 'tlv8', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'tlv10', '', 'socket'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None), ('cgc_size_t', 'tlv8', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'tlv10', '', 'socket'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
===> context { int tlv10 ; tlv10 = socket ; const char tlv9 [ ] = "\n" ; cgc_size_t tlv8 ; { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: int, var: tlv10
1 : |  decl_scope  | type: const char *, var: tlv9
2 : |  decl_scope  | type: const char, var: tlv9 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv8
4 : |  decl_scope  | type: int, var: socket
5 : |  decl_scope  | type: Song *, var: selectedSong
6 : |  decl_scope  | type: SongList *, var: mySongList
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; } ] 
p_decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('cgc_size_t', 'tlv8', '', 'cgc_strlen ( tlv14 )')]
compares = []
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('cgc_size_t', 'tlv8', '', 'cgc_strlen ( tlv14 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('cgc_size_t', 'tlv8', '', 'cgc_strlen ( tlv14 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('cgc_size_t', 'tlv8', '', 'cgc_strlen ( tlv14 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None), ('int', 'tlv10', None), ('const char *', 'tlv9', ' [ ]'), ('const char', 'tlv9 [ ]', None), ('cgc_size_t', 'tlv8', None)]
assigns = [('cgc_size_t', 'tlv8', '', 'cgc_strlen ( tlv14 )'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price'), ('int', 'tlv10', '', 'socket')]
compares = ['', '']
===> context { const char tlv14 [ ] = "\n" ; tlv8 = cgc_strlen ( tlv14 ) ; }
ignore sibs: ['ret = cgc_transmit_all ( tlv10 , tlv9 , tlv8 ) ;', '}', 'if ( ret != 0 ) { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv14
1 : |  decl_scope  | type: const char, var: tlv14 [ ]
2 : |  decl_scope  | type: int, var: socket
3 : |  decl_scope  | type: Song *, var: selectedSong
4 : |  decl_scope  | type: SongList *, var: mySongList
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: char, var: price
7 : |  decl_scope  | type: int, var: tlv10
8 : |  decl_scope  | type: const char *, var: tlv9
9 : |  decl_scope  | type: const char, var: tlv9 [ ]
10 : |  decl_scope  | type: cgc_size_t, var: tlv8
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv14 )
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: UNDEF, value: price
4 : | assign_scope | type: int, value: socket
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
decls = [('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '', '', '']
===> context { { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } }
ignore sibs: ['return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: Song *, var: selectedSong
2 : |  decl_scope  | type: SongList *, var: mySongList
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: char, value: 0
2 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; } ] 
p_decls = [('unsigned int', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv12', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv12', '', '10')]
compares = []
decls = [('unsigned int', 'tlv12', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv12', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = []
decls = [('unsigned int', 'tlv12', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv12', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv12', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv12', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '']
decls = [('unsigned int', 'tlv12', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv12', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '', '', '']
decls = [('unsigned int', 'tlv12', None), ('int', 'socket', None), ('Song *', 'selectedSong', None), ('SongList *', 'mySongList', None), ('int', 'ret', None), ('char', 'price', None)]
assigns = [('unsigned int', 'tlv12', '', '10'), ('int', 'ret', '', '0'), ('char', 'price', '', '0'), ('UNDEF', 'mySongList -> balance', '', 'price')]
compares = ['', '', '', '']
===> context { unsigned int tlv12 ; tlv12 = 10 ; cgc__terminate ( tlv12 ) ; }
ignore sibs: ['}', 'return SUCCESS ;', '}', 'return LOW_BALANCE ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv12
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Song *, var: selectedSong
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: char, var: price
0 : | assign_scope | type: unsigned int, value: 10
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: UNDEF, value: price
0 : |compare_scopes| type: SongList *, value: mySongList -> balance
1 : |compare_scopes| type: SongList *, value: price
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; }
compound scope 1 : { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; }
compound scope 2 : { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 3 : { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; }
compound scope 4 : { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }
compound scope 5 : { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; } ] 
p_decls = [('int', 'ret', None), ('char *', 'search_string', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('char *', 'search_string', None), ('int', 'socket', None), ('Request', 'request', None)]
assigns = [('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = []
===> context { int ret ; ret = 0 ; char * search_string ; search_string = NULL ; { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: char *, var: search_string
2 : |  decl_scope  | type: int, var: socket
3 : |  decl_scope  | type: Request, var: request
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; } ] 
p_decls = [('Request', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Request', 'tlv1', None), ('int', 'socket', None), ('Request', 'request', None)]
assigns = [('Request', 'tlv1', '', 'request')]
compares = []
decls = [('Request', 'tlv1', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('Request', 'tlv1', '', 'request'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = []
===> context { Request tlv1 ; tlv1 = request ; search_string = cgc_createSearchString ( tlv1 ) ; }
ignore sibs: ['{ int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: Request, var: tlv1
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char *, var: search_string
0 : | assign_scope | type: Request, value: request
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('Request', 'request', None)]
assigns = [('int', 'tlv4', '', 'socket')]
compares = []
decls = [('int', 'tlv4', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('int', 'tlv4', '', 'socket'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = []
===> context { int tlv4 ; tlv4 = socket ; const char * tlv3 = search_string ; cgc_size_t tlv2 ; { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: const char *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: int, var: socket
4 : |  decl_scope  | type: Request, var: request
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: char *, var: search_string
0 : | assign_scope | type: int, value: socket
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; } ] 
p_decls = [('const char *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('int', 'socket', None), ('Request', 'request', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )')]
compares = []
decls = [('const char *', 'tlv6', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = []
decls = [('const char *', 'tlv6', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None), ('int', 'tlv4', None), ('const char *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
assigns = [('cgc_size_t', 'tlv2', '', 'cgc_strlen ( tlv6 )'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL'), ('int', 'tlv4', '', 'socket')]
compares = []
===> context { const char * tlv6 = search_string ; tlv2 = cgc_strlen ( tlv6 ) ; }
ignore sibs: ['ret = cgc_transmit_all ( tlv4 , tlv3 , tlv2 ) ;', '}', 'if ( ret != 0 ) { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char *, var: search_string
5 : |  decl_scope  | type: int, var: tlv4
6 : |  decl_scope  | type: const char *, var: tlv3
7 : |  decl_scope  | type: cgc_size_t, var: tlv2
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv6 )
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: socket
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'socket', None), ('Request', 'request', None)]
assigns = []
compares = []
decls = [('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = []
decls = [('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = ['', '']
===> context { { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: int, var: socket
1 : |  decl_scope  | type: Request, var: request
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: char *, var: search_string
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: char *, value: NULL
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('Request', 'request', None)]
assigns = [('unsigned int', 'tlv5', '', '4')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('unsigned int', 'tlv5', '', '4'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('unsigned int', 'tlv5', '', '4'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = ['', '']
decls = [('unsigned int', 'tlv5', None), ('int', 'socket', None), ('Request', 'request', None), ('int', 'ret', None), ('char *', 'search_string', None)]
assigns = [('unsigned int', 'tlv5', '', '4'), ('int', 'ret', '', '0'), ('char *', 'search_string', '', 'NULL')]
compares = ['', '']
===> context { unsigned int tlv5 ; tlv5 = 4 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: int, var: socket
2 : |  decl_scope  | type: Request, var: request
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char *, var: search_string
0 : | assign_scope | type: unsigned int, value: 4
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char *, value: NULL
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; }
compound scope 1 : { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; }
compound scope 2 : { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; }
compound scope 3 : { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } }
compound scope 4 : { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; }
compound scope 5 : { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 6 : { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }
compound scope 7 : { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }
compound scope 8 : { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }
compound scope 9 : { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }
compound scope 10 : { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }
compound scope 11 : { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; }
compound scope 12 : { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }
compound scope 13 : { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; }
compound scope 14 : { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }
compound scope 15 : { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; }
compound scope 16 : { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }
compound scope 17 : { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }
compound scope 18 : { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; }
compound scope 19 : { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }
compound scope 20 : { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }
compound scope 21 : { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }
compound scope 22 : { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; }
len(compound_scope) : 23
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; } ] 
p_decls = [('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None), ('SongList *', 'mySongList', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t size ; size = 0 ; char * gift_card ; gift_card = NULL ; char * buffer ; buffer = NULL ; int ret ; ret = 0 ; { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: size
1 : |  decl_scope  | type: char *, var: gift_card
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: SongList *, var: mySongList
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; } ] 
p_decls = [('char * *', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv10', None), ('SongList *', 'mySongList', None)]
assigns = [('char * *', 'tlv10', '', '& gift_card')]
compares = []
decls = [('char * *', 'tlv10', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char * *', 'tlv10', '', '& gift_card'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * * tlv10 ; tlv10 = & gift_card ; size = cgc_getRandomGiftCard ( tlv10 ) ; }
ignore sibs: ['{ cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } }', '{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv10
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char * *, value: & gift_card
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv13', None), ('int', 'tlv12', None), ('void * *', 'tlv11', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv13', None), ('int', 'tlv12', None), ('void * *', 'tlv11', None), ('SongList *', 'mySongList', None)]
assigns = [('cgc_size_t', 'tlv13', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1'), ('int', 'tlv12', '', '0'), ('void * *', 'tlv11', '', '( void * * ) & buffer')]
compares = []
decls = [('cgc_size_t', 'tlv13', None), ('int', 'tlv12', None), ('void * *', 'tlv11', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'tlv13', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1'), ('int', 'tlv12', '', '0'), ('void * *', 'tlv11', '', '( void * * ) & buffer'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t tlv13 ; tlv13 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; int tlv12 ; tlv12 = 0 ; void * * tlv11 ; tlv11 = ( void * * ) & buffer ; ret = cgc_allocate ( tlv13 , tlv12 , tlv11 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } }', '{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv13
1 : |  decl_scope  | type: int, var: tlv12
2 : |  decl_scope  | type: void * *, var: tlv11
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: cgc_size_t, var: size
5 : |  decl_scope  | type: char *, var: gift_card
6 : |  decl_scope  | type: char *, var: buffer
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void * *, value: ( void * * ) & buffer
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: char *, value: NULL
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } }
ignore sibs: ['{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: SongList *, var: mySongList
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: char *, var: gift_card
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; } ] 
p_decls = [('unsigned int', 'tlv25', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv25', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv25', '', '3')]
compares = []
decls = [('unsigned int', 'tlv25', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv25', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv25', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv25', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv25', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv25', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv25 ; tlv25 = 3 ; cgc__terminate ( tlv25 ) ; }
ignore sibs: ['}', '{ void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }', '{ char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv25
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('SongList *', 'mySongList', None)]
assigns = [('void *', 'tlv3', '', 'buffer'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1')]
compares = []
decls = [('void *', 'tlv3', None), ('int', 'tlv2', None), ('cgc_size_t', 'tlv1', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv3', '', 'buffer'), ('int', 'tlv2', '', '0'), ('cgc_size_t', 'tlv1', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv3 ; tlv3 = buffer ; int tlv2 ; tlv2 = 0 ; cgc_size_t tlv1 ; tlv1 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; cgc_memset ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['{ char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }', '{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: int, var: tlv2
2 : |  decl_scope  | type: cgc_size_t, var: tlv1
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: cgc_size_t, var: size
5 : |  decl_scope  | type: char *, var: gift_card
6 : |  decl_scope  | type: char *, var: buffer
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: buffer
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: char *, value: NULL
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; } ] 
p_decls = [('char *', 'tlv5', None), ('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv5', None), ('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('SongList *', 'mySongList', None)]
assigns = [('char *', 'tlv5', '', 'buffer')]
compares = []
decls = [('char *', 'tlv5', None), ('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv5', '', 'buffer'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv5 ; tlv5 = buffer ; const char tlv4 [ ] = "ID=" ; cgc_strcat ( tlv5 , tlv4 ) ; }
ignore sibs: ['{ char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv5
1 : |  decl_scope  | type: const char *, var: tlv4
2 : |  decl_scope  | type: const char, var: tlv4 [ ]
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: cgc_size_t, var: size
5 : |  decl_scope  | type: char *, var: gift_card
6 : |  decl_scope  | type: char *, var: buffer
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; } ] 
p_decls = [('char *', 'tlv7', None), ('const char *', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv7', None), ('const char *', 'tlv6', None), ('SongList *', 'mySongList', None)]
assigns = [('char *', 'tlv7', '', 'buffer')]
compares = []
decls = [('char *', 'tlv7', None), ('const char *', 'tlv6', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv7', '', 'buffer'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv7 ; tlv7 = buffer ; const char * tlv6 = gift_card ; cgc_strcat ( tlv7 , tlv6 ) ; }
ignore sibs: ['{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }', '{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv7
1 : |  decl_scope  | type: const char *, var: tlv6
2 : |  decl_scope  | type: SongList *, var: mySongList
3 : |  decl_scope  | type: cgc_size_t, var: size
4 : |  decl_scope  | type: char *, var: gift_card
5 : |  decl_scope  | type: char *, var: buffer
6 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; } ] 
p_decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('SongList *', 'mySongList', None)]
assigns = [('char *', 'tlv9', '', 'buffer')]
compares = []
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('char *', 'tlv9', '', 'buffer'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = "\n" ; cgc_strcat ( tlv9 , tlv8 ) ; }
ignore sibs: ['{ void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv9
1 : |  decl_scope  | type: const char *, var: tlv8
2 : |  decl_scope  | type: const char, var: tlv8 [ ]
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: cgc_size_t, var: size
5 : |  decl_scope  | type: char *, var: gift_card
6 : |  decl_scope  | type: char *, var: buffer
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; } ] 
p_decls = [('void *', 'tlv15', None), ('cgc_size_t', 'tlv14', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv15', None), ('cgc_size_t', 'tlv14', None), ('SongList *', 'mySongList', None)]
assigns = [('void *', 'tlv15', '', 'gift_card'), ('cgc_size_t', 'tlv14', '', 'size')]
compares = []
decls = [('void *', 'tlv15', None), ('cgc_size_t', 'tlv14', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv15', '', 'gift_card'), ('cgc_size_t', 'tlv14', '', 'size'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv15 ; tlv15 = gift_card ; cgc_size_t tlv14 ; tlv14 = size ; ret = cgc_deallocate ( tlv15 , tlv14 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv15
1 : |  decl_scope  | type: cgc_size_t, var: tlv14
2 : |  decl_scope  | type: SongList *, var: mySongList
3 : |  decl_scope  | type: cgc_size_t, var: size
4 : |  decl_scope  | type: char *, var: gift_card
5 : |  decl_scope  | type: char *, var: buffer
6 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: gift_card
1 : | assign_scope | type: cgc_size_t, value: size
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } }
ignore sibs: ['{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: SongList *, var: mySongList
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: char *, var: gift_card
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; } ] 
p_decls = [('unsigned int', 'tlv26', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv26', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv26', '', '3')]
compares = []
decls = [('unsigned int', 'tlv26', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv26', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv26', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv26', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv26', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv26', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv26 ; tlv26 = 3 ; cgc__terminate ( tlv26 ) ; }
ignore sibs: ['}', '{ int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv26
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; } ] 
p_decls = [('int', 'tlv18', None), ('const char *', 'tlv17', None), ('cgc_size_t', 'tlv16', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv18', None), ('const char *', 'tlv17', None), ('cgc_size_t', 'tlv16', None), ('SongList *', 'mySongList', None)]
assigns = [('int', 'tlv18', '', 'STDOUT')]
compares = []
decls = [('int', 'tlv18', None), ('const char *', 'tlv17', None), ('cgc_size_t', 'tlv16', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('int', 'tlv18', '', 'STDOUT'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { int tlv18 ; tlv18 = STDOUT ; const char * tlv17 = buffer ; cgc_size_t tlv16 ; { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv18
1 : |  decl_scope  | type: const char *, var: tlv17
2 : |  decl_scope  | type: cgc_size_t, var: tlv16
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: cgc_size_t, var: size
5 : |  decl_scope  | type: char *, var: gift_card
6 : |  decl_scope  | type: char *, var: buffer
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; } ] 
p_decls = [('const char *', 'tlv30', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv30', None), ('SongList *', 'mySongList', None)]
assigns = [('cgc_size_t', 'tlv16', '', 'cgc_strlen ( tlv30 )')]
compares = []
decls = [('const char *', 'tlv30', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'tlv16', '', 'cgc_strlen ( tlv30 )'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('const char *', 'tlv30', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None), ('int', 'tlv18', None), ('const char *', 'tlv17', None), ('cgc_size_t', 'tlv16', None)]
assigns = [('cgc_size_t', 'tlv16', '', 'cgc_strlen ( tlv30 )'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0'), ('int', 'tlv18', '', 'STDOUT')]
compares = []
===> context { const char * tlv30 = buffer ; tlv16 = cgc_strlen ( tlv30 ) ; }
ignore sibs: ['ret = cgc_transmit_all ( tlv18 , tlv17 , tlv16 ) ;', '}', 'if ( ret != 0 ) { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv30
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: tlv18
7 : |  decl_scope  | type: const char *, var: tlv17
8 : |  decl_scope  | type: cgc_size_t, var: tlv16
0 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv30 )
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: STDOUT
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } }
ignore sibs: ['{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: SongList *, var: mySongList
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: char *, var: gift_card
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; } ] 
p_decls = [('unsigned int', 'tlv27', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv27', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv27', '', '10')]
compares = []
decls = [('unsigned int', 'tlv27', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv27', '', '10'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv27', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv27', '', '10'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv27', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv27', '', '10'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv27 ; tlv27 = 10 ; cgc__terminate ( tlv27 ) ; }
ignore sibs: ['}', '{ void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv27
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 10
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; } ] 
p_decls = [('void *', 'tlv20', None), ('cgc_size_t', 'tlv19', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv20', None), ('cgc_size_t', 'tlv19', None), ('SongList *', 'mySongList', None)]
assigns = [('void *', 'tlv20', '', 'buffer'), ('cgc_size_t', 'tlv19', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1')]
compares = []
decls = [('void *', 'tlv20', None), ('cgc_size_t', 'tlv19', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('void *', 'tlv20', '', 'buffer'), ('cgc_size_t', 'tlv19', '', 'size + sizeof ( "ID=" ) + sizeof ( "\\n" ) + 1'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { void * tlv20 ; tlv20 = buffer ; cgc_size_t tlv19 ; tlv19 = size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 ; ret = cgc_deallocate ( tlv20 , tlv19 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: void *, var: tlv20
1 : |  decl_scope  | type: cgc_size_t, var: tlv19
2 : |  decl_scope  | type: SongList *, var: mySongList
3 : |  decl_scope  | type: cgc_size_t, var: size
4 : |  decl_scope  | type: char *, var: gift_card
5 : |  decl_scope  | type: char *, var: buffer
6 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: void *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } }
ignore sibs: ['{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: SongList *, var: mySongList
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: char *, var: gift_card
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; } ] 
p_decls = [('unsigned int', 'tlv28', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv28', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv28', '', '3')]
compares = []
decls = [('unsigned int', 'tlv28', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv28', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv28', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv28', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv28', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv28', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv28 ; tlv28 = 3 ; cgc__terminate ( tlv28 ) ; }
ignore sibs: ['}', '{ int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }', '{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv28
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; } ] 
p_decls = [('int', 'tlv21', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv21', None), ('SongList *', 'mySongList', None)]
assigns = [('int', 'tlv21', '', 'STDIN')]
compares = []
decls = [('int', 'tlv21', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('int', 'tlv21', '', 'STDIN'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { int tlv21 ; tlv21 = STDIN ; mySongList -> balance = cgc_receiveBalance ( tlv21 ) ; }
ignore sibs: ['{ cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: int, var: tlv21
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv24', None), ('int', 'tlv23', None), ('void * *', 'tlv22', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv24', None), ('int', 'tlv23', None), ('void * *', 'tlv22', None), ('SongList *', 'mySongList', None)]
assigns = [('cgc_size_t', 'tlv24', '', 'sizeof ( Song ) * mySongList -> balance'), ('int', 'tlv23', '', '0'), ('void * *', 'tlv22', '', '( void * * ) & mySongList -> songs')]
compares = []
decls = [('cgc_size_t', 'tlv24', None), ('int', 'tlv23', None), ('void * *', 'tlv22', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'tlv24', '', 'sizeof ( Song ) * mySongList -> balance'), ('int', 'tlv23', '', '0'), ('void * *', 'tlv22', '', '( void * * ) & mySongList -> songs'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t tlv24 ; tlv24 = sizeof ( Song ) * mySongList -> balance ; int tlv23 ; tlv23 = 0 ; void * * tlv22 ; tlv22 = ( void * * ) & mySongList -> songs ; ret = cgc_allocate ( tlv24 , tlv23 , tlv22 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv24
1 : |  decl_scope  | type: int, var: tlv23
2 : |  decl_scope  | type: void * *, var: tlv22
3 : |  decl_scope  | type: SongList *, var: mySongList
4 : |  decl_scope  | type: cgc_size_t, var: size
5 : |  decl_scope  | type: char *, var: gift_card
6 : |  decl_scope  | type: char *, var: buffer
7 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: sizeof ( Song ) * mySongList -> balance
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void * *, value: ( void * * ) & mySongList -> songs
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char *, value: NULL
5 : | assign_scope | type: char *, value: NULL
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList *', 'mySongList', None)]
assigns = []
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: SongList *, var: mySongList
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: char *, var: gift_card
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: char *, value: NULL
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; } ] 
p_decls = [('unsigned int', 'tlv29', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv29', None), ('SongList *', 'mySongList', None)]
assigns = [('unsigned int', 'tlv29', '', '3')]
compares = []
decls = [('unsigned int', 'tlv29', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv29', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv29', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv29', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
decls = [('unsigned int', 'tlv29', None), ('SongList *', 'mySongList', None), ('cgc_size_t', 'size', None), ('char *', 'gift_card', None), ('char *', 'buffer', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv29', '', '3'), ('cgc_size_t', 'size', '', '0'), ('char *', 'gift_card', '', 'NULL'), ('char *', 'buffer', '', 'NULL'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { unsigned int tlv29 ; tlv29 = 3 ; cgc__terminate ( tlv29 ) ; }
ignore sibs: ['}', 'return 0 ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv29
1 : |  decl_scope  | type: SongList *, var: mySongList
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: char *, var: gift_card
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: char *, value: NULL
3 : | assign_scope | type: char *, value: NULL
4 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
compound scope 0 : { return & results . songs [ 0 ] ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return & results . songs [ 0 ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return & results . songs [ 0 ] ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList', 'results', None), ('Request', 'request', None)]
assigns = []
compares = []
===> context { return & results . songs [ 0 ] ; }
ignore sibs: []
0 : |  decl_scope  | type: SongList, var: results
1 : |  decl_scope  | type: Request, var: request
=======END=======
compound scope 0 : { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; }
compound scope 1 : { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; }
compound scope 2 : { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; }
compound scope 3 : { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; }
compound scope 4 : { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; }
compound scope 5 : { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; }
compound scope 6 : { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; }
compound scope 7 : { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }
compound scope 8 : { break ; }
compound scope 9 : { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }
compound scope 10 : { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }
compound scope 11 : { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; }
len(compound_scope) : 12
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; } ] 
p_decls = [('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
===> context { int ret ; ret = 0 ; int starting_balance ; starting_balance = 0 ; SongList mySongList = { 0 , NULL , 0 } ; SongList results = { 0 , NULL , 0 } ; Request request = { 0 , 0 , 0 } ; Song songs [ RESULT_LIMIT ] = { 0 } ; Song * selectedSong ; selectedSong = NULL ; results . songs = songs ; { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } starting_balance = mySongList . balance ; while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } return ret ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: int, var: starting_balance
2 : |  decl_scope  | type: SongList, var: mySongList
3 : |  decl_scope  | type: SongList, var: results
4 : |  decl_scope  | type: Request, var: request
5 : |  decl_scope  | type: Song *, var: songs
6 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
7 : |  decl_scope  | type: Song *, var: selectedSong
8 : |  decl_scope  | type: int, var: cgc_argc
9 : |  decl_scope  | type: char * *, var: cgc_argv
10 : |  decl_scope  | type: char *, var: cgc_argv [ ]
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: Song *, value: NULL
3 : | assign_scope | type: UNDEF, value: songs
4 : | assign_scope | type: int, value: mySongList . balance
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; } ] 
p_decls = [('SongList *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList *', 'tlv1', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('SongList *', 'tlv1', '', '& mySongList')]
compares = []
decls = [('SongList *', 'tlv1', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('SongList *', 'tlv1', '', '& mySongList'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs')]
compares = []
===> context { SongList * tlv1 ; tlv1 = & mySongList ; cgc_getBalance ( tlv1 ) ; }
ignore sibs: ['starting_balance = mySongList . balance ;', 'while ( mySongList . balance > 0 ) { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; }', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: SongList *, var: tlv1
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: int, var: starting_balance
6 : |  decl_scope  | type: SongList, var: mySongList
7 : |  decl_scope  | type: SongList, var: results
8 : |  decl_scope  | type: Request, var: request
9 : |  decl_scope  | type: Song *, var: songs
10 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
11 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: SongList *, value: & mySongList
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: Song *, value: NULL
4 : | assign_scope | type: UNDEF, value: songs
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('UNDEF', 'results . size', '', '0')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('UNDEF', 'results . size', '', '0'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('UNDEF', 'results . size', '', '0'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
===> context { results . size = 0 ; { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } if ( ret == LOW_BALANCE ) { break ; } cgc_receiveBalance ( STDIN ) ; }
ignore sibs: ['{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: int, var: starting_balance
5 : |  decl_scope  | type: SongList, var: mySongList
6 : |  decl_scope  | type: SongList, var: results
7 : |  decl_scope  | type: Request, var: request
8 : |  decl_scope  | type: Song *, var: songs
9 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
10 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: UNDEF, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: Song *, value: NULL
4 : | assign_scope | type: UNDEF, value: songs
5 : | assign_scope | type: int, value: mySongList . balance
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; } ] 
p_decls = [('Request *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Request *', 'tlv4', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('Request *', 'tlv4', '', '& request')]
compares = []
decls = [('Request *', 'tlv4', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('Request *', 'tlv4', '', '& request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('Request *', 'tlv4', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('Request *', 'tlv4', '', '& request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('Request *', 'tlv4', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('Request *', 'tlv4', '', '& request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '']
===> context { Request * tlv4 ; tlv4 = & request ; cgc_createRandomRequest ( tlv4 ) ; }
ignore sibs: ['{ int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; }', '{ int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; }', '{ SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; }', '{ int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }', 'if ( ret == LOW_BALANCE ) { break ; }', 'cgc_receiveBalance ( STDIN ) ;', '}', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: Request *, var: tlv4
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: int, var: starting_balance
6 : |  decl_scope  | type: SongList, var: mySongList
7 : |  decl_scope  | type: SongList, var: results
8 : |  decl_scope  | type: Request, var: request
9 : |  decl_scope  | type: Song *, var: songs
10 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
11 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: Request *, value: & request
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: Song *, value: NULL
4 : | assign_scope | type: UNDEF, value: songs
5 : | assign_scope | type: int, value: mySongList . balance
6 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; } ] 
p_decls = [('int', 'tlv6', None), ('Request', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv6', None), ('Request', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv6', '', 'STDOUT'), ('Request', 'tlv5', '', 'request')]
compares = []
decls = [('int', 'tlv6', None), ('Request', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv6', '', 'STDOUT'), ('Request', 'tlv5', '', 'request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('int', 'tlv6', None), ('Request', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv6', '', 'STDOUT'), ('Request', 'tlv5', '', 'request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('int', 'tlv6', None), ('Request', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv6', '', 'STDOUT'), ('Request', 'tlv5', '', 'request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '']
===> context { int tlv6 ; tlv6 = STDOUT ; Request tlv5 ; tlv5 = request ; cgc_sendSearchString ( tlv6 , tlv5 ) ; }
ignore sibs: ['{ int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; }', '{ SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; }', '{ int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }', 'if ( ret == LOW_BALANCE ) { break ; }', 'cgc_receiveBalance ( STDIN ) ;', '}', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv6
1 : |  decl_scope  | type: Request, var: tlv5
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: starting_balance
7 : |  decl_scope  | type: SongList, var: mySongList
8 : |  decl_scope  | type: SongList, var: results
9 : |  decl_scope  | type: Request, var: request
10 : |  decl_scope  | type: Song *, var: songs
11 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
12 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: Request, value: request
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: Song *, value: NULL
5 : | assign_scope | type: UNDEF, value: songs
6 : | assign_scope | type: int, value: mySongList . balance
7 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; } ] 
p_decls = [('int', 'tlv9', None), ('SongList *', 'tlv8', None), ('int', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv9', None), ('SongList *', 'tlv8', None), ('int', 'tlv7', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv9', '', 'STDIN'), ('SongList *', 'tlv8', '', '& results'), ('int', 'tlv7', '', 'RESULT_LIMIT')]
compares = []
decls = [('int', 'tlv9', None), ('SongList *', 'tlv8', None), ('int', 'tlv7', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv9', '', 'STDIN'), ('SongList *', 'tlv8', '', '& results'), ('int', 'tlv7', '', 'RESULT_LIMIT'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('int', 'tlv9', None), ('SongList *', 'tlv8', None), ('int', 'tlv7', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv9', '', 'STDIN'), ('SongList *', 'tlv8', '', '& results'), ('int', 'tlv7', '', 'RESULT_LIMIT'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('int', 'tlv9', None), ('SongList *', 'tlv8', None), ('int', 'tlv7', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv9', '', 'STDIN'), ('SongList *', 'tlv8', '', '& results'), ('int', 'tlv7', '', 'RESULT_LIMIT'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '']
===> context { int tlv9 ; tlv9 = STDIN ; SongList * tlv8 ; tlv8 = & results ; int tlv7 ; tlv7 = RESULT_LIMIT ; cgc_receiveSearchResults ( tlv9 , tlv8 , tlv7 ) ; }
ignore sibs: ['{ SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; }', '{ int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }', 'if ( ret == LOW_BALANCE ) { break ; }', 'cgc_receiveBalance ( STDIN ) ;', '}', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv9
1 : |  decl_scope  | type: SongList *, var: tlv8
2 : |  decl_scope  | type: int, var: tlv7
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: starting_balance
8 : |  decl_scope  | type: SongList, var: mySongList
9 : |  decl_scope  | type: SongList, var: results
10 : |  decl_scope  | type: Request, var: request
11 : |  decl_scope  | type: Song *, var: songs
12 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
13 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: SongList *, value: & results
2 : | assign_scope | type: int, value: RESULT_LIMIT
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: Song *, value: NULL
6 : | assign_scope | type: UNDEF, value: songs
7 : | assign_scope | type: int, value: mySongList . balance
8 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; } ] 
p_decls = [('SongList', 'tlv12', None), ('Request', 'tlv11', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('SongList', 'tlv12', None), ('Request', 'tlv11', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('SongList', 'tlv12', '', 'results'), ('Request', 'tlv11', '', 'request')]
compares = []
decls = [('SongList', 'tlv12', None), ('Request', 'tlv11', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('SongList', 'tlv12', '', 'results'), ('Request', 'tlv11', '', 'request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('SongList', 'tlv12', None), ('Request', 'tlv11', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('SongList', 'tlv12', '', 'results'), ('Request', 'tlv11', '', 'request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('SongList', 'tlv12', None), ('Request', 'tlv11', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('SongList', 'tlv12', '', 'results'), ('Request', 'tlv11', '', 'request'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '']
===> context { SongList tlv12 ; tlv12 = results ; Request tlv11 ; tlv11 = request ; selectedSong = cgc_selectSong ( tlv12 , tlv11 ) ; }
ignore sibs: ['{ int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }', 'if ( ret == LOW_BALANCE ) { break ; }', 'cgc_receiveBalance ( STDIN ) ;', '}', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: SongList, var: tlv12
1 : |  decl_scope  | type: Request, var: tlv11
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: starting_balance
7 : |  decl_scope  | type: SongList, var: mySongList
8 : |  decl_scope  | type: SongList, var: results
9 : |  decl_scope  | type: Request, var: request
10 : |  decl_scope  | type: Song *, var: songs
11 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
12 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: SongList, value: results
1 : | assign_scope | type: Request, value: request
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: Song *, value: NULL
5 : | assign_scope | type: UNDEF, value: songs
6 : | assign_scope | type: int, value: mySongList . balance
7 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; } ] 
p_decls = [('int', 'tlv15', None), ('Song *', 'tlv14', None), ('SongList *', 'tlv13', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv15', None), ('Song *', 'tlv14', None), ('SongList *', 'tlv13', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv15', '', 'STDOUT'), ('Song *', 'tlv14', '', 'selectedSong'), ('SongList *', 'tlv13', '', '& mySongList')]
compares = []
decls = [('int', 'tlv15', None), ('Song *', 'tlv14', None), ('SongList *', 'tlv13', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv15', '', 'STDOUT'), ('Song *', 'tlv14', '', 'selectedSong'), ('SongList *', 'tlv13', '', '& mySongList'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('int', 'tlv15', None), ('Song *', 'tlv14', None), ('SongList *', 'tlv13', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv15', '', 'STDOUT'), ('Song *', 'tlv14', '', 'selectedSong'), ('SongList *', 'tlv13', '', '& mySongList'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('int', 'tlv15', None), ('Song *', 'tlv14', None), ('SongList *', 'tlv13', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'tlv15', '', 'STDOUT'), ('Song *', 'tlv14', '', 'selectedSong'), ('SongList *', 'tlv13', '', '& mySongList'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '']
===> context { int tlv15 ; tlv15 = STDOUT ; Song * tlv14 ; tlv14 = selectedSong ; SongList * tlv13 ; tlv13 = & mySongList ; ret = cgc_purchaseSong ( tlv15 , tlv14 , tlv13 ) ; }
ignore sibs: ['if ( ret == LOW_BALANCE ) { break ; }', 'cgc_receiveBalance ( STDIN ) ;', '}', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv15
1 : |  decl_scope  | type: Song *, var: tlv14
2 : |  decl_scope  | type: SongList *, var: tlv13
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: starting_balance
8 : |  decl_scope  | type: SongList, var: mySongList
9 : |  decl_scope  | type: SongList, var: results
10 : |  decl_scope  | type: Request, var: request
11 : |  decl_scope  | type: Song *, var: songs
12 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
13 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: Song *, value: selectedSong
2 : | assign_scope | type: SongList *, value: & mySongList
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: Song *, value: NULL
6 : | assign_scope | type: UNDEF, value: songs
7 : | assign_scope | type: int, value: mySongList . balance
8 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { break ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance'), ('UNDEF', 'results . size', '', '0')]
compares = ['', '', '', '']
===> context { break ; }
ignore sibs: ['cgc_receiveBalance ( STDIN ) ;', '}', '{ void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }', 'if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: int, var: starting_balance
5 : |  decl_scope  | type: SongList, var: mySongList
6 : |  decl_scope  | type: SongList, var: results
7 : |  decl_scope  | type: Request, var: request
8 : |  decl_scope  | type: Song *, var: songs
9 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
10 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: Song *, value: NULL
3 : | assign_scope | type: UNDEF, value: songs
4 : | assign_scope | type: int, value: mySongList . balance
5 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: SongList, value: mySongList . balance
1 : |compare_scopes| type: SongList, value: 0
2 : |compare_scopes| type: int, value: ret
3 : |compare_scopes| type: int, value: LOW_BALANCE
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; } ] 
p_decls = [('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('void *', 'tlv3', '', 'mySongList . songs'), ('cgc_size_t', 'tlv2', '', 'sizeof ( Song ) * starting_balance')]
compares = []
decls = [('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('void *', 'tlv3', '', 'mySongList . songs'), ('cgc_size_t', 'tlv2', '', 'sizeof ( Song ) * starting_balance'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
===> context { void * tlv3 ; tlv3 = mySongList . songs ; cgc_size_t tlv2 ; tlv2 = sizeof ( Song ) * starting_balance ; ret = cgc_deallocate ( tlv3 , tlv2 ) ; }
ignore sibs: ['if ( ret != 0 ) { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv3
1 : |  decl_scope  | type: cgc_size_t, var: tlv2
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: int, var: ret
6 : |  decl_scope  | type: int, var: starting_balance
7 : |  decl_scope  | type: SongList, var: mySongList
8 : |  decl_scope  | type: SongList, var: results
9 : |  decl_scope  | type: Request, var: request
10 : |  decl_scope  | type: Song *, var: songs
11 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
12 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: void *, value: mySongList . songs
1 : | assign_scope | type: cgc_size_t, value: sizeof ( Song ) * starting_balance
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: Song *, value: NULL
5 : | assign_scope | type: UNDEF, value: songs
6 : | assign_scope | type: int, value: mySongList . balance
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
===> context { { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } }
ignore sibs: ['return ret ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: int, var: starting_balance
5 : |  decl_scope  | type: SongList, var: mySongList
6 : |  decl_scope  | type: SongList, var: results
7 : |  decl_scope  | type: Request, var: request
8 : |  decl_scope  | type: Song *, var: songs
9 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
10 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: Song *, value: NULL
3 : | assign_scope | type: UNDEF, value: songs
4 : | assign_scope | type: int, value: mySongList . balance
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; } ] 
p_decls = [('unsigned int', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv10', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('unsigned int', 'tlv10', '', '3')]
compares = []
decls = [('unsigned int', 'tlv10', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('unsigned int', 'tlv10', '', '3'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = []
decls = [('unsigned int', 'tlv10', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('unsigned int', 'tlv10', '', '3'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
decls = [('unsigned int', 'tlv10', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('int', 'ret', None), ('int', 'starting_balance', None), ('SongList', 'mySongList', None), ('SongList', 'results', None), ('Request', 'request', None), ('Song *', 'songs', ' [ RESULT_LIMIT ]'), ('Song', 'songs [ RESULT_LIMIT ]', None), ('Song *', 'selectedSong', None)]
assigns = [('unsigned int', 'tlv10', '', '3'), ('int', 'ret', '', '0'), ('int', 'starting_balance', '', '0'), ('Song *', 'selectedSong', '', 'NULL'), ('UNDEF', 'results . songs', '', 'songs'), ('int', 'starting_balance', '', 'mySongList . balance')]
compares = ['', '']
===> context { unsigned int tlv10 ; tlv10 = 3 ; cgc__terminate ( tlv10 ) ; }
ignore sibs: ['}', 'return ret ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv10
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: int, var: starting_balance
6 : |  decl_scope  | type: SongList, var: mySongList
7 : |  decl_scope  | type: SongList, var: results
8 : |  decl_scope  | type: Request, var: request
9 : |  decl_scope  | type: Song *, var: songs
10 : |  decl_scope  | type: Song, var: songs [ RESULT_LIMIT ]
11 : |  decl_scope  | type: Song *, var: selectedSong
0 : | assign_scope | type: unsigned int, value: 3
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: Song *, value: NULL
4 : | assign_scope | type: UNDEF, value: songs
5 : | assign_scope | type: int, value: mySongList . balance
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
def_vars[0]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : char * ptr ;
def_vars[1]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : int count ;
def_vars[2]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[3]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : char * delim ;
def_vars[4]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[5]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : void * tlv2 ;
def_vars[6]: [cgc_setValue] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
sym_lut=>'{'buffer': 'char *', 'value': 'char *', 'ptr': 'char *', 'count': 'int', 'i': 'int', 'delim': 'char *'}'
val_s=>'[('char *', 'ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4affba8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b17a58>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b11908>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b22898>), ('char *', 'ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b033c8>)]'
cval_s=>'[]'
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=0/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=0/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=0/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=0/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=1/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=1/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=1/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=1/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=2/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=2/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=2/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=2/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=3/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=3/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=3/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=3/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=4/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=4/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=4/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=4/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=5/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=5/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=5/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=5/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/18][j=0/3][dd=6/7][k=0/5] | type: char * ; var : ptr ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/18][j=0/3][dd=6/7][k=1/5] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [P] => '[False, False, False]'
has_multiptr_refs 'PARAM_DELIM' - False OR  False
[i=0/18][j=0/3][dd=6/7][k=3/5] | type: char * ; var : delim ; varinfo :  ; value_node : PARAM_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : PARAM_DELIM
 => is literal (False) | is operator (False) PARAM_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=0/3][dd=6/7][k=4/5] | type: char * ; var : ptr ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
----
UNIQ_INIT: ('char *','buffer','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

==== Scope 1 ====
void fix_ingred_service_0_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(NULL); }
    {int count; count = (int)(NULL); }
    {int i; i = (int)(NULL); }
    {char * delim; delim = (char *)(NULL); }
    {void * tlv3; tlv3 = (void *)(NULL); }
    {void * tlv2; tlv2 = (void *)(NULL); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(NULL); }
}
void fix_ingred_service_0_0_1(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(0); }
    {int count; count = (int)(0); }
    {int i; i = (int)(0); }
    {char * delim; delim = (char *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {void * tlv2; tlv2 = (void *)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
}
void fix_ingred_service_0_0_3(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(PARAM_DELIM); }
    {int count; count = (int)(PARAM_DELIM); }
    {int i; i = (int)(PARAM_DELIM); }
    {char * delim; delim = (char *)(PARAM_DELIM); }
    {void * tlv3; tlv3 = (void *)(PARAM_DELIM); }
    {void * tlv2; tlv2 = (void *)(PARAM_DELIM); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(PARAM_DELIM); }
}
void fix_ingred_service_0_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(buffer); }
    {int count; count = (int)(buffer); }
    {int i; i = (int)(buffer); }
    {char * delim; delim = (char *)(buffer); }
    {void * tlv3; tlv3 = (void *)(buffer); }
    {void * tlv2; tlv2 = (void *)(buffer); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(buffer); }
}
void fix_ingred_service_0_0(){
fix_ingred_service_0_0_0();
fix_ingred_service_0_0_1();
fix_ingred_service_0_0_3();
fix_ingred_service_0_0_4();
}

sym_lut=>'{'buffer': 'char *', 'value': 'char *', 'ptr': 'char *', 'count': 'int', 'i': 'int', 'delim': 'char *'}'
val_s=>'[('char *', 'ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4affba8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b17a58>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b11908>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b22898>), ('char *', 'ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b033c8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4afce48>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4af8358>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4af8a58>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4af8d68>)]'
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=0/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
unique : ('char *', 'ptr', None)
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=0/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
unique : ('char *', 'delim', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=0/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=0/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=1/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
not unique: ('char *', 'ptr', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=1/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=1/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=1/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=2/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
not unique: ('char *', 'ptr', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=2/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=2/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=2/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=3/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
not unique: ('char *', 'ptr', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=3/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=3/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=3/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=4/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
not unique: ('char *', 'ptr', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=4/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=4/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=4/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=5/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
not unique: ('char *', 'ptr', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=5/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=5/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=5/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*ptr' - False OR  False
[i=0/18][j=1/3][dd=6/7][k=5/9] | type: char ; var :  ; varinfo :  ; value_node : * ptr (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,ptr
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) ptr [vtype=char *]
not unique: ('char *', 'ptr', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=0/18][j=1/3][dd=6/7][k=6/9] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=1/3][dd=6/7][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=0/18][j=1/3][dd=6/7][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
not valid - char * ptr; ptr = ((char *)* ptr);

----
UNIQ_INIT: ('char *','ptr','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

not valid - char * delim; delim = ((char *)* delim);

----
UNIQ_INIT: ('char *','ptr','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

not valid - int count; count = ((int)count);

----
UNIQ_INIT: ('char *','ptr','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','ptr','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_0_1_5(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int count; count = (int)(* ptr); }
    {int i; i = (int)(* ptr); }
    {char * delim; delim = (char *)(* ptr); }
    {void * tlv3; tlv3 = (void *)(* ptr); }
    {void * tlv2; tlv2 = (void *)(* ptr); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(* ptr); }
}
void fix_ingred_service_0_1_6(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(* delim); }
    {int count; count = (int)(* delim); }
    {int i; i = (int)(* delim); }
    {void * tlv3; tlv3 = (void *)(* delim); }
    {void * tlv2; tlv2 = (void *)(* delim); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(* delim); }
}
void fix_ingred_service_0_1_7(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(count); }
    {int i; i = (int)(count); }
    {char * delim; delim = (char *)(count); }
    {void * tlv3; tlv3 = (void *)(count); }
    {void * tlv2; tlv2 = (void *)(count); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(count); }
}
void fix_ingred_service_0_1_8(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(RESULT_VALUE_SIZE); }
    {int count; count = (int)(RESULT_VALUE_SIZE); }
    {int i; i = (int)(RESULT_VALUE_SIZE); }
    {char * delim; delim = (char *)(RESULT_VALUE_SIZE); }
    {void * tlv3; tlv3 = (void *)(RESULT_VALUE_SIZE); }
    {void * tlv2; tlv2 = (void *)(RESULT_VALUE_SIZE); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(RESULT_VALUE_SIZE); }
}
void fix_ingred_service_0_1(){
fix_ingred_service_0_1_5();
fix_ingred_service_0_1_6();
fix_ingred_service_0_1_7();
fix_ingred_service_0_1_8();
}

sym_lut=>'{'buffer': 'char *', 'value': 'char *', 'ptr': 'char *', 'count': 'int', 'i': 'int', 'delim': 'char *', 'tlv3': 'void *', 'tlv2': 'void *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b0ac18>), ('void *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b1eba8>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b00ac8>), ('char *', 'ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4affba8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b17a58>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b11908>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b22898>), ('char *', 'ptr', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b033c8>)]'
cval_s=>'[]'
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=0/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
unique : ('char *', 'value', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=0/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=0/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=1/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
not unique: ('char *', 'value', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=1/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=1/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=2/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
not unique: ('char *', 'value', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=2/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=2/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=3/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
not unique: ('char *', 'value', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=3/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=3/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=4/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
not unique: ('char *', 'value', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=4/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=4/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=5/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
not unique: ('char *', 'value', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=5/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=5/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=0/18][j=2/3][dd=6/7][k=0/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
not unique: ('char *', 'value', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=0/18][j=2/3][dd=6/7][k=1/8] | type: void * ; var : tlv2 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=0/18][j=2/3][dd=6/7][k=2/8] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
----
UNIQ_INIT: ('char *','value','None','None');

UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','value','None','None');

UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('int','count','None','None');

not valid - int count; count = ((int)count);

----
UNIQ_INIT: ('char *','value','None','None');

UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_0_2_0(){
char value_ref;
    bzero(&value_ref,1*sizeof(char));
char * value = &value_ref;
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(value); }
    {int count; count = (int)(value); }
    {int i; i = (int)(value); }
    {char * delim; delim = (char *)(value); }
    {void * tlv3; tlv3 = (void *)(value); }
    {void * tlv2; tlv2 = (void *)(value); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(value); }
}
void fix_ingred_service_0_2_1(){
char value_ref;
    bzero(&value_ref,1*sizeof(char));
char * value = &value_ref;
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(buffer); }
    {int count; count = (int)(buffer); }
    {int i; i = (int)(buffer); }
    {char * delim; delim = (char *)(buffer); }
    {void * tlv3; tlv3 = (void *)(buffer); }
    {void * tlv2; tlv2 = (void *)(buffer); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(buffer); }
}
void fix_ingred_service_0_2_2(){
char value_ref;
    bzero(&value_ref,1*sizeof(char));
char * value = &value_ref;
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(count); }
    {int i; i = (int)(count); }
    {char * delim; delim = (char *)(count); }
    {void * tlv3; tlv3 = (void *)(count); }
    {void * tlv2; tlv2 = (void *)(count); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(count); }
}
void fix_ingred_service_0_2(){
fix_ingred_service_0_2_0();
fix_ingred_service_0_2_1();
fix_ingred_service_0_2_2();
}

==== Scope 2 ====
void fix_ingred_service_0_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(NULL); }
    {int count; count = (int)(NULL); }
    {int i; i = (int)(NULL); }
    {char * delim; delim = (char *)(NULL); }
    {void * tlv3; tlv3 = (void *)(NULL); }
    {void * tlv2; tlv2 = (void *)(NULL); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(NULL); }
}
void fix_ingred_service_0_0_1(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(0); }
    {int count; count = (int)(0); }
    {int i; i = (int)(0); }
    {char * delim; delim = (char *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {void * tlv2; tlv2 = (void *)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
}
void fix_ingred_service_0_0_3(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(PARAM_DELIM); }
    {int count; count = (int)(PARAM_DELIM); }
    {int i; i = (int)(PARAM_DELIM); }
    {char * delim; delim = (char *)(PARAM_DELIM); }
    {void * tlv3; tlv3 = (void *)(PARAM_DELIM); }
    {void * tlv2; tlv2 = (void *)(PARAM_DELIM); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(PARAM_DELIM); }
}
void fix_ingred_service_0_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {char * ptr; ptr = (char *)(buffer); }
    {int count; count = (int)(buffer); }
    {int i; i = (int)(buffer); }
    {char * delim; delim = (char *)(buffer); }
    {void * tlv3; tlv3 = (void *)(buffer); }
    {void * tlv2; tlv2 = (void *)(buffer); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(buffer); }
}
void fix_ingred_service_0_0(){
fix_ingred_service_0_0_0();
fix_ingred_service_0_0_1();
fix_ingred_service_0_0_3();
fix_ingred_service_0_0_4();
}
void fix_ingred_service_0_1_5(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int count; count = (int)(* ptr); }
    {int i; i = (int)(* ptr); }
    {char * delim; delim = (char *)(* ptr); }
    {void * tlv3; tlv3 = (void *)(* ptr); }
    {void * tlv2; tlv2 = (void *)(* ptr); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(* ptr); }
}
void fix_ingred_service_0_1_6(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(* delim); }
    {int count; count = (int)(* delim); }
    {int i; i = (int)(* delim); }
    {void * tlv3; tlv3 = (void *)(* delim); }
    {void * tlv2; tlv2 = (void *)(* delim); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(* delim); }
}
void fix_ingred_service_0_1_7(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(count); }
    {int i; i = (int)(count); }
    {char * delim; delim = (char *)(count); }
    {void * tlv3; tlv3 = (void *)(count); }
    {void * tlv2; tlv2 = (void *)(count); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(count); }
}
void fix_ingred_service_0_1_8(){
char ptr_ref;
    bzero(&ptr_ref,1*sizeof(char));
char * ptr = &ptr_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(RESULT_VALUE_SIZE); }
    {int count; count = (int)(RESULT_VALUE_SIZE); }
    {int i; i = (int)(RESULT_VALUE_SIZE); }
    {char * delim; delim = (char *)(RESULT_VALUE_SIZE); }
    {void * tlv3; tlv3 = (void *)(RESULT_VALUE_SIZE); }
    {void * tlv2; tlv2 = (void *)(RESULT_VALUE_SIZE); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(RESULT_VALUE_SIZE); }
}
void fix_ingred_service_0_1(){
fix_ingred_service_0_1_5();
fix_ingred_service_0_1_6();
fix_ingred_service_0_1_7();
fix_ingred_service_0_1_8();
}
void fix_ingred_service_0_2_0(){
char value_ref;
    bzero(&value_ref,1*sizeof(char));
char * value = &value_ref;
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(value); }
    {int count; count = (int)(value); }
    {int i; i = (int)(value); }
    {char * delim; delim = (char *)(value); }
    {void * tlv3; tlv3 = (void *)(value); }
    {void * tlv2; tlv2 = (void *)(value); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(value); }
}
void fix_ingred_service_0_2_1(){
char value_ref;
    bzero(&value_ref,1*sizeof(char));
char * value = &value_ref;
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(buffer); }
    {int count; count = (int)(buffer); }
    {int i; i = (int)(buffer); }
    {char * delim; delim = (char *)(buffer); }
    {void * tlv3; tlv3 = (void *)(buffer); }
    {void * tlv2; tlv2 = (void *)(buffer); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(buffer); }
}
void fix_ingred_service_0_2_2(){
char value_ref;
    bzero(&value_ref,1*sizeof(char));
char * value = &value_ref;
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
int count;
    bzero(&count,sizeof(int));
    {char * ptr; ptr = (char *)(count); }
    {int i; i = (int)(count); }
    {char * delim; delim = (char *)(count); }
    {void * tlv3; tlv3 = (void *)(count); }
    {void * tlv2; tlv2 = (void *)(count); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(count); }
}
void fix_ingred_service_0_2(){
fix_ingred_service_0_2_0();
fix_ingred_service_0_2_1();
fix_ingred_service_0_2_2();
}
void fix_ingred_service_0(){
fix_ingred_service_0_0();
fix_ingred_service_0_1();
fix_ingred_service_0_2();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_service_0_0_0();
void fix_ingred_service_0_0_1();
void fix_ingred_service_0_0_3();
void fix_ingred_service_0_0_4();
void fix_ingred_service_0_0();
void fix_ingred_service_0_1_5();
void fix_ingred_service_0_1_6();
void fix_ingred_service_0_1_7();
void fix_ingred_service_0_1_8();
void fix_ingred_service_0_1();
void fix_ingred_service_0_2_0();
void fix_ingred_service_0_2_1();
void fix_ingred_service_0_2_2();
void fix_ingred_service_0_2();
void fix_ingred_service_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char * start ;
def_vars[1]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char * end ;
def_vars[2]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char key [ KEY_SIZE ] = { 0 } ;
def_vars[3]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char value [ RESULT_VALUE_SIZE ] = { 0 } ;
def_vars[4]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : int count ;
def_vars[5]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[6]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char * delim ;
def_vars[7]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[8]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : int num_results ;
def_vars[9]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[10]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[11]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[12]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[13]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = key ;
def_vars[14]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = NUM_STR ;
def_vars[15]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char * tlv8 ;
def_vars[16]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[17]: [cgc_parseResultSize] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv9 = value ;
sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[]'
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=0/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=0/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=0/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=0/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=0/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
unique : ('char *', 'start', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=1/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=1/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=1/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=1/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=1/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=2/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=2/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=2/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=2/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=2/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
Skipping RESULT_VALUE_SIZE => #define
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=3/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=3/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=3/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=3/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=3/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=4/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=4/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=5/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=5/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=6/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=6/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=7/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=7/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=7/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=7/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=7/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=8/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=8/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=8/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=8/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=8/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=9/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=9/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=9/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=9/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=9/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=10/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=10/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=10/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=10/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=10/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=11/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=11/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=12/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=12/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=12/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=12/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=12/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=15/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=15/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=15/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=15/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=15/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/18][j=0/7][dd=16/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/18][j=0/7][dd=16/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=1/18][j=0/7][dd=16/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/18][j=0/7][dd=16/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=0/7][dd=16/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

not valid - char * start; start = ((char *)start);

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

==== Scope 1 ====
void fix_ingred_service_1_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(NULL); }
    {char * end; end = (char *)(NULL); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(NULL); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(NULL); }
    {int ret; ret = (int)(NULL); }
    {int num_results; num_results = (int)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
    {void * tlv4; tlv4 = (void *)(NULL); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(NULL); }
    {char * tlv8; tlv8 = (char *)(NULL); }
    {char * tlv7; tlv7 = (char *)(NULL); }
}
void fix_ingred_service_1_0_2(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(0); }
    {char * end; end = (char *)(0); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(0); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(0); }
    {int ret; ret = (int)(0); }
    {int num_results; num_results = (int)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {char * tlv8; tlv8 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
}
void fix_ingred_service_1_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(KEYVAL_DELIM); }
    {char * end; end = (char *)(KEYVAL_DELIM); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(KEYVAL_DELIM); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(KEYVAL_DELIM); }
    {int count; count = (int)(KEYVAL_DELIM); }
    {int i; i = (int)(KEYVAL_DELIM); }
    {char * delim; delim = (char *)(KEYVAL_DELIM); }
    {int ret; ret = (int)(KEYVAL_DELIM); }
    {int num_results; num_results = (int)(KEYVAL_DELIM); }
    {int tlv1; tlv1 = (int)(KEYVAL_DELIM); }
    {void * tlv4; tlv4 = (void *)(KEYVAL_DELIM); }
    {void * tlv3; tlv3 = (void *)(KEYVAL_DELIM); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(KEYVAL_DELIM); }
    {char * tlv8; tlv8 = (char *)(KEYVAL_DELIM); }
    {char * tlv7; tlv7 = (char *)(KEYVAL_DELIM); }
}
void fix_ingred_service_1_0_7(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(buffer); }
    {char * end; end = (char *)(buffer); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(buffer); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(buffer); }
    {int ret; ret = (int)(buffer); }
    {int num_results; num_results = (int)(buffer); }
    {int tlv1; tlv1 = (int)(buffer); }
    {void * tlv4; tlv4 = (void *)(buffer); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buffer); }
    {char * tlv8; tlv8 = (char *)(buffer); }
    {char * tlv7; tlv7 = (char *)(buffer); }
}
void fix_ingred_service_1_0_8(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * end; end = (char *)(start); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(start); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(start); }
    {int count; count = (int)(start); }
    {int i; i = (int)(start); }
    {char * delim; delim = (char *)(start); }
    {int ret; ret = (int)(start); }
    {int num_results; num_results = (int)(start); }
    {int tlv1; tlv1 = (int)(start); }
    {void * tlv4; tlv4 = (void *)(start); }
    {void * tlv3; tlv3 = (void *)(start); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(start); }
    {char * tlv8; tlv8 = (char *)(start); }
    {char * tlv7; tlv7 = (char *)(start); }
}
void fix_ingred_service_1_0(){
fix_ingred_service_1_0_0();
fix_ingred_service_1_0_2();
fix_ingred_service_1_0_4();
fix_ingred_service_1_0_7();
fix_ingred_service_1_0_8();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d00898>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d00d68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4d244a8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4d247b8>)]'
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=0/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
unique : ('char *', 'end', None)
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=0/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
unique : ('char *', 'delim', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=0/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=0/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=1/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=1/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=1/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=1/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=2/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=2/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=2/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=2/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
Skipping RESULT_VALUE_SIZE => #define
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=3/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=3/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=3/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=3/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=4/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=4/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=5/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=5/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=6/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=6/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=7/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=7/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=7/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=7/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=8/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=8/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=8/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=8/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=9/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=9/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=9/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=9/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=10/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=10/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=10/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=10/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=11/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=11/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=12/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=12/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=12/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=12/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=15/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=15/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=15/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=15/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=1/18][j=1/7][dd=16/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=1/18][j=1/7][dd=16/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=1/7][dd=16/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=1/18][j=1/7][dd=16/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
not valid - char * end; end = ((char *)* end);

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_1_1_10(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(* end); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(* end); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(* end); }
    {int count; count = (int)(* end); }
    {int i; i = (int)(* end); }
    {char * delim; delim = (char *)(* end); }
    {int ret; ret = (int)(* end); }
    {int num_results; num_results = (int)(* end); }
    {int tlv1; tlv1 = (int)(* end); }
    {void * tlv4; tlv4 = (void *)(* end); }
    {void * tlv3; tlv3 = (void *)(* end); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(* end); }
    {char * tlv8; tlv8 = (char *)(* end); }
    {char * tlv7; tlv7 = (char *)(* end); }
}
void fix_ingred_service_1_1_11(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(* delim); }
    {char * end; end = (char *)(* delim); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(* delim); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(* delim); }
    {int ret; ret = (int)(* delim); }
    {int num_results; num_results = (int)(* delim); }
    {int tlv1; tlv1 = (int)(* delim); }
    {void * tlv4; tlv4 = (void *)(* delim); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(* delim); }
    {char * tlv8; tlv8 = (char *)(* delim); }
    {char * tlv7; tlv7 = (char *)(* delim); }
}
void fix_ingred_service_1_1_12(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(count); }
    {char * end; end = (char *)(count); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(count); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(count); }
    {int ret; ret = (int)(count); }
    {int num_results; num_results = (int)(count); }
    {int tlv1; tlv1 = (int)(count); }
    {void * tlv4; tlv4 = (void *)(count); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(count); }
    {char * tlv8; tlv8 = (char *)(count); }
    {char * tlv7; tlv7 = (char *)(count); }
}
void fix_ingred_service_1_1_13(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(KEY_SIZE); }
    {char * end; end = (char *)(KEY_SIZE); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(KEY_SIZE); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(KEY_SIZE); }
    {int count; count = (int)(KEY_SIZE); }
    {int i; i = (int)(KEY_SIZE); }
    {char * delim; delim = (char *)(KEY_SIZE); }
    {int ret; ret = (int)(KEY_SIZE); }
    {int num_results; num_results = (int)(KEY_SIZE); }
    {int tlv1; tlv1 = (int)(KEY_SIZE); }
    {void * tlv4; tlv4 = (void *)(KEY_SIZE); }
    {void * tlv3; tlv3 = (void *)(KEY_SIZE); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(KEY_SIZE); }
    {char * tlv8; tlv8 = (char *)(KEY_SIZE); }
    {char * tlv7; tlv7 = (char *)(KEY_SIZE); }
}
void fix_ingred_service_1_1(){
fix_ingred_service_1_1_10();
fix_ingred_service_1_1_11();
fix_ingred_service_1_1_12();
fix_ingred_service_1_1_13();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d04668>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfe5f8>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfb518>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[]'
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=0/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
unique : ('char', 'key [ KEY_SIZE ]', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=0/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
unique : ('char *', 'start', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=0/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=1/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=1/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=1/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=2/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=2/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=2/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
Skipping RESULT_VALUE_SIZE => #define
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=3/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=3/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=3/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=4/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=4/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=5/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=5/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=6/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=6/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=7/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=7/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=7/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=8/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=8/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=8/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=9/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=9/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=9/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=10/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=10/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=10/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=11/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=11/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=12/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=12/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=12/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=15/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=15/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=15/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=1/18][j=2/7][dd=16/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=1/18][j=2/7][dd=16/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/18][j=2/7][dd=16/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

not valid - char * start; start = ((char *)start);

----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_1_2_0(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(key); }
    {char * end; end = (char *)(key); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(key); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(key); }
    {int count; count = (int)(key); }
    {int i; i = (int)(key); }
    {char * delim; delim = (char *)(key); }
    {int ret; ret = (int)(key); }
    {int num_results; num_results = (int)(key); }
    {int tlv1; tlv1 = (int)(key); }
    {void * tlv4; tlv4 = (void *)(key); }
    {void * tlv3; tlv3 = (void *)(key); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(key); }
    {char * tlv8; tlv8 = (char *)(key); }
    {char * tlv7; tlv7 = (char *)(key); }
}
void fix_ingred_service_1_2_1(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {char * end; end = (char *)(start); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(start); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(start); }
    {int count; count = (int)(start); }
    {int i; i = (int)(start); }
    {char * delim; delim = (char *)(start); }
    {int ret; ret = (int)(start); }
    {int num_results; num_results = (int)(start); }
    {int tlv1; tlv1 = (int)(start); }
    {void * tlv4; tlv4 = (void *)(start); }
    {void * tlv3; tlv3 = (void *)(start); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(start); }
    {char * tlv8; tlv8 = (char *)(start); }
    {char * tlv7; tlv7 = (char *)(start); }
}
void fix_ingred_service_1_2_2(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(count); }
    {char * end; end = (char *)(count); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(count); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(count); }
    {int ret; ret = (int)(count); }
    {int num_results; num_results = (int)(count); }
    {int tlv1; tlv1 = (int)(count); }
    {void * tlv4; tlv4 = (void *)(count); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(count); }
    {char * tlv8; tlv8 = (char *)(count); }
    {char * tlv7; tlv7 = (char *)(count); }
}
void fix_ingred_service_1_2(){
fix_ingred_service_1_2_0();
fix_ingred_service_1_2_1();
fix_ingred_service_1_2_2();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d27f28>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d1d2e8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=0/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=1/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=2/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
Skipping RESULT_VALUE_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=3/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=4/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=5/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=6/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=7/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=8/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=9/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=10/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=11/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=12/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=15/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/18][j=4/7][dd=16/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
not valid - int tlv1; tlv1 = ((int)tlv1);

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_service_1_4_10(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char * start; start = (char *)(tlv1); }
    {char * end; end = (char *)(tlv1); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv1); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(tlv1); }
    {int count; count = (int)(tlv1); }
    {int i; i = (int)(tlv1); }
    {char * delim; delim = (char *)(tlv1); }
    {int ret; ret = (int)(tlv1); }
    {int num_results; num_results = (int)(tlv1); }
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {void * tlv3; tlv3 = (void *)(tlv1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv1); }
    {char * tlv8; tlv8 = (char *)(tlv1); }
    {char * tlv7; tlv7 = (char *)(tlv1); }
}
void fix_ingred_service_1_4(){
fix_ingred_service_1_4_10();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv8': 'char *', 'tlv7': 'char *'}'
val_s=>'[('char *', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d01208>), ('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d03198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d27f28>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d1d2e8>)]'
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=0/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
unique : ('char *', 'end', None)
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=0/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
unique : ('char', 'value [ RESULT_VALUE_SIZE ]', None)
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=1/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=1/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=2/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=2/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
Skipping RESULT_VALUE_SIZE => #define
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=3/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=3/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=4/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=4/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=5/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=5/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=6/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=6/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=7/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=7/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=8/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=8/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=9/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=9/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=10/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=10/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=11/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=11/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=12/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=12/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=15/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=15/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=1/18][j=5/7][dd=16/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=1/18][j=5/7][dd=16/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
not unique: ('char', 'value [ RESULT_VALUE_SIZE ]', None) ... continue!
not valid - char * end; end = ((char *)++ end);

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char','value [ RESULT_VALUE_SIZE ]','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char','value [ RESULT_VALUE_SIZE ]','None','None');

==== Scope 1 ====
void fix_ingred_service_1_5_0(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {char * start; start = (char *)(++ end); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(++ end); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(++ end); }
    {int count; count = (int)(++ end); }
    {int i; i = (int)(++ end); }
    {char * delim; delim = (char *)(++ end); }
    {int ret; ret = (int)(++ end); }
    {int num_results; num_results = (int)(++ end); }
    {int tlv1; tlv1 = (int)(++ end); }
    {void * tlv4; tlv4 = (void *)(++ end); }
    {void * tlv3; tlv3 = (void *)(++ end); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(++ end); }
    {char * tlv8; tlv8 = (char *)(++ end); }
    {char * tlv7; tlv7 = (char *)(++ end); }
}
void fix_ingred_service_1_5_1(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {char * start; start = (char *)(value); }
    {char * end; end = (char *)(value); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(value); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(value); }
    {int count; count = (int)(value); }
    {int i; i = (int)(value); }
    {char * delim; delim = (char *)(value); }
    {int ret; ret = (int)(value); }
    {int num_results; num_results = (int)(value); }
    {int tlv1; tlv1 = (int)(value); }
    {void * tlv4; tlv4 = (void *)(value); }
    {void * tlv3; tlv3 = (void *)(value); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(value); }
    {char * tlv8; tlv8 = (char *)(value); }
    {char * tlv7; tlv7 = (char *)(value); }
}
void fix_ingred_service_1_5(){
fix_ingred_service_1_5_0();
fix_ingred_service_1_5_1();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'num_results': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv8': 'char *', 'tlv7': 'char *', 'tlv9': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b18ac8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b29a58>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d17f98>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d26f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d30dd8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d28c88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d237b8>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfa2e8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cfadd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d27f28>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4d1d2e8>)]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
==== Scope 2 ====
void fix_ingred_service_1_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(NULL); }
    {char * end; end = (char *)(NULL); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(NULL); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(NULL); }
    {int ret; ret = (int)(NULL); }
    {int num_results; num_results = (int)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
    {void * tlv4; tlv4 = (void *)(NULL); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(NULL); }
    {char * tlv8; tlv8 = (char *)(NULL); }
    {char * tlv7; tlv7 = (char *)(NULL); }
}
void fix_ingred_service_1_0_2(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(0); }
    {char * end; end = (char *)(0); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(0); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(0); }
    {int ret; ret = (int)(0); }
    {int num_results; num_results = (int)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {char * tlv8; tlv8 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
}
void fix_ingred_service_1_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(KEYVAL_DELIM); }
    {char * end; end = (char *)(KEYVAL_DELIM); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(KEYVAL_DELIM); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(KEYVAL_DELIM); }
    {int count; count = (int)(KEYVAL_DELIM); }
    {int i; i = (int)(KEYVAL_DELIM); }
    {char * delim; delim = (char *)(KEYVAL_DELIM); }
    {int ret; ret = (int)(KEYVAL_DELIM); }
    {int num_results; num_results = (int)(KEYVAL_DELIM); }
    {int tlv1; tlv1 = (int)(KEYVAL_DELIM); }
    {void * tlv4; tlv4 = (void *)(KEYVAL_DELIM); }
    {void * tlv3; tlv3 = (void *)(KEYVAL_DELIM); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(KEYVAL_DELIM); }
    {char * tlv8; tlv8 = (char *)(KEYVAL_DELIM); }
    {char * tlv7; tlv7 = (char *)(KEYVAL_DELIM); }
}
void fix_ingred_service_1_0_7(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * start; start = (char *)(buffer); }
    {char * end; end = (char *)(buffer); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(buffer); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(buffer); }
    {int ret; ret = (int)(buffer); }
    {int num_results; num_results = (int)(buffer); }
    {int tlv1; tlv1 = (int)(buffer); }
    {void * tlv4; tlv4 = (void *)(buffer); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buffer); }
    {char * tlv8; tlv8 = (char *)(buffer); }
    {char * tlv7; tlv7 = (char *)(buffer); }
}
void fix_ingred_service_1_0_8(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {char * end; end = (char *)(start); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(start); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(start); }
    {int count; count = (int)(start); }
    {int i; i = (int)(start); }
    {char * delim; delim = (char *)(start); }
    {int ret; ret = (int)(start); }
    {int num_results; num_results = (int)(start); }
    {int tlv1; tlv1 = (int)(start); }
    {void * tlv4; tlv4 = (void *)(start); }
    {void * tlv3; tlv3 = (void *)(start); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(start); }
    {char * tlv8; tlv8 = (char *)(start); }
    {char * tlv7; tlv7 = (char *)(start); }
}
void fix_ingred_service_1_0(){
fix_ingred_service_1_0_0();
fix_ingred_service_1_0_2();
fix_ingred_service_1_0_4();
fix_ingred_service_1_0_7();
fix_ingred_service_1_0_8();
}
void fix_ingred_service_1_1_10(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(* end); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(* end); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(* end); }
    {int count; count = (int)(* end); }
    {int i; i = (int)(* end); }
    {char * delim; delim = (char *)(* end); }
    {int ret; ret = (int)(* end); }
    {int num_results; num_results = (int)(* end); }
    {int tlv1; tlv1 = (int)(* end); }
    {void * tlv4; tlv4 = (void *)(* end); }
    {void * tlv3; tlv3 = (void *)(* end); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(* end); }
    {char * tlv8; tlv8 = (char *)(* end); }
    {char * tlv7; tlv7 = (char *)(* end); }
}
void fix_ingred_service_1_1_11(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(* delim); }
    {char * end; end = (char *)(* delim); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(* delim); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(* delim); }
    {int ret; ret = (int)(* delim); }
    {int num_results; num_results = (int)(* delim); }
    {int tlv1; tlv1 = (int)(* delim); }
    {void * tlv4; tlv4 = (void *)(* delim); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(* delim); }
    {char * tlv8; tlv8 = (char *)(* delim); }
    {char * tlv7; tlv7 = (char *)(* delim); }
}
void fix_ingred_service_1_1_12(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(count); }
    {char * end; end = (char *)(count); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(count); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(count); }
    {int ret; ret = (int)(count); }
    {int num_results; num_results = (int)(count); }
    {int tlv1; tlv1 = (int)(count); }
    {void * tlv4; tlv4 = (void *)(count); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(count); }
    {char * tlv8; tlv8 = (char *)(count); }
    {char * tlv7; tlv7 = (char *)(count); }
}
void fix_ingred_service_1_1_13(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(KEY_SIZE); }
    {char * end; end = (char *)(KEY_SIZE); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(KEY_SIZE); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(KEY_SIZE); }
    {int count; count = (int)(KEY_SIZE); }
    {int i; i = (int)(KEY_SIZE); }
    {char * delim; delim = (char *)(KEY_SIZE); }
    {int ret; ret = (int)(KEY_SIZE); }
    {int num_results; num_results = (int)(KEY_SIZE); }
    {int tlv1; tlv1 = (int)(KEY_SIZE); }
    {void * tlv4; tlv4 = (void *)(KEY_SIZE); }
    {void * tlv3; tlv3 = (void *)(KEY_SIZE); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(KEY_SIZE); }
    {char * tlv8; tlv8 = (char *)(KEY_SIZE); }
    {char * tlv7; tlv7 = (char *)(KEY_SIZE); }
}
void fix_ingred_service_1_1(){
fix_ingred_service_1_1_10();
fix_ingred_service_1_1_11();
fix_ingred_service_1_1_12();
fix_ingred_service_1_1_13();
}
void fix_ingred_service_1_2_0(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(key); }
    {char * end; end = (char *)(key); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(key); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(key); }
    {int count; count = (int)(key); }
    {int i; i = (int)(key); }
    {char * delim; delim = (char *)(key); }
    {int ret; ret = (int)(key); }
    {int num_results; num_results = (int)(key); }
    {int tlv1; tlv1 = (int)(key); }
    {void * tlv4; tlv4 = (void *)(key); }
    {void * tlv3; tlv3 = (void *)(key); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(key); }
    {char * tlv8; tlv8 = (char *)(key); }
    {char * tlv7; tlv7 = (char *)(key); }
}
void fix_ingred_service_1_2_1(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {char * end; end = (char *)(start); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(start); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(start); }
    {int count; count = (int)(start); }
    {int i; i = (int)(start); }
    {char * delim; delim = (char *)(start); }
    {int ret; ret = (int)(start); }
    {int num_results; num_results = (int)(start); }
    {int tlv1; tlv1 = (int)(start); }
    {void * tlv4; tlv4 = (void *)(start); }
    {void * tlv3; tlv3 = (void *)(start); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(start); }
    {char * tlv8; tlv8 = (char *)(start); }
    {char * tlv7; tlv7 = (char *)(start); }
}
void fix_ingred_service_1_2_2(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {char * start; start = (char *)(count); }
    {char * end; end = (char *)(count); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(count); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(count); }
    {int ret; ret = (int)(count); }
    {int num_results; num_results = (int)(count); }
    {int tlv1; tlv1 = (int)(count); }
    {void * tlv4; tlv4 = (void *)(count); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(count); }
    {char * tlv8; tlv8 = (char *)(count); }
    {char * tlv7; tlv7 = (char *)(count); }
}
void fix_ingred_service_1_2(){
fix_ingred_service_1_2_0();
fix_ingred_service_1_2_1();
fix_ingred_service_1_2_2();
}
void fix_ingred_service_1_4_10(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char * start; start = (char *)(tlv1); }
    {char * end; end = (char *)(tlv1); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv1); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(tlv1); }
    {int count; count = (int)(tlv1); }
    {int i; i = (int)(tlv1); }
    {char * delim; delim = (char *)(tlv1); }
    {int ret; ret = (int)(tlv1); }
    {int num_results; num_results = (int)(tlv1); }
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {void * tlv3; tlv3 = (void *)(tlv1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv1); }
    {char * tlv8; tlv8 = (char *)(tlv1); }
    {char * tlv7; tlv7 = (char *)(tlv1); }
}
void fix_ingred_service_1_4(){
fix_ingred_service_1_4_10();
}
void fix_ingred_service_1_5_0(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {char * start; start = (char *)(++ end); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(++ end); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(++ end); }
    {int count; count = (int)(++ end); }
    {int i; i = (int)(++ end); }
    {char * delim; delim = (char *)(++ end); }
    {int ret; ret = (int)(++ end); }
    {int num_results; num_results = (int)(++ end); }
    {int tlv1; tlv1 = (int)(++ end); }
    {void * tlv4; tlv4 = (void *)(++ end); }
    {void * tlv3; tlv3 = (void *)(++ end); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(++ end); }
    {char * tlv8; tlv8 = (char *)(++ end); }
    {char * tlv7; tlv7 = (char *)(++ end); }
}
void fix_ingred_service_1_5_1(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {char * start; start = (char *)(value); }
    {char * end; end = (char *)(value); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(value); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(value); }
    {int count; count = (int)(value); }
    {int i; i = (int)(value); }
    {char * delim; delim = (char *)(value); }
    {int ret; ret = (int)(value); }
    {int num_results; num_results = (int)(value); }
    {int tlv1; tlv1 = (int)(value); }
    {void * tlv4; tlv4 = (void *)(value); }
    {void * tlv3; tlv3 = (void *)(value); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(value); }
    {char * tlv8; tlv8 = (char *)(value); }
    {char * tlv7; tlv7 = (char *)(value); }
}
void fix_ingred_service_1_5(){
fix_ingred_service_1_5_0();
fix_ingred_service_1_5_1();
}
void fix_ingred_service_1(){
fix_ingred_service_1_0();
fix_ingred_service_1_1();
fix_ingred_service_1_2();
fix_ingred_service_1_4();
fix_ingred_service_1_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_1_0_0();
void fix_ingred_service_1_0_2();
void fix_ingred_service_1_0_4();
void fix_ingred_service_1_0_7();
void fix_ingred_service_1_0_8();
void fix_ingred_service_1_0();
void fix_ingred_service_1_1_10();
void fix_ingred_service_1_1_11();
void fix_ingred_service_1_1_12();
void fix_ingred_service_1_1_13();
void fix_ingred_service_1_1();
void fix_ingred_service_1_2_0();
void fix_ingred_service_1_2_1();
void fix_ingred_service_1_2_2();
void fix_ingred_service_1_2();
void fix_ingred_service_1_4_10();
void fix_ingred_service_1_4();
void fix_ingred_service_1_5_0();
void fix_ingred_service_1_5_1();
void fix_ingred_service_1_5();
void fix_ingred_service_1();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char * start ;
def_vars[1]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char * end ;
def_vars[2]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char key [ KEY_SIZE ] = { 0 } ;
def_vars[3]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char value [ RESULT_VALUE_SIZE ] = { 0 } ;
def_vars[4]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : int count ;
def_vars[5]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[6]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char * delim ;
def_vars[7]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[8]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : int balance ;
def_vars[9]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[10]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[11]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[12]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[13]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = key ;
def_vars[14]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = BAL_STR ;
def_vars[15]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv8 ;
def_vars[16]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[17]: [cgc_parseBalanceResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv9 = value ;
sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=2/18][j=0/8][dd=8/18][k=0/10] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=2/18][j=0/8][dd=8/18][k=2/10] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=2/18][j=0/8][dd=8/18][k=4/10] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=2/18][j=0/8][dd=8/18][k=7/10] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=2/18][j=0/8][dd=8/18][k=8/10] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
unique : ('char *', 'start', None)
----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

UNIQ_INIT: ('char *','start','None','None');

==== Scope 1 ====
void fix_ingred_service_2_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(NULL); }
}
void fix_ingred_service_2_0_2(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(0); }
}
void fix_ingred_service_2_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(KEYVAL_DELIM); }
}
void fix_ingred_service_2_0_7(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(buffer); }
}
void fix_ingred_service_2_0_8(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(start); }
}
void fix_ingred_service_2_0(){
fix_ingred_service_2_0_0();
fix_ingred_service_2_0_2();
fix_ingred_service_2_0_4();
fix_ingred_service_2_0_7();
fix_ingred_service_2_0_8();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49c32e8>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49c37b8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49c3eb8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49c2208>)]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=2/18][j=1/8][dd=8/18][k=10/14] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
unique : ('char *', 'end', None)
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=2/18][j=1/8][dd=8/18][k=11/14] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
unique : ('char *', 'delim', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=2/18][j=1/8][dd=8/18][k=12/14] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=2/18][j=1/8][dd=8/18][k=13/14] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_2_1_10(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(* end); }
}
void fix_ingred_service_2_1_11(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(* delim); }
}
void fix_ingred_service_2_1_12(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(count); }
}
void fix_ingred_service_2_1_13(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(KEY_SIZE); }
}
void fix_ingred_service_2_1(){
fix_ingred_service_2_1_10();
fix_ingred_service_2_1_11();
fix_ingred_service_2_1_12();
fix_ingred_service_2_1_13();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f10b8>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49ea048>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49eaf28>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=2/18][j=2/8][dd=8/18][k=0/13] | type: void * ; var : tlv4 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
unique : ('char', 'key [ KEY_SIZE ]', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=2/18][j=2/8][dd=8/18][k=1/13] | type: void * ; var : tlv3 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
unique : ('char *', 'start', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=2/18][j=2/8][dd=8/18][k=2/13] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_2_2_0(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(key); }
}
void fix_ingred_service_2_2_1(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(start); }
}
void fix_ingred_service_2_2_2(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(count); }
}
void fix_ingred_service_2_2(){
fix_ingred_service_2_2_0();
fix_ingred_service_2_2_1();
fix_ingred_service_2_2_2();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cc978>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cccf8>)]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=2/18][j=4/8][dd=8/18][k=10/12] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_service_2_4_10(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {int balance; balance = (int)(tlv1); }
}
void fix_ingred_service_2_4(){
fix_ingred_service_2_4_10();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv8': 'char *', 'tlv7': 'char *'}'
val_s=>'[('char *', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49d9c18>), ('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49bcba8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cc978>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cccf8>)]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=2/18][j=5/8][dd=8/18][k=0/14] | type: char * ; var : tlv8 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
unique : ('char *', 'end', None)
is_func_ [v] => '[False, False, False]'
has_multiptr_refs 'value' - False OR  False
[i=2/18][j=5/8][dd=8/18][k=1/14] | type: char * ; var : tlv7 ; varinfo :  ; value_node : value (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : value
 => is literal (False) | is operator (False) value [vtype=char *]
BEFORE => literal (False) value => char *
AFTER => literal (False) value [ RESULT_VALUE_SIZE ] => char [size=RESULT_VALUE_SIZE]
Array size is variable => 'RESULT_VALUE_SIZE'
unique : ('char', 'value [ RESULT_VALUE_SIZE ]', None)
----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char','value [ RESULT_VALUE_SIZE ]','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char','value [ RESULT_VALUE_SIZE ]','None','None');

==== Scope 1 ====
void fix_ingred_service_2_5_0(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {int balance; balance = (int)(++ end); }
}
void fix_ingred_service_2_5_1(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {int balance; balance = (int)(value); }
}
void fix_ingred_service_2_5(){
fix_ingred_service_2_5_0();
fix_ingred_service_2_5_1();
}

sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv8': 'char *', 'tlv7': 'char *', 'tlv9': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cc978>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cccf8>)]'
Skipping KEY_SIZE => #define
Skipping RESULT_VALUE_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'value': 'char *', 'value [ RESULT_VALUE_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'balance': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'int', 'tlv6': 'const char *', 'tlv5': 'const char *', 'tlv8': 'char *', 'tlv7': 'char *', 'tlv9': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d19518>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c64a8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49efb38>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f29e8>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49db978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e0828>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49c16d8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5208>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49b5cf8>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49e9828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cc978>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49cccf8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49cf208>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49cf518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49cfac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49cfdd8>)]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=0/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
unique : ('int', 'balance', None)
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=0/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=1/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=1/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
Skipping KEY_SIZE => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=2/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=2/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
Skipping RESULT_VALUE_SIZE => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=3/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=3/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=4/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=4/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=5/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=5/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=6/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=6/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=7/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=7/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=8/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=8/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=9/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=9/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=10/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=10/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=11/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=11/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=12/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=12/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=15/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=15/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'balance' - False OR  False
[i=2/18][j=7/8][dd=16/18][k=12/16] | type: int ; var :  ; varinfo :  ; value_node : balance (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : balance
 => is literal (False) | is operator (False) balance [vtype=int]
not unique: ('int', 'balance', None) ... continue!
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '255' - False OR  False
[i=2/18][j=7/8][dd=16/18][k=15/16] | type: int ; var :  ; varinfo :  ; value_node : 255 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 255
 => is literal (True) | is operator (False) 255
not valid - int balance; balance = ((int)balance);

----
UNIQ_INIT: ('int','balance','None','None');

----
UNIQ_INIT: ('int','balance','None','None');

==== Scope 1 ====
void fix_ingred_service_2_7_12(){
int balance;
    bzero(&balance,sizeof(int));
    {char * start; start = (char *)(balance); }
    {char * end; end = (char *)(balance); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(balance); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(balance); }
    {int count; count = (int)(balance); }
    {int i; i = (int)(balance); }
    {char * delim; delim = (char *)(balance); }
    {int ret; ret = (int)(balance); }
    {int tlv1; tlv1 = (int)(balance); }
    {void * tlv4; tlv4 = (void *)(balance); }
    {void * tlv3; tlv3 = (void *)(balance); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(balance); }
    {char * tlv8; tlv8 = (char *)(balance); }
    {char * tlv7; tlv7 = (char *)(balance); }
}
void fix_ingred_service_2_7_15(){
int balance;
    bzero(&balance,sizeof(int));
    {char * start; start = (char *)(255); }
    {char * end; end = (char *)(255); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(255); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(255); }
    {int count; count = (int)(255); }
    {int i; i = (int)(255); }
    {char * delim; delim = (char *)(255); }
    {int ret; ret = (int)(255); }
    {int balance; balance = (int)(255); }
    {int tlv1; tlv1 = (int)(255); }
    {void * tlv4; tlv4 = (void *)(255); }
    {void * tlv3; tlv3 = (void *)(255); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(255); }
    {char * tlv8; tlv8 = (char *)(255); }
    {char * tlv7; tlv7 = (char *)(255); }
}
void fix_ingred_service_2_7(){
fix_ingred_service_2_7_12();
fix_ingred_service_2_7_15();
}

==== Scope 2 ====
void fix_ingred_service_2_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(NULL); }
}
void fix_ingred_service_2_0_2(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(0); }
}
void fix_ingred_service_2_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(KEYVAL_DELIM); }
}
void fix_ingred_service_2_0_7(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(buffer); }
}
void fix_ingred_service_2_0_8(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {int balance; balance = (int)(start); }
}
void fix_ingred_service_2_0(){
fix_ingred_service_2_0_0();
fix_ingred_service_2_0_2();
fix_ingred_service_2_0_4();
fix_ingred_service_2_0_7();
fix_ingred_service_2_0_8();
}
void fix_ingred_service_2_1_10(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(* end); }
}
void fix_ingred_service_2_1_11(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(* delim); }
}
void fix_ingred_service_2_1_12(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(count); }
}
void fix_ingred_service_2_1_13(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(KEY_SIZE); }
}
void fix_ingred_service_2_1(){
fix_ingred_service_2_1_10();
fix_ingred_service_2_1_11();
fix_ingred_service_2_1_12();
fix_ingred_service_2_1_13();
}
void fix_ingred_service_2_2_0(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(key); }
}
void fix_ingred_service_2_2_1(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(start); }
}
void fix_ingred_service_2_2_2(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {int balance; balance = (int)(count); }
}
void fix_ingred_service_2_2(){
fix_ingred_service_2_2_0();
fix_ingred_service_2_2_1();
fix_ingred_service_2_2_2();
}
void fix_ingred_service_2_4_10(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {int balance; balance = (int)(tlv1); }
}
void fix_ingred_service_2_4(){
fix_ingred_service_2_4_10();
}
void fix_ingred_service_2_5_0(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {int balance; balance = (int)(++ end); }
}
void fix_ingred_service_2_5_1(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char value [ RESULT_VALUE_SIZE ];
    bzero(&value,( RESULT_VALUE_SIZE *sizeof(char) ) );
    {int balance; balance = (int)(value); }
}
void fix_ingred_service_2_5(){
fix_ingred_service_2_5_0();
fix_ingred_service_2_5_1();
}
void fix_ingred_service_2_7_12(){
int balance;
    bzero(&balance,sizeof(int));
    {char * start; start = (char *)(balance); }
    {char * end; end = (char *)(balance); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(balance); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(balance); }
    {int count; count = (int)(balance); }
    {int i; i = (int)(balance); }
    {char * delim; delim = (char *)(balance); }
    {int ret; ret = (int)(balance); }
    {int tlv1; tlv1 = (int)(balance); }
    {void * tlv4; tlv4 = (void *)(balance); }
    {void * tlv3; tlv3 = (void *)(balance); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(balance); }
    {char * tlv8; tlv8 = (char *)(balance); }
    {char * tlv7; tlv7 = (char *)(balance); }
}
void fix_ingred_service_2_7_15(){
int balance;
    bzero(&balance,sizeof(int));
    {char * start; start = (char *)(255); }
    {char * end; end = (char *)(255); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(255); }
    {char value [ RESULT_VALUE_SIZE ]; value [ ( RESULT_VALUE_SIZE )-1 ] = (char)(255); }
    {int count; count = (int)(255); }
    {int i; i = (int)(255); }
    {char * delim; delim = (char *)(255); }
    {int ret; ret = (int)(255); }
    {int balance; balance = (int)(255); }
    {int tlv1; tlv1 = (int)(255); }
    {void * tlv4; tlv4 = (void *)(255); }
    {void * tlv3; tlv3 = (void *)(255); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(255); }
    {char * tlv8; tlv8 = (char *)(255); }
    {char * tlv7; tlv7 = (char *)(255); }
}
void fix_ingred_service_2_7(){
fix_ingred_service_2_7_12();
fix_ingred_service_2_7_15();
}
void fix_ingred_service_2(){
fix_ingred_service_2_0();
fix_ingred_service_2_1();
fix_ingred_service_2_2();
fix_ingred_service_2_4();
fix_ingred_service_2_5();
fix_ingred_service_2_7();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_2_0_0();
void fix_ingred_service_2_0_2();
void fix_ingred_service_2_0_4();
void fix_ingred_service_2_0_7();
void fix_ingred_service_2_0_8();
void fix_ingred_service_2_0();
void fix_ingred_service_2_1_10();
void fix_ingred_service_2_1_11();
void fix_ingred_service_2_1_12();
void fix_ingred_service_2_1_13();
void fix_ingred_service_2_1();
void fix_ingred_service_2_2_0();
void fix_ingred_service_2_2_1();
void fix_ingred_service_2_2_2();
void fix_ingred_service_2_2();
void fix_ingred_service_2_4_10();
void fix_ingred_service_2_4();
void fix_ingred_service_2_5_0();
void fix_ingred_service_2_5_1();
void fix_ingred_service_2_5();
void fix_ingred_service_2_7_12();
void fix_ingred_service_2_7_15();
void fix_ingred_service_2_7();
void fix_ingred_service_2();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * start ;
def_vars[1]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * end ;
def_vars[2]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char key [ KEY_SIZE ] = { 0 } ;
def_vars[3]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int count ;
def_vars[4]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[5]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * delim ;
def_vars[6]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[7]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : void * tlv8 ;
def_vars[8]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv7 ;
def_vars[9]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv6 ;
def_vars[10]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[11]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : void * tlv11 ;
def_vars[12]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : void * tlv10 ;
def_vars[13]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv9 ;
def_vars[14]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv16 = key ;
def_vars[15]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv15 = SONG_ID_STR ;
def_vars[16]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : void * tlv14 ;
def_vars[17]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv13 ;
def_vars[18]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv12 ;
def_vars[19]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[20]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv18 ;
def_vars[21]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv17 ;
def_vars[22]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv20 = key ;
def_vars[23]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv19 = PRICE_STR ;
def_vars[24]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[25]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv22 ;
def_vars[26]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv21 ;
def_vars[27]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv24 = key ;
def_vars[28]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv23 = ARTIST_STR ;
def_vars[29]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[30]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv26 ;
def_vars[31]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv25 ;
def_vars[32]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv28 = key ;
def_vars[33]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv27 = ALBUM_STR ;
def_vars[34]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[35]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv30 ;
def_vars[36]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv29 ;
def_vars[37]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv32 = key ;
def_vars[38]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv31 = SONG_STR ;
def_vars[39]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv34 ;
def_vars[40]: [cgc_parseSearchResult] : <class 'CParser.CParser.DeclarationContext'> : char * tlv33 ;
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=7/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=7/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=7/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=7/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=8/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=8/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=8/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=8/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=9/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=9/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=9/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=9/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=11/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=11/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=11/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=11/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=12/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=12/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=12/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=12/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=13/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=13/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=13/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=13/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=16/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=16/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=16/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=16/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=17/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=17/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=17/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=17/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=18/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=18/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=18/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=18/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=19/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=19/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=19/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=19/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=20/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=20/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=20/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=20/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=21/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=21/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=21/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=21/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=24/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=24/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=24/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=24/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=25/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=25/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=25/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=25/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=26/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=26/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=26/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=26/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=29/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=29/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=29/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=29/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=30/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=30/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=30/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=30/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=31/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=31/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=31/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=31/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=34/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=34/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=34/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=34/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=35/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=35/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=35/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=35/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=36/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=36/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=36/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=36/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=39/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=39/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=39/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=39/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=3/18][j=0/26][dd=40/41][k=0/7] | type: char * ; var : start ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/18][j=0/26][dd=40/41][k=2/7] | type: int ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEYVAL_DELIM' - False OR  False
[i=3/18][j=0/26][dd=40/41][k=4/7] | type: char * ; var : delim ; varinfo :  ; value_node : KEYVAL_DELIM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEYVAL_DELIM
 => is literal (False) | is operator (False) KEYVAL_DELIM [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=3/18][j=0/26][dd=40/41][k=6/7] | type: char * ; var : start ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
----
UNIQ_INIT: ('char *','buffer','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

----
UNIQ_INIT: ('char *','buffer','None','None');

==== Scope 1 ====
void fix_ingred_service_3_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(NULL); }
    {int tlv7; tlv7 = (int)(NULL); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NULL); }
    {void * tlv11; tlv11 = (void *)(NULL); }
    {void * tlv10; tlv10 = (void *)(NULL); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(NULL); }
    {void * tlv14; tlv14 = (void *)(NULL); }
    {int tlv13; tlv13 = (int)(NULL); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(NULL); }
    {int tlv2; tlv2 = (int)(NULL); }
    {char * tlv18; tlv18 = (char *)(NULL); }
    {char * tlv17; tlv17 = (char *)(NULL); }
    {int tlv3; tlv3 = (int)(NULL); }
    {char * tlv22; tlv22 = (char *)(NULL); }
    {char * tlv21; tlv21 = (char *)(NULL); }
    {int tlv4; tlv4 = (int)(NULL); }
    {char * tlv26; tlv26 = (char *)(NULL); }
    {char * tlv25; tlv25 = (char *)(NULL); }
    {int tlv5; tlv5 = (int)(NULL); }
    {char * tlv30; tlv30 = (char *)(NULL); }
    {char * tlv29; tlv29 = (char *)(NULL); }
    {char * tlv34; tlv34 = (char *)(NULL); }
    {char * tlv33; tlv33 = (char *)(NULL); }
}
void fix_ingred_service_3_0_2(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {void * tlv10; tlv10 = (void *)(0); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {int tlv13; tlv13 = (int)(0); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {char * tlv18; tlv18 = (char *)(0); }
    {char * tlv17; tlv17 = (char *)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {char * tlv22; tlv22 = (char *)(0); }
    {char * tlv21; tlv21 = (char *)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {char * tlv26; tlv26 = (char *)(0); }
    {char * tlv25; tlv25 = (char *)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char * tlv30; tlv30 = (char *)(0); }
    {char * tlv29; tlv29 = (char *)(0); }
    {char * tlv34; tlv34 = (char *)(0); }
    {char * tlv33; tlv33 = (char *)(0); }
}
void fix_ingred_service_3_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(KEYVAL_DELIM); }
    {int tlv7; tlv7 = (int)(KEYVAL_DELIM); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(KEYVAL_DELIM); }
    {void * tlv11; tlv11 = (void *)(KEYVAL_DELIM); }
    {void * tlv10; tlv10 = (void *)(KEYVAL_DELIM); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(KEYVAL_DELIM); }
    {void * tlv14; tlv14 = (void *)(KEYVAL_DELIM); }
    {int tlv13; tlv13 = (int)(KEYVAL_DELIM); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(KEYVAL_DELIM); }
    {int tlv2; tlv2 = (int)(KEYVAL_DELIM); }
    {char * tlv18; tlv18 = (char *)(KEYVAL_DELIM); }
    {char * tlv17; tlv17 = (char *)(KEYVAL_DELIM); }
    {int tlv3; tlv3 = (int)(KEYVAL_DELIM); }
    {char * tlv22; tlv22 = (char *)(KEYVAL_DELIM); }
    {char * tlv21; tlv21 = (char *)(KEYVAL_DELIM); }
    {int tlv4; tlv4 = (int)(KEYVAL_DELIM); }
    {char * tlv26; tlv26 = (char *)(KEYVAL_DELIM); }
    {char * tlv25; tlv25 = (char *)(KEYVAL_DELIM); }
    {int tlv5; tlv5 = (int)(KEYVAL_DELIM); }
    {char * tlv30; tlv30 = (char *)(KEYVAL_DELIM); }
    {char * tlv29; tlv29 = (char *)(KEYVAL_DELIM); }
    {char * tlv34; tlv34 = (char *)(KEYVAL_DELIM); }
    {char * tlv33; tlv33 = (char *)(KEYVAL_DELIM); }
}
void fix_ingred_service_3_0_6(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(buffer); }
    {int tlv7; tlv7 = (int)(buffer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(buffer); }
    {void * tlv11; tlv11 = (void *)(buffer); }
    {void * tlv10; tlv10 = (void *)(buffer); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(buffer); }
    {void * tlv14; tlv14 = (void *)(buffer); }
    {int tlv13; tlv13 = (int)(buffer); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(buffer); }
    {int tlv2; tlv2 = (int)(buffer); }
    {char * tlv18; tlv18 = (char *)(buffer); }
    {char * tlv17; tlv17 = (char *)(buffer); }
    {int tlv3; tlv3 = (int)(buffer); }
    {char * tlv22; tlv22 = (char *)(buffer); }
    {char * tlv21; tlv21 = (char *)(buffer); }
    {int tlv4; tlv4 = (int)(buffer); }
    {char * tlv26; tlv26 = (char *)(buffer); }
    {char * tlv25; tlv25 = (char *)(buffer); }
    {int tlv5; tlv5 = (int)(buffer); }
    {char * tlv30; tlv30 = (char *)(buffer); }
    {char * tlv29; tlv29 = (char *)(buffer); }
    {char * tlv34; tlv34 = (char *)(buffer); }
    {char * tlv33; tlv33 = (char *)(buffer); }
}
void fix_ingred_service_3_0(){
fix_ingred_service_3_0_0();
fix_ingred_service_3_0_2();
fix_ingred_service_3_0_4();
fix_ingred_service_3_0_6();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b02e8>), ('int', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4881198>), ('cgc_size_t', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48a50b8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>)]'
cval_s=>'[]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=0/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
unique : ('Song *', 'song', None)
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=0/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=1/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=1/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=2/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=2/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=3/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=3/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=4/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=4/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=5/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=5/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=6/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=6/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=7/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=7/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=8/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=8/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=9/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=9/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=10/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=10/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=11/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=11/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=12/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=12/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=13/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=13/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=16/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=16/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=17/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=17/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=18/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=18/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=19/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=19/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=20/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=20/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=21/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=21/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=24/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=24/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=25/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=25/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=26/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=26/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=29/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=29/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=30/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=30/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=31/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=31/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=34/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=34/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=35/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=35/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=36/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=36/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=39/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=39/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song' - False OR  False
[i=3/18][j=1/26][dd=40/41][k=0/9] | type: void * ; var : tlv8 ; varinfo :  ; value_node : song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'SONG_SIZE' - False OR  False
[i=3/18][j=1/26][dd=40/41][k=2/9] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : SONG_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : SONG_SIZE
 => is literal (False) | is operator (False) SONG_SIZE [vtype=None]
----
UNIQ_INIT: ('Song *','song','None','None');

----
UNIQ_INIT: ('Song *','song','None','None');

==== Scope 1 ====
void fix_ingred_service_3_1_0(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song); }
    {char * end; end = (char *)(song); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song); }
    {int count; count = (int)(song); }
    {int i; i = (int)(song); }
    {char * delim; delim = (char *)(song); }
    {int ret; ret = (int)(song); }
    {void * tlv8; tlv8 = (void *)(song); }
    {int tlv7; tlv7 = (int)(song); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song); }
    {int tlv1; tlv1 = (int)(song); }
    {void * tlv11; tlv11 = (void *)(song); }
    {void * tlv10; tlv10 = (void *)(song); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song); }
    {void * tlv14; tlv14 = (void *)(song); }
    {int tlv13; tlv13 = (int)(song); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song); }
    {int tlv2; tlv2 = (int)(song); }
    {char * tlv18; tlv18 = (char *)(song); }
    {char * tlv17; tlv17 = (char *)(song); }
    {int tlv3; tlv3 = (int)(song); }
    {char * tlv22; tlv22 = (char *)(song); }
    {char * tlv21; tlv21 = (char *)(song); }
    {int tlv4; tlv4 = (int)(song); }
    {char * tlv26; tlv26 = (char *)(song); }
    {char * tlv25; tlv25 = (char *)(song); }
    {int tlv5; tlv5 = (int)(song); }
    {char * tlv30; tlv30 = (char *)(song); }
    {char * tlv29; tlv29 = (char *)(song); }
    {char * tlv34; tlv34 = (char *)(song); }
    {char * tlv33; tlv33 = (char *)(song); }
}
void fix_ingred_service_3_1_2(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(SONG_SIZE); }
    {char * end; end = (char *)(SONG_SIZE); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(SONG_SIZE); }
    {int count; count = (int)(SONG_SIZE); }
    {int i; i = (int)(SONG_SIZE); }
    {char * delim; delim = (char *)(SONG_SIZE); }
    {int ret; ret = (int)(SONG_SIZE); }
    {void * tlv8; tlv8 = (void *)(SONG_SIZE); }
    {int tlv7; tlv7 = (int)(SONG_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(SONG_SIZE); }
    {int tlv1; tlv1 = (int)(SONG_SIZE); }
    {void * tlv11; tlv11 = (void *)(SONG_SIZE); }
    {void * tlv10; tlv10 = (void *)(SONG_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(SONG_SIZE); }
    {void * tlv14; tlv14 = (void *)(SONG_SIZE); }
    {int tlv13; tlv13 = (int)(SONG_SIZE); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(SONG_SIZE); }
    {int tlv2; tlv2 = (int)(SONG_SIZE); }
    {char * tlv18; tlv18 = (char *)(SONG_SIZE); }
    {char * tlv17; tlv17 = (char *)(SONG_SIZE); }
    {int tlv3; tlv3 = (int)(SONG_SIZE); }
    {char * tlv22; tlv22 = (char *)(SONG_SIZE); }
    {char * tlv21; tlv21 = (char *)(SONG_SIZE); }
    {int tlv4; tlv4 = (int)(SONG_SIZE); }
    {char * tlv26; tlv26 = (char *)(SONG_SIZE); }
    {char * tlv25; tlv25 = (char *)(SONG_SIZE); }
    {int tlv5; tlv5 = (int)(SONG_SIZE); }
    {char * tlv30; tlv30 = (char *)(SONG_SIZE); }
    {char * tlv29; tlv29 = (char *)(SONG_SIZE); }
    {char * tlv34; tlv34 = (char *)(SONG_SIZE); }
    {char * tlv33; tlv33 = (char *)(SONG_SIZE); }
}
void fix_ingred_service_3_1(){
fix_ingred_service_3_1_0();
fix_ingred_service_3_1_2();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t'}'
val_s=>'[('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=7/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
unique : ('char *', 'start', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=8/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=9/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=11/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=12/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=13/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=16/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=17/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=18/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=19/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=20/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=21/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=24/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=25/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=26/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=29/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=30/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=31/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=34/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=35/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=36/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=39/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=2/26][dd=40/41][k=0/9] | type: char * ; var : end ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
----
UNIQ_INIT: ('char *','start','None','None');

==== Scope 1 ====
void fix_ingred_service_3_2_0(){
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {void * tlv8; tlv8 = (void *)(start); }
    {int tlv7; tlv7 = (int)(start); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(start); }
    {void * tlv11; tlv11 = (void *)(start); }
    {void * tlv10; tlv10 = (void *)(start); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(start); }
    {void * tlv14; tlv14 = (void *)(start); }
    {int tlv13; tlv13 = (int)(start); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(start); }
    {int tlv2; tlv2 = (int)(start); }
    {char * tlv18; tlv18 = (char *)(start); }
    {char * tlv17; tlv17 = (char *)(start); }
    {int tlv3; tlv3 = (int)(start); }
    {char * tlv22; tlv22 = (char *)(start); }
    {char * tlv21; tlv21 = (char *)(start); }
    {int tlv4; tlv4 = (int)(start); }
    {char * tlv26; tlv26 = (char *)(start); }
    {char * tlv25; tlv25 = (char *)(start); }
    {int tlv5; tlv5 = (int)(start); }
    {char * tlv30; tlv30 = (char *)(start); }
    {char * tlv29; tlv29 = (char *)(start); }
    {char * tlv34; tlv34 = (char *)(start); }
    {char * tlv33; tlv33 = (char *)(start); }
}
void fix_ingred_service_3_2(){
fix_ingred_service_3_2_0();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb488e588>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb488ea58>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4878198>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb48784a8>)]'
Skipping KEY_SIZE => #define
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=7/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
unique : ('char *', 'end', None)
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=7/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
unique : ('char *', 'delim', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=7/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=7/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=8/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=8/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=8/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=8/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=9/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=9/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=9/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=9/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=11/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=11/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=11/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=11/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=12/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=12/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=12/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=12/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=13/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=13/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=13/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=13/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=16/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=16/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=16/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=16/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=17/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=17/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=17/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=17/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=18/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=18/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=18/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=18/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=19/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=19/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=19/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=19/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=20/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=20/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=20/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=20/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=21/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=21/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=21/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=21/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=24/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=24/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=24/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=24/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=25/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=25/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=25/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=25/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=26/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=26/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=26/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=26/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=29/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=29/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=29/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=29/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=30/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=30/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=30/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=30/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=31/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=31/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=31/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=31/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=34/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=34/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=34/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=34/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=35/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=35/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=35/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=35/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=36/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=36/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=36/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=36/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=39/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=39/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=39/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=39/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*end' - False OR  False
[i=3/18][j=3/26][dd=40/41][k=9/13] | type: char ; var :  ; varinfo :  ; value_node : * end (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,end
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*delim' - False OR  False
[i=3/18][j=3/26][dd=40/41][k=10/13] | type: char ; var :  ; varinfo :  ; value_node : * delim (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,delim
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) delim [vtype=char *]
not unique: ('char *', 'delim', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=3/26][dd=40/41][k=11/13] | type: int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=3/26][dd=40/41][k=12/13] | type: int ; var :  ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char *','end','None','None');

UNIQ_INIT: ('char *','delim','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_3_3_9(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(* end); }
    {int tlv7; tlv7 = (int)(* end); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(* end); }
    {void * tlv11; tlv11 = (void *)(* end); }
    {void * tlv10; tlv10 = (void *)(* end); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(* end); }
    {void * tlv14; tlv14 = (void *)(* end); }
    {int tlv13; tlv13 = (int)(* end); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(* end); }
    {int tlv2; tlv2 = (int)(* end); }
    {char * tlv18; tlv18 = (char *)(* end); }
    {char * tlv17; tlv17 = (char *)(* end); }
    {int tlv3; tlv3 = (int)(* end); }
    {char * tlv22; tlv22 = (char *)(* end); }
    {char * tlv21; tlv21 = (char *)(* end); }
    {int tlv4; tlv4 = (int)(* end); }
    {char * tlv26; tlv26 = (char *)(* end); }
    {char * tlv25; tlv25 = (char *)(* end); }
    {int tlv5; tlv5 = (int)(* end); }
    {char * tlv30; tlv30 = (char *)(* end); }
    {char * tlv29; tlv29 = (char *)(* end); }
    {char * tlv34; tlv34 = (char *)(* end); }
    {char * tlv33; tlv33 = (char *)(* end); }
}
void fix_ingred_service_3_3_10(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(* delim); }
    {int tlv7; tlv7 = (int)(* delim); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(* delim); }
    {void * tlv11; tlv11 = (void *)(* delim); }
    {void * tlv10; tlv10 = (void *)(* delim); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(* delim); }
    {void * tlv14; tlv14 = (void *)(* delim); }
    {int tlv13; tlv13 = (int)(* delim); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(* delim); }
    {int tlv2; tlv2 = (int)(* delim); }
    {char * tlv18; tlv18 = (char *)(* delim); }
    {char * tlv17; tlv17 = (char *)(* delim); }
    {int tlv3; tlv3 = (int)(* delim); }
    {char * tlv22; tlv22 = (char *)(* delim); }
    {char * tlv21; tlv21 = (char *)(* delim); }
    {int tlv4; tlv4 = (int)(* delim); }
    {char * tlv26; tlv26 = (char *)(* delim); }
    {char * tlv25; tlv25 = (char *)(* delim); }
    {int tlv5; tlv5 = (int)(* delim); }
    {char * tlv30; tlv30 = (char *)(* delim); }
    {char * tlv29; tlv29 = (char *)(* delim); }
    {char * tlv34; tlv34 = (char *)(* delim); }
    {char * tlv33; tlv33 = (char *)(* delim); }
}
void fix_ingred_service_3_3_11(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(count); }
    {int tlv7; tlv7 = (int)(count); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(count); }
    {void * tlv11; tlv11 = (void *)(count); }
    {void * tlv10; tlv10 = (void *)(count); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(count); }
    {void * tlv14; tlv14 = (void *)(count); }
    {int tlv13; tlv13 = (int)(count); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(count); }
    {int tlv2; tlv2 = (int)(count); }
    {char * tlv18; tlv18 = (char *)(count); }
    {char * tlv17; tlv17 = (char *)(count); }
    {int tlv3; tlv3 = (int)(count); }
    {char * tlv22; tlv22 = (char *)(count); }
    {char * tlv21; tlv21 = (char *)(count); }
    {int tlv4; tlv4 = (int)(count); }
    {char * tlv26; tlv26 = (char *)(count); }
    {char * tlv25; tlv25 = (char *)(count); }
    {int tlv5; tlv5 = (int)(count); }
    {char * tlv30; tlv30 = (char *)(count); }
    {char * tlv29; tlv29 = (char *)(count); }
    {char * tlv34; tlv34 = (char *)(count); }
    {char * tlv33; tlv33 = (char *)(count); }
}
void fix_ingred_service_3_3_12(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(KEY_SIZE); }
    {int tlv7; tlv7 = (int)(KEY_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(KEY_SIZE); }
    {void * tlv11; tlv11 = (void *)(KEY_SIZE); }
    {void * tlv10; tlv10 = (void *)(KEY_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(KEY_SIZE); }
    {void * tlv14; tlv14 = (void *)(KEY_SIZE); }
    {int tlv13; tlv13 = (int)(KEY_SIZE); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(KEY_SIZE); }
    {int tlv2; tlv2 = (int)(KEY_SIZE); }
    {char * tlv18; tlv18 = (char *)(KEY_SIZE); }
    {char * tlv17; tlv17 = (char *)(KEY_SIZE); }
    {int tlv3; tlv3 = (int)(KEY_SIZE); }
    {char * tlv22; tlv22 = (char *)(KEY_SIZE); }
    {char * tlv21; tlv21 = (char *)(KEY_SIZE); }
    {int tlv4; tlv4 = (int)(KEY_SIZE); }
    {char * tlv26; tlv26 = (char *)(KEY_SIZE); }
    {char * tlv25; tlv25 = (char *)(KEY_SIZE); }
    {int tlv5; tlv5 = (int)(KEY_SIZE); }
    {char * tlv30; tlv30 = (char *)(KEY_SIZE); }
    {char * tlv29; tlv29 = (char *)(KEY_SIZE); }
    {char * tlv34; tlv34 = (char *)(KEY_SIZE); }
    {char * tlv33; tlv33 = (char *)(KEY_SIZE); }
}
void fix_ingred_service_3_3(){
fix_ingred_service_3_3_9();
fix_ingred_service_3_3_10();
fix_ingred_service_3_3_11();
fix_ingred_service_3_3_12();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4884358>), ('void *', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48a92e8>), ('cgc_size_t', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4896208>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=7/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
unique : ('char', 'key [ KEY_SIZE ]', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=7/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
unique : ('char *', 'start', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=7/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
unique : ('int', 'count', None)
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=8/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=8/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=8/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=9/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=9/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=9/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=11/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=11/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=11/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=12/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=12/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=12/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=13/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=13/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=13/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=16/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=16/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=16/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=17/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=17/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=17/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=18/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=18/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=18/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=19/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=19/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=19/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=20/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=20/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=20/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=21/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=21/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=21/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=24/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=24/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=24/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=25/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=25/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=25/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=26/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=26/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=26/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=29/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=29/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=29/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=30/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=30/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=30/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=31/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=31/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=31/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=34/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=34/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=34/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=35/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=35/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=35/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=36/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=36/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=36/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=39/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=39/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=39/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
is_func_ [k] => '[False, False, False]'
has_multiptr_refs 'key' - False OR  False
[i=3/18][j=4/26][dd=40/41][k=0/12] | type: void * ; var : tlv11 ; varinfo :  ; value_node : key (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : key
 => is literal (False) | is operator (False) key [vtype=char *]
BEFORE => literal (False) key => char *
AFTER => literal (False) key [ KEY_SIZE ] => char [size=KEY_SIZE]
Array size is variable => 'KEY_SIZE'
not unique: ('char', 'key [ KEY_SIZE ]', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'start' - False OR  False
[i=3/18][j=4/26][dd=40/41][k=1/12] | type: void * ; var : tlv10 ; varinfo :  ; value_node : start (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : start
 => is literal (False) | is operator (False) start [vtype=char *]
not unique: ('char *', 'start', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=3/18][j=4/26][dd=40/41][k=2/12] | type: cgc_size_t ; var : tlv9 ; varinfo :  ; value_node : count (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=int]
not unique: ('int', 'count', None) ... continue!
----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

----
UNIQ_INIT: ('char','key [ KEY_SIZE ]','None','None');

UNIQ_INIT: ('char *','start','None','None');

UNIQ_INIT: ('int','count','None','None');

==== Scope 1 ====
void fix_ingred_service_3_4_0(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(key); }
    {int tlv7; tlv7 = (int)(key); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(key); }
    {void * tlv11; tlv11 = (void *)(key); }
    {void * tlv10; tlv10 = (void *)(key); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(key); }
    {void * tlv14; tlv14 = (void *)(key); }
    {int tlv13; tlv13 = (int)(key); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(key); }
    {int tlv2; tlv2 = (int)(key); }
    {char * tlv18; tlv18 = (char *)(key); }
    {char * tlv17; tlv17 = (char *)(key); }
    {int tlv3; tlv3 = (int)(key); }
    {char * tlv22; tlv22 = (char *)(key); }
    {char * tlv21; tlv21 = (char *)(key); }
    {int tlv4; tlv4 = (int)(key); }
    {char * tlv26; tlv26 = (char *)(key); }
    {char * tlv25; tlv25 = (char *)(key); }
    {int tlv5; tlv5 = (int)(key); }
    {char * tlv30; tlv30 = (char *)(key); }
    {char * tlv29; tlv29 = (char *)(key); }
    {char * tlv34; tlv34 = (char *)(key); }
    {char * tlv33; tlv33 = (char *)(key); }
}
void fix_ingred_service_3_4_1(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(start); }
    {int tlv7; tlv7 = (int)(start); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(start); }
    {void * tlv11; tlv11 = (void *)(start); }
    {void * tlv10; tlv10 = (void *)(start); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(start); }
    {void * tlv14; tlv14 = (void *)(start); }
    {int tlv13; tlv13 = (int)(start); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(start); }
    {int tlv2; tlv2 = (int)(start); }
    {char * tlv18; tlv18 = (char *)(start); }
    {char * tlv17; tlv17 = (char *)(start); }
    {int tlv3; tlv3 = (int)(start); }
    {char * tlv22; tlv22 = (char *)(start); }
    {char * tlv21; tlv21 = (char *)(start); }
    {int tlv4; tlv4 = (int)(start); }
    {char * tlv26; tlv26 = (char *)(start); }
    {char * tlv25; tlv25 = (char *)(start); }
    {int tlv5; tlv5 = (int)(start); }
    {char * tlv30; tlv30 = (char *)(start); }
    {char * tlv29; tlv29 = (char *)(start); }
    {char * tlv34; tlv34 = (char *)(start); }
    {char * tlv33; tlv33 = (char *)(start); }
}
void fix_ingred_service_3_4_2(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(count); }
    {int tlv7; tlv7 = (int)(count); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(count); }
    {void * tlv11; tlv11 = (void *)(count); }
    {void * tlv10; tlv10 = (void *)(count); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(count); }
    {void * tlv14; tlv14 = (void *)(count); }
    {int tlv13; tlv13 = (int)(count); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(count); }
    {int tlv2; tlv2 = (int)(count); }
    {char * tlv18; tlv18 = (char *)(count); }
    {char * tlv17; tlv17 = (char *)(count); }
    {int tlv3; tlv3 = (int)(count); }
    {char * tlv22; tlv22 = (char *)(count); }
    {char * tlv21; tlv21 = (char *)(count); }
    {int tlv4; tlv4 = (int)(count); }
    {char * tlv26; tlv26 = (char *)(count); }
    {char * tlv25; tlv25 = (char *)(count); }
    {int tlv5; tlv5 = (int)(count); }
    {char * tlv30; tlv30 = (char *)(count); }
    {char * tlv29; tlv29 = (char *)(count); }
    {char * tlv34; tlv34 = (char *)(count); }
    {char * tlv33; tlv33 = (char *)(count); }
}
void fix_ingred_service_3_4(){
fix_ingred_service_3_4_0();
fix_ingred_service_3_4_1();
fix_ingred_service_3_4_2();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb48a6c18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb48a6f98>)]'
Skipping KEY_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=7/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=8/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=9/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=11/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=12/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=13/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=16/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=17/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=18/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=19/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=20/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=21/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=24/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=25/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=26/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=29/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=30/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=31/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=34/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=35/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=36/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=39/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/18][j=6/26][dd=40/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_service_3_6_9(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {void * tlv8; tlv8 = (void *)(tlv1); }
    {int tlv7; tlv7 = (int)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {void * tlv11; tlv11 = (void *)(tlv1); }
    {void * tlv10; tlv10 = (void *)(tlv1); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv1); }
    {void * tlv14; tlv14 = (void *)(tlv1); }
    {int tlv13; tlv13 = (int)(tlv1); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {char * tlv18; tlv18 = (char *)(tlv1); }
    {char * tlv17; tlv17 = (char *)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {char * tlv22; tlv22 = (char *)(tlv1); }
    {char * tlv21; tlv21 = (char *)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {char * tlv26; tlv26 = (char *)(tlv1); }
    {char * tlv25; tlv25 = (char *)(tlv1); }
    {int tlv5; tlv5 = (int)(tlv1); }
    {char * tlv30; tlv30 = (char *)(tlv1); }
    {char * tlv29; tlv29 = (char *)(tlv1); }
    {char * tlv34; tlv34 = (char *)(tlv1); }
    {char * tlv33; tlv33 = (char *)(tlv1); }
}
void fix_ingred_service_3_6(){
fix_ingred_service_3_6_9();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv18': 'char *', 'tlv17': 'char *'}'
val_s=>'[('char *', 'tlv18', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4890eb8>), ('char *', 'tlv17', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4894e48>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb48a6c18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb48a6f98>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=0/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
unique : ('Song *', 'song', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=1/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=2/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=3/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=4/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=5/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=6/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=7/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
unique : ('char *', 'end', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=7/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=8/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=8/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=9/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=9/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=10/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=11/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=11/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=12/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=12/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=13/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=13/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=16/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=16/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=17/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=17/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=18/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=18/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=19/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=19/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=20/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=20/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=21/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=21/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=24/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=24/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=25/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=25/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=26/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=26/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=29/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=29/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=30/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=30/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=31/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=31/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=34/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=34/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=35/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=35/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=36/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=36/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=39/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=39/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
is_func_ [+] => '[False, False, False]'
has_multiptr_refs '++end' - False OR  False
[i=3/18][j=7/26][dd=40/41][k=0/13] | type: char * ; var : tlv18 ; varinfo :  ; value_node : ++ end (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ++,end
 => is literal (False) | is operator (True) ++
 => is literal (False) | is operator (False) end [vtype=char *]
not unique: ('char *', 'end', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->id' - False OR  False
[i=3/18][j=7/26][dd=40/41][k=1/13] | type: char * ; var : tlv17 ; varinfo :  ; value_node : song -> id (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,id
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) id [vtype=None]
----
UNIQ_INIT: ('Song *','song','None','None');

UNIQ_INIT: ('char *','end','None','None');

----
UNIQ_INIT: ('Song *','song','None','None');

UNIQ_INIT: ('char *','end','None','None');

==== Scope 1 ====
void fix_ingred_service_3_7_0(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
    {void * tlv8; tlv8 = (void *)(++ end); }
    {int tlv7; tlv7 = (int)(++ end); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(++ end); }
    {void * tlv11; tlv11 = (void *)(++ end); }
    {void * tlv10; tlv10 = (void *)(++ end); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(++ end); }
    {void * tlv14; tlv14 = (void *)(++ end); }
    {int tlv13; tlv13 = (int)(++ end); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(++ end); }
    {int tlv2; tlv2 = (int)(++ end); }
    {char * tlv18; tlv18 = (char *)(++ end); }
    {char * tlv17; tlv17 = (char *)(++ end); }
    {int tlv3; tlv3 = (int)(++ end); }
    {char * tlv22; tlv22 = (char *)(++ end); }
    {char * tlv21; tlv21 = (char *)(++ end); }
    {int tlv4; tlv4 = (int)(++ end); }
    {char * tlv26; tlv26 = (char *)(++ end); }
    {char * tlv25; tlv25 = (char *)(++ end); }
    {int tlv5; tlv5 = (int)(++ end); }
    {char * tlv30; tlv30 = (char *)(++ end); }
    {char * tlv29; tlv29 = (char *)(++ end); }
    {char * tlv34; tlv34 = (char *)(++ end); }
    {char * tlv33; tlv33 = (char *)(++ end); }
}
void fix_ingred_service_3_7_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
    {char * start; start = (char *)(song -> id); }
    {char * end; end = (char *)(song -> id); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> id); }
    {int count; count = (int)(song -> id); }
    {int i; i = (int)(song -> id); }
    {char * delim; delim = (char *)(song -> id); }
    {int ret; ret = (int)(song -> id); }
    {void * tlv8; tlv8 = (void *)(song -> id); }
    {int tlv7; tlv7 = (int)(song -> id); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> id); }
    {int tlv1; tlv1 = (int)(song -> id); }
    {void * tlv11; tlv11 = (void *)(song -> id); }
    {void * tlv10; tlv10 = (void *)(song -> id); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> id); }
    {void * tlv14; tlv14 = (void *)(song -> id); }
    {int tlv13; tlv13 = (int)(song -> id); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> id); }
    {int tlv2; tlv2 = (int)(song -> id); }
    {char * tlv18; tlv18 = (char *)(song -> id); }
    {char * tlv17; tlv17 = (char *)(song -> id); }
    {int tlv3; tlv3 = (int)(song -> id); }
    {char * tlv22; tlv22 = (char *)(song -> id); }
    {char * tlv21; tlv21 = (char *)(song -> id); }
    {int tlv4; tlv4 = (int)(song -> id); }
    {char * tlv26; tlv26 = (char *)(song -> id); }
    {char * tlv25; tlv25 = (char *)(song -> id); }
    {int tlv5; tlv5 = (int)(song -> id); }
    {char * tlv30; tlv30 = (char *)(song -> id); }
    {char * tlv29; tlv29 = (char *)(song -> id); }
    {char * tlv34; tlv34 = (char *)(song -> id); }
    {char * tlv33; tlv33 = (char *)(song -> id); }
}
void fix_ingred_service_3_7(){
fix_ingred_service_3_7_0();
fix_ingred_service_3_7_1();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b3ea58>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b3edd8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=0/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
unique : ('int', 'tlv2', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=1/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=2/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=3/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=4/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=5/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=6/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=7/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=8/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=9/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=10/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=11/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=12/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=13/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=16/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=17/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=18/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=19/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=20/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=21/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=24/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=25/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=26/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=29/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=30/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=31/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=34/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=35/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=36/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=39/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=3/18][j=10/26][dd=40/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
not valid - int tlv2; tlv2 = ((int)tlv2);

----
UNIQ_INIT: ('int','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_service_3_10_9(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char * start; start = (char *)(tlv2); }
    {char * end; end = (char *)(tlv2); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv2); }
    {int count; count = (int)(tlv2); }
    {int i; i = (int)(tlv2); }
    {char * delim; delim = (char *)(tlv2); }
    {int ret; ret = (int)(tlv2); }
    {void * tlv8; tlv8 = (void *)(tlv2); }
    {int tlv7; tlv7 = (int)(tlv2); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {void * tlv11; tlv11 = (void *)(tlv2); }
    {void * tlv10; tlv10 = (void *)(tlv2); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv2); }
    {void * tlv14; tlv14 = (void *)(tlv2); }
    {int tlv13; tlv13 = (int)(tlv2); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv2); }
    {char * tlv18; tlv18 = (char *)(tlv2); }
    {char * tlv17; tlv17 = (char *)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {char * tlv22; tlv22 = (char *)(tlv2); }
    {char * tlv21; tlv21 = (char *)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {char * tlv26; tlv26 = (char *)(tlv2); }
    {char * tlv25; tlv25 = (char *)(tlv2); }
    {int tlv5; tlv5 = (int)(tlv2); }
    {char * tlv30; tlv30 = (char *)(tlv2); }
    {char * tlv29; tlv29 = (char *)(tlv2); }
    {char * tlv34; tlv34 = (char *)(tlv2); }
    {char * tlv33; tlv33 = (char *)(tlv2); }
}
void fix_ingred_service_3_10(){
fix_ingred_service_3_10_9();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv22': 'char *', 'tlv21': 'char *'}'
val_s=>'[('char *', 'tlv22', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b5acf8>), ('char *', 'tlv21', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b6fc88>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b3ea58>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b3edd8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=0/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
unique : ('Song *', 'song', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=1/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=2/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=3/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=4/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=5/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=6/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=7/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=8/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=9/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=10/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=11/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=12/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=13/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=16/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=17/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=18/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=19/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=20/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=21/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=24/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=25/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=26/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=29/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=30/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=31/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=34/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=35/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=36/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=39/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->price' - False OR  False
[i=3/18][j=11/26][dd=40/41][k=1/13] | type: char * ; var : tlv21 ; varinfo :  ; value_node : song -> price (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,price
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) price [vtype=None]
----
UNIQ_INIT: ('Song *','song','None','None');

==== Scope 1 ====
void fix_ingred_service_3_11_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> price); }
    {char * end; end = (char *)(song -> price); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> price); }
    {int count; count = (int)(song -> price); }
    {int i; i = (int)(song -> price); }
    {char * delim; delim = (char *)(song -> price); }
    {int ret; ret = (int)(song -> price); }
    {void * tlv8; tlv8 = (void *)(song -> price); }
    {int tlv7; tlv7 = (int)(song -> price); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> price); }
    {int tlv1; tlv1 = (int)(song -> price); }
    {void * tlv11; tlv11 = (void *)(song -> price); }
    {void * tlv10; tlv10 = (void *)(song -> price); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> price); }
    {void * tlv14; tlv14 = (void *)(song -> price); }
    {int tlv13; tlv13 = (int)(song -> price); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> price); }
    {int tlv2; tlv2 = (int)(song -> price); }
    {char * tlv18; tlv18 = (char *)(song -> price); }
    {char * tlv17; tlv17 = (char *)(song -> price); }
    {int tlv3; tlv3 = (int)(song -> price); }
    {char * tlv22; tlv22 = (char *)(song -> price); }
    {char * tlv21; tlv21 = (char *)(song -> price); }
    {int tlv4; tlv4 = (int)(song -> price); }
    {char * tlv26; tlv26 = (char *)(song -> price); }
    {char * tlv25; tlv25 = (char *)(song -> price); }
    {int tlv5; tlv5 = (int)(song -> price); }
    {char * tlv30; tlv30 = (char *)(song -> price); }
    {char * tlv29; tlv29 = (char *)(song -> price); }
    {char * tlv34; tlv34 = (char *)(song -> price); }
    {char * tlv33; tlv33 = (char *)(song -> price); }
}
void fix_ingred_service_3_11(){
fix_ingred_service_3_11_1();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b5d898>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b5dc18>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=0/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
unique : ('int', 'tlv3', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=1/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=2/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=3/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=4/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=5/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=6/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=7/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=8/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=9/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=10/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=11/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=12/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=13/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=16/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=17/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=18/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=19/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=20/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=21/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=24/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=25/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=26/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=29/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=30/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=31/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=34/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=35/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=36/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=39/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=3/18][j=14/26][dd=40/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
not valid - int tlv3; tlv3 = ((int)tlv3);

----
UNIQ_INIT: ('int','tlv3','None','None');

==== Scope 1 ====
void fix_ingred_service_3_14_9(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char * start; start = (char *)(tlv3); }
    {char * end; end = (char *)(tlv3); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv3); }
    {int count; count = (int)(tlv3); }
    {int i; i = (int)(tlv3); }
    {char * delim; delim = (char *)(tlv3); }
    {int ret; ret = (int)(tlv3); }
    {void * tlv8; tlv8 = (void *)(tlv3); }
    {int tlv7; tlv7 = (int)(tlv3); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv3); }
    {int tlv1; tlv1 = (int)(tlv3); }
    {void * tlv11; tlv11 = (void *)(tlv3); }
    {void * tlv10; tlv10 = (void *)(tlv3); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv3); }
    {void * tlv14; tlv14 = (void *)(tlv3); }
    {int tlv13; tlv13 = (int)(tlv3); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {char * tlv18; tlv18 = (char *)(tlv3); }
    {char * tlv17; tlv17 = (char *)(tlv3); }
    {char * tlv22; tlv22 = (char *)(tlv3); }
    {char * tlv21; tlv21 = (char *)(tlv3); }
    {int tlv4; tlv4 = (int)(tlv3); }
    {char * tlv26; tlv26 = (char *)(tlv3); }
    {char * tlv25; tlv25 = (char *)(tlv3); }
    {int tlv5; tlv5 = (int)(tlv3); }
    {char * tlv30; tlv30 = (char *)(tlv3); }
    {char * tlv29; tlv29 = (char *)(tlv3); }
    {char * tlv34; tlv34 = (char *)(tlv3); }
    {char * tlv33; tlv33 = (char *)(tlv3); }
}
void fix_ingred_service_3_14(){
fix_ingred_service_3_14_9();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv26': 'char *', 'tlv25': 'char *'}'
val_s=>'[('char *', 'tlv26', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b4db38>), ('char *', 'tlv25', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b40ac8>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b5d898>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b5dc18>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=0/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
unique : ('Song *', 'song', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=1/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=2/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=3/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=4/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=5/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=6/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=7/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=8/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=9/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=10/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=11/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=12/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=13/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=16/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=17/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=18/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=19/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=20/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=21/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=24/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=25/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=26/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=29/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=30/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=31/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=34/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=35/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=36/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=39/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->artist' - False OR  False
[i=3/18][j=15/26][dd=40/41][k=1/13] | type: char * ; var : tlv25 ; varinfo :  ; value_node : song -> artist (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,artist
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) artist [vtype=None]
----
UNIQ_INIT: ('Song *','song','None','None');

==== Scope 1 ====
void fix_ingred_service_3_15_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> artist); }
    {char * end; end = (char *)(song -> artist); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> artist); }
    {int count; count = (int)(song -> artist); }
    {int i; i = (int)(song -> artist); }
    {char * delim; delim = (char *)(song -> artist); }
    {int ret; ret = (int)(song -> artist); }
    {void * tlv8; tlv8 = (void *)(song -> artist); }
    {int tlv7; tlv7 = (int)(song -> artist); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> artist); }
    {int tlv1; tlv1 = (int)(song -> artist); }
    {void * tlv11; tlv11 = (void *)(song -> artist); }
    {void * tlv10; tlv10 = (void *)(song -> artist); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> artist); }
    {void * tlv14; tlv14 = (void *)(song -> artist); }
    {int tlv13; tlv13 = (int)(song -> artist); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> artist); }
    {int tlv2; tlv2 = (int)(song -> artist); }
    {char * tlv18; tlv18 = (char *)(song -> artist); }
    {char * tlv17; tlv17 = (char *)(song -> artist); }
    {int tlv3; tlv3 = (int)(song -> artist); }
    {char * tlv22; tlv22 = (char *)(song -> artist); }
    {char * tlv21; tlv21 = (char *)(song -> artist); }
    {int tlv4; tlv4 = (int)(song -> artist); }
    {char * tlv26; tlv26 = (char *)(song -> artist); }
    {char * tlv25; tlv25 = (char *)(song -> artist); }
    {int tlv5; tlv5 = (int)(song -> artist); }
    {char * tlv30; tlv30 = (char *)(song -> artist); }
    {char * tlv29; tlv29 = (char *)(song -> artist); }
    {char * tlv34; tlv34 = (char *)(song -> artist); }
    {char * tlv33; tlv33 = (char *)(song -> artist); }
}
void fix_ingred_service_3_15(){
fix_ingred_service_3_15_1();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b706d8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b70a58>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=0/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
unique : ('int', 'tlv4', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=1/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=2/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=3/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=4/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=5/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=6/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=7/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=8/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=9/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=10/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=11/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=12/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=13/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=16/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=17/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=18/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=19/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=20/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=21/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=24/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=25/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=26/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=29/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=30/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=31/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=34/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=35/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=36/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=39/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=3/18][j=18/26][dd=40/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
not valid - int tlv4; tlv4 = ((int)tlv4);

----
UNIQ_INIT: ('int','tlv4','None','None');

==== Scope 1 ====
void fix_ingred_service_3_18_9(){
int tlv4;
    bzero(&tlv4,sizeof(int));
    {char * start; start = (char *)(tlv4); }
    {char * end; end = (char *)(tlv4); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv4); }
    {int count; count = (int)(tlv4); }
    {int i; i = (int)(tlv4); }
    {char * delim; delim = (char *)(tlv4); }
    {int ret; ret = (int)(tlv4); }
    {void * tlv8; tlv8 = (void *)(tlv4); }
    {int tlv7; tlv7 = (int)(tlv4); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv4); }
    {int tlv1; tlv1 = (int)(tlv4); }
    {void * tlv11; tlv11 = (void *)(tlv4); }
    {void * tlv10; tlv10 = (void *)(tlv4); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv4); }
    {void * tlv14; tlv14 = (void *)(tlv4); }
    {int tlv13; tlv13 = (int)(tlv4); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv4); }
    {int tlv2; tlv2 = (int)(tlv4); }
    {char * tlv18; tlv18 = (char *)(tlv4); }
    {char * tlv17; tlv17 = (char *)(tlv4); }
    {int tlv3; tlv3 = (int)(tlv4); }
    {char * tlv22; tlv22 = (char *)(tlv4); }
    {char * tlv21; tlv21 = (char *)(tlv4); }
    {char * tlv26; tlv26 = (char *)(tlv4); }
    {char * tlv25; tlv25 = (char *)(tlv4); }
    {int tlv5; tlv5 = (int)(tlv4); }
    {char * tlv30; tlv30 = (char *)(tlv4); }
    {char * tlv29; tlv29 = (char *)(tlv4); }
    {char * tlv34; tlv34 = (char *)(tlv4); }
    {char * tlv33; tlv33 = (char *)(tlv4); }
}
void fix_ingred_service_3_18(){
fix_ingred_service_3_18_9();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *', 'tlv30': 'char *', 'tlv29': 'char *'}'
val_s=>'[('char *', 'tlv30', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b6a978>), ('char *', 'tlv29', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b5e908>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b706d8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b70a58>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=0/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
unique : ('Song *', 'song', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=1/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=2/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=3/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=4/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=5/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=6/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=7/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=8/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=9/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=10/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=11/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=12/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=13/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=16/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=17/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=18/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=19/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=20/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=21/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=24/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=25/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=26/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=29/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=30/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=31/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=34/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=35/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=36/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=39/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->album' - False OR  False
[i=3/18][j=19/26][dd=40/41][k=1/13] | type: char * ; var : tlv29 ; varinfo :  ; value_node : song -> album (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,album
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) album [vtype=None]
----
UNIQ_INIT: ('Song *','song','None','None');

==== Scope 1 ====
void fix_ingred_service_3_19_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> album); }
    {char * end; end = (char *)(song -> album); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> album); }
    {int count; count = (int)(song -> album); }
    {int i; i = (int)(song -> album); }
    {char * delim; delim = (char *)(song -> album); }
    {int ret; ret = (int)(song -> album); }
    {void * tlv8; tlv8 = (void *)(song -> album); }
    {int tlv7; tlv7 = (int)(song -> album); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> album); }
    {int tlv1; tlv1 = (int)(song -> album); }
    {void * tlv11; tlv11 = (void *)(song -> album); }
    {void * tlv10; tlv10 = (void *)(song -> album); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> album); }
    {void * tlv14; tlv14 = (void *)(song -> album); }
    {int tlv13; tlv13 = (int)(song -> album); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> album); }
    {int tlv2; tlv2 = (int)(song -> album); }
    {char * tlv18; tlv18 = (char *)(song -> album); }
    {char * tlv17; tlv17 = (char *)(song -> album); }
    {int tlv3; tlv3 = (int)(song -> album); }
    {char * tlv22; tlv22 = (char *)(song -> album); }
    {char * tlv21; tlv21 = (char *)(song -> album); }
    {int tlv4; tlv4 = (int)(song -> album); }
    {char * tlv26; tlv26 = (char *)(song -> album); }
    {char * tlv25; tlv25 = (char *)(song -> album); }
    {int tlv5; tlv5 = (int)(song -> album); }
    {char * tlv30; tlv30 = (char *)(song -> album); }
    {char * tlv29; tlv29 = (char *)(song -> album); }
    {char * tlv34; tlv34 = (char *)(song -> album); }
    {char * tlv33; tlv33 = (char *)(song -> album); }
}
void fix_ingred_service_3_19(){
fix_ingred_service_3_19_1();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *', 'tlv5': 'int'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *', 'tlv5': 'int', 'tlv32': 'const char *', 'tlv31': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *', 'tlv5': 'int', 'tlv32': 'const char *', 'tlv31': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b49518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b49898>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=0/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
unique : ('int', 'tlv5', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=1/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=2/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=3/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=4/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=5/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=6/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=7/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=8/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=9/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=10/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=11/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=12/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=13/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=16/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=17/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=18/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=19/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=20/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=21/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=24/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=25/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=26/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=29/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=30/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=31/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=34/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=35/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=36/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=39/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=3/18][j=22/26][dd=40/41][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
not valid - int tlv5; tlv5 = ((int)tlv5);

----
UNIQ_INIT: ('int','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_service_3_22_9(){
int tlv5;
    bzero(&tlv5,sizeof(int));
    {char * start; start = (char *)(tlv5); }
    {char * end; end = (char *)(tlv5); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv5); }
    {int count; count = (int)(tlv5); }
    {int i; i = (int)(tlv5); }
    {char * delim; delim = (char *)(tlv5); }
    {int ret; ret = (int)(tlv5); }
    {void * tlv8; tlv8 = (void *)(tlv5); }
    {int tlv7; tlv7 = (int)(tlv5); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv5); }
    {int tlv1; tlv1 = (int)(tlv5); }
    {void * tlv11; tlv11 = (void *)(tlv5); }
    {void * tlv10; tlv10 = (void *)(tlv5); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv5); }
    {void * tlv14; tlv14 = (void *)(tlv5); }
    {int tlv13; tlv13 = (int)(tlv5); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv5); }
    {int tlv2; tlv2 = (int)(tlv5); }
    {char * tlv18; tlv18 = (char *)(tlv5); }
    {char * tlv17; tlv17 = (char *)(tlv5); }
    {int tlv3; tlv3 = (int)(tlv5); }
    {char * tlv22; tlv22 = (char *)(tlv5); }
    {char * tlv21; tlv21 = (char *)(tlv5); }
    {int tlv4; tlv4 = (int)(tlv5); }
    {char * tlv26; tlv26 = (char *)(tlv5); }
    {char * tlv25; tlv25 = (char *)(tlv5); }
    {char * tlv30; tlv30 = (char *)(tlv5); }
    {char * tlv29; tlv29 = (char *)(tlv5); }
    {char * tlv34; tlv34 = (char *)(tlv5); }
    {char * tlv33; tlv33 = (char *)(tlv5); }
}
void fix_ingred_service_3_22(){
fix_ingred_service_3_22_9();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *', 'tlv5': 'int', 'tlv32': 'const char *', 'tlv31': 'const char *', 'tlv34': 'char *', 'tlv33': 'char *'}'
val_s=>'[('char *', 'tlv34', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b697b8>), ('char *', 'tlv33', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4b5f748>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b49518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b49898>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=0/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
unique : ('Song *', 'song', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=1/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
Skipping KEY_SIZE => #define
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=2/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=3/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=4/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=5/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=6/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=7/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=8/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=9/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=10/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=11/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=12/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=13/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=16/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=17/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=18/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=19/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=20/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=21/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=24/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=25/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=26/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=29/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=30/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=31/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=34/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=35/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=36/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=39/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'song->song' - False OR  False
[i=3/18][j=23/26][dd=40/41][k=1/13] | type: char * ; var : tlv33 ; varinfo :  ; value_node : song -> song (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : song,->,song
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) song [vtype=Song *]
not unique: ('Song *', 'song', None) ... continue!
----
UNIQ_INIT: ('Song *','song','None','None');

==== Scope 1 ====
void fix_ingred_service_3_23_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> song); }
    {char * end; end = (char *)(song -> song); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> song); }
    {int count; count = (int)(song -> song); }
    {int i; i = (int)(song -> song); }
    {char * delim; delim = (char *)(song -> song); }
    {int ret; ret = (int)(song -> song); }
    {void * tlv8; tlv8 = (void *)(song -> song); }
    {int tlv7; tlv7 = (int)(song -> song); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> song); }
    {int tlv1; tlv1 = (int)(song -> song); }
    {void * tlv11; tlv11 = (void *)(song -> song); }
    {void * tlv10; tlv10 = (void *)(song -> song); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> song); }
    {void * tlv14; tlv14 = (void *)(song -> song); }
    {int tlv13; tlv13 = (int)(song -> song); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> song); }
    {int tlv2; tlv2 = (int)(song -> song); }
    {char * tlv18; tlv18 = (char *)(song -> song); }
    {char * tlv17; tlv17 = (char *)(song -> song); }
    {int tlv3; tlv3 = (int)(song -> song); }
    {char * tlv22; tlv22 = (char *)(song -> song); }
    {char * tlv21; tlv21 = (char *)(song -> song); }
    {int tlv4; tlv4 = (int)(song -> song); }
    {char * tlv26; tlv26 = (char *)(song -> song); }
    {char * tlv25; tlv25 = (char *)(song -> song); }
    {int tlv5; tlv5 = (int)(song -> song); }
    {char * tlv30; tlv30 = (char *)(song -> song); }
    {char * tlv29; tlv29 = (char *)(song -> song); }
    {char * tlv34; tlv34 = (char *)(song -> song); }
    {char * tlv33; tlv33 = (char *)(song -> song); }
}
void fix_ingred_service_3_23(){
fix_ingred_service_3_23_1();
}

sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv2': 'int', 'tlv20': 'const char *', 'tlv19': 'const char *', 'tlv3': 'int', 'tlv24': 'const char *', 'tlv23': 'const char *', 'tlv4': 'int', 'tlv28': 'const char *', 'tlv27': 'const char *', 'tlv5': 'int', 'tlv32': 'const char *', 'tlv31': 'const char *'}'
val_s=>'[('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
Skipping KEY_SIZE => #define
sym_lut=>'{'buffer': 'char *', 'song': 'Song *', 'start': 'char *', 'end': 'char *', 'key': 'char *', 'key [ KEY_SIZE ]': 'char', 'count': 'int', 'i': 'int', 'delim': 'char *', 'ret': 'int', 'tlv8': 'void *', 'tlv7': 'int', 'tlv6': 'cgc_size_t', 'tlv11': 'void *', 'tlv10': 'void *', 'tlv9': 'cgc_size_t', 'tlv1': 'int', 'tlv16': 'const char *', 'tlv15': 'const char *', 'tlv14': 'void *', 'tlv13': 'int', 'tlv12': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a31898>), ('int', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a10748>), ('cgc_size_t', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0d668>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489c278>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb487f208>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ad4a8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48b1358>), ('char *', 'delim', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48892e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48ae198>), ('char *', 'start', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aba58>), ('char *', 'end', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb48aff98>), ('int', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb489dac8>)]'
cval_s=>'[]'
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=0/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=1/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
Skipping KEY_SIZE => #define
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=2/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=3/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=4/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=5/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=6/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=7/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=8/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=9/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=10/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=11/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=12/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=13/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=16/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=17/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=18/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=19/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=20/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=21/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=24/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=25/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=26/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=29/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=30/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=31/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=34/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=35/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=36/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=39/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
is_func_ [K] => '[False, False, False]'
has_multiptr_refs 'KEY_SIZE' - False OR  False
[i=3/18][j=25/26][dd=40/41][k=2/12] | type: cgc_size_t ; var : tlv12 ; varinfo :  ; value_node : KEY_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : KEY_SIZE
 => is literal (False) | is operator (False) KEY_SIZE [vtype=None]
----
==== Scope 1 ====
void fix_ingred_service_3_25_2(){
    {char * start; start = (char *)(KEY_SIZE); }
    {char * end; end = (char *)(KEY_SIZE); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(KEY_SIZE); }
    {int count; count = (int)(KEY_SIZE); }
    {int i; i = (int)(KEY_SIZE); }
    {char * delim; delim = (char *)(KEY_SIZE); }
    {int ret; ret = (int)(KEY_SIZE); }
    {void * tlv8; tlv8 = (void *)(KEY_SIZE); }
    {int tlv7; tlv7 = (int)(KEY_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(KEY_SIZE); }
    {int tlv1; tlv1 = (int)(KEY_SIZE); }
    {void * tlv11; tlv11 = (void *)(KEY_SIZE); }
    {void * tlv10; tlv10 = (void *)(KEY_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(KEY_SIZE); }
    {void * tlv14; tlv14 = (void *)(KEY_SIZE); }
    {int tlv13; tlv13 = (int)(KEY_SIZE); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(KEY_SIZE); }
    {int tlv2; tlv2 = (int)(KEY_SIZE); }
    {char * tlv18; tlv18 = (char *)(KEY_SIZE); }
    {char * tlv17; tlv17 = (char *)(KEY_SIZE); }
    {int tlv3; tlv3 = (int)(KEY_SIZE); }
    {char * tlv22; tlv22 = (char *)(KEY_SIZE); }
    {char * tlv21; tlv21 = (char *)(KEY_SIZE); }
    {int tlv4; tlv4 = (int)(KEY_SIZE); }
    {char * tlv26; tlv26 = (char *)(KEY_SIZE); }
    {char * tlv25; tlv25 = (char *)(KEY_SIZE); }
    {int tlv5; tlv5 = (int)(KEY_SIZE); }
    {char * tlv30; tlv30 = (char *)(KEY_SIZE); }
    {char * tlv29; tlv29 = (char *)(KEY_SIZE); }
    {char * tlv34; tlv34 = (char *)(KEY_SIZE); }
    {char * tlv33; tlv33 = (char *)(KEY_SIZE); }
}
void fix_ingred_service_3_25(){
fix_ingred_service_3_25_2();
}

==== Scope 2 ====
void fix_ingred_service_3_0_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(NULL); }
    {int tlv7; tlv7 = (int)(NULL); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NULL); }
    {void * tlv11; tlv11 = (void *)(NULL); }
    {void * tlv10; tlv10 = (void *)(NULL); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(NULL); }
    {void * tlv14; tlv14 = (void *)(NULL); }
    {int tlv13; tlv13 = (int)(NULL); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(NULL); }
    {int tlv2; tlv2 = (int)(NULL); }
    {char * tlv18; tlv18 = (char *)(NULL); }
    {char * tlv17; tlv17 = (char *)(NULL); }
    {int tlv3; tlv3 = (int)(NULL); }
    {char * tlv22; tlv22 = (char *)(NULL); }
    {char * tlv21; tlv21 = (char *)(NULL); }
    {int tlv4; tlv4 = (int)(NULL); }
    {char * tlv26; tlv26 = (char *)(NULL); }
    {char * tlv25; tlv25 = (char *)(NULL); }
    {int tlv5; tlv5 = (int)(NULL); }
    {char * tlv30; tlv30 = (char *)(NULL); }
    {char * tlv29; tlv29 = (char *)(NULL); }
    {char * tlv34; tlv34 = (char *)(NULL); }
    {char * tlv33; tlv33 = (char *)(NULL); }
}
void fix_ingred_service_3_0_2(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {void * tlv10; tlv10 = (void *)(0); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {int tlv13; tlv13 = (int)(0); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {char * tlv18; tlv18 = (char *)(0); }
    {char * tlv17; tlv17 = (char *)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {char * tlv22; tlv22 = (char *)(0); }
    {char * tlv21; tlv21 = (char *)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {char * tlv26; tlv26 = (char *)(0); }
    {char * tlv25; tlv25 = (char *)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char * tlv30; tlv30 = (char *)(0); }
    {char * tlv29; tlv29 = (char *)(0); }
    {char * tlv34; tlv34 = (char *)(0); }
    {char * tlv33; tlv33 = (char *)(0); }
}
void fix_ingred_service_3_0_4(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(KEYVAL_DELIM); }
    {int tlv7; tlv7 = (int)(KEYVAL_DELIM); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(KEYVAL_DELIM); }
    {void * tlv11; tlv11 = (void *)(KEYVAL_DELIM); }
    {void * tlv10; tlv10 = (void *)(KEYVAL_DELIM); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(KEYVAL_DELIM); }
    {void * tlv14; tlv14 = (void *)(KEYVAL_DELIM); }
    {int tlv13; tlv13 = (int)(KEYVAL_DELIM); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(KEYVAL_DELIM); }
    {int tlv2; tlv2 = (int)(KEYVAL_DELIM); }
    {char * tlv18; tlv18 = (char *)(KEYVAL_DELIM); }
    {char * tlv17; tlv17 = (char *)(KEYVAL_DELIM); }
    {int tlv3; tlv3 = (int)(KEYVAL_DELIM); }
    {char * tlv22; tlv22 = (char *)(KEYVAL_DELIM); }
    {char * tlv21; tlv21 = (char *)(KEYVAL_DELIM); }
    {int tlv4; tlv4 = (int)(KEYVAL_DELIM); }
    {char * tlv26; tlv26 = (char *)(KEYVAL_DELIM); }
    {char * tlv25; tlv25 = (char *)(KEYVAL_DELIM); }
    {int tlv5; tlv5 = (int)(KEYVAL_DELIM); }
    {char * tlv30; tlv30 = (char *)(KEYVAL_DELIM); }
    {char * tlv29; tlv29 = (char *)(KEYVAL_DELIM); }
    {char * tlv34; tlv34 = (char *)(KEYVAL_DELIM); }
    {char * tlv33; tlv33 = (char *)(KEYVAL_DELIM); }
}
void fix_ingred_service_3_0_6(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {void * tlv8; tlv8 = (void *)(buffer); }
    {int tlv7; tlv7 = (int)(buffer); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(buffer); }
    {void * tlv11; tlv11 = (void *)(buffer); }
    {void * tlv10; tlv10 = (void *)(buffer); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(buffer); }
    {void * tlv14; tlv14 = (void *)(buffer); }
    {int tlv13; tlv13 = (int)(buffer); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(buffer); }
    {int tlv2; tlv2 = (int)(buffer); }
    {char * tlv18; tlv18 = (char *)(buffer); }
    {char * tlv17; tlv17 = (char *)(buffer); }
    {int tlv3; tlv3 = (int)(buffer); }
    {char * tlv22; tlv22 = (char *)(buffer); }
    {char * tlv21; tlv21 = (char *)(buffer); }
    {int tlv4; tlv4 = (int)(buffer); }
    {char * tlv26; tlv26 = (char *)(buffer); }
    {char * tlv25; tlv25 = (char *)(buffer); }
    {int tlv5; tlv5 = (int)(buffer); }
    {char * tlv30; tlv30 = (char *)(buffer); }
    {char * tlv29; tlv29 = (char *)(buffer); }
    {char * tlv34; tlv34 = (char *)(buffer); }
    {char * tlv33; tlv33 = (char *)(buffer); }
}
void fix_ingred_service_3_0(){
fix_ingred_service_3_0_0();
fix_ingred_service_3_0_2();
fix_ingred_service_3_0_4();
fix_ingred_service_3_0_6();
}
void fix_ingred_service_3_1_0(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song); }
    {char * end; end = (char *)(song); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song); }
    {int count; count = (int)(song); }
    {int i; i = (int)(song); }
    {char * delim; delim = (char *)(song); }
    {int ret; ret = (int)(song); }
    {void * tlv8; tlv8 = (void *)(song); }
    {int tlv7; tlv7 = (int)(song); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song); }
    {int tlv1; tlv1 = (int)(song); }
    {void * tlv11; tlv11 = (void *)(song); }
    {void * tlv10; tlv10 = (void *)(song); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song); }
    {void * tlv14; tlv14 = (void *)(song); }
    {int tlv13; tlv13 = (int)(song); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song); }
    {int tlv2; tlv2 = (int)(song); }
    {char * tlv18; tlv18 = (char *)(song); }
    {char * tlv17; tlv17 = (char *)(song); }
    {int tlv3; tlv3 = (int)(song); }
    {char * tlv22; tlv22 = (char *)(song); }
    {char * tlv21; tlv21 = (char *)(song); }
    {int tlv4; tlv4 = (int)(song); }
    {char * tlv26; tlv26 = (char *)(song); }
    {char * tlv25; tlv25 = (char *)(song); }
    {int tlv5; tlv5 = (int)(song); }
    {char * tlv30; tlv30 = (char *)(song); }
    {char * tlv29; tlv29 = (char *)(song); }
    {char * tlv34; tlv34 = (char *)(song); }
    {char * tlv33; tlv33 = (char *)(song); }
}
void fix_ingred_service_3_1_2(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(SONG_SIZE); }
    {char * end; end = (char *)(SONG_SIZE); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(SONG_SIZE); }
    {int count; count = (int)(SONG_SIZE); }
    {int i; i = (int)(SONG_SIZE); }
    {char * delim; delim = (char *)(SONG_SIZE); }
    {int ret; ret = (int)(SONG_SIZE); }
    {void * tlv8; tlv8 = (void *)(SONG_SIZE); }
    {int tlv7; tlv7 = (int)(SONG_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(SONG_SIZE); }
    {int tlv1; tlv1 = (int)(SONG_SIZE); }
    {void * tlv11; tlv11 = (void *)(SONG_SIZE); }
    {void * tlv10; tlv10 = (void *)(SONG_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(SONG_SIZE); }
    {void * tlv14; tlv14 = (void *)(SONG_SIZE); }
    {int tlv13; tlv13 = (int)(SONG_SIZE); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(SONG_SIZE); }
    {int tlv2; tlv2 = (int)(SONG_SIZE); }
    {char * tlv18; tlv18 = (char *)(SONG_SIZE); }
    {char * tlv17; tlv17 = (char *)(SONG_SIZE); }
    {int tlv3; tlv3 = (int)(SONG_SIZE); }
    {char * tlv22; tlv22 = (char *)(SONG_SIZE); }
    {char * tlv21; tlv21 = (char *)(SONG_SIZE); }
    {int tlv4; tlv4 = (int)(SONG_SIZE); }
    {char * tlv26; tlv26 = (char *)(SONG_SIZE); }
    {char * tlv25; tlv25 = (char *)(SONG_SIZE); }
    {int tlv5; tlv5 = (int)(SONG_SIZE); }
    {char * tlv30; tlv30 = (char *)(SONG_SIZE); }
    {char * tlv29; tlv29 = (char *)(SONG_SIZE); }
    {char * tlv34; tlv34 = (char *)(SONG_SIZE); }
    {char * tlv33; tlv33 = (char *)(SONG_SIZE); }
}
void fix_ingred_service_3_1(){
fix_ingred_service_3_1_0();
fix_ingred_service_3_1_2();
}
void fix_ingred_service_3_2_0(){
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
    {void * tlv8; tlv8 = (void *)(start); }
    {int tlv7; tlv7 = (int)(start); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(start); }
    {void * tlv11; tlv11 = (void *)(start); }
    {void * tlv10; tlv10 = (void *)(start); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(start); }
    {void * tlv14; tlv14 = (void *)(start); }
    {int tlv13; tlv13 = (int)(start); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(start); }
    {int tlv2; tlv2 = (int)(start); }
    {char * tlv18; tlv18 = (char *)(start); }
    {char * tlv17; tlv17 = (char *)(start); }
    {int tlv3; tlv3 = (int)(start); }
    {char * tlv22; tlv22 = (char *)(start); }
    {char * tlv21; tlv21 = (char *)(start); }
    {int tlv4; tlv4 = (int)(start); }
    {char * tlv26; tlv26 = (char *)(start); }
    {char * tlv25; tlv25 = (char *)(start); }
    {int tlv5; tlv5 = (int)(start); }
    {char * tlv30; tlv30 = (char *)(start); }
    {char * tlv29; tlv29 = (char *)(start); }
    {char * tlv34; tlv34 = (char *)(start); }
    {char * tlv33; tlv33 = (char *)(start); }
}
void fix_ingred_service_3_2(){
fix_ingred_service_3_2_0();
}
void fix_ingred_service_3_3_9(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(* end); }
    {int tlv7; tlv7 = (int)(* end); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(* end); }
    {void * tlv11; tlv11 = (void *)(* end); }
    {void * tlv10; tlv10 = (void *)(* end); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(* end); }
    {void * tlv14; tlv14 = (void *)(* end); }
    {int tlv13; tlv13 = (int)(* end); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(* end); }
    {int tlv2; tlv2 = (int)(* end); }
    {char * tlv18; tlv18 = (char *)(* end); }
    {char * tlv17; tlv17 = (char *)(* end); }
    {int tlv3; tlv3 = (int)(* end); }
    {char * tlv22; tlv22 = (char *)(* end); }
    {char * tlv21; tlv21 = (char *)(* end); }
    {int tlv4; tlv4 = (int)(* end); }
    {char * tlv26; tlv26 = (char *)(* end); }
    {char * tlv25; tlv25 = (char *)(* end); }
    {int tlv5; tlv5 = (int)(* end); }
    {char * tlv30; tlv30 = (char *)(* end); }
    {char * tlv29; tlv29 = (char *)(* end); }
    {char * tlv34; tlv34 = (char *)(* end); }
    {char * tlv33; tlv33 = (char *)(* end); }
}
void fix_ingred_service_3_3_10(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(* delim); }
    {int tlv7; tlv7 = (int)(* delim); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(* delim); }
    {void * tlv11; tlv11 = (void *)(* delim); }
    {void * tlv10; tlv10 = (void *)(* delim); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(* delim); }
    {void * tlv14; tlv14 = (void *)(* delim); }
    {int tlv13; tlv13 = (int)(* delim); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(* delim); }
    {int tlv2; tlv2 = (int)(* delim); }
    {char * tlv18; tlv18 = (char *)(* delim); }
    {char * tlv17; tlv17 = (char *)(* delim); }
    {int tlv3; tlv3 = (int)(* delim); }
    {char * tlv22; tlv22 = (char *)(* delim); }
    {char * tlv21; tlv21 = (char *)(* delim); }
    {int tlv4; tlv4 = (int)(* delim); }
    {char * tlv26; tlv26 = (char *)(* delim); }
    {char * tlv25; tlv25 = (char *)(* delim); }
    {int tlv5; tlv5 = (int)(* delim); }
    {char * tlv30; tlv30 = (char *)(* delim); }
    {char * tlv29; tlv29 = (char *)(* delim); }
    {char * tlv34; tlv34 = (char *)(* delim); }
    {char * tlv33; tlv33 = (char *)(* delim); }
}
void fix_ingred_service_3_3_11(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(count); }
    {int tlv7; tlv7 = (int)(count); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(count); }
    {void * tlv11; tlv11 = (void *)(count); }
    {void * tlv10; tlv10 = (void *)(count); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(count); }
    {void * tlv14; tlv14 = (void *)(count); }
    {int tlv13; tlv13 = (int)(count); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(count); }
    {int tlv2; tlv2 = (int)(count); }
    {char * tlv18; tlv18 = (char *)(count); }
    {char * tlv17; tlv17 = (char *)(count); }
    {int tlv3; tlv3 = (int)(count); }
    {char * tlv22; tlv22 = (char *)(count); }
    {char * tlv21; tlv21 = (char *)(count); }
    {int tlv4; tlv4 = (int)(count); }
    {char * tlv26; tlv26 = (char *)(count); }
    {char * tlv25; tlv25 = (char *)(count); }
    {int tlv5; tlv5 = (int)(count); }
    {char * tlv30; tlv30 = (char *)(count); }
    {char * tlv29; tlv29 = (char *)(count); }
    {char * tlv34; tlv34 = (char *)(count); }
    {char * tlv33; tlv33 = (char *)(count); }
}
void fix_ingred_service_3_3_12(){
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
char delim_ref;
    bzero(&delim_ref,1*sizeof(char));
char * delim = &delim_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(KEY_SIZE); }
    {int tlv7; tlv7 = (int)(KEY_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(KEY_SIZE); }
    {void * tlv11; tlv11 = (void *)(KEY_SIZE); }
    {void * tlv10; tlv10 = (void *)(KEY_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(KEY_SIZE); }
    {void * tlv14; tlv14 = (void *)(KEY_SIZE); }
    {int tlv13; tlv13 = (int)(KEY_SIZE); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(KEY_SIZE); }
    {int tlv2; tlv2 = (int)(KEY_SIZE); }
    {char * tlv18; tlv18 = (char *)(KEY_SIZE); }
    {char * tlv17; tlv17 = (char *)(KEY_SIZE); }
    {int tlv3; tlv3 = (int)(KEY_SIZE); }
    {char * tlv22; tlv22 = (char *)(KEY_SIZE); }
    {char * tlv21; tlv21 = (char *)(KEY_SIZE); }
    {int tlv4; tlv4 = (int)(KEY_SIZE); }
    {char * tlv26; tlv26 = (char *)(KEY_SIZE); }
    {char * tlv25; tlv25 = (char *)(KEY_SIZE); }
    {int tlv5; tlv5 = (int)(KEY_SIZE); }
    {char * tlv30; tlv30 = (char *)(KEY_SIZE); }
    {char * tlv29; tlv29 = (char *)(KEY_SIZE); }
    {char * tlv34; tlv34 = (char *)(KEY_SIZE); }
    {char * tlv33; tlv33 = (char *)(KEY_SIZE); }
}
void fix_ingred_service_3_3(){
fix_ingred_service_3_3_9();
fix_ingred_service_3_3_10();
fix_ingred_service_3_3_11();
fix_ingred_service_3_3_12();
}
void fix_ingred_service_3_4_0(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(key); }
    {int tlv7; tlv7 = (int)(key); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(key); }
    {void * tlv11; tlv11 = (void *)(key); }
    {void * tlv10; tlv10 = (void *)(key); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(key); }
    {void * tlv14; tlv14 = (void *)(key); }
    {int tlv13; tlv13 = (int)(key); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(key); }
    {int tlv2; tlv2 = (int)(key); }
    {char * tlv18; tlv18 = (char *)(key); }
    {char * tlv17; tlv17 = (char *)(key); }
    {int tlv3; tlv3 = (int)(key); }
    {char * tlv22; tlv22 = (char *)(key); }
    {char * tlv21; tlv21 = (char *)(key); }
    {int tlv4; tlv4 = (int)(key); }
    {char * tlv26; tlv26 = (char *)(key); }
    {char * tlv25; tlv25 = (char *)(key); }
    {int tlv5; tlv5 = (int)(key); }
    {char * tlv30; tlv30 = (char *)(key); }
    {char * tlv29; tlv29 = (char *)(key); }
    {char * tlv34; tlv34 = (char *)(key); }
    {char * tlv33; tlv33 = (char *)(key); }
}
void fix_ingred_service_3_4_1(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(start); }
    {int tlv7; tlv7 = (int)(start); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(start); }
    {void * tlv11; tlv11 = (void *)(start); }
    {void * tlv10; tlv10 = (void *)(start); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(start); }
    {void * tlv14; tlv14 = (void *)(start); }
    {int tlv13; tlv13 = (int)(start); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(start); }
    {int tlv2; tlv2 = (int)(start); }
    {char * tlv18; tlv18 = (char *)(start); }
    {char * tlv17; tlv17 = (char *)(start); }
    {int tlv3; tlv3 = (int)(start); }
    {char * tlv22; tlv22 = (char *)(start); }
    {char * tlv21; tlv21 = (char *)(start); }
    {int tlv4; tlv4 = (int)(start); }
    {char * tlv26; tlv26 = (char *)(start); }
    {char * tlv25; tlv25 = (char *)(start); }
    {int tlv5; tlv5 = (int)(start); }
    {char * tlv30; tlv30 = (char *)(start); }
    {char * tlv29; tlv29 = (char *)(start); }
    {char * tlv34; tlv34 = (char *)(start); }
    {char * tlv33; tlv33 = (char *)(start); }
}
void fix_ingred_service_3_4_2(){
char key [ KEY_SIZE ];
    bzero(&key,( KEY_SIZE *sizeof(char) ) );
char start_ref;
    bzero(&start_ref,1*sizeof(char));
char * start = &start_ref;
int count;
    bzero(&count,sizeof(int));
    {void * tlv8; tlv8 = (void *)(count); }
    {int tlv7; tlv7 = (int)(count); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(count); }
    {void * tlv11; tlv11 = (void *)(count); }
    {void * tlv10; tlv10 = (void *)(count); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(count); }
    {void * tlv14; tlv14 = (void *)(count); }
    {int tlv13; tlv13 = (int)(count); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(count); }
    {int tlv2; tlv2 = (int)(count); }
    {char * tlv18; tlv18 = (char *)(count); }
    {char * tlv17; tlv17 = (char *)(count); }
    {int tlv3; tlv3 = (int)(count); }
    {char * tlv22; tlv22 = (char *)(count); }
    {char * tlv21; tlv21 = (char *)(count); }
    {int tlv4; tlv4 = (int)(count); }
    {char * tlv26; tlv26 = (char *)(count); }
    {char * tlv25; tlv25 = (char *)(count); }
    {int tlv5; tlv5 = (int)(count); }
    {char * tlv30; tlv30 = (char *)(count); }
    {char * tlv29; tlv29 = (char *)(count); }
    {char * tlv34; tlv34 = (char *)(count); }
    {char * tlv33; tlv33 = (char *)(count); }
}
void fix_ingred_service_3_4(){
fix_ingred_service_3_4_0();
fix_ingred_service_3_4_1();
fix_ingred_service_3_4_2();
}
void fix_ingred_service_3_6_9(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {void * tlv8; tlv8 = (void *)(tlv1); }
    {int tlv7; tlv7 = (int)(tlv1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv1); }
    {void * tlv11; tlv11 = (void *)(tlv1); }
    {void * tlv10; tlv10 = (void *)(tlv1); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv1); }
    {void * tlv14; tlv14 = (void *)(tlv1); }
    {int tlv13; tlv13 = (int)(tlv1); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {char * tlv18; tlv18 = (char *)(tlv1); }
    {char * tlv17; tlv17 = (char *)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {char * tlv22; tlv22 = (char *)(tlv1); }
    {char * tlv21; tlv21 = (char *)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {char * tlv26; tlv26 = (char *)(tlv1); }
    {char * tlv25; tlv25 = (char *)(tlv1); }
    {int tlv5; tlv5 = (int)(tlv1); }
    {char * tlv30; tlv30 = (char *)(tlv1); }
    {char * tlv29; tlv29 = (char *)(tlv1); }
    {char * tlv34; tlv34 = (char *)(tlv1); }
    {char * tlv33; tlv33 = (char *)(tlv1); }
}
void fix_ingred_service_3_6(){
fix_ingred_service_3_6_9();
}
void fix_ingred_service_3_7_0(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
    {void * tlv8; tlv8 = (void *)(++ end); }
    {int tlv7; tlv7 = (int)(++ end); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(++ end); }
    {void * tlv11; tlv11 = (void *)(++ end); }
    {void * tlv10; tlv10 = (void *)(++ end); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(++ end); }
    {void * tlv14; tlv14 = (void *)(++ end); }
    {int tlv13; tlv13 = (int)(++ end); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(++ end); }
    {int tlv2; tlv2 = (int)(++ end); }
    {char * tlv18; tlv18 = (char *)(++ end); }
    {char * tlv17; tlv17 = (char *)(++ end); }
    {int tlv3; tlv3 = (int)(++ end); }
    {char * tlv22; tlv22 = (char *)(++ end); }
    {char * tlv21; tlv21 = (char *)(++ end); }
    {int tlv4; tlv4 = (int)(++ end); }
    {char * tlv26; tlv26 = (char *)(++ end); }
    {char * tlv25; tlv25 = (char *)(++ end); }
    {int tlv5; tlv5 = (int)(++ end); }
    {char * tlv30; tlv30 = (char *)(++ end); }
    {char * tlv29; tlv29 = (char *)(++ end); }
    {char * tlv34; tlv34 = (char *)(++ end); }
    {char * tlv33; tlv33 = (char *)(++ end); }
}
void fix_ingred_service_3_7_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
char end_ref;
    bzero(&end_ref,1*sizeof(char));
char * end = &end_ref;
    {char * start; start = (char *)(song -> id); }
    {char * end; end = (char *)(song -> id); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> id); }
    {int count; count = (int)(song -> id); }
    {int i; i = (int)(song -> id); }
    {char * delim; delim = (char *)(song -> id); }
    {int ret; ret = (int)(song -> id); }
    {void * tlv8; tlv8 = (void *)(song -> id); }
    {int tlv7; tlv7 = (int)(song -> id); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> id); }
    {int tlv1; tlv1 = (int)(song -> id); }
    {void * tlv11; tlv11 = (void *)(song -> id); }
    {void * tlv10; tlv10 = (void *)(song -> id); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> id); }
    {void * tlv14; tlv14 = (void *)(song -> id); }
    {int tlv13; tlv13 = (int)(song -> id); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> id); }
    {int tlv2; tlv2 = (int)(song -> id); }
    {char * tlv18; tlv18 = (char *)(song -> id); }
    {char * tlv17; tlv17 = (char *)(song -> id); }
    {int tlv3; tlv3 = (int)(song -> id); }
    {char * tlv22; tlv22 = (char *)(song -> id); }
    {char * tlv21; tlv21 = (char *)(song -> id); }
    {int tlv4; tlv4 = (int)(song -> id); }
    {char * tlv26; tlv26 = (char *)(song -> id); }
    {char * tlv25; tlv25 = (char *)(song -> id); }
    {int tlv5; tlv5 = (int)(song -> id); }
    {char * tlv30; tlv30 = (char *)(song -> id); }
    {char * tlv29; tlv29 = (char *)(song -> id); }
    {char * tlv34; tlv34 = (char *)(song -> id); }
    {char * tlv33; tlv33 = (char *)(song -> id); }
}
void fix_ingred_service_3_7(){
fix_ingred_service_3_7_0();
fix_ingred_service_3_7_1();
}
void fix_ingred_service_3_10_9(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char * start; start = (char *)(tlv2); }
    {char * end; end = (char *)(tlv2); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv2); }
    {int count; count = (int)(tlv2); }
    {int i; i = (int)(tlv2); }
    {char * delim; delim = (char *)(tlv2); }
    {int ret; ret = (int)(tlv2); }
    {void * tlv8; tlv8 = (void *)(tlv2); }
    {int tlv7; tlv7 = (int)(tlv2); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {void * tlv11; tlv11 = (void *)(tlv2); }
    {void * tlv10; tlv10 = (void *)(tlv2); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv2); }
    {void * tlv14; tlv14 = (void *)(tlv2); }
    {int tlv13; tlv13 = (int)(tlv2); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv2); }
    {char * tlv18; tlv18 = (char *)(tlv2); }
    {char * tlv17; tlv17 = (char *)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {char * tlv22; tlv22 = (char *)(tlv2); }
    {char * tlv21; tlv21 = (char *)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {char * tlv26; tlv26 = (char *)(tlv2); }
    {char * tlv25; tlv25 = (char *)(tlv2); }
    {int tlv5; tlv5 = (int)(tlv2); }
    {char * tlv30; tlv30 = (char *)(tlv2); }
    {char * tlv29; tlv29 = (char *)(tlv2); }
    {char * tlv34; tlv34 = (char *)(tlv2); }
    {char * tlv33; tlv33 = (char *)(tlv2); }
}
void fix_ingred_service_3_10(){
fix_ingred_service_3_10_9();
}
void fix_ingred_service_3_11_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> price); }
    {char * end; end = (char *)(song -> price); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> price); }
    {int count; count = (int)(song -> price); }
    {int i; i = (int)(song -> price); }
    {char * delim; delim = (char *)(song -> price); }
    {int ret; ret = (int)(song -> price); }
    {void * tlv8; tlv8 = (void *)(song -> price); }
    {int tlv7; tlv7 = (int)(song -> price); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> price); }
    {int tlv1; tlv1 = (int)(song -> price); }
    {void * tlv11; tlv11 = (void *)(song -> price); }
    {void * tlv10; tlv10 = (void *)(song -> price); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> price); }
    {void * tlv14; tlv14 = (void *)(song -> price); }
    {int tlv13; tlv13 = (int)(song -> price); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> price); }
    {int tlv2; tlv2 = (int)(song -> price); }
    {char * tlv18; tlv18 = (char *)(song -> price); }
    {char * tlv17; tlv17 = (char *)(song -> price); }
    {int tlv3; tlv3 = (int)(song -> price); }
    {char * tlv22; tlv22 = (char *)(song -> price); }
    {char * tlv21; tlv21 = (char *)(song -> price); }
    {int tlv4; tlv4 = (int)(song -> price); }
    {char * tlv26; tlv26 = (char *)(song -> price); }
    {char * tlv25; tlv25 = (char *)(song -> price); }
    {int tlv5; tlv5 = (int)(song -> price); }
    {char * tlv30; tlv30 = (char *)(song -> price); }
    {char * tlv29; tlv29 = (char *)(song -> price); }
    {char * tlv34; tlv34 = (char *)(song -> price); }
    {char * tlv33; tlv33 = (char *)(song -> price); }
}
void fix_ingred_service_3_11(){
fix_ingred_service_3_11_1();
}
void fix_ingred_service_3_14_9(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char * start; start = (char *)(tlv3); }
    {char * end; end = (char *)(tlv3); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv3); }
    {int count; count = (int)(tlv3); }
    {int i; i = (int)(tlv3); }
    {char * delim; delim = (char *)(tlv3); }
    {int ret; ret = (int)(tlv3); }
    {void * tlv8; tlv8 = (void *)(tlv3); }
    {int tlv7; tlv7 = (int)(tlv3); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv3); }
    {int tlv1; tlv1 = (int)(tlv3); }
    {void * tlv11; tlv11 = (void *)(tlv3); }
    {void * tlv10; tlv10 = (void *)(tlv3); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv3); }
    {void * tlv14; tlv14 = (void *)(tlv3); }
    {int tlv13; tlv13 = (int)(tlv3); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {char * tlv18; tlv18 = (char *)(tlv3); }
    {char * tlv17; tlv17 = (char *)(tlv3); }
    {char * tlv22; tlv22 = (char *)(tlv3); }
    {char * tlv21; tlv21 = (char *)(tlv3); }
    {int tlv4; tlv4 = (int)(tlv3); }
    {char * tlv26; tlv26 = (char *)(tlv3); }
    {char * tlv25; tlv25 = (char *)(tlv3); }
    {int tlv5; tlv5 = (int)(tlv3); }
    {char * tlv30; tlv30 = (char *)(tlv3); }
    {char * tlv29; tlv29 = (char *)(tlv3); }
    {char * tlv34; tlv34 = (char *)(tlv3); }
    {char * tlv33; tlv33 = (char *)(tlv3); }
}
void fix_ingred_service_3_14(){
fix_ingred_service_3_14_9();
}
void fix_ingred_service_3_15_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> artist); }
    {char * end; end = (char *)(song -> artist); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> artist); }
    {int count; count = (int)(song -> artist); }
    {int i; i = (int)(song -> artist); }
    {char * delim; delim = (char *)(song -> artist); }
    {int ret; ret = (int)(song -> artist); }
    {void * tlv8; tlv8 = (void *)(song -> artist); }
    {int tlv7; tlv7 = (int)(song -> artist); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> artist); }
    {int tlv1; tlv1 = (int)(song -> artist); }
    {void * tlv11; tlv11 = (void *)(song -> artist); }
    {void * tlv10; tlv10 = (void *)(song -> artist); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> artist); }
    {void * tlv14; tlv14 = (void *)(song -> artist); }
    {int tlv13; tlv13 = (int)(song -> artist); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> artist); }
    {int tlv2; tlv2 = (int)(song -> artist); }
    {char * tlv18; tlv18 = (char *)(song -> artist); }
    {char * tlv17; tlv17 = (char *)(song -> artist); }
    {int tlv3; tlv3 = (int)(song -> artist); }
    {char * tlv22; tlv22 = (char *)(song -> artist); }
    {char * tlv21; tlv21 = (char *)(song -> artist); }
    {int tlv4; tlv4 = (int)(song -> artist); }
    {char * tlv26; tlv26 = (char *)(song -> artist); }
    {char * tlv25; tlv25 = (char *)(song -> artist); }
    {int tlv5; tlv5 = (int)(song -> artist); }
    {char * tlv30; tlv30 = (char *)(song -> artist); }
    {char * tlv29; tlv29 = (char *)(song -> artist); }
    {char * tlv34; tlv34 = (char *)(song -> artist); }
    {char * tlv33; tlv33 = (char *)(song -> artist); }
}
void fix_ingred_service_3_15(){
fix_ingred_service_3_15_1();
}
void fix_ingred_service_3_18_9(){
int tlv4;
    bzero(&tlv4,sizeof(int));
    {char * start; start = (char *)(tlv4); }
    {char * end; end = (char *)(tlv4); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv4); }
    {int count; count = (int)(tlv4); }
    {int i; i = (int)(tlv4); }
    {char * delim; delim = (char *)(tlv4); }
    {int ret; ret = (int)(tlv4); }
    {void * tlv8; tlv8 = (void *)(tlv4); }
    {int tlv7; tlv7 = (int)(tlv4); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv4); }
    {int tlv1; tlv1 = (int)(tlv4); }
    {void * tlv11; tlv11 = (void *)(tlv4); }
    {void * tlv10; tlv10 = (void *)(tlv4); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv4); }
    {void * tlv14; tlv14 = (void *)(tlv4); }
    {int tlv13; tlv13 = (int)(tlv4); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv4); }
    {int tlv2; tlv2 = (int)(tlv4); }
    {char * tlv18; tlv18 = (char *)(tlv4); }
    {char * tlv17; tlv17 = (char *)(tlv4); }
    {int tlv3; tlv3 = (int)(tlv4); }
    {char * tlv22; tlv22 = (char *)(tlv4); }
    {char * tlv21; tlv21 = (char *)(tlv4); }
    {char * tlv26; tlv26 = (char *)(tlv4); }
    {char * tlv25; tlv25 = (char *)(tlv4); }
    {int tlv5; tlv5 = (int)(tlv4); }
    {char * tlv30; tlv30 = (char *)(tlv4); }
    {char * tlv29; tlv29 = (char *)(tlv4); }
    {char * tlv34; tlv34 = (char *)(tlv4); }
    {char * tlv33; tlv33 = (char *)(tlv4); }
}
void fix_ingred_service_3_18(){
fix_ingred_service_3_18_9();
}
void fix_ingred_service_3_19_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> album); }
    {char * end; end = (char *)(song -> album); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> album); }
    {int count; count = (int)(song -> album); }
    {int i; i = (int)(song -> album); }
    {char * delim; delim = (char *)(song -> album); }
    {int ret; ret = (int)(song -> album); }
    {void * tlv8; tlv8 = (void *)(song -> album); }
    {int tlv7; tlv7 = (int)(song -> album); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> album); }
    {int tlv1; tlv1 = (int)(song -> album); }
    {void * tlv11; tlv11 = (void *)(song -> album); }
    {void * tlv10; tlv10 = (void *)(song -> album); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> album); }
    {void * tlv14; tlv14 = (void *)(song -> album); }
    {int tlv13; tlv13 = (int)(song -> album); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> album); }
    {int tlv2; tlv2 = (int)(song -> album); }
    {char * tlv18; tlv18 = (char *)(song -> album); }
    {char * tlv17; tlv17 = (char *)(song -> album); }
    {int tlv3; tlv3 = (int)(song -> album); }
    {char * tlv22; tlv22 = (char *)(song -> album); }
    {char * tlv21; tlv21 = (char *)(song -> album); }
    {int tlv4; tlv4 = (int)(song -> album); }
    {char * tlv26; tlv26 = (char *)(song -> album); }
    {char * tlv25; tlv25 = (char *)(song -> album); }
    {int tlv5; tlv5 = (int)(song -> album); }
    {char * tlv30; tlv30 = (char *)(song -> album); }
    {char * tlv29; tlv29 = (char *)(song -> album); }
    {char * tlv34; tlv34 = (char *)(song -> album); }
    {char * tlv33; tlv33 = (char *)(song -> album); }
}
void fix_ingred_service_3_19(){
fix_ingred_service_3_19_1();
}
void fix_ingred_service_3_22_9(){
int tlv5;
    bzero(&tlv5,sizeof(int));
    {char * start; start = (char *)(tlv5); }
    {char * end; end = (char *)(tlv5); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(tlv5); }
    {int count; count = (int)(tlv5); }
    {int i; i = (int)(tlv5); }
    {char * delim; delim = (char *)(tlv5); }
    {int ret; ret = (int)(tlv5); }
    {void * tlv8; tlv8 = (void *)(tlv5); }
    {int tlv7; tlv7 = (int)(tlv5); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(tlv5); }
    {int tlv1; tlv1 = (int)(tlv5); }
    {void * tlv11; tlv11 = (void *)(tlv5); }
    {void * tlv10; tlv10 = (void *)(tlv5); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(tlv5); }
    {void * tlv14; tlv14 = (void *)(tlv5); }
    {int tlv13; tlv13 = (int)(tlv5); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(tlv5); }
    {int tlv2; tlv2 = (int)(tlv5); }
    {char * tlv18; tlv18 = (char *)(tlv5); }
    {char * tlv17; tlv17 = (char *)(tlv5); }
    {int tlv3; tlv3 = (int)(tlv5); }
    {char * tlv22; tlv22 = (char *)(tlv5); }
    {char * tlv21; tlv21 = (char *)(tlv5); }
    {int tlv4; tlv4 = (int)(tlv5); }
    {char * tlv26; tlv26 = (char *)(tlv5); }
    {char * tlv25; tlv25 = (char *)(tlv5); }
    {char * tlv30; tlv30 = (char *)(tlv5); }
    {char * tlv29; tlv29 = (char *)(tlv5); }
    {char * tlv34; tlv34 = (char *)(tlv5); }
    {char * tlv33; tlv33 = (char *)(tlv5); }
}
void fix_ingred_service_3_22(){
fix_ingred_service_3_22_9();
}
void fix_ingred_service_3_23_1(){
Song song_ref;
    bzero(&song_ref,1*sizeof(Song));
Song * song = &song_ref;
    {char * start; start = (char *)(song -> song); }
    {char * end; end = (char *)(song -> song); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(song -> song); }
    {int count; count = (int)(song -> song); }
    {int i; i = (int)(song -> song); }
    {char * delim; delim = (char *)(song -> song); }
    {int ret; ret = (int)(song -> song); }
    {void * tlv8; tlv8 = (void *)(song -> song); }
    {int tlv7; tlv7 = (int)(song -> song); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(song -> song); }
    {int tlv1; tlv1 = (int)(song -> song); }
    {void * tlv11; tlv11 = (void *)(song -> song); }
    {void * tlv10; tlv10 = (void *)(song -> song); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(song -> song); }
    {void * tlv14; tlv14 = (void *)(song -> song); }
    {int tlv13; tlv13 = (int)(song -> song); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(song -> song); }
    {int tlv2; tlv2 = (int)(song -> song); }
    {char * tlv18; tlv18 = (char *)(song -> song); }
    {char * tlv17; tlv17 = (char *)(song -> song); }
    {int tlv3; tlv3 = (int)(song -> song); }
    {char * tlv22; tlv22 = (char *)(song -> song); }
    {char * tlv21; tlv21 = (char *)(song -> song); }
    {int tlv4; tlv4 = (int)(song -> song); }
    {char * tlv26; tlv26 = (char *)(song -> song); }
    {char * tlv25; tlv25 = (char *)(song -> song); }
    {int tlv5; tlv5 = (int)(song -> song); }
    {char * tlv30; tlv30 = (char *)(song -> song); }
    {char * tlv29; tlv29 = (char *)(song -> song); }
    {char * tlv34; tlv34 = (char *)(song -> song); }
    {char * tlv33; tlv33 = (char *)(song -> song); }
}
void fix_ingred_service_3_23(){
fix_ingred_service_3_23_1();
}
void fix_ingred_service_3_25_2(){
    {char * start; start = (char *)(KEY_SIZE); }
    {char * end; end = (char *)(KEY_SIZE); }
    {char key [ KEY_SIZE ]; key [ ( KEY_SIZE )-1 ] = (char)(KEY_SIZE); }
    {int count; count = (int)(KEY_SIZE); }
    {int i; i = (int)(KEY_SIZE); }
    {char * delim; delim = (char *)(KEY_SIZE); }
    {int ret; ret = (int)(KEY_SIZE); }
    {void * tlv8; tlv8 = (void *)(KEY_SIZE); }
    {int tlv7; tlv7 = (int)(KEY_SIZE); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(KEY_SIZE); }
    {int tlv1; tlv1 = (int)(KEY_SIZE); }
    {void * tlv11; tlv11 = (void *)(KEY_SIZE); }
    {void * tlv10; tlv10 = (void *)(KEY_SIZE); }
    {cgc_size_t tlv9; tlv9 = (cgc_size_t)(KEY_SIZE); }
    {void * tlv14; tlv14 = (void *)(KEY_SIZE); }
    {int tlv13; tlv13 = (int)(KEY_SIZE); }
    {cgc_size_t tlv12; tlv12 = (cgc_size_t)(KEY_SIZE); }
    {int tlv2; tlv2 = (int)(KEY_SIZE); }
    {char * tlv18; tlv18 = (char *)(KEY_SIZE); }
    {char * tlv17; tlv17 = (char *)(KEY_SIZE); }
    {int tlv3; tlv3 = (int)(KEY_SIZE); }
    {char * tlv22; tlv22 = (char *)(KEY_SIZE); }
    {char * tlv21; tlv21 = (char *)(KEY_SIZE); }
    {int tlv4; tlv4 = (int)(KEY_SIZE); }
    {char * tlv26; tlv26 = (char *)(KEY_SIZE); }
    {char * tlv25; tlv25 = (char *)(KEY_SIZE); }
    {int tlv5; tlv5 = (int)(KEY_SIZE); }
    {char * tlv30; tlv30 = (char *)(KEY_SIZE); }
    {char * tlv29; tlv29 = (char *)(KEY_SIZE); }
    {char * tlv34; tlv34 = (char *)(KEY_SIZE); }
    {char * tlv33; tlv33 = (char *)(KEY_SIZE); }
}
void fix_ingred_service_3_25(){
fix_ingred_service_3_25_2();
}
void fix_ingred_service_3(){
fix_ingred_service_3_0();
fix_ingred_service_3_1();
fix_ingred_service_3_2();
fix_ingred_service_3_3();
fix_ingred_service_3_4();
fix_ingred_service_3_6();
fix_ingred_service_3_7();
fix_ingred_service_3_10();
fix_ingred_service_3_11();
fix_ingred_service_3_14();
fix_ingred_service_3_15();
fix_ingred_service_3_18();
fix_ingred_service_3_19();
fix_ingred_service_3_22();
fix_ingred_service_3_23();
fix_ingred_service_3_25();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_3_0_0();
void fix_ingred_service_3_0_2();
void fix_ingred_service_3_0_4();
void fix_ingred_service_3_0_6();
void fix_ingred_service_3_0();
void fix_ingred_service_3_1_0();
void fix_ingred_service_3_1_2();
void fix_ingred_service_3_1();
void fix_ingred_service_3_2_0();
void fix_ingred_service_3_2();
void fix_ingred_service_3_3_9();
void fix_ingred_service_3_3_10();
void fix_ingred_service_3_3_11();
void fix_ingred_service_3_3_12();
void fix_ingred_service_3_3();
void fix_ingred_service_3_4_0();
void fix_ingred_service_3_4_1();
void fix_ingred_service_3_4_2();
void fix_ingred_service_3_4();
void fix_ingred_service_3_6_9();
void fix_ingred_service_3_6();
void fix_ingred_service_3_7_0();
void fix_ingred_service_3_7_1();
void fix_ingred_service_3_7();
void fix_ingred_service_3_10_9();
void fix_ingred_service_3_10();
void fix_ingred_service_3_11_1();
void fix_ingred_service_3_11();
void fix_ingred_service_3_14_9();
void fix_ingred_service_3_14();
void fix_ingred_service_3_15_1();
void fix_ingred_service_3_15();
void fix_ingred_service_3_18_9();
void fix_ingred_service_3_18();
void fix_ingred_service_3_19_1();
void fix_ingred_service_3_19();
void fix_ingred_service_3_22_9();
void fix_ingred_service_3_22();
void fix_ingred_service_3_23_1();
void fix_ingred_service_3_23();
void fix_ingred_service_3_25_2();
void fix_ingred_service_3_25();
void fix_ingred_service_3();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : char buf [ 1024 ] = { 0 } ;
def_vars[1]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : int bytes_read ;
def_vars[2]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : int balance ;
def_vars[3]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[4]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[5]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[6]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : char * tlv4 ;
def_vars[7]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[8]: [cgc_receiveBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'balance': 'int'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0e898>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1d748>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/18][j=0/6][dd=0/9][k=0/2] | type: int ; var : bytes_read ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/18][j=0/6][dd=1/9][k=0/2] | type: int ; var : bytes_read ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/18][j=0/6][dd=4/9][k=0/2] | type: int ; var : bytes_read ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/18][j=0/6][dd=6/9][k=0/2] | type: int ; var : bytes_read ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/18][j=0/6][dd=7/9][k=0/2] | type: int ; var : bytes_read ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_service_4_0_0(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(0); }
    {int bytes_read; bytes_read = (int)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {char * tlv4; tlv4 = (char *)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_service_4_0(){
fix_ingred_service_4_0_0();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'balance': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a2f7b8>), ('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a30748>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a08668>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0e898>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1d748>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=0/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
unique : ('int', 'socket', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=0/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
unique : ('char', 'buf [ 1024 ]', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=0/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=1/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=1/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=1/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=2/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=2/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=2/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=3/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=3/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=3/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=4/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=4/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=4/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=5/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=5/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=5/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=6/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=6/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=6/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=4/18][j=1/6][dd=7/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/18][j=1/6][dd=7/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=4/18][j=1/6][dd=7/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('int','socket','None','None');

UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

----
UNIQ_INIT: ('int','socket','None','None');

UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

----
UNIQ_INIT: ('int','socket','None','None');

UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

==== Scope 1 ====
void fix_ingred_service_4_1_0(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(socket); }
    {int bytes_read; bytes_read = (int)(socket); }
    {int balance; balance = (int)(socket); }
    {int tlv3; tlv3 = (int)(socket); }
    {char * tlv2; tlv2 = (char *)(socket); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(socket); }
    {char * tlv4; tlv4 = (char *)(socket); }
    {unsigned int tlv5; tlv5 = (unsigned int)(socket); }
}
void fix_ingred_service_4_1_1(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(buf); }
    {int bytes_read; bytes_read = (int)(buf); }
    {int balance; balance = (int)(buf); }
    {int tlv3; tlv3 = (int)(buf); }
    {char * tlv2; tlv2 = (char *)(buf); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(buf); }
    {char * tlv4; tlv4 = (char *)(buf); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buf); }
}
void fix_ingred_service_4_1_2(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(sizeof ( buf ) - 1); }
    {int bytes_read; bytes_read = (int)(sizeof ( buf ) - 1); }
    {int balance; balance = (int)(sizeof ( buf ) - 1); }
    {int tlv3; tlv3 = (int)(sizeof ( buf ) - 1); }
    {char * tlv2; tlv2 = (char *)(sizeof ( buf ) - 1); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( buf ) - 1); }
    {char * tlv4; tlv4 = (char *)(sizeof ( buf ) - 1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( buf ) - 1); }
}
void fix_ingred_service_4_1(){
fix_ingred_service_4_1_0();
fix_ingred_service_4_1_1();
fix_ingred_service_4_1_2();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'balance': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0e898>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1d748>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4a21dd8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49f5128>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=0/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
unique : ('int', 'bytes_read', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=1/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=2/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=3/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=4/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=5/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=6/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=4/18][j=2/6][dd=7/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
not valid - int bytes_read; bytes_read = ((int)bytes_read);

----
UNIQ_INIT: ('int','bytes_read','None','None');

==== Scope 1 ====
void fix_ingred_service_4_2_2(){
int bytes_read;
    bzero(&bytes_read,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(bytes_read); }
    {int balance; balance = (int)(bytes_read); }
    {int tlv3; tlv3 = (int)(bytes_read); }
    {char * tlv2; tlv2 = (char *)(bytes_read); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(bytes_read); }
    {char * tlv4; tlv4 = (char *)(bytes_read); }
    {unsigned int tlv5; tlv5 = (unsigned int)(bytes_read); }
}
void fix_ingred_service_4_2(){
fix_ingred_service_4_2_2();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'balance': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49f5eb8>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0e898>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1d748>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4a21dd8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb49f5128>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=0/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=1/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=2/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=3/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=4/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=5/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=6/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=4/18][j=3/6][dd=7/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
----
==== Scope 1 ====
void fix_ingred_service_4_3_0(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(2); }
    {int bytes_read; bytes_read = (int)(2); }
    {int balance; balance = (int)(2); }
    {int tlv3; tlv3 = (int)(2); }
    {char * tlv2; tlv2 = (char *)(2); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(2); }
    {char * tlv4; tlv4 = (char *)(2); }
    {unsigned int tlv5; tlv5 = (unsigned int)(2); }
}
void fix_ingred_service_4_3(){
fix_ingred_service_4_3_0();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'balance': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0e898>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1d748>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4a170b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4a17438>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'balance': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'tlv4': 'char *'}'
val_s=>'[('char *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a16c18>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a0e898>), ('int', 'balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1d748>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_service_4_0_0(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(0); }
    {int bytes_read; bytes_read = (int)(0); }
    {char * tlv2; tlv2 = (char *)(0); }
    {char * tlv4; tlv4 = (char *)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_service_4_0(){
fix_ingred_service_4_0_0();
}
void fix_ingred_service_4_1_0(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(socket); }
    {int bytes_read; bytes_read = (int)(socket); }
    {int balance; balance = (int)(socket); }
    {int tlv3; tlv3 = (int)(socket); }
    {char * tlv2; tlv2 = (char *)(socket); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(socket); }
    {char * tlv4; tlv4 = (char *)(socket); }
    {unsigned int tlv5; tlv5 = (unsigned int)(socket); }
}
void fix_ingred_service_4_1_1(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(buf); }
    {int bytes_read; bytes_read = (int)(buf); }
    {int balance; balance = (int)(buf); }
    {int tlv3; tlv3 = (int)(buf); }
    {char * tlv2; tlv2 = (char *)(buf); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(buf); }
    {char * tlv4; tlv4 = (char *)(buf); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buf); }
}
void fix_ingred_service_4_1_2(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(sizeof ( buf ) - 1); }
    {int bytes_read; bytes_read = (int)(sizeof ( buf ) - 1); }
    {int balance; balance = (int)(sizeof ( buf ) - 1); }
    {int tlv3; tlv3 = (int)(sizeof ( buf ) - 1); }
    {char * tlv2; tlv2 = (char *)(sizeof ( buf ) - 1); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( buf ) - 1); }
    {char * tlv4; tlv4 = (char *)(sizeof ( buf ) - 1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( buf ) - 1); }
}
void fix_ingred_service_4_1(){
fix_ingred_service_4_1_0();
fix_ingred_service_4_1_1();
fix_ingred_service_4_1_2();
}
void fix_ingred_service_4_2_2(){
int bytes_read;
    bzero(&bytes_read,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(bytes_read); }
    {int balance; balance = (int)(bytes_read); }
    {int tlv3; tlv3 = (int)(bytes_read); }
    {char * tlv2; tlv2 = (char *)(bytes_read); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(bytes_read); }
    {char * tlv4; tlv4 = (char *)(bytes_read); }
    {unsigned int tlv5; tlv5 = (unsigned int)(bytes_read); }
}
void fix_ingred_service_4_2(){
fix_ingred_service_4_2_2();
}
void fix_ingred_service_4_3_0(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(2); }
    {int bytes_read; bytes_read = (int)(2); }
    {int balance; balance = (int)(2); }
    {int tlv3; tlv3 = (int)(2); }
    {char * tlv2; tlv2 = (char *)(2); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(2); }
    {char * tlv4; tlv4 = (char *)(2); }
    {unsigned int tlv5; tlv5 = (unsigned int)(2); }
}
void fix_ingred_service_4_3(){
fix_ingred_service_4_3_0();
}
void fix_ingred_service_4(){
fix_ingred_service_4_0();
fix_ingred_service_4_1();
fix_ingred_service_4_2();
fix_ingred_service_4_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_4_0_0();
void fix_ingred_service_4_0();
void fix_ingred_service_4_1_0();
void fix_ingred_service_4_1_1();
void fix_ingred_service_4_1_2();
void fix_ingred_service_4_1();
void fix_ingred_service_4_2_2();
void fix_ingred_service_4_2();
void fix_ingred_service_4_3_0();
void fix_ingred_service_4_3();
void fix_ingred_service_4();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : char buf [ 1024 ] = { 0 } ;
def_vars[1]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : int bytes_read ;
def_vars[2]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : int num_results ;
def_vars[3]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[4]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : char * tlv2 ;
def_vars[5]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[6]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : char * tlv4 ;
def_vars[7]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[8]: [cgc_receiveNumResults] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1ac18>), ('char *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a06ba8>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a1cac8>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=5/18][j=1/7][dd=2/9][k=0/5] | type: int ; var : tlv3 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
unique : ('int', 'socket', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=5/18][j=1/7][dd=2/9][k=1/5] | type: char * ; var : tlv2 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
unique : ('char', 'buf [ 1024 ]', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=5/18][j=1/7][dd=2/9][k=2/5] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('int','socket','None','None');

UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

----
UNIQ_INIT: ('int','socket','None','None');

UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

----
UNIQ_INIT: ('int','socket','None','None');

UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

==== Scope 1 ====
void fix_ingred_service_5_1_0(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int num_results; num_results = (int)(socket); }
}
void fix_ingred_service_5_1_1(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int num_results; num_results = (int)(buf); }
}
void fix_ingred_service_5_1_2(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int num_results; num_results = (int)(sizeof ( buf ) - 1); }
}
void fix_ingred_service_5_1(){
fix_ingred_service_5_1_0();
fix_ingred_service_5_1_1();
fix_ingred_service_5_1_2();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4a09278>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4a09588>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=5/18][j=2/7][dd=2/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
unique : ('int', 'bytes_read', None)
----
UNIQ_INIT: ('int','bytes_read','None','None');

==== Scope 1 ====
void fix_ingred_service_5_2_2(){
int bytes_read;
    bzero(&bytes_read,sizeof(int));
    {int num_results; num_results = (int)(bytes_read); }
}
void fix_ingred_service_5_2(){
fix_ingred_service_5_2_2();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f6358>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4a09278>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4a09588>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=5/18][j=3/7][dd=2/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
----
==== Scope 1 ====
void fix_ingred_service_5_3_0(){
    {int num_results; num_results = (int)(2); }
}
void fix_ingred_service_5_3(){
fix_ingred_service_5_3_0();
}

sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb43fd518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb43fd898>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'tlv4': 'char *'}'
val_s=>'[('char *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb44070b8>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'bytes_read': 'int', 'num_results': 'int', 'tlv3': 'int', 'tlv2': 'char *', 'tlv1': 'cgc_size_t', 'tlv4': 'char *'}'
val_s=>'[('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a00cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49faba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4408ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4408dd8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=0/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
unique : ('int', 'num_results', None)
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=1/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=2/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=3/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=4/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=5/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=6/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'num_results' - False OR  False
[i=5/18][j=6/7][dd=7/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : num_results (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : num_results
 => is literal (False) | is operator (False) num_results [vtype=int]
not unique: ('int', 'num_results', None) ... continue!
not valid - int num_results; num_results = ((int)num_results);

----
UNIQ_INIT: ('int','num_results','None','None');

==== Scope 1 ====
void fix_ingred_service_5_6_2(){
int num_results;
    bzero(&num_results,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(num_results); }
    {int bytes_read; bytes_read = (int)(num_results); }
    {int tlv3; tlv3 = (int)(num_results); }
    {char * tlv2; tlv2 = (char *)(num_results); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(num_results); }
    {char * tlv4; tlv4 = (char *)(num_results); }
    {unsigned int tlv5; tlv5 = (unsigned int)(num_results); }
}
void fix_ingred_service_5_6(){
fix_ingred_service_5_6_2();
}

==== Scope 2 ====
void fix_ingred_service_5_1_0(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int num_results; num_results = (int)(socket); }
}
void fix_ingred_service_5_1_1(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int num_results; num_results = (int)(buf); }
}
void fix_ingred_service_5_1_2(){
int socket;
    bzero(&socket,sizeof(int));
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int num_results; num_results = (int)(sizeof ( buf ) - 1); }
}
void fix_ingred_service_5_1(){
fix_ingred_service_5_1_0();
fix_ingred_service_5_1_1();
fix_ingred_service_5_1_2();
}
void fix_ingred_service_5_2_2(){
int bytes_read;
    bzero(&bytes_read,sizeof(int));
    {int num_results; num_results = (int)(bytes_read); }
}
void fix_ingred_service_5_2(){
fix_ingred_service_5_2_2();
}
void fix_ingred_service_5_3_0(){
    {int num_results; num_results = (int)(2); }
}
void fix_ingred_service_5_3(){
fix_ingred_service_5_3_0();
}
void fix_ingred_service_5_6_2(){
int num_results;
    bzero(&num_results,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(num_results); }
    {int bytes_read; bytes_read = (int)(num_results); }
    {int tlv3; tlv3 = (int)(num_results); }
    {char * tlv2; tlv2 = (char *)(num_results); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(num_results); }
    {char * tlv4; tlv4 = (char *)(num_results); }
    {unsigned int tlv5; tlv5 = (unsigned int)(num_results); }
}
void fix_ingred_service_5_6(){
fix_ingred_service_5_6_2();
}
void fix_ingred_service_5(){
fix_ingred_service_5_1();
fix_ingred_service_5_2();
fix_ingred_service_5_3();
fix_ingred_service_5_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_5_1_0();
void fix_ingred_service_5_1_1();
void fix_ingred_service_5_1_2();
void fix_ingred_service_5_1();
void fix_ingred_service_5_2_2();
void fix_ingred_service_5_2();
void fix_ingred_service_5_3_0();
void fix_ingred_service_5_3();
void fix_ingred_service_5_6_2();
void fix_ingred_service_5_6();
void fix_ingred_service_5();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : char buf [ 1024 ] = { 0 } ;
def_vars[1]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[2]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : int bytes_read ;
def_vars[3]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : int num_results ;
def_vars[4]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[5]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[6]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : char * tlv3 ;
def_vars[7]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[8]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[9]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
def_vars[10]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[11]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : Song * tlv6 ;
def_vars[12]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv8 ;
def_vars[13]: [cgc_receiveSearchResults] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv8 ) ;
sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/18][j=0/11][dd=6/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/18][j=0/11][dd=11/14][k=0/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_service_6_0_0(){
    {char * tlv3; tlv3 = (char *)(0); }
    {unsigned int tlv8; tlv8 = (unsigned int)(0); }
}
void fix_ingred_service_6_0(){
fix_ingred_service_6_0_0();
}

sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int'}'
val_s=>'[('int', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb440bc18>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=1/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
unique : ('int', 'socket', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=4/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=5/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=6/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=7/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=9/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=6/18][j=1/11][dd=11/14][k=0/4] | type: int ; var : tlv1 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
----
UNIQ_INIT: ('int','socket','None','None');

==== Scope 1 ====
void fix_ingred_service_6_1_0(){
int socket;
    bzero(&socket,sizeof(int));
    {int ret; ret = (int)(socket); }
    {int tlv1; tlv1 = (int)(socket); }
    {int tlv4; tlv4 = (int)(socket); }
    {char * tlv3; tlv3 = (char *)(socket); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(socket); }
    {char * tlv7; tlv7 = (char *)(socket); }
    {unsigned int tlv8; tlv8 = (unsigned int)(socket); }
}
void fix_ingred_service_6_1(){
fix_ingred_service_6_1_0();
}

sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4413438>), ('char *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb44143c8>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb44172e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=1/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
unique : ('char', 'buf [ 1024 ]', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=1/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=4/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=4/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=5/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=5/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=6/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=6/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=7/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=7/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=9/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=9/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=6/18][j=3/11][dd=11/14][k=1/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)-1' - False OR  False
[i=6/18][j=3/11][dd=11/14][k=2/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( buf ) - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,),-,1
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

----
UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

==== Scope 1 ====
void fix_ingred_service_6_3_1(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int ret; ret = (int)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {char * tlv3; tlv3 = (char *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {char * tlv7; tlv7 = (char *)(buf); }
    {unsigned int tlv8; tlv8 = (unsigned int)(buf); }
}
void fix_ingred_service_6_3_2(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int ret; ret = (int)(sizeof ( buf ) - 1); }
    {int tlv1; tlv1 = (int)(sizeof ( buf ) - 1); }
    {int tlv4; tlv4 = (int)(sizeof ( buf ) - 1); }
    {char * tlv3; tlv3 = (char *)(sizeof ( buf ) - 1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( buf ) - 1); }
    {char * tlv7; tlv7 = (char *)(sizeof ( buf ) - 1); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( buf ) - 1); }
}
void fix_ingred_service_6_3(){
fix_ingred_service_6_3_1();
fix_ingred_service_6_3_2();
}

sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4420a58>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4420d68>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=1/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
unique : ('int', 'bytes_read', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=4/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=5/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=6/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=7/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=9/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_read' - False OR  False
[i=6/18][j=4/11][dd=11/14][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : bytes_read (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_read
 => is literal (False) | is operator (False) bytes_read [vtype=int]
not unique: ('int', 'bytes_read', None) ... continue!
----
UNIQ_INIT: ('int','bytes_read','None','None');

==== Scope 1 ====
void fix_ingred_service_6_4_3(){
int bytes_read;
    bzero(&bytes_read,sizeof(int));
    {int ret; ret = (int)(bytes_read); }
    {int tlv1; tlv1 = (int)(bytes_read); }
    {int tlv4; tlv4 = (int)(bytes_read); }
    {char * tlv3; tlv3 = (char *)(bytes_read); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(bytes_read); }
    {char * tlv7; tlv7 = (char *)(bytes_read); }
    {unsigned int tlv8; tlv8 = (unsigned int)(bytes_read); }
}
void fix_ingred_service_6_4(){
fix_ingred_service_6_4_3();
}

sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb441fb38>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4420a58>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4420d68>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=1/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=4/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=5/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=6/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=7/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=9/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=6/18][j=5/11][dd=11/14][k=0/6] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
----
==== Scope 1 ====
void fix_ingred_service_6_5_0(){
    {int ret; ret = (int)(2); }
    {int tlv1; tlv1 = (int)(2); }
    {int tlv4; tlv4 = (int)(2); }
    {char * tlv3; tlv3 = (char *)(2); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(2); }
    {char * tlv7; tlv7 = (char *)(2); }
    {unsigned int tlv8; tlv8 = (unsigned int)(2); }
}
void fix_ingred_service_6_5(){
fix_ingred_service_6_5_0();
}

sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4419cf8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb44290b8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427438>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427748>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv7': 'char *', 'tlv6': 'Song *'}'
val_s=>'[('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb44215f8>), ('Song *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb442b5f8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427438>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427748>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv7': 'char *', 'tlv6': 'Song *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427438>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427748>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb442aa58>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb442add8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=0/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=1/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=2/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=3/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=4/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=5/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=6/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=7/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=8/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=9/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=6/18][j=9/11][dd=11/14][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
not valid - int ret; ret = ((int)ret);

----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_6_9_5(){
int ret;
    bzero(&ret,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(ret); }
    {int bytes_read; bytes_read = (int)(ret); }
    {int num_results; num_results = (int)(ret); }
    {int tlv1; tlv1 = (int)(ret); }
    {int tlv4; tlv4 = (int)(ret); }
    {char * tlv3; tlv3 = (char *)(ret); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(ret); }
    {unsigned int tlv5; tlv5 = (unsigned int)(ret); }
    {char * tlv7; tlv7 = (char *)(ret); }
    {unsigned int tlv8; tlv8 = (unsigned int)(ret); }
}
void fix_ingred_service_6_9(){
fix_ingred_service_6_9_5();
}

sym_lut=>'{'socket': 'int', 'songList': 'SongList *', 'limit': 'int', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'ret': 'int', 'bytes_read': 'int', 'num_results': 'int', 'tlv1': 'int', 'tlv4': 'int', 'tlv3': 'char *', 'tlv2': 'cgc_size_t', 'tlv7': 'char *', 'tlv6': 'Song *', 'tlv8': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb442ec18>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f8e48>), ('int', 'bytes_read', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43f9cf8>), ('int', 'num_results', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4409ba8>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427438>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4427748>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb442aa58>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb442add8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=0/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=1/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=2/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=3/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=4/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=5/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=6/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=7/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=8/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=9/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=6/18][j=10/11][dd=11/14][k=0/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
----
==== Scope 1 ====
void fix_ingred_service_6_10_0(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(10); }
    {int ret; ret = (int)(10); }
    {int bytes_read; bytes_read = (int)(10); }
    {int num_results; num_results = (int)(10); }
    {int tlv1; tlv1 = (int)(10); }
    {int tlv4; tlv4 = (int)(10); }
    {char * tlv3; tlv3 = (char *)(10); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(10); }
    {unsigned int tlv5; tlv5 = (unsigned int)(10); }
    {char * tlv7; tlv7 = (char *)(10); }
    {unsigned int tlv8; tlv8 = (unsigned int)(10); }
}
void fix_ingred_service_6_10(){
fix_ingred_service_6_10_0();
}

==== Scope 2 ====
void fix_ingred_service_6_0_0(){
    {char * tlv3; tlv3 = (char *)(0); }
    {unsigned int tlv8; tlv8 = (unsigned int)(0); }
}
void fix_ingred_service_6_0(){
fix_ingred_service_6_0_0();
}
void fix_ingred_service_6_1_0(){
int socket;
    bzero(&socket,sizeof(int));
    {int ret; ret = (int)(socket); }
    {int tlv1; tlv1 = (int)(socket); }
    {int tlv4; tlv4 = (int)(socket); }
    {char * tlv3; tlv3 = (char *)(socket); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(socket); }
    {char * tlv7; tlv7 = (char *)(socket); }
    {unsigned int tlv8; tlv8 = (unsigned int)(socket); }
}
void fix_ingred_service_6_1(){
fix_ingred_service_6_1_0();
}
void fix_ingred_service_6_3_1(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int ret; ret = (int)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {char * tlv3; tlv3 = (char *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {char * tlv7; tlv7 = (char *)(buf); }
    {unsigned int tlv8; tlv8 = (unsigned int)(buf); }
}
void fix_ingred_service_6_3_2(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {int ret; ret = (int)(sizeof ( buf ) - 1); }
    {int tlv1; tlv1 = (int)(sizeof ( buf ) - 1); }
    {int tlv4; tlv4 = (int)(sizeof ( buf ) - 1); }
    {char * tlv3; tlv3 = (char *)(sizeof ( buf ) - 1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( buf ) - 1); }
    {char * tlv7; tlv7 = (char *)(sizeof ( buf ) - 1); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( buf ) - 1); }
}
void fix_ingred_service_6_3(){
fix_ingred_service_6_3_1();
fix_ingred_service_6_3_2();
}
void fix_ingred_service_6_4_3(){
int bytes_read;
    bzero(&bytes_read,sizeof(int));
    {int ret; ret = (int)(bytes_read); }
    {int tlv1; tlv1 = (int)(bytes_read); }
    {int tlv4; tlv4 = (int)(bytes_read); }
    {char * tlv3; tlv3 = (char *)(bytes_read); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(bytes_read); }
    {char * tlv7; tlv7 = (char *)(bytes_read); }
    {unsigned int tlv8; tlv8 = (unsigned int)(bytes_read); }
}
void fix_ingred_service_6_4(){
fix_ingred_service_6_4_3();
}
void fix_ingred_service_6_5_0(){
    {int ret; ret = (int)(2); }
    {int tlv1; tlv1 = (int)(2); }
    {int tlv4; tlv4 = (int)(2); }
    {char * tlv3; tlv3 = (char *)(2); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(2); }
    {char * tlv7; tlv7 = (char *)(2); }
    {unsigned int tlv8; tlv8 = (unsigned int)(2); }
}
void fix_ingred_service_6_5(){
fix_ingred_service_6_5_0();
}
void fix_ingred_service_6_9_5(){
int ret;
    bzero(&ret,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(ret); }
    {int bytes_read; bytes_read = (int)(ret); }
    {int num_results; num_results = (int)(ret); }
    {int tlv1; tlv1 = (int)(ret); }
    {int tlv4; tlv4 = (int)(ret); }
    {char * tlv3; tlv3 = (char *)(ret); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(ret); }
    {unsigned int tlv5; tlv5 = (unsigned int)(ret); }
    {char * tlv7; tlv7 = (char *)(ret); }
    {unsigned int tlv8; tlv8 = (unsigned int)(ret); }
}
void fix_ingred_service_6_9(){
fix_ingred_service_6_9_5();
}
void fix_ingred_service_6_10_0(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(10); }
    {int ret; ret = (int)(10); }
    {int bytes_read; bytes_read = (int)(10); }
    {int num_results; num_results = (int)(10); }
    {int tlv1; tlv1 = (int)(10); }
    {int tlv4; tlv4 = (int)(10); }
    {char * tlv3; tlv3 = (char *)(10); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(10); }
    {unsigned int tlv5; tlv5 = (unsigned int)(10); }
    {char * tlv7; tlv7 = (char *)(10); }
    {unsigned int tlv8; tlv8 = (unsigned int)(10); }
}
void fix_ingred_service_6_10(){
fix_ingred_service_6_10_0();
}
void fix_ingred_service_6(){
fix_ingred_service_6_0();
fix_ingred_service_6_1();
fix_ingred_service_6_3();
fix_ingred_service_6_4();
fix_ingred_service_6_5();
fix_ingred_service_6_9();
fix_ingred_service_6_10();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_6_0_0();
void fix_ingred_service_6_0();
void fix_ingred_service_6_1_0();
void fix_ingred_service_6_1();
void fix_ingred_service_6_3_1();
void fix_ingred_service_6_3_2();
void fix_ingred_service_6_3();
void fix_ingred_service_6_4_3();
void fix_ingred_service_6_4();
void fix_ingred_service_6_5_0();
void fix_ingred_service_6_5();
void fix_ingred_service_6_9_5();
void fix_ingred_service_6_9();
void fix_ingred_service_6_10_0();
void fix_ingred_service_6_10();
void fix_ingred_service_6();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * buffer ;
def_vars[1]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[2]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv30 ;
def_vars[3]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : int tlv29 ;
def_vars[4]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : void * * tlv28 ;
def_vars[5]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[6]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[7]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[8]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv5 ;
def_vars[9]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv4 = TERM_STR ;
def_vars[10]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[11]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = KEYVAL_DELIM ;
def_vars[12]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv9 ;
def_vars[13]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv8 = request . term ;
def_vars[14]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv11 ;
def_vars[15]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv10 = PARAM_DELIM ;
def_vars[16]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv13 ;
def_vars[17]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv12 = ATTRIBUTE_STR ;
def_vars[18]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv15 ;
def_vars[19]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv14 = KEYVAL_DELIM ;
def_vars[20]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv17 ;
def_vars[21]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv16 = request . attribute ;
def_vars[22]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv19 ;
def_vars[23]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv18 = PARAM_DELIM ;
def_vars[24]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv21 ;
def_vars[25]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv20 = LIMIT_STR ;
def_vars[26]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv23 ;
def_vars[27]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv22 = KEYVAL_DELIM ;
def_vars[28]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv25 ;
def_vars[29]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv24 = request . limit ;
def_vars[30]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * tlv27 ;
def_vars[31]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv26 = EOL_STR ;
def_vars[32]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv31 ;
def_vars[33]: [cgc_createSearchString] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv31 ) ;
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int'}'
val_s=>'[('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=0/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=0/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=2/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=2/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=3/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=3/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=8/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=8/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=12/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=12/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=14/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=14/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=16/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=16/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=18/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=18/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=22/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=22/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=26/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=26/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=30/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=30/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=7/18][j=0/17][dd=32/34][k=0/2] | type: char * ; var : buffer ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/18][j=0/17][dd=32/34][k=1/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_service_7_0_0(){
    {char * buffer; buffer = (char *)(NULL); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(NULL); }
    {int tlv29; tlv29 = (int)(NULL); }
    {char * tlv5; tlv5 = (char *)(NULL); }
    {char * tlv9; tlv9 = (char *)(NULL); }
    {char * tlv11; tlv11 = (char *)(NULL); }
    {char * tlv13; tlv13 = (char *)(NULL); }
    {char * tlv15; tlv15 = (char *)(NULL); }
    {char * tlv19; tlv19 = (char *)(NULL); }
    {char * tlv23; tlv23 = (char *)(NULL); }
    {char * tlv27; tlv27 = (char *)(NULL); }
    {unsigned int tlv31; tlv31 = (unsigned int)(NULL); }
}
void fix_ingred_service_7_0_1(){
    {char * buffer; buffer = (char *)(0); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(0); }
    {int tlv29; tlv29 = (int)(0); }
    {char * tlv5; tlv5 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {char * tlv11; tlv11 = (char *)(0); }
    {char * tlv13; tlv13 = (char *)(0); }
    {char * tlv15; tlv15 = (char *)(0); }
    {char * tlv19; tlv19 = (char *)(0); }
    {char * tlv23; tlv23 = (char *)(0); }
    {char * tlv27; tlv27 = (char *)(0); }
    {unsigned int tlv31; tlv31 = (unsigned int)(0); }
}
void fix_ingred_service_7_0(){
fix_ingred_service_7_0_0();
fix_ingred_service_7_0_1();
}

sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *'}'
val_s=>'[('cgc_size_t', 'tlv30', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b54a8>), ('int', 'tlv29', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43c1cf8>), ('void * *', 'tlv28', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43bdc88>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=0/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
unique : ('Request', 'request', None)
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=1/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=2/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=3/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=5/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=6/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=7/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=8/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=10/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=12/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=14/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=16/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=18/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=20/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=22/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=24/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=26/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=28/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=30/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(request)+cgc_MIN_REQ_LEN' - False OR  False
[i=7/18][j=1/17][dd=32/34][k=0/5] | type: cgc_size_t ; var : tlv30 ; varinfo :  ; value_node : sizeof ( request ) + cgc_MIN_REQ_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,request,),+,cgc_MIN_REQ_LEN
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) request [vtype=Request]
not unique: ('Request', 'request', None) ... continue!
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_MIN_REQ_LEN [vtype=None]
----
UNIQ_INIT: ('Request','request','None','None');

==== Scope 1 ====
void fix_ingred_service_7_1_0(){
Request request;
    bzero(&request,sizeof(Request));
    {char * buffer; buffer = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {int ret; ret = (int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {int tlv29; tlv29 = (int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {void * tlv3; tlv3 = (void *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {int tlv2; tlv2 = (int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv5; tlv5 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv7; tlv7 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv9; tlv9 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv11; tlv11 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv13; tlv13 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv15; tlv15 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv17; tlv17 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv19; tlv19 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv21; tlv21 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv23; tlv23 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv25; tlv25 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv27; tlv27 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
}
void fix_ingred_service_7_1(){
fix_ingred_service_7_1_0();
}

sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *'}'
val_s=>'[('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb43badd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb43c5198>)]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=0/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=2/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=3/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=5/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=6/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=7/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=8/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=12/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=14/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=16/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=18/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=20/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=22/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=24/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=26/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=28/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=30/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/18][j=2/17][dd=32/34][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_7_2_2(){
int ret;
    bzero(&ret,sizeof(int));
    {char * buffer; buffer = (char *)(ret); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(ret); }
    {int tlv29; tlv29 = (int)(ret); }
    {void * tlv3; tlv3 = (void *)(ret); }
    {int tlv2; tlv2 = (int)(ret); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(ret); }
    {char * tlv5; tlv5 = (char *)(ret); }
    {char * tlv9; tlv9 = (char *)(ret); }
    {char * tlv11; tlv11 = (char *)(ret); }
    {char * tlv13; tlv13 = (char *)(ret); }
    {char * tlv15; tlv15 = (char *)(ret); }
    {char * tlv17; tlv17 = (char *)(ret); }
    {char * tlv19; tlv19 = (char *)(ret); }
    {char * tlv21; tlv21 = (char *)(ret); }
    {char * tlv23; tlv23 = (char *)(ret); }
    {char * tlv25; tlv25 = (char *)(ret); }
    {char * tlv27; tlv27 = (char *)(ret); }
    {unsigned int tlv31; tlv31 = (unsigned int)(ret); }
}
void fix_ingred_service_7_2(){
fix_ingred_service_7_2_2();
}

sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv31': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv31', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43c5f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb43badd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb43c5198>)]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=0/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=1/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=2/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=3/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=5/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=6/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=7/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=8/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=10/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=12/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=14/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=16/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=18/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=20/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=22/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=24/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=26/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=28/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=30/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=7/18][j=3/17][dd=32/34][k=0/5] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
----
==== Scope 1 ====
void fix_ingred_service_7_3_0(){
    {char * buffer; buffer = (char *)(3); }
    {int ret; ret = (int)(3); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(3); }
    {int tlv29; tlv29 = (int)(3); }
    {void * tlv3; tlv3 = (void *)(3); }
    {int tlv2; tlv2 = (int)(3); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(3); }
    {char * tlv5; tlv5 = (char *)(3); }
    {char * tlv7; tlv7 = (char *)(3); }
    {char * tlv9; tlv9 = (char *)(3); }
    {char * tlv11; tlv11 = (char *)(3); }
    {char * tlv13; tlv13 = (char *)(3); }
    {char * tlv15; tlv15 = (char *)(3); }
    {char * tlv17; tlv17 = (char *)(3); }
    {char * tlv19; tlv19 = (char *)(3); }
    {char * tlv21; tlv21 = (char *)(3); }
    {char * tlv23; tlv23 = (char *)(3); }
    {char * tlv25; tlv25 = (char *)(3); }
    {char * tlv27; tlv27 = (char *)(3); }
    {unsigned int tlv31; tlv31 = (unsigned int)(3); }
}
void fix_ingred_service_7_3(){
fix_ingred_service_7_3_0();
}

sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43cf668>), ('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43cc518>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43c6438>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=0/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=1/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=2/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=3/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=6/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=8/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=10/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=12/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=14/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=16/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=18/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=20/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=22/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=24/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=26/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=28/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=30/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=4/17][dd=32/34][k=0/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
not valid - char * buffer; buffer = ((char *)buffer);

----
UNIQ_INIT: ('char *','buffer','None','None');

==== Scope 1 ====
void fix_ingred_service_7_4_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {int ret; ret = (int)(buffer); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(buffer); }
    {int tlv29; tlv29 = (int)(buffer); }
    {int tlv2; tlv2 = (int)(buffer); }
    {char * tlv5; tlv5 = (char *)(buffer); }
    {char * tlv7; tlv7 = (char *)(buffer); }
    {char * tlv9; tlv9 = (char *)(buffer); }
    {char * tlv11; tlv11 = (char *)(buffer); }
    {char * tlv13; tlv13 = (char *)(buffer); }
    {char * tlv15; tlv15 = (char *)(buffer); }
    {char * tlv17; tlv17 = (char *)(buffer); }
    {char * tlv19; tlv19 = (char *)(buffer); }
    {char * tlv21; tlv21 = (char *)(buffer); }
    {char * tlv23; tlv23 = (char *)(buffer); }
    {char * tlv25; tlv25 = (char *)(buffer); }
    {char * tlv27; tlv27 = (char *)(buffer); }
    {unsigned int tlv31; tlv31 = (unsigned int)(buffer); }
}
void fix_ingred_service_7_4(){
fix_ingred_service_7_4_0();
}

sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *'}'
val_s=>'[('char *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43cbdd8>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=0/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=2/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=3/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=8/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=12/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=14/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=16/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=18/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=22/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=26/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=30/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=7/18][j=5/17][dd=32/34][k=0/3] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
not valid - char * buffer; buffer = ((char *)buffer);

----
UNIQ_INIT: ('char *','buffer','None','None');

==== Scope 1 ====
void fix_ingred_service_7_5_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(buffer); }
    {int tlv29; tlv29 = (int)(buffer); }
    {char * tlv5; tlv5 = (char *)(buffer); }
    {char * tlv9; tlv9 = (char *)(buffer); }
    {char * tlv11; tlv11 = (char *)(buffer); }
    {char * tlv13; tlv13 = (char *)(buffer); }
    {char * tlv15; tlv15 = (char *)(buffer); }
    {char * tlv19; tlv19 = (char *)(buffer); }
    {char * tlv23; tlv23 = (char *)(buffer); }
    {char * tlv27; tlv27 = (char *)(buffer); }
    {unsigned int tlv31; tlv31 = (unsigned int)(buffer); }
}
void fix_ingred_service_7_5(){
fix_ingred_service_7_5_0();
}

sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *'}'
val_s=>'[('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43d9978>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *'}'
val_s=>'[('char *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43e0518>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *'}'
val_s=>'[('char *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43e50b8>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *'}'
val_s=>'[('char *', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43eac18>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *'}'
val_s=>'[('char *', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43ed7b8>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *', 'tlv17': 'char *', 'tlv16': 'const char *'}'
val_s=>'[('char *', 'tlv17', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43ee358>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *', 'tlv17': 'char *', 'tlv16': 'const char *', 'tlv19': 'char *', 'tlv18': 'const char *'}'
val_s=>'[('char *', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4334eb8>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *', 'tlv17': 'char *', 'tlv16': 'const char *', 'tlv19': 'char *', 'tlv18': 'const char *', 'tlv21': 'char *', 'tlv20': 'const char *'}'
val_s=>'[('char *', 'tlv21', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4336a58>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *', 'tlv17': 'char *', 'tlv16': 'const char *', 'tlv19': 'char *', 'tlv18': 'const char *', 'tlv21': 'char *', 'tlv20': 'const char *', 'tlv23': 'char *', 'tlv22': 'const char *'}'
val_s=>'[('char *', 'tlv23', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43425f8>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *', 'tlv17': 'char *', 'tlv16': 'const char *', 'tlv19': 'char *', 'tlv18': 'const char *', 'tlv21': 'char *', 'tlv20': 'const char *', 'tlv23': 'char *', 'tlv22': 'const char *', 'tlv25': 'char *', 'tlv24': 'const char *'}'
val_s=>'[('char *', 'tlv25', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb434b198>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
sym_lut=>'{'request': 'Request', 'buffer': 'char *', 'ret': 'int', 'tlv30': 'cgc_size_t', 'tlv29': 'int', 'tlv28': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv11': 'char *', 'tlv10': 'const char *', 'tlv13': 'char *', 'tlv12': 'const char *', 'tlv15': 'char *', 'tlv14': 'const char *', 'tlv17': 'char *', 'tlv16': 'const char *', 'tlv19': 'char *', 'tlv18': 'const char *', 'tlv21': 'char *', 'tlv20': 'const char *', 'tlv23': 'char *', 'tlv22': 'const char *', 'tlv25': 'char *', 'tlv24': 'const char *', 'tlv27': 'char *', 'tlv26': 'const char *'}'
val_s=>'[('char *', 'tlv27', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4350cf8>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43be518>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb43b33c8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv31 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv31 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_service_7_0_0(){
    {char * buffer; buffer = (char *)(NULL); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(NULL); }
    {int tlv29; tlv29 = (int)(NULL); }
    {char * tlv5; tlv5 = (char *)(NULL); }
    {char * tlv9; tlv9 = (char *)(NULL); }
    {char * tlv11; tlv11 = (char *)(NULL); }
    {char * tlv13; tlv13 = (char *)(NULL); }
    {char * tlv15; tlv15 = (char *)(NULL); }
    {char * tlv19; tlv19 = (char *)(NULL); }
    {char * tlv23; tlv23 = (char *)(NULL); }
    {char * tlv27; tlv27 = (char *)(NULL); }
    {unsigned int tlv31; tlv31 = (unsigned int)(NULL); }
}
void fix_ingred_service_7_0_1(){
    {char * buffer; buffer = (char *)(0); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(0); }
    {int tlv29; tlv29 = (int)(0); }
    {char * tlv5; tlv5 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {char * tlv11; tlv11 = (char *)(0); }
    {char * tlv13; tlv13 = (char *)(0); }
    {char * tlv15; tlv15 = (char *)(0); }
    {char * tlv19; tlv19 = (char *)(0); }
    {char * tlv23; tlv23 = (char *)(0); }
    {char * tlv27; tlv27 = (char *)(0); }
    {unsigned int tlv31; tlv31 = (unsigned int)(0); }
}
void fix_ingred_service_7_0(){
fix_ingred_service_7_0_0();
fix_ingred_service_7_0_1();
}
void fix_ingred_service_7_1_0(){
Request request;
    bzero(&request,sizeof(Request));
    {char * buffer; buffer = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {int ret; ret = (int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {int tlv29; tlv29 = (int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {void * tlv3; tlv3 = (void *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {int tlv2; tlv2 = (int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv5; tlv5 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv7; tlv7 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv9; tlv9 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv11; tlv11 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv13; tlv13 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv15; tlv15 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv17; tlv17 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv19; tlv19 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv21; tlv21 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv23; tlv23 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv25; tlv25 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {char * tlv27; tlv27 = (char *)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( request ) + cgc_MIN_REQ_LEN); }
}
void fix_ingred_service_7_1(){
fix_ingred_service_7_1_0();
}
void fix_ingred_service_7_2_2(){
int ret;
    bzero(&ret,sizeof(int));
    {char * buffer; buffer = (char *)(ret); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(ret); }
    {int tlv29; tlv29 = (int)(ret); }
    {void * tlv3; tlv3 = (void *)(ret); }
    {int tlv2; tlv2 = (int)(ret); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(ret); }
    {char * tlv5; tlv5 = (char *)(ret); }
    {char * tlv9; tlv9 = (char *)(ret); }
    {char * tlv11; tlv11 = (char *)(ret); }
    {char * tlv13; tlv13 = (char *)(ret); }
    {char * tlv15; tlv15 = (char *)(ret); }
    {char * tlv17; tlv17 = (char *)(ret); }
    {char * tlv19; tlv19 = (char *)(ret); }
    {char * tlv21; tlv21 = (char *)(ret); }
    {char * tlv23; tlv23 = (char *)(ret); }
    {char * tlv25; tlv25 = (char *)(ret); }
    {char * tlv27; tlv27 = (char *)(ret); }
    {unsigned int tlv31; tlv31 = (unsigned int)(ret); }
}
void fix_ingred_service_7_2(){
fix_ingred_service_7_2_2();
}
void fix_ingred_service_7_3_0(){
    {char * buffer; buffer = (char *)(3); }
    {int ret; ret = (int)(3); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(3); }
    {int tlv29; tlv29 = (int)(3); }
    {void * tlv3; tlv3 = (void *)(3); }
    {int tlv2; tlv2 = (int)(3); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(3); }
    {char * tlv5; tlv5 = (char *)(3); }
    {char * tlv7; tlv7 = (char *)(3); }
    {char * tlv9; tlv9 = (char *)(3); }
    {char * tlv11; tlv11 = (char *)(3); }
    {char * tlv13; tlv13 = (char *)(3); }
    {char * tlv15; tlv15 = (char *)(3); }
    {char * tlv17; tlv17 = (char *)(3); }
    {char * tlv19; tlv19 = (char *)(3); }
    {char * tlv21; tlv21 = (char *)(3); }
    {char * tlv23; tlv23 = (char *)(3); }
    {char * tlv25; tlv25 = (char *)(3); }
    {char * tlv27; tlv27 = (char *)(3); }
    {unsigned int tlv31; tlv31 = (unsigned int)(3); }
}
void fix_ingred_service_7_3(){
fix_ingred_service_7_3_0();
}
void fix_ingred_service_7_4_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {int ret; ret = (int)(buffer); }
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(buffer); }
    {int tlv29; tlv29 = (int)(buffer); }
    {int tlv2; tlv2 = (int)(buffer); }
    {char * tlv5; tlv5 = (char *)(buffer); }
    {char * tlv7; tlv7 = (char *)(buffer); }
    {char * tlv9; tlv9 = (char *)(buffer); }
    {char * tlv11; tlv11 = (char *)(buffer); }
    {char * tlv13; tlv13 = (char *)(buffer); }
    {char * tlv15; tlv15 = (char *)(buffer); }
    {char * tlv17; tlv17 = (char *)(buffer); }
    {char * tlv19; tlv19 = (char *)(buffer); }
    {char * tlv21; tlv21 = (char *)(buffer); }
    {char * tlv23; tlv23 = (char *)(buffer); }
    {char * tlv25; tlv25 = (char *)(buffer); }
    {char * tlv27; tlv27 = (char *)(buffer); }
    {unsigned int tlv31; tlv31 = (unsigned int)(buffer); }
}
void fix_ingred_service_7_4(){
fix_ingred_service_7_4_0();
}
void fix_ingred_service_7_5_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {cgc_size_t tlv30; tlv30 = (cgc_size_t)(buffer); }
    {int tlv29; tlv29 = (int)(buffer); }
    {char * tlv5; tlv5 = (char *)(buffer); }
    {char * tlv9; tlv9 = (char *)(buffer); }
    {char * tlv11; tlv11 = (char *)(buffer); }
    {char * tlv13; tlv13 = (char *)(buffer); }
    {char * tlv15; tlv15 = (char *)(buffer); }
    {char * tlv19; tlv19 = (char *)(buffer); }
    {char * tlv23; tlv23 = (char *)(buffer); }
    {char * tlv27; tlv27 = (char *)(buffer); }
    {unsigned int tlv31; tlv31 = (unsigned int)(buffer); }
}
void fix_ingred_service_7_5(){
fix_ingred_service_7_5_0();
}
void fix_ingred_service_7(){
fix_ingred_service_7_0();
fix_ingred_service_7_1();
fix_ingred_service_7_2();
fix_ingred_service_7_3();
fix_ingred_service_7_4();
fix_ingred_service_7_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_7_0_0();
void fix_ingred_service_7_0_1();
void fix_ingred_service_7_0();
void fix_ingred_service_7_1_0();
void fix_ingred_service_7_1();
void fix_ingred_service_7_2_2();
void fix_ingred_service_7_2();
void fix_ingred_service_7_3_0();
void fix_ingred_service_7_3();
void fix_ingred_service_7_4_0();
void fix_ingred_service_7_4();
void fix_ingred_service_7_5_0();
void fix_ingred_service_7_5();
void fix_ingred_service_7();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t bytes_written ;
def_vars[1]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : unsigned int index ;
def_vars[2]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[3]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : unsigned long tlv_size_0 ;
def_vars[4]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[5]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[6]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t * tlv1 ;
def_vars[7]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv4 ;
def_vars[8]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv4 ) ;
def_vars[9]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[10]: [cgc_getRandomNumber] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'max': 'unsigned int', 'bytes_written': 'cgc_size_t', 'index': 'unsigned int', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9f0b8>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc1828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50eae48>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb5332e48>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4e4ccf8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv4 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=0/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=0/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=0/11][k=2/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=0/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
unique : ('unsigned int', 'index', None)
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=0/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
unique : ('unsigned int', 'max', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=1/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=1/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=1/11][k=2/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=1/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=1/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=2/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=2/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=2/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=2/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=3/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=3/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=3/11][k=2/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=3/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=3/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=4/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=4/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=4/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=4/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=5/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=5/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=5/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=5/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=7/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=7/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=7/11][k=2/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=7/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=7/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=8/11][k=0/5] | type: cgc_size_t ; var : bytes_written ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/18][j=0/6][dd=8/11][k=1/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=0/6][dd=8/11][k=3/5] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index%max' - False OR  False
[i=8/18][j=0/6][dd=8/11][k=4/5] | type: unsigned int ; var : index ; varinfo :  ; value_node : index % max (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index,%,max
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) max [vtype=unsigned int]
not unique: ('unsigned int', 'max', None) ... continue!
----
UNIQ_INIT: ('unsigned int','index','None','None');

UNIQ_INIT: ('unsigned int','max','None','None');

----
UNIQ_INIT: ('unsigned int','index','None','None');

UNIQ_INIT: ('unsigned int','max','None','None');

----
UNIQ_INIT: ('unsigned int','index','None','None');

UNIQ_INIT: ('unsigned int','max','None','None');

not valid - unsigned int index; index = ((unsigned int)sizeof ( index ));

----
UNIQ_INIT: ('unsigned int','index','None','None');

UNIQ_INIT: ('unsigned int','max','None','None');

not valid - unsigned int index; index = ((unsigned int)index % max);

----
UNIQ_INIT: ('unsigned int','index','None','None');

UNIQ_INIT: ('unsigned int','max','None','None');

==== Scope 1 ====
void fix_ingred_service_8_0_0(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(0); }
    {unsigned int index; index = (unsigned int)(0); }
    {int ret; ret = (int)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_service_8_0_1(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(0); }
    {unsigned int index; index = (unsigned int)(0); }
    {int ret; ret = (int)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_service_8_0_2(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(0); }
    {unsigned int index; index = (unsigned int)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(0); }
}
void fix_ingred_service_8_0_3(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(sizeof ( index )); }
    {int ret; ret = (int)(sizeof ( index )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( index )); }
    {void * tlv3; tlv3 = (void *)(sizeof ( index )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( index )); }
    {unsigned int tlv4; tlv4 = (unsigned int)(sizeof ( index )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( index )); }
}
void fix_ingred_service_8_0_4(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {    max = 1;
         cgc_size_t bytes_written; bytes_written = (cgc_size_t)(index % max); }
    {    max = 1;
         int ret; ret = (int)(index % max); }
    {    max = 1;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(index % max); }
    {    max = 1;
         void * tlv3; tlv3 = (void *)(index % max); }
    {    max = 1;
         cgc_size_t tlv2; tlv2 = (cgc_size_t)(index % max); }
    {    max = 1;
         unsigned int tlv4; tlv4 = (unsigned int)(index % max); }
    {    max = 1;
         unsigned int tlv5; tlv5 = (unsigned int)(index % max); }
}
void fix_ingred_service_8_0(){
fix_ingred_service_8_0_0();
fix_ingred_service_8_0_1();
fix_ingred_service_8_0_2();
fix_ingred_service_8_0_3();
fix_ingred_service_8_0_4();
}

sym_lut=>'{'max': 'unsigned int', 'bytes_written': 'cgc_size_t', 'index': 'unsigned int', 'ret': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c90c88>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb477d828>), ('cgc_size_t *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4730048>), ('cgc_size_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9f0b8>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc1828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50eae48>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv4 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=0/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
unique : ('unsigned int', 'index', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=0/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=1/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=1/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=2/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=2/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=3/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=3/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=4/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=4/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=5/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=5/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=7/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=7/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&index' - False OR  False
[i=8/18][j=1/6][dd=8/11][k=0/6] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & index (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,index
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(index)' - False OR  False
[i=8/18][j=1/6][dd=8/11][k=1/6] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( index ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,index,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) index [vtype=unsigned int]
not unique: ('unsigned int', 'index', None) ... continue!
 => is literal (False) | is operator (True) )
not valid - unsigned int index; index = ((unsigned int)& index);

----
UNIQ_INIT: ('unsigned int','index','None','None');

not valid - unsigned int index; index = ((unsigned int)sizeof ( index ));

----
UNIQ_INIT: ('unsigned int','index','None','None');

==== Scope 1 ====
void fix_ingred_service_8_1_0(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(& index); }
    {int ret; ret = (int)(& index); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(& index); }
    {void * tlv3; tlv3 = (void *)(& index); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(& index); }
    {unsigned int tlv4; tlv4 = (unsigned int)(& index); }
    {unsigned int tlv5; tlv5 = (unsigned int)(& index); }
}
void fix_ingred_service_8_1_1(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(sizeof ( index )); }
    {int ret; ret = (int)(sizeof ( index )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( index )); }
    {void * tlv3; tlv3 = (void *)(sizeof ( index )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( index )); }
    {unsigned int tlv4; tlv4 = (unsigned int)(sizeof ( index )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( index )); }
}
void fix_ingred_service_8_1(){
fix_ingred_service_8_1_0();
fix_ingred_service_8_1_1();
}

sym_lut=>'{'max': 'unsigned int', 'bytes_written': 'cgc_size_t', 'index': 'unsigned int', 'ret': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('cgc_size_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9f0b8>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc1828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50eae48>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b2cc18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b2cc88>)]'
Checking 'cgc__terminate( tlv4 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/18][j=2/6][dd=0/11][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/18][j=2/6][dd=1/11][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/18][j=2/6][dd=3/11][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=8/18][j=2/6][dd=7/11][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_8_2_3(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(ret); }
    {unsigned int index; index = (unsigned int)(ret); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ret); }
    {unsigned int tlv4; tlv4 = (unsigned int)(ret); }
}
void fix_ingred_service_8_2(){
fix_ingred_service_8_2_3();
}

sym_lut=>'{'max': 'unsigned int', 'bytes_written': 'cgc_size_t', 'index': 'unsigned int', 'ret': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *', 'tlv4': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fa2588>), ('cgc_size_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9f0b8>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc1828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50eae48>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b2cc18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4b2cc88>)]'
Checking 'cgc__terminate( tlv4 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=0/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=1/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=2/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=3/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=4/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=5/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=7/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=8/18][j=3/6][dd=8/11][k=0/6] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_service_8_3_0(){
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(1); }
    {unsigned int index; index = (unsigned int)(1); }
    {int ret; ret = (int)(1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(1); }
    {void * tlv3; tlv3 = (void *)(1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(1); }
    {unsigned int tlv4; tlv4 = (unsigned int)(1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(1); }
}
void fix_ingred_service_8_3(){
fix_ingred_service_8_3_0();
}

sym_lut=>'{'max': 'unsigned int', 'bytes_written': 'cgc_size_t', 'index': 'unsigned int', 'ret': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *', 'tlv_size_0': 'unsigned long'}'
val_s=>'[('cgc_size_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9f0b8>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc1828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50eae48>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb5332e48>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb508e0b8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb508e278>)]'
Checking 'cgc__terminate( tlv4 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=0/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
unique : ('cgc_size_t', 'bytes_written', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=0/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
unique : ('unsigned long', 'tlv_size_0', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=1/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=1/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=2/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=2/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=3/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=3/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=4/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=4/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=5/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=5/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=7/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=7/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_written' - False OR  False
[i=8/18][j=4/6][dd=8/11][k=4/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : bytes_written (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_written
 => is literal (False) | is operator (False) bytes_written [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'bytes_written', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv_size_0' - False OR  False
[i=8/18][j=4/6][dd=8/11][k=5/6] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : tlv_size_0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv_size_0
 => is literal (False) | is operator (False) tlv_size_0 [vtype=unsigned long]
not unique: ('unsigned long', 'tlv_size_0', None) ... continue!
not valid - cgc_size_t bytes_written; bytes_written = ((cgc_size_t)bytes_written);

----
UNIQ_INIT: ('cgc_size_t','bytes_written','None','None');

UNIQ_INIT: ('unsigned long','tlv_size_0','None','None');

not valid - unsigned long tlv_size_0; tlv_size_0 = ((unsigned long)tlv_size_0);

----
UNIQ_INIT: ('cgc_size_t','bytes_written','None','None');

UNIQ_INIT: ('unsigned long','tlv_size_0','None','None');

==== Scope 1 ====
void fix_ingred_service_8_4_4(){
cgc_size_t bytes_written;
    bzero(&bytes_written,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {unsigned int index; index = (unsigned int)(bytes_written); }
    {int ret; ret = (int)(bytes_written); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(bytes_written); }
    {void * tlv3; tlv3 = (void *)(bytes_written); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(bytes_written); }
    {unsigned int tlv4; tlv4 = (unsigned int)(bytes_written); }
    {unsigned int tlv5; tlv5 = (unsigned int)(bytes_written); }
}
void fix_ingred_service_8_4_5(){
cgc_size_t bytes_written;
    bzero(&bytes_written,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(tlv_size_0); }
    {unsigned int index; index = (unsigned int)(tlv_size_0); }
    {int ret; ret = (int)(tlv_size_0); }
    {void * tlv3; tlv3 = (void *)(tlv_size_0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv_size_0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(tlv_size_0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(tlv_size_0); }
}
void fix_ingred_service_8_4(){
fix_ingred_service_8_4_4();
fix_ingred_service_8_4_5();
}

sym_lut=>'{'max': 'unsigned int', 'bytes_written': 'cgc_size_t', 'index': 'unsigned int', 'ret': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *', 'tlv_size_0': 'unsigned long', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4bc4588>), ('cgc_size_t', 'bytes_written', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9f0b8>), ('unsigned int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc1828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50eae48>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb5332e48>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb508e0b8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb508e278>)]'
Checking 'cgc__terminate( tlv4 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=8/18][j=5/6][dd=0/11][k=0/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=8/18][j=5/6][dd=1/11][k=0/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=8/18][j=5/6][dd=3/11][k=0/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=8/18][j=5/6][dd=4/11][k=0/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '2' - False OR  False
[i=8/18][j=5/6][dd=7/11][k=0/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 2
 => is literal (True) | is operator (False) 2
----
==== Scope 1 ====
void fix_ingred_service_8_5_0(){
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(2); }
    {unsigned int index; index = (unsigned int)(2); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(2); }
    {void * tlv3; tlv3 = (void *)(2); }
    {unsigned int tlv4; tlv4 = (unsigned int)(2); }
}
void fix_ingred_service_8_5(){
fix_ingred_service_8_5_0();
}

==== Scope 2 ====
void fix_ingred_service_8_0_0(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(0); }
    {unsigned int index; index = (unsigned int)(0); }
    {int ret; ret = (int)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_service_8_0_1(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(0); }
    {unsigned int index; index = (unsigned int)(0); }
    {int ret; ret = (int)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_service_8_0_2(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(0); }
    {unsigned int index; index = (unsigned int)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(0); }
}
void fix_ingred_service_8_0_3(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(sizeof ( index )); }
    {int ret; ret = (int)(sizeof ( index )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( index )); }
    {void * tlv3; tlv3 = (void *)(sizeof ( index )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( index )); }
    {unsigned int tlv4; tlv4 = (unsigned int)(sizeof ( index )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( index )); }
}
void fix_ingred_service_8_0_4(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
unsigned int max;
    bzero(&max,sizeof(unsigned int));
    {    max = 1;
         cgc_size_t bytes_written; bytes_written = (cgc_size_t)(index % max); }
    {    max = 1;
         int ret; ret = (int)(index % max); }
    {    max = 1;
         unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(index % max); }
    {    max = 1;
         void * tlv3; tlv3 = (void *)(index % max); }
    {    max = 1;
         cgc_size_t tlv2; tlv2 = (cgc_size_t)(index % max); }
    {    max = 1;
         unsigned int tlv4; tlv4 = (unsigned int)(index % max); }
    {    max = 1;
         unsigned int tlv5; tlv5 = (unsigned int)(index % max); }
}
void fix_ingred_service_8_0(){
fix_ingred_service_8_0_0();
fix_ingred_service_8_0_1();
fix_ingred_service_8_0_2();
fix_ingred_service_8_0_3();
fix_ingred_service_8_0_4();
}
void fix_ingred_service_8_1_0(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(& index); }
    {int ret; ret = (int)(& index); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(& index); }
    {void * tlv3; tlv3 = (void *)(& index); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(& index); }
    {unsigned int tlv4; tlv4 = (unsigned int)(& index); }
    {unsigned int tlv5; tlv5 = (unsigned int)(& index); }
}
void fix_ingred_service_8_1_1(){
unsigned int index;
    bzero(&index,sizeof(unsigned int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(sizeof ( index )); }
    {int ret; ret = (int)(sizeof ( index )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( index )); }
    {void * tlv3; tlv3 = (void *)(sizeof ( index )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( index )); }
    {unsigned int tlv4; tlv4 = (unsigned int)(sizeof ( index )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( index )); }
}
void fix_ingred_service_8_1(){
fix_ingred_service_8_1_0();
fix_ingred_service_8_1_1();
}
void fix_ingred_service_8_2_3(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(ret); }
    {unsigned int index; index = (unsigned int)(ret); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(ret); }
    {unsigned int tlv4; tlv4 = (unsigned int)(ret); }
}
void fix_ingred_service_8_2(){
fix_ingred_service_8_2_3();
}
void fix_ingred_service_8_3_0(){
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(1); }
    {unsigned int index; index = (unsigned int)(1); }
    {int ret; ret = (int)(1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(1); }
    {void * tlv3; tlv3 = (void *)(1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(1); }
    {unsigned int tlv4; tlv4 = (unsigned int)(1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(1); }
}
void fix_ingred_service_8_3(){
fix_ingred_service_8_3_0();
}
void fix_ingred_service_8_4_4(){
cgc_size_t bytes_written;
    bzero(&bytes_written,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {unsigned int index; index = (unsigned int)(bytes_written); }
    {int ret; ret = (int)(bytes_written); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(bytes_written); }
    {void * tlv3; tlv3 = (void *)(bytes_written); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(bytes_written); }
    {unsigned int tlv4; tlv4 = (unsigned int)(bytes_written); }
    {unsigned int tlv5; tlv5 = (unsigned int)(bytes_written); }
}
void fix_ingred_service_8_4_5(){
cgc_size_t bytes_written;
    bzero(&bytes_written,sizeof(cgc_size_t));
unsigned long tlv_size_0;
    bzero(&tlv_size_0,sizeof(unsigned long));
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(tlv_size_0); }
    {unsigned int index; index = (unsigned int)(tlv_size_0); }
    {int ret; ret = (int)(tlv_size_0); }
    {void * tlv3; tlv3 = (void *)(tlv_size_0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(tlv_size_0); }
    {unsigned int tlv4; tlv4 = (unsigned int)(tlv_size_0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(tlv_size_0); }
}
void fix_ingred_service_8_4(){
fix_ingred_service_8_4_4();
fix_ingred_service_8_4_5();
}
void fix_ingred_service_8_5_0(){
    {cgc_size_t bytes_written; bytes_written = (cgc_size_t)(2); }
    {unsigned int index; index = (unsigned int)(2); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(2); }
    {void * tlv3; tlv3 = (void *)(2); }
    {unsigned int tlv4; tlv4 = (unsigned int)(2); }
}
void fix_ingred_service_8_5(){
fix_ingred_service_8_5_0();
}
void fix_ingred_service_8(){
fix_ingred_service_8_0();
fix_ingred_service_8_1();
fix_ingred_service_8_2();
fix_ingred_service_8_3();
fix_ingred_service_8_4();
fix_ingred_service_8_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_8_0_0();
void fix_ingred_service_8_0_1();
void fix_ingred_service_8_0_2();
void fix_ingred_service_8_0_3();
void fix_ingred_service_8_0_4();
void fix_ingred_service_8_0();
void fix_ingred_service_8_1_0();
void fix_ingred_service_8_1_1();
void fix_ingred_service_8_1();
void fix_ingred_service_8_2_3();
void fix_ingred_service_8_2();
void fix_ingred_service_8_3_0();
void fix_ingred_service_8_3();
void fix_ingred_service_8_4_4();
void fix_ingred_service_8_4_5();
void fix_ingred_service_8_4();
void fix_ingred_service_8_5_0();
void fix_ingred_service_8_5();
void fix_ingred_service_8();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_getRandomAttribute] : <class 'CParser.CParser.DeclarationContext'> : int index ;
def_vars[1]: [cgc_getRandomAttribute] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv4 ;
def_vars[2]: [cgc_getRandomAttribute] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[3]: [cgc_getRandomAttribute] : <class 'CParser.CParser.DeclarationContext'> : void * tlv2 ;
def_vars[4]: [cgc_getRandomAttribute] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[5]: [cgc_getRandomAttribute] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = attributes [ index ] ;
sym_lut=>'{'request': 'Request *', 'index': 'int'}'
val_s=>'[('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb51f1e48>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=9/18][j=0/4][dd=0/6][k=0/1] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_service_9_0_0(){
    {int index; index = (int)(0); }
}
void fix_ingred_service_9_0(){
fix_ingred_service_9_0_0();
}

sym_lut=>'{'request': 'Request *', 'index': 'int', 'tlv4': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb5037278>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb51f1e48>)]'
cval_s=>'[]'
is_func_ [A] => '[False, False, False]'
has_multiptr_refs 'ATTR_NUM' - False OR  False
[i=9/18][j=1/4][dd=0/6][k=0/2] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : ATTR_NUM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ATTR_NUM
 => is literal (False) | is operator (False) ATTR_NUM [vtype=None]
is_func_ [A] => '[False, False, False]'
has_multiptr_refs 'ATTR_NUM' - False OR  False
[i=9/18][j=1/4][dd=1/6][k=0/2] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : ATTR_NUM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ATTR_NUM
 => is literal (False) | is operator (False) ATTR_NUM [vtype=None]
is_func_ [A] => '[False, False, False]'
has_multiptr_refs 'ATTR_NUM' - False OR  False
[i=9/18][j=1/4][dd=2/6][k=0/2] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : ATTR_NUM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ATTR_NUM
 => is literal (False) | is operator (False) ATTR_NUM [vtype=None]
is_func_ [A] => '[False, False, False]'
has_multiptr_refs 'ATTR_NUM' - False OR  False
[i=9/18][j=1/4][dd=3/6][k=0/2] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : ATTR_NUM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ATTR_NUM
 => is literal (False) | is operator (False) ATTR_NUM [vtype=None]
is_func_ [A] => '[False, False, False]'
has_multiptr_refs 'ATTR_NUM' - False OR  False
[i=9/18][j=1/4][dd=4/6][k=0/2] | type: unsigned int ; var : tlv4 ; varinfo :  ; value_node : ATTR_NUM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ATTR_NUM
 => is literal (False) | is operator (False) ATTR_NUM [vtype=None]
----
==== Scope 1 ====
void fix_ingred_service_9_1_0(){
    {int index; index = (int)(ATTR_NUM); }
    {unsigned int tlv4; tlv4 = (unsigned int)(ATTR_NUM); }
    {void * tlv3; tlv3 = (void *)(ATTR_NUM); }
    {void * tlv2; tlv2 = (void *)(ATTR_NUM); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(ATTR_NUM); }
}
void fix_ingred_service_9_1(){
fix_ingred_service_9_1_0();
}

sym_lut=>'{'request': 'Request *', 'index': 'int', 'tlv4': 'unsigned int', 'tlv3': 'void *', 'tlv2': 'void *', 'tlv1': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4e6dd68>), ('void *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb493e668>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb51f1e48>)]'
cval_s=>'[]'
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->attribute' - False OR  False
[i=9/18][j=2/4][dd=0/6][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request -> attribute (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,attribute
 => is literal (False) | is operator (False) request [vtype=Request *]
unique : ('Request *', 'request', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) attribute [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'attributes[index]' - False OR  False
[i=9/18][j=2/4][dd=0/6][k=1/3] | type: void * ; var : tlv2 ; varinfo :  ; value_node : attributes [ index ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : attributes,[,index,]
 => is literal (False) | is operator (False) attributes [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) index [vtype=int]
unique : ('int', 'index', None)
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->attribute' - False OR  False
[i=9/18][j=2/4][dd=1/6][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request -> attribute (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,attribute
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) attribute [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'attributes[index]' - False OR  False
[i=9/18][j=2/4][dd=1/6][k=1/3] | type: void * ; var : tlv2 ; varinfo :  ; value_node : attributes [ index ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : attributes,[,index,]
 => is literal (False) | is operator (False) attributes [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->attribute' - False OR  False
[i=9/18][j=2/4][dd=2/6][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request -> attribute (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,attribute
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) attribute [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'attributes[index]' - False OR  False
[i=9/18][j=2/4][dd=2/6][k=1/3] | type: void * ; var : tlv2 ; varinfo :  ; value_node : attributes [ index ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : attributes,[,index,]
 => is literal (False) | is operator (False) attributes [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->attribute' - False OR  False
[i=9/18][j=2/4][dd=3/6][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request -> attribute (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,attribute
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) attribute [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'attributes[index]' - False OR  False
[i=9/18][j=2/4][dd=3/6][k=1/3] | type: void * ; var : tlv2 ; varinfo :  ; value_node : attributes [ index ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : attributes,[,index,]
 => is literal (False) | is operator (False) attributes [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->attribute' - False OR  False
[i=9/18][j=2/4][dd=4/6][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request -> attribute (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,attribute
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) attribute [vtype=None]
is_func_ [a] => '[False, False, False]'
has_multiptr_refs 'attributes[index]' - False OR  False
[i=9/18][j=2/4][dd=4/6][k=1/3] | type: void * ; var : tlv2 ; varinfo :  ; value_node : attributes [ index ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : attributes,[,index,]
 => is literal (False) | is operator (False) attributes [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
 => is literal (False) | is operator (True) ]
----
UNIQ_INIT: ('Request *','request','None','None');

UNIQ_INIT: ('int','index','None','None');

not valid - int index; index = ((int)attributes [ index ]);

----
UNIQ_INIT: ('Request *','request','None','None');

UNIQ_INIT: ('int','index','None','None');

==== Scope 1 ====
void fix_ingred_service_9_2_0(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
int index;
    bzero(&index,sizeof(int));
    {int index; index = (int)(request -> attribute); }
    {unsigned int tlv4; tlv4 = (unsigned int)(request -> attribute); }
    {void * tlv3; tlv3 = (void *)(request -> attribute); }
    {void * tlv2; tlv2 = (void *)(request -> attribute); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(request -> attribute); }
}
void fix_ingred_service_9_2_1(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
int index;
    bzero(&index,sizeof(int));
    {if (attributes){    index = 0;
         unsigned int tlv4; tlv4 = (unsigned int)(attributes [ index ]); }}
    {if (attributes){    index = 0;
         void * tlv3; tlv3 = (void *)(attributes [ index ]); }}
    {if (attributes){    index = 0;
         void * tlv2; tlv2 = (void *)(attributes [ index ]); }}
    {if (attributes){    index = 0;
         cgc_size_t tlv1; tlv1 = (cgc_size_t)(attributes [ index ]); }}
}
void fix_ingred_service_9_2(){
fix_ingred_service_9_2_0();
fix_ingred_service_9_2_1();
}

sym_lut=>'{'request': 'Request *', 'index': 'int', 'tlv4': 'unsigned int', 'tlv3': 'void *', 'tlv2': 'void *', 'tlv1': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4f12ba8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb51f1e48>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4e6dd68>), ('void *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb493e668>)]'
cval_s=>'[]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=9/18][j=3/4][dd=0/6][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
unique : ('const char *', 'tlv5', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=9/18][j=3/4][dd=1/6][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=9/18][j=3/4][dd=2/6][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=9/18][j=3/4][dd=3/6][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv5)' - False OR  False
[i=9/18][j=3/4][dd=4/6][k=0/4] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : cgc_strlen ( tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv5 [vtype=const char *]
not unique: ('const char *', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_service_9_3_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {int index; index = (int)(cgc_strlen ( tlv5 )); }
    {unsigned int tlv4; tlv4 = (unsigned int)(cgc_strlen ( tlv5 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv5 )); }
    {void * tlv2; tlv2 = (void *)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
}
void fix_ingred_service_9_3(){
fix_ingred_service_9_3_0();
}

==== Scope 2 ====
void fix_ingred_service_9_0_0(){
    {int index; index = (int)(0); }
}
void fix_ingred_service_9_0(){
fix_ingred_service_9_0_0();
}
void fix_ingred_service_9_1_0(){
    {int index; index = (int)(ATTR_NUM); }
    {unsigned int tlv4; tlv4 = (unsigned int)(ATTR_NUM); }
    {void * tlv3; tlv3 = (void *)(ATTR_NUM); }
    {void * tlv2; tlv2 = (void *)(ATTR_NUM); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(ATTR_NUM); }
}
void fix_ingred_service_9_1(){
fix_ingred_service_9_1_0();
}
void fix_ingred_service_9_2_0(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
int index;
    bzero(&index,sizeof(int));
    {int index; index = (int)(request -> attribute); }
    {unsigned int tlv4; tlv4 = (unsigned int)(request -> attribute); }
    {void * tlv3; tlv3 = (void *)(request -> attribute); }
    {void * tlv2; tlv2 = (void *)(request -> attribute); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(request -> attribute); }
}
void fix_ingred_service_9_2_1(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
int index;
    bzero(&index,sizeof(int));
    {if (attributes){    index = 0;
         unsigned int tlv4; tlv4 = (unsigned int)(attributes [ index ]); }}
    {if (attributes){    index = 0;
         void * tlv3; tlv3 = (void *)(attributes [ index ]); }}
    {if (attributes){    index = 0;
         void * tlv2; tlv2 = (void *)(attributes [ index ]); }}
    {if (attributes){    index = 0;
         cgc_size_t tlv1; tlv1 = (cgc_size_t)(attributes [ index ]); }}
}
void fix_ingred_service_9_2(){
fix_ingred_service_9_2_0();
fix_ingred_service_9_2_1();
}
void fix_ingred_service_9_3_0(){
char tlv5_ref;
    bzero(&tlv5_ref,1*sizeof(char));
const char * tlv5 = &tlv5_ref;
    {int index; index = (int)(cgc_strlen ( tlv5 )); }
    {unsigned int tlv4; tlv4 = (unsigned int)(cgc_strlen ( tlv5 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv5 )); }
    {void * tlv2; tlv2 = (void *)(cgc_strlen ( tlv5 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv5 )); }
}
void fix_ingred_service_9_3(){
fix_ingred_service_9_3_0();
}
void fix_ingred_service_9(){
fix_ingred_service_9_0();
fix_ingred_service_9_1();
fix_ingred_service_9_2();
fix_ingred_service_9_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_9_0_0();
void fix_ingred_service_9_0();
void fix_ingred_service_9_1_0();
void fix_ingred_service_9_1();
void fix_ingred_service_9_2_0();
void fix_ingred_service_9_2_1();
void fix_ingred_service_9_2();
void fix_ingred_service_9_3_0();
void fix_ingred_service_9_3();
void fix_ingred_service_9();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : unsigned int size ;
def_vars[1]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : unsigned int charset_size ;
def_vars[2]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : int index ;
def_vars[3]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv1 = cgc_charset ;
def_vars[4]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : int letter ;
def_vars[5]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv2 ;
def_vars[6]: [cgc_getRandomTerm] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv3 ;
sym_lut=>'{'request': 'Request *', 'size': 'unsigned int', 'charset_size': 'unsigned int', 'index': 'int'}'
val_s=>'[('unsigned int', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50a7ba8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fbb358>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50d9978>), ('UNDEF', 'request -> term ', '[ size ]', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4f51d68>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=0/7][k=0/4] | type: unsigned int ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=0/7][k=2/4] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=1/7][k=0/4] | type: unsigned int ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=1/7][k=2/4] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=2/7][k=0/4] | type: unsigned int ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=4/7][k=0/4] | type: unsigned int ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=4/7][k=2/4] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=5/7][k=0/4] | type: unsigned int ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=5/7][k=2/4] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=6/7][k=0/4] | type: unsigned int ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/18][j=0/6][dd=6/7][k=2/4] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_service_10_0_0(){
    {unsigned int size; size = (unsigned int)(0); }
    {unsigned int charset_size; charset_size = (unsigned int)(0); }
    {int index; index = (int)(0); }
    {int letter; letter = (int)(0); }
    {unsigned int tlv2; tlv2 = (unsigned int)(0); }
    {unsigned int tlv3; tlv3 = (unsigned int)(0); }
}
void fix_ingred_service_10_0_2(){
    {unsigned int size; size = (unsigned int)(0); }
    {unsigned int charset_size; charset_size = (unsigned int)(0); }
    {int letter; letter = (int)(0); }
    {unsigned int tlv2; tlv2 = (unsigned int)(0); }
    {unsigned int tlv3; tlv3 = (unsigned int)(0); }
}
void fix_ingred_service_10_0(){
fix_ingred_service_10_0_0();
fix_ingred_service_10_0_2();
}

sym_lut=>'{'request': 'Request *', 'size': 'unsigned int', 'charset_size': 'unsigned int', 'index': 'int'}'
val_s=>'[('unsigned int', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50a7ba8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fbb358>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50d9978>)]'
cval_s=>'[('unsigned int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cca978>), ('unsigned int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cca588>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=1/6][dd=0/7][k=3/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
unique : ('unsigned int', 'size', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=1/6][dd=1/7][k=3/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=1/6][dd=2/7][k=3/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=1/6][dd=4/7][k=3/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=1/6][dd=5/7][k=3/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=1/6][dd=6/7][k=3/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
not valid - unsigned int size; size = ((unsigned int)size);

----
UNIQ_INIT: ('unsigned int','size','None','None');

==== Scope 1 ====
void fix_ingred_service_10_1_3(){
unsigned int size;
    bzero(&size,sizeof(unsigned int));
    {unsigned int charset_size; charset_size = (unsigned int)(size); }
    {int index; index = (int)(size); }
    {int letter; letter = (int)(size); }
    {unsigned int tlv2; tlv2 = (unsigned int)(size); }
    {unsigned int tlv3; tlv3 = (unsigned int)(size); }
}
void fix_ingred_service_10_1(){
fix_ingred_service_10_1_3();
}

sym_lut=>'{'request': 'Request *', 'size': 'unsigned int', 'charset_size': 'unsigned int', 'index': 'int', 'tlv2': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fc9ba8>), ('unsigned int', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50a7ba8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fbb358>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50d9978>)]'
cval_s=>'[('unsigned int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cca978>), ('unsigned int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cca588>)]'
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=10/18][j=2/6][dd=0/7][k=0/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=10/18][j=2/6][dd=1/7][k=0/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=10/18][j=2/6][dd=2/7][k=0/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=10/18][j=2/6][dd=4/7][k=0/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=10/18][j=2/6][dd=5/7][k=0/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE' - False OR  False
[i=10/18][j=2/6][dd=6/7][k=0/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
----
==== Scope 1 ====
void fix_ingred_service_10_2_0(){
    {unsigned int size; size = (unsigned int)(RESULT_VALUE_SIZE); }
    {unsigned int charset_size; charset_size = (unsigned int)(RESULT_VALUE_SIZE); }
    {int index; index = (int)(RESULT_VALUE_SIZE); }
    {int letter; letter = (int)(RESULT_VALUE_SIZE); }
    {unsigned int tlv2; tlv2 = (unsigned int)(RESULT_VALUE_SIZE); }
    {unsigned int tlv3; tlv3 = (unsigned int)(RESULT_VALUE_SIZE); }
}
void fix_ingred_service_10_2(){
fix_ingred_service_10_2_0();
}

sym_lut=>'{'request': 'Request *', 'size': 'unsigned int', 'charset_size': 'unsigned int', 'index': 'int', 'tlv1': 'const char *'}'
val_s=>'[('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb5307a58>), ('unsigned int', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50a7ba8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fbb358>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50d9978>)]'
cval_s=>'[]'
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=10/18][j=3/6][dd=0/7][k=0/4] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=const char *]
unique : ('const char *', 'tlv1', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=10/18][j=3/6][dd=1/7][k=0/4] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=const char *]
not unique: ('const char *', 'tlv1', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=10/18][j=3/6][dd=2/7][k=0/4] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=const char *]
not unique: ('const char *', 'tlv1', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=10/18][j=3/6][dd=4/7][k=0/4] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=const char *]
not unique: ('const char *', 'tlv1', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=10/18][j=3/6][dd=5/7][k=0/4] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=const char *]
not unique: ('const char *', 'tlv1', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=10/18][j=3/6][dd=6/7][k=0/4] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=const char *]
not unique: ('const char *', 'tlv1', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_service_10_3_0(){
char tlv1_ref;
    bzero(&tlv1_ref,1*sizeof(char));
const char * tlv1 = &tlv1_ref;
    {unsigned int size; size = (unsigned int)(cgc_strlen ( tlv1 )); }
    {unsigned int charset_size; charset_size = (unsigned int)(cgc_strlen ( tlv1 )); }
    {int index; index = (int)(cgc_strlen ( tlv1 )); }
    {int letter; letter = (int)(cgc_strlen ( tlv1 )); }
    {unsigned int tlv2; tlv2 = (unsigned int)(cgc_strlen ( tlv1 )); }
    {unsigned int tlv3; tlv3 = (unsigned int)(cgc_strlen ( tlv1 )); }
}
void fix_ingred_service_10_3(){
fix_ingred_service_10_3_0();
}

sym_lut=>'{'request': 'Request *', 'size': 'unsigned int', 'charset_size': 'unsigned int', 'index': 'int', 'tlv1': 'const char *', 'letter': 'int'}'
val_s=>'[('UNDEF', 'request -> term ', '[ index ]', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cb9f98>), ('unsigned int', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50a7ba8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fbb358>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50d9978>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50b6c18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4d423c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4d42438>)]'
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=10/18][j=4/6][dd=0/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
unique : ('int', 'index', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=4/6][dd=0/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
unique : ('unsigned int', 'size', None)
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=10/18][j=4/6][dd=1/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=4/6][dd=1/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=10/18][j=4/6][dd=2/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=4/6][dd=2/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=10/18][j=4/6][dd=4/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=4/6][dd=4/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=10/18][j=4/6][dd=5/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=4/6][dd=5/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=10/18][j=4/6][dd=6/7][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=10/18][j=4/6][dd=6/7][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=unsigned int]
not unique: ('unsigned int', 'size', None) ... continue!
not valid - int index; index = ((int)index);

----
UNIQ_INIT: ('int','index','None','None');

UNIQ_INIT: ('unsigned int','size','None','None');

not valid - unsigned int size; size = ((unsigned int)size);

----
UNIQ_INIT: ('int','index','None','None');

UNIQ_INIT: ('unsigned int','size','None','None');

==== Scope 1 ====
void fix_ingred_service_10_4_5(){
int index;
    bzero(&index,sizeof(int));
unsigned int size;
    bzero(&size,sizeof(unsigned int));
    {unsigned int size; size = (unsigned int)(index); }
    {unsigned int charset_size; charset_size = (unsigned int)(index); }
    {int letter; letter = (int)(index); }
    {unsigned int tlv2; tlv2 = (unsigned int)(index); }
    {unsigned int tlv3; tlv3 = (unsigned int)(index); }
}
void fix_ingred_service_10_4_6(){
int index;
    bzero(&index,sizeof(int));
unsigned int size;
    bzero(&size,sizeof(unsigned int));
    {unsigned int charset_size; charset_size = (unsigned int)(size); }
    {int index; index = (int)(size); }
    {int letter; letter = (int)(size); }
    {unsigned int tlv2; tlv2 = (unsigned int)(size); }
    {unsigned int tlv3; tlv3 = (unsigned int)(size); }
}
void fix_ingred_service_10_4(){
fix_ingred_service_10_4_5();
fix_ingred_service_10_4_6();
}

sym_lut=>'{'request': 'Request *', 'size': 'unsigned int', 'charset_size': 'unsigned int', 'index': 'int', 'tlv1': 'const char *', 'letter': 'int', 'tlv3': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4ca1048>), ('unsigned int', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50a7ba8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4fbb358>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50d9978>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50b6c18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4d423c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4d42438>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=10/18][j=5/6][dd=0/7][k=0/7] | type: unsigned int ; var : tlv3 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
unique : ('unsigned int', 'charset_size', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=10/18][j=5/6][dd=1/7][k=0/7] | type: unsigned int ; var : tlv3 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=10/18][j=5/6][dd=2/7][k=0/7] | type: unsigned int ; var : tlv3 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=10/18][j=5/6][dd=4/7][k=0/7] | type: unsigned int ; var : tlv3 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=10/18][j=5/6][dd=5/7][k=0/7] | type: unsigned int ; var : tlv3 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=10/18][j=5/6][dd=6/7][k=0/7] | type: unsigned int ; var : tlv3 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
not valid - unsigned int charset_size; charset_size = ((unsigned int)charset_size);

----
UNIQ_INIT: ('unsigned int','charset_size','None','None');

==== Scope 1 ====
void fix_ingred_service_10_5_0(){
unsigned int charset_size;
    bzero(&charset_size,sizeof(unsigned int));
    {unsigned int size; size = (unsigned int)(charset_size); }
    {int index; index = (int)(charset_size); }
    {int letter; letter = (int)(charset_size); }
    {unsigned int tlv2; tlv2 = (unsigned int)(charset_size); }
    {unsigned int tlv3; tlv3 = (unsigned int)(charset_size); }
}
void fix_ingred_service_10_5(){
fix_ingred_service_10_5_0();
}

==== Scope 2 ====
void fix_ingred_service_10_0_0(){
    {unsigned int size; size = (unsigned int)(0); }
    {unsigned int charset_size; charset_size = (unsigned int)(0); }
    {int index; index = (int)(0); }
    {int letter; letter = (int)(0); }
    {unsigned int tlv2; tlv2 = (unsigned int)(0); }
    {unsigned int tlv3; tlv3 = (unsigned int)(0); }
}
void fix_ingred_service_10_0_2(){
    {unsigned int size; size = (unsigned int)(0); }
    {unsigned int charset_size; charset_size = (unsigned int)(0); }
    {int letter; letter = (int)(0); }
    {unsigned int tlv2; tlv2 = (unsigned int)(0); }
    {unsigned int tlv3; tlv3 = (unsigned int)(0); }
}
void fix_ingred_service_10_0(){
fix_ingred_service_10_0_0();
fix_ingred_service_10_0_2();
}
void fix_ingred_service_10_1_3(){
unsigned int size;
    bzero(&size,sizeof(unsigned int));
    {unsigned int charset_size; charset_size = (unsigned int)(size); }
    {int index; index = (int)(size); }
    {int letter; letter = (int)(size); }
    {unsigned int tlv2; tlv2 = (unsigned int)(size); }
    {unsigned int tlv3; tlv3 = (unsigned int)(size); }
}
void fix_ingred_service_10_1(){
fix_ingred_service_10_1_3();
}
void fix_ingred_service_10_2_0(){
    {unsigned int size; size = (unsigned int)(RESULT_VALUE_SIZE); }
    {unsigned int charset_size; charset_size = (unsigned int)(RESULT_VALUE_SIZE); }
    {int index; index = (int)(RESULT_VALUE_SIZE); }
    {int letter; letter = (int)(RESULT_VALUE_SIZE); }
    {unsigned int tlv2; tlv2 = (unsigned int)(RESULT_VALUE_SIZE); }
    {unsigned int tlv3; tlv3 = (unsigned int)(RESULT_VALUE_SIZE); }
}
void fix_ingred_service_10_2(){
fix_ingred_service_10_2_0();
}
void fix_ingred_service_10_3_0(){
char tlv1_ref;
    bzero(&tlv1_ref,1*sizeof(char));
const char * tlv1 = &tlv1_ref;
    {unsigned int size; size = (unsigned int)(cgc_strlen ( tlv1 )); }
    {unsigned int charset_size; charset_size = (unsigned int)(cgc_strlen ( tlv1 )); }
    {int index; index = (int)(cgc_strlen ( tlv1 )); }
    {int letter; letter = (int)(cgc_strlen ( tlv1 )); }
    {unsigned int tlv2; tlv2 = (unsigned int)(cgc_strlen ( tlv1 )); }
    {unsigned int tlv3; tlv3 = (unsigned int)(cgc_strlen ( tlv1 )); }
}
void fix_ingred_service_10_3(){
fix_ingred_service_10_3_0();
}
void fix_ingred_service_10_4_5(){
int index;
    bzero(&index,sizeof(int));
unsigned int size;
    bzero(&size,sizeof(unsigned int));
    {unsigned int size; size = (unsigned int)(index); }
    {unsigned int charset_size; charset_size = (unsigned int)(index); }
    {int letter; letter = (int)(index); }
    {unsigned int tlv2; tlv2 = (unsigned int)(index); }
    {unsigned int tlv3; tlv3 = (unsigned int)(index); }
}
void fix_ingred_service_10_4_6(){
int index;
    bzero(&index,sizeof(int));
unsigned int size;
    bzero(&size,sizeof(unsigned int));
    {unsigned int charset_size; charset_size = (unsigned int)(size); }
    {int index; index = (int)(size); }
    {int letter; letter = (int)(size); }
    {unsigned int tlv2; tlv2 = (unsigned int)(size); }
    {unsigned int tlv3; tlv3 = (unsigned int)(size); }
}
void fix_ingred_service_10_4(){
fix_ingred_service_10_4_5();
fix_ingred_service_10_4_6();
}
void fix_ingred_service_10_5_0(){
unsigned int charset_size;
    bzero(&charset_size,sizeof(unsigned int));
    {unsigned int size; size = (unsigned int)(charset_size); }
    {int index; index = (int)(charset_size); }
    {int letter; letter = (int)(charset_size); }
    {unsigned int tlv2; tlv2 = (unsigned int)(charset_size); }
    {unsigned int tlv3; tlv3 = (unsigned int)(charset_size); }
}
void fix_ingred_service_10_5(){
fix_ingred_service_10_5_0();
}
void fix_ingred_service_10(){
fix_ingred_service_10_0();
fix_ingred_service_10_1();
fix_ingred_service_10_2();
fix_ingred_service_10_3();
fix_ingred_service_10_4();
fix_ingred_service_10_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_10_0_0();
void fix_ingred_service_10_0_2();
void fix_ingred_service_10_0();
void fix_ingred_service_10_1_3();
void fix_ingred_service_10_1();
void fix_ingred_service_10_2_0();
void fix_ingred_service_10_2();
void fix_ingred_service_10_3_0();
void fix_ingred_service_10_3();
void fix_ingred_service_10_4_5();
void fix_ingred_service_10_4_6();
void fix_ingred_service_10_4();
void fix_ingred_service_10_5_0();
void fix_ingred_service_10_5();
void fix_ingred_service_10();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : cgc_getRandomTerm ( request ) ;
def_vars[1]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : cgc_getRandomAttribute ( request ) ;
def_vars[2]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[3]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[4]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[5]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : void * tlv6 ;
def_vars[6]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : void * tlv5 ;
def_vars[7]: [cgc_createRandomRequest] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv4 ;
sym_lut=>'{'request': 'Request *'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_getRandomTerm( request )' - is_func=True, is_func_ptr=False
cgc_getRandomTerm( request ) is a function.
Skipping.
Checking 'cgc_getRandomAttribute( request )' - is_func=True, is_func_ptr=False
cgc_getRandomAttribute( request ) is a function.
Skipping.
sym_lut=>'{'request': 'Request *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb50acc18>), ('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4e63f98>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a4e898>)]'
cval_s=>'[]'
Checking 'cgc_getRandomTerm( request )' - is_func=True, is_func_ptr=False
cgc_getRandomTerm( request ) is a function.
Skipping.
Checking 'cgc_getRandomAttribute( request )' - is_func=True, is_func_ptr=False
cgc_getRandomAttribute( request ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request' - False OR  False
[i=11/18][j=1/3][dd=0/8][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request
 => is literal (False) | is operator (False) request [vtype=Request *]
unique : ('Request *', 'request', None)
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'REQUEST_SIZE' - False OR  False
[i=11/18][j=1/3][dd=0/8][k=2/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : REQUEST_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : REQUEST_SIZE
 => is literal (False) | is operator (False) REQUEST_SIZE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request' - False OR  False
[i=11/18][j=1/3][dd=1/8][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'REQUEST_SIZE' - False OR  False
[i=11/18][j=1/3][dd=1/8][k=2/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : REQUEST_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : REQUEST_SIZE
 => is literal (False) | is operator (False) REQUEST_SIZE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request' - False OR  False
[i=11/18][j=1/3][dd=2/8][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'REQUEST_SIZE' - False OR  False
[i=11/18][j=1/3][dd=2/8][k=2/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : REQUEST_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : REQUEST_SIZE
 => is literal (False) | is operator (False) REQUEST_SIZE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request' - False OR  False
[i=11/18][j=1/3][dd=3/8][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=11/18][j=1/3][dd=3/8][k=1/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'REQUEST_SIZE' - False OR  False
[i=11/18][j=1/3][dd=3/8][k=2/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : REQUEST_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : REQUEST_SIZE
 => is literal (False) | is operator (False) REQUEST_SIZE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request' - False OR  False
[i=11/18][j=1/3][dd=4/8][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=11/18][j=1/3][dd=4/8][k=1/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'REQUEST_SIZE' - False OR  False
[i=11/18][j=1/3][dd=4/8][k=2/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : REQUEST_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : REQUEST_SIZE
 => is literal (False) | is operator (False) REQUEST_SIZE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request' - False OR  False
[i=11/18][j=1/3][dd=5/8][k=0/3] | type: void * ; var : tlv3 ; varinfo :  ; value_node : request (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=11/18][j=1/3][dd=5/8][k=1/3] | type: int ; var : tlv2 ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'REQUEST_SIZE' - False OR  False
[i=11/18][j=1/3][dd=5/8][k=2/3] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : REQUEST_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : REQUEST_SIZE
 => is literal (False) | is operator (False) REQUEST_SIZE [vtype=None]
----
UNIQ_INIT: ('Request *','request','None','None');

----
UNIQ_INIT: ('Request *','request','None','None');

----
UNIQ_INIT: ('Request *','request','None','None');

==== Scope 1 ====
void fix_ingred_service_11_1_0(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(request); }
    {int tlv2; tlv2 = (int)(request); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(request); }
    {void * tlv6; tlv6 = (void *)(request); }
    {void * tlv5; tlv5 = (void *)(request); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(request); }
}
void fix_ingred_service_11_1_1(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv6; tlv6 = (void *)(0); }
    {void * tlv5; tlv5 = (void *)(0); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(0); }
}
void fix_ingred_service_11_1_2(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(REQUEST_SIZE); }
    {int tlv2; tlv2 = (int)(REQUEST_SIZE); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(REQUEST_SIZE); }
    {void * tlv6; tlv6 = (void *)(REQUEST_SIZE); }
    {void * tlv5; tlv5 = (void *)(REQUEST_SIZE); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(REQUEST_SIZE); }
}
void fix_ingred_service_11_1(){
fix_ingred_service_11_1_0();
fix_ingred_service_11_1_1();
fix_ingred_service_11_1_2();
}

sym_lut=>'{'request': 'Request *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv6': 'void *', 'tlv5': 'void *', 'tlv4': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4e05cf8>), ('void *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cb5c88>), ('cgc_size_t', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d05ba8>)]'
cval_s=>'[]'
Checking 'cgc_getRandomTerm( request )' - is_func=True, is_func_ptr=False
cgc_getRandomTerm( request ) is a function.
Skipping.
Checking 'cgc_getRandomAttribute( request )' - is_func=True, is_func_ptr=False
cgc_getRandomAttribute( request ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->limit' - False OR  False
[i=11/18][j=2/3][dd=0/8][k=0/3] | type: void * ; var : tlv6 ; varinfo :  ; value_node : request -> limit (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,limit
 => is literal (False) | is operator (False) request [vtype=Request *]
unique : ('Request *', 'request', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) limit [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT_STR' - False OR  False
[i=11/18][j=2/3][dd=0/8][k=1/3] | type: void * ; var : tlv5 ; varinfo :  ; value_node : RESULT_LIMIT_STR (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT_STR
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(RESULT_LIMIT_STR)' - False OR  False
[i=11/18][j=2/3][dd=0/8][k=2/3] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : sizeof ( RESULT_LIMIT_STR ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,RESULT_LIMIT_STR,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->limit' - False OR  False
[i=11/18][j=2/3][dd=1/8][k=0/3] | type: void * ; var : tlv6 ; varinfo :  ; value_node : request -> limit (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,limit
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) limit [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT_STR' - False OR  False
[i=11/18][j=2/3][dd=1/8][k=1/3] | type: void * ; var : tlv5 ; varinfo :  ; value_node : RESULT_LIMIT_STR (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT_STR
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(RESULT_LIMIT_STR)' - False OR  False
[i=11/18][j=2/3][dd=1/8][k=2/3] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : sizeof ( RESULT_LIMIT_STR ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,RESULT_LIMIT_STR,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->limit' - False OR  False
[i=11/18][j=2/3][dd=2/8][k=0/3] | type: void * ; var : tlv6 ; varinfo :  ; value_node : request -> limit (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,limit
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) limit [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT_STR' - False OR  False
[i=11/18][j=2/3][dd=2/8][k=1/3] | type: void * ; var : tlv5 ; varinfo :  ; value_node : RESULT_LIMIT_STR (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT_STR
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(RESULT_LIMIT_STR)' - False OR  False
[i=11/18][j=2/3][dd=2/8][k=2/3] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : sizeof ( RESULT_LIMIT_STR ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,RESULT_LIMIT_STR,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->limit' - False OR  False
[i=11/18][j=2/3][dd=3/8][k=0/3] | type: void * ; var : tlv6 ; varinfo :  ; value_node : request -> limit (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,limit
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) limit [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT_STR' - False OR  False
[i=11/18][j=2/3][dd=3/8][k=1/3] | type: void * ; var : tlv5 ; varinfo :  ; value_node : RESULT_LIMIT_STR (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT_STR
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(RESULT_LIMIT_STR)' - False OR  False
[i=11/18][j=2/3][dd=3/8][k=2/3] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : sizeof ( RESULT_LIMIT_STR ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,RESULT_LIMIT_STR,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->limit' - False OR  False
[i=11/18][j=2/3][dd=4/8][k=0/3] | type: void * ; var : tlv6 ; varinfo :  ; value_node : request -> limit (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,limit
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) limit [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT_STR' - False OR  False
[i=11/18][j=2/3][dd=4/8][k=1/3] | type: void * ; var : tlv5 ; varinfo :  ; value_node : RESULT_LIMIT_STR (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT_STR
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(RESULT_LIMIT_STR)' - False OR  False
[i=11/18][j=2/3][dd=4/8][k=2/3] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : sizeof ( RESULT_LIMIT_STR ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,RESULT_LIMIT_STR,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'request->limit' - False OR  False
[i=11/18][j=2/3][dd=5/8][k=0/3] | type: void * ; var : tlv6 ; varinfo :  ; value_node : request -> limit (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : request,->,limit
 => is literal (False) | is operator (False) request [vtype=Request *]
not unique: ('Request *', 'request', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) limit [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT_STR' - False OR  False
[i=11/18][j=2/3][dd=5/8][k=1/3] | type: void * ; var : tlv5 ; varinfo :  ; value_node : RESULT_LIMIT_STR (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT_STR
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(RESULT_LIMIT_STR)' - False OR  False
[i=11/18][j=2/3][dd=5/8][k=2/3] | type: cgc_size_t ; var : tlv4 ; varinfo :  ; value_node : sizeof ( RESULT_LIMIT_STR ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,RESULT_LIMIT_STR,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) RESULT_LIMIT_STR [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('Request *','request','None','None');

----
UNIQ_INIT: ('Request *','request','None','None');

----
UNIQ_INIT: ('Request *','request','None','None');

==== Scope 1 ====
void fix_ingred_service_11_2_0(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(request -> limit); }
    {int tlv2; tlv2 = (int)(request -> limit); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(request -> limit); }
    {void * tlv6; tlv6 = (void *)(request -> limit); }
    {void * tlv5; tlv5 = (void *)(request -> limit); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(request -> limit); }
}
void fix_ingred_service_11_2_1(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(RESULT_LIMIT_STR); }
    {int tlv2; tlv2 = (int)(RESULT_LIMIT_STR); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(RESULT_LIMIT_STR); }
    {void * tlv6; tlv6 = (void *)(RESULT_LIMIT_STR); }
    {void * tlv5; tlv5 = (void *)(RESULT_LIMIT_STR); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(RESULT_LIMIT_STR); }
}
void fix_ingred_service_11_2_2(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(sizeof ( RESULT_LIMIT_STR )); }
    {int tlv2; tlv2 = (int)(sizeof ( RESULT_LIMIT_STR )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( RESULT_LIMIT_STR )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( RESULT_LIMIT_STR )); }
    {void * tlv5; tlv5 = (void *)(sizeof ( RESULT_LIMIT_STR )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(sizeof ( RESULT_LIMIT_STR )); }
}
void fix_ingred_service_11_2(){
fix_ingred_service_11_2_0();
fix_ingred_service_11_2_1();
fix_ingred_service_11_2_2();
}

==== Scope 2 ====
void fix_ingred_service_11_1_0(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(request); }
    {int tlv2; tlv2 = (int)(request); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(request); }
    {void * tlv6; tlv6 = (void *)(request); }
    {void * tlv5; tlv5 = (void *)(request); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(request); }
}
void fix_ingred_service_11_1_1(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv6; tlv6 = (void *)(0); }
    {void * tlv5; tlv5 = (void *)(0); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(0); }
}
void fix_ingred_service_11_1_2(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(REQUEST_SIZE); }
    {int tlv2; tlv2 = (int)(REQUEST_SIZE); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(REQUEST_SIZE); }
    {void * tlv6; tlv6 = (void *)(REQUEST_SIZE); }
    {void * tlv5; tlv5 = (void *)(REQUEST_SIZE); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(REQUEST_SIZE); }
}
void fix_ingred_service_11_1(){
fix_ingred_service_11_1_0();
fix_ingred_service_11_1_1();
fix_ingred_service_11_1_2();
}
void fix_ingred_service_11_2_0(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(request -> limit); }
    {int tlv2; tlv2 = (int)(request -> limit); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(request -> limit); }
    {void * tlv6; tlv6 = (void *)(request -> limit); }
    {void * tlv5; tlv5 = (void *)(request -> limit); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(request -> limit); }
}
void fix_ingred_service_11_2_1(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(RESULT_LIMIT_STR); }
    {int tlv2; tlv2 = (int)(RESULT_LIMIT_STR); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(RESULT_LIMIT_STR); }
    {void * tlv6; tlv6 = (void *)(RESULT_LIMIT_STR); }
    {void * tlv5; tlv5 = (void *)(RESULT_LIMIT_STR); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(RESULT_LIMIT_STR); }
}
void fix_ingred_service_11_2_2(){
Request request_ref;
    bzero(&request_ref,1*sizeof(Request));
Request * request = &request_ref;
    {void * tlv3; tlv3 = (void *)(sizeof ( RESULT_LIMIT_STR )); }
    {int tlv2; tlv2 = (int)(sizeof ( RESULT_LIMIT_STR )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( RESULT_LIMIT_STR )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( RESULT_LIMIT_STR )); }
    {void * tlv5; tlv5 = (void *)(sizeof ( RESULT_LIMIT_STR )); }
    {cgc_size_t tlv4; tlv4 = (cgc_size_t)(sizeof ( RESULT_LIMIT_STR )); }
}
void fix_ingred_service_11_2(){
fix_ingred_service_11_2_0();
fix_ingred_service_11_2_1();
fix_ingred_service_11_2_2();
}
void fix_ingred_service_11(){
fix_ingred_service_11_1();
fix_ingred_service_11_2();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_11_1_0();
void fix_ingred_service_11_1_1();
void fix_ingred_service_11_1_2();
void fix_ingred_service_11_1();
void fix_ingred_service_11_2_0();
void fix_ingred_service_11_2_1();
void fix_ingred_service_11_2_2();
void fix_ingred_service_11_2();
void fix_ingred_service_11();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : unsigned int charset_size ;
def_vars[1]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : int index ;
def_vars[2]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : int section ;
def_vars[3]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[4]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv6 ;
def_vars[5]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[6]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : void * * tlv4 ;
def_vars[7]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[8]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[9]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[10]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv7 = cgc_charset ;
def_vars[11]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : int letter ;
def_vars[12]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv8 ;
def_vars[13]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv8 ) ;
def_vars[14]: [cgc_getRandomGiftCard] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv9 ;
sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int'}'
val_s=>'[('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>), ('UNDEF', '( * gift_card ) ', '[ GIFT_CARD_LEN ]', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4720908>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=2/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=2/15][k=1/5] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=4/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=5/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=8/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=9/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=12/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=13/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/18][j=0/8][dd=13/15][k=1/5] | type: int ; var : index ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_service_12_0_0(){
    {int section; section = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {unsigned int tlv8; tlv8 = (unsigned int)(0); }
    {unsigned int tlv9; tlv9 = (unsigned int)(0); }
}
void fix_ingred_service_12_0_1(){
    {int section; section = (int)(0); }
    {unsigned int tlv9; tlv9 = (unsigned int)(0); }
}
void fix_ingred_service_12_0(){
fix_ingred_service_12_0_0();
fix_ingred_service_12_0_1();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *'}'
val_s=>'[('cgc_size_t', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0b6d8>), ('int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0a7b8>), ('void * *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4bf7748>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=0/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=1/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=2/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=3/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=4/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=5/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=7/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=8/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=9/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=11/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=12/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN+1' - False OR  False
[i=12/18][j=1/8][dd=13/15][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : GIFT_CARD_LEN + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN,+,1
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_service_12_1_0(){
    {unsigned int charset_size; charset_size = (unsigned int)(GIFT_CARD_LEN + 1); }
    {int index; index = (int)(GIFT_CARD_LEN + 1); }
    {int section; section = (int)(GIFT_CARD_LEN + 1); }
    {int ret; ret = (int)(GIFT_CARD_LEN + 1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(GIFT_CARD_LEN + 1); }
    {int tlv5; tlv5 = (int)(GIFT_CARD_LEN + 1); }
    {void * tlv3; tlv3 = (void *)(GIFT_CARD_LEN + 1); }
    {int tlv2; tlv2 = (int)(GIFT_CARD_LEN + 1); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(GIFT_CARD_LEN + 1); }
    {int letter; letter = (int)(GIFT_CARD_LEN + 1); }
    {unsigned int tlv8; tlv8 = (unsigned int)(GIFT_CARD_LEN + 1); }
    {unsigned int tlv9; tlv9 = (unsigned int)(GIFT_CARD_LEN + 1); }
}
void fix_ingred_service_12_1(){
fix_ingred_service_12_1_0();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *'}'
val_s=>'[('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4bfe748>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4bfeac8>)]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=0/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=1/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=2/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=4/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=5/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=11/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=12/18][j=2/8][dd=13/15][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_12_2_4(){
int ret;
    bzero(&ret,sizeof(int));
    {unsigned int charset_size; charset_size = (unsigned int)(ret); }
    {int index; index = (int)(ret); }
    {int section; section = (int)(ret); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ret); }
    {int tlv5; tlv5 = (int)(ret); }
    {int letter; letter = (int)(ret); }
    {unsigned int tlv9; tlv9 = (unsigned int)(ret); }
}
void fix_ingred_service_12_2(){
fix_ingred_service_12_2_4();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'tlv8': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c31908>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4bfe748>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4bfeac8>)]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=0/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=1/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=2/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=4/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=5/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=11/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=12/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=12/18][j=3/8][dd=13/15][k=0/7] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
----
==== Scope 1 ====
void fix_ingred_service_12_3_0(){
    {unsigned int charset_size; charset_size = (unsigned int)(3); }
    {int index; index = (int)(3); }
    {int section; section = (int)(3); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(3); }
    {int tlv5; tlv5 = (int)(3); }
    {int letter; letter = (int)(3); }
    {unsigned int tlv8; tlv8 = (unsigned int)(3); }
    {unsigned int tlv9; tlv9 = (unsigned int)(3); }
}
void fix_ingred_service_12_3(){
fix_ingred_service_12_3_0();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c28f98>), ('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c14f98>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c11eb8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=0/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
unique : ('char * *', 'gift_card', None)
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=0/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=1/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=1/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=2/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=2/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=3/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=3/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=4/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=4/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=5/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=5/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=7/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=7/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=8/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=8/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=9/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=9/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=11/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=11/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=12/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=12/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*gift_card' - False OR  False
[i=12/18][j=4/8][dd=13/15][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : * gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,gift_card
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) gift_card [vtype=char * *]
not unique: ('char * *', 'gift_card', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=4/8][dd=13/15][k=2/7] | type: cgc_size_t ; var : tlv1 ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
----
UNIQ_INIT: ('char * *','gift_card','None','None');

----
UNIQ_INIT: ('char * *','gift_card','None','None');

==== Scope 1 ====
void fix_ingred_service_12_4_0(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * * gift_card = &gift_card_ref;
    {unsigned int charset_size; charset_size = (unsigned int)(* gift_card); }
    {int index; index = (int)(* gift_card); }
    {int section; section = (int)(* gift_card); }
    {int ret; ret = (int)(* gift_card); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(* gift_card); }
    {int tlv5; tlv5 = (int)(* gift_card); }
    {void * tlv3; tlv3 = (void *)(* gift_card); }
    {int tlv2; tlv2 = (int)(* gift_card); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(* gift_card); }
    {int letter; letter = (int)(* gift_card); }
    {unsigned int tlv8; tlv8 = (unsigned int)(* gift_card); }
    {unsigned int tlv9; tlv9 = (unsigned int)(* gift_card); }
}
void fix_ingred_service_12_4_2(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * * gift_card = &gift_card_ref;
    {unsigned int charset_size; charset_size = (unsigned int)(GIFT_CARD_LEN); }
    {int index; index = (int)(GIFT_CARD_LEN); }
    {int section; section = (int)(GIFT_CARD_LEN); }
    {int ret; ret = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int tlv5; tlv5 = (int)(GIFT_CARD_LEN); }
    {void * tlv3; tlv3 = (void *)(GIFT_CARD_LEN); }
    {int tlv2; tlv2 = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int letter; letter = (int)(GIFT_CARD_LEN); }
    {unsigned int tlv8; tlv8 = (unsigned int)(GIFT_CARD_LEN); }
    {unsigned int tlv9; tlv9 = (unsigned int)(GIFT_CARD_LEN); }
}
void fix_ingred_service_12_4(){
fix_ingred_service_12_4_0();
fix_ingred_service_12_4_2();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv7': 'const char *'}'
val_s=>'[('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c307b8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=0/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
unique : ('const char *', 'tlv7', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=1/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=2/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=3/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=4/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=5/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=7/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=8/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=9/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=11/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=12/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=12/18][j=5/8][dd=13/15][k=0/5] | type: unsigned int ; var : charset_size ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=const char *]
not unique: ('const char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv7','None','None');

==== Scope 1 ====
void fix_ingred_service_12_5_0(){
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
const char * tlv7 = &tlv7_ref;
    {unsigned int charset_size; charset_size = (unsigned int)(cgc_strlen ( tlv7 )); }
    {int index; index = (int)(cgc_strlen ( tlv7 )); }
    {int section; section = (int)(cgc_strlen ( tlv7 )); }
    {int ret; ret = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv5; tlv5 = (int)(cgc_strlen ( tlv7 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv7 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int letter; letter = (int)(cgc_strlen ( tlv7 )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(cgc_strlen ( tlv7 )); }
    {unsigned int tlv9; tlv9 = (unsigned int)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_service_12_5(){
fix_ingred_service_12_5_0();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv7': 'const char *', 'letter': 'int'}'
val_s=>'[('UNDEF', '( * gift_card ) ', '[ index ]', <CParser.CParser.AssignmentExpressionContext object at 0x14adb471b5f8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c2c588>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4c29048>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4c29438>)]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=0/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=1/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=2/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
unique : ('int', 'index', None)
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=2/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=3/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=3/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=4/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=4/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=5/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=5/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=7/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=7/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=8/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=8/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=9/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=9/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=11/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=12/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=12/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'index' - False OR  False
[i=12/18][j=6/8][dd=13/15][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : index (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : index
 => is literal (False) | is operator (False) index [vtype=int]
not unique: ('int', 'index', None) ... continue!
is_func_ [G] => '[False, False, False]'
has_multiptr_refs 'GIFT_CARD_LEN' - False OR  False
[i=12/18][j=6/8][dd=13/15][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : GIFT_CARD_LEN (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : GIFT_CARD_LEN
 => is literal (False) | is operator (False) GIFT_CARD_LEN [vtype=None]
----
UNIQ_INIT: ('int','index','None','None');

----
UNIQ_INIT: ('int','index','None','None');

==== Scope 1 ====
void fix_ingred_service_12_6_6(){
int index;
    bzero(&index,sizeof(int));
    {int section; section = (int)(index); }
    {int ret; ret = (int)(index); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(index); }
    {int tlv5; tlv5 = (int)(index); }
    {void * tlv3; tlv3 = (void *)(index); }
    {int tlv2; tlv2 = (int)(index); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(index); }
    {unsigned int tlv8; tlv8 = (unsigned int)(index); }
    {unsigned int tlv9; tlv9 = (unsigned int)(index); }
}
void fix_ingred_service_12_6_7(){
int index;
    bzero(&index,sizeof(int));
    {unsigned int charset_size; charset_size = (unsigned int)(GIFT_CARD_LEN); }
    {int index; index = (int)(GIFT_CARD_LEN); }
    {int section; section = (int)(GIFT_CARD_LEN); }
    {int ret; ret = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int tlv5; tlv5 = (int)(GIFT_CARD_LEN); }
    {void * tlv3; tlv3 = (void *)(GIFT_CARD_LEN); }
    {int tlv2; tlv2 = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int letter; letter = (int)(GIFT_CARD_LEN); }
    {unsigned int tlv8; tlv8 = (unsigned int)(GIFT_CARD_LEN); }
    {unsigned int tlv9; tlv9 = (unsigned int)(GIFT_CARD_LEN); }
}
void fix_ingred_service_12_6(){
fix_ingred_service_12_6_6();
fix_ingred_service_12_6_7();
}

sym_lut=>'{'gift_card': 'char * *', 'charset_size': 'unsigned int', 'index': 'int', 'section': 'int', 'ret': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv7': 'const char *', 'letter': 'int', 'tlv9': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4bfbcf8>), ('unsigned int', 'charset_size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4d9a9e8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a44898>), ('int', 'section', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4a61748>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c0d5f8>), ('int', 'index', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c2c588>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4c29048>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4c29438>)]'
Checking 'cgc__terminate( tlv8 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv8 ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=2/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
unique : ('unsigned int', 'charset_size', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=3/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=4/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=5/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=7/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=8/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=9/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=12/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'charset_size' - False OR  False
[i=12/18][j=7/8][dd=13/15][k=0/8] | type: unsigned int ; var : tlv9 ; varinfo :  ; value_node : charset_size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : charset_size
 => is literal (False) | is operator (False) charset_size [vtype=unsigned int]
not unique: ('unsigned int', 'charset_size', None) ... continue!
----
UNIQ_INIT: ('unsigned int','charset_size','None','None');

==== Scope 1 ====
void fix_ingred_service_12_7_0(){
unsigned int charset_size;
    bzero(&charset_size,sizeof(unsigned int));
    {int section; section = (int)(charset_size); }
    {int ret; ret = (int)(charset_size); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(charset_size); }
    {int tlv5; tlv5 = (int)(charset_size); }
    {void * tlv3; tlv3 = (void *)(charset_size); }
    {int tlv2; tlv2 = (int)(charset_size); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(charset_size); }
    {unsigned int tlv8; tlv8 = (unsigned int)(charset_size); }
    {unsigned int tlv9; tlv9 = (unsigned int)(charset_size); }
}
void fix_ingred_service_12_7(){
fix_ingred_service_12_7_0();
}

==== Scope 2 ====
void fix_ingred_service_12_0_0(){
    {int section; section = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {unsigned int tlv8; tlv8 = (unsigned int)(0); }
    {unsigned int tlv9; tlv9 = (unsigned int)(0); }
}
void fix_ingred_service_12_0_1(){
    {int section; section = (int)(0); }
    {unsigned int tlv9; tlv9 = (unsigned int)(0); }
}
void fix_ingred_service_12_0(){
fix_ingred_service_12_0_0();
fix_ingred_service_12_0_1();
}
void fix_ingred_service_12_1_0(){
    {unsigned int charset_size; charset_size = (unsigned int)(GIFT_CARD_LEN + 1); }
    {int index; index = (int)(GIFT_CARD_LEN + 1); }
    {int section; section = (int)(GIFT_CARD_LEN + 1); }
    {int ret; ret = (int)(GIFT_CARD_LEN + 1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(GIFT_CARD_LEN + 1); }
    {int tlv5; tlv5 = (int)(GIFT_CARD_LEN + 1); }
    {void * tlv3; tlv3 = (void *)(GIFT_CARD_LEN + 1); }
    {int tlv2; tlv2 = (int)(GIFT_CARD_LEN + 1); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(GIFT_CARD_LEN + 1); }
    {int letter; letter = (int)(GIFT_CARD_LEN + 1); }
    {unsigned int tlv8; tlv8 = (unsigned int)(GIFT_CARD_LEN + 1); }
    {unsigned int tlv9; tlv9 = (unsigned int)(GIFT_CARD_LEN + 1); }
}
void fix_ingred_service_12_1(){
fix_ingred_service_12_1_0();
}
void fix_ingred_service_12_2_4(){
int ret;
    bzero(&ret,sizeof(int));
    {unsigned int charset_size; charset_size = (unsigned int)(ret); }
    {int index; index = (int)(ret); }
    {int section; section = (int)(ret); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ret); }
    {int tlv5; tlv5 = (int)(ret); }
    {int letter; letter = (int)(ret); }
    {unsigned int tlv9; tlv9 = (unsigned int)(ret); }
}
void fix_ingred_service_12_2(){
fix_ingred_service_12_2_4();
}
void fix_ingred_service_12_3_0(){
    {unsigned int charset_size; charset_size = (unsigned int)(3); }
    {int index; index = (int)(3); }
    {int section; section = (int)(3); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(3); }
    {int tlv5; tlv5 = (int)(3); }
    {int letter; letter = (int)(3); }
    {unsigned int tlv8; tlv8 = (unsigned int)(3); }
    {unsigned int tlv9; tlv9 = (unsigned int)(3); }
}
void fix_ingred_service_12_3(){
fix_ingred_service_12_3_0();
}
void fix_ingred_service_12_4_0(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * * gift_card = &gift_card_ref;
    {unsigned int charset_size; charset_size = (unsigned int)(* gift_card); }
    {int index; index = (int)(* gift_card); }
    {int section; section = (int)(* gift_card); }
    {int ret; ret = (int)(* gift_card); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(* gift_card); }
    {int tlv5; tlv5 = (int)(* gift_card); }
    {void * tlv3; tlv3 = (void *)(* gift_card); }
    {int tlv2; tlv2 = (int)(* gift_card); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(* gift_card); }
    {int letter; letter = (int)(* gift_card); }
    {unsigned int tlv8; tlv8 = (unsigned int)(* gift_card); }
    {unsigned int tlv9; tlv9 = (unsigned int)(* gift_card); }
}
void fix_ingred_service_12_4_2(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * * gift_card = &gift_card_ref;
    {unsigned int charset_size; charset_size = (unsigned int)(GIFT_CARD_LEN); }
    {int index; index = (int)(GIFT_CARD_LEN); }
    {int section; section = (int)(GIFT_CARD_LEN); }
    {int ret; ret = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int tlv5; tlv5 = (int)(GIFT_CARD_LEN); }
    {void * tlv3; tlv3 = (void *)(GIFT_CARD_LEN); }
    {int tlv2; tlv2 = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int letter; letter = (int)(GIFT_CARD_LEN); }
    {unsigned int tlv8; tlv8 = (unsigned int)(GIFT_CARD_LEN); }
    {unsigned int tlv9; tlv9 = (unsigned int)(GIFT_CARD_LEN); }
}
void fix_ingred_service_12_4(){
fix_ingred_service_12_4_0();
fix_ingred_service_12_4_2();
}
void fix_ingred_service_12_5_0(){
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
const char * tlv7 = &tlv7_ref;
    {unsigned int charset_size; charset_size = (unsigned int)(cgc_strlen ( tlv7 )); }
    {int index; index = (int)(cgc_strlen ( tlv7 )); }
    {int section; section = (int)(cgc_strlen ( tlv7 )); }
    {int ret; ret = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv5; tlv5 = (int)(cgc_strlen ( tlv7 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv7 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int letter; letter = (int)(cgc_strlen ( tlv7 )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(cgc_strlen ( tlv7 )); }
    {unsigned int tlv9; tlv9 = (unsigned int)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_service_12_5(){
fix_ingred_service_12_5_0();
}
void fix_ingred_service_12_6_6(){
int index;
    bzero(&index,sizeof(int));
    {int section; section = (int)(index); }
    {int ret; ret = (int)(index); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(index); }
    {int tlv5; tlv5 = (int)(index); }
    {void * tlv3; tlv3 = (void *)(index); }
    {int tlv2; tlv2 = (int)(index); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(index); }
    {unsigned int tlv8; tlv8 = (unsigned int)(index); }
    {unsigned int tlv9; tlv9 = (unsigned int)(index); }
}
void fix_ingred_service_12_6_7(){
int index;
    bzero(&index,sizeof(int));
    {unsigned int charset_size; charset_size = (unsigned int)(GIFT_CARD_LEN); }
    {int index; index = (int)(GIFT_CARD_LEN); }
    {int section; section = (int)(GIFT_CARD_LEN); }
    {int ret; ret = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int tlv5; tlv5 = (int)(GIFT_CARD_LEN); }
    {void * tlv3; tlv3 = (void *)(GIFT_CARD_LEN); }
    {int tlv2; tlv2 = (int)(GIFT_CARD_LEN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(GIFT_CARD_LEN); }
    {int letter; letter = (int)(GIFT_CARD_LEN); }
    {unsigned int tlv8; tlv8 = (unsigned int)(GIFT_CARD_LEN); }
    {unsigned int tlv9; tlv9 = (unsigned int)(GIFT_CARD_LEN); }
}
void fix_ingred_service_12_6(){
fix_ingred_service_12_6_6();
fix_ingred_service_12_6_7();
}
void fix_ingred_service_12_7_0(){
unsigned int charset_size;
    bzero(&charset_size,sizeof(unsigned int));
    {int section; section = (int)(charset_size); }
    {int ret; ret = (int)(charset_size); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(charset_size); }
    {int tlv5; tlv5 = (int)(charset_size); }
    {void * tlv3; tlv3 = (void *)(charset_size); }
    {int tlv2; tlv2 = (int)(charset_size); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(charset_size); }
    {unsigned int tlv8; tlv8 = (unsigned int)(charset_size); }
    {unsigned int tlv9; tlv9 = (unsigned int)(charset_size); }
}
void fix_ingred_service_12_7(){
fix_ingred_service_12_7_0();
}
void fix_ingred_service_12(){
fix_ingred_service_12_0();
fix_ingred_service_12_1();
fix_ingred_service_12_2();
fix_ingred_service_12_3();
fix_ingred_service_12_4();
fix_ingred_service_12_5();
fix_ingred_service_12_6();
fix_ingred_service_12_7();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_12_0_0();
void fix_ingred_service_12_0_1();
void fix_ingred_service_12_0();
void fix_ingred_service_12_1_0();
void fix_ingred_service_12_1();
void fix_ingred_service_12_2_4();
void fix_ingred_service_12_2();
void fix_ingred_service_12_3_0();
void fix_ingred_service_12_3();
void fix_ingred_service_12_4_0();
void fix_ingred_service_12_4_2();
void fix_ingred_service_12_4();
void fix_ingred_service_12_5_0();
void fix_ingred_service_12_5();
void fix_ingred_service_12_6_6();
void fix_ingred_service_12_6_7();
void fix_ingred_service_12_6();
void fix_ingred_service_12_7_0();
void fix_ingred_service_12_7();
void fix_ingred_service_12();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : char price ;
def_vars[2]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv1 = selectedSong -> price ;
def_vars[3]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[4]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[5]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[6]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : int tlv7 ;
def_vars[7]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = mySongList -> songs [ mySongList -> size - 1 ] . id ;
def_vars[8]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv5 ;
def_vars[9]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : int tlv10 ;
def_vars[10]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : const char tlv9 [ ] = "\n" ;
def_vars[11]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv8 ;
def_vars[12]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv13 = mySongList -> songs [ mySongList -> size - 1 ] . id ;
def_vars[13]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : const char tlv14 [ ] = "\n" ;
def_vars[14]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv11 ;
def_vars[15]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv11 ) ;
def_vars[16]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv12 ;
def_vars[17]: [cgc_purchaseSong] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv12 ) ;
sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=0/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=1/18][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=1/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=3/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=4/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=5/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=6/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=8/18][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=8/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=9/18][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=9/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=11/18][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=11/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=14/18][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=14/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=15/18][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/18][j=0/12][dd=15/18][k=1/2] | type: char ; var : price ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_service_13_0_0(){
    {char price; price = (char)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {int tlv10; tlv10 = (int)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {unsigned int tlv11; tlv11 = (unsigned int)(0); }
    {unsigned int tlv12; tlv12 = (unsigned int)(0); }
}
void fix_ingred_service_13_0_1(){
    {int ret; ret = (int)(0); }
    {char price; price = (char)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {int tlv10; tlv10 = (int)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {unsigned int tlv11; tlv11 = (unsigned int)(0); }
    {unsigned int tlv12; tlv12 = (unsigned int)(0); }
}
void fix_ingred_service_13_0(){
fix_ingred_service_13_0_0();
fix_ingred_service_13_0_1();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *'}'
val_s=>'[('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb470e0b8>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4704b38>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4705a58>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=0/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=0/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
unique : ('Song *', 'selectedSong', None)
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=0/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=1/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=1/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=1/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=3/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=3/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=3/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=4/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=4/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=4/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=5/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=5/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=5/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=6/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=6/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=6/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=8/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=8/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=8/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=9/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=9/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=9/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=11/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=11/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=11/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=14/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=14/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=14/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&mySongList->songs[mySongList->size-1]' - True OR  False
[i=13/18][j=3/12][dd=15/18][k=0/8] | type: void * ; var : tlv4 ; varinfo :  ; value_node : & mySongList -> songs [ mySongList -> size - 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(True) && ( not (False) || False )]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'selectedSong' - False OR  False
[i=13/18][j=3/12][dd=15/18][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : selectedSong (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : selectedSong
 => is literal (False) | is operator (False) selectedSong [vtype=Song *]
not unique: ('Song *', 'selectedSong', None) ... continue!
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_VALUE_SIZE*3' - False OR  False
[i=13/18][j=3/12][dd=15/18][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : RESULT_VALUE_SIZE * 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_VALUE_SIZE,*,3
 => is literal (False) | is operator (False) RESULT_VALUE_SIZE [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (True) | is operator (False) 3
----
UNIQ_INIT: ('Song *','selectedSong','None','None');

----
UNIQ_INIT: ('Song *','selectedSong','None','None');

==== Scope 1 ====
void fix_ingred_service_13_3_1(){
Song selectedSong_ref;
    bzero(&selectedSong_ref,1*sizeof(Song));
Song * selectedSong = &selectedSong_ref;
    {int ret; ret = (int)(selectedSong); }
    {char price; price = (char)(selectedSong); }
    {void * tlv4; tlv4 = (void *)(selectedSong); }
    {void * tlv3; tlv3 = (void *)(selectedSong); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(selectedSong); }
    {int tlv7; tlv7 = (int)(selectedSong); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(selectedSong); }
    {int tlv10; tlv10 = (int)(selectedSong); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(selectedSong); }
    {unsigned int tlv11; tlv11 = (unsigned int)(selectedSong); }
    {unsigned int tlv12; tlv12 = (unsigned int)(selectedSong); }
}
void fix_ingred_service_13_3_2(){
Song selectedSong_ref;
    bzero(&selectedSong_ref,1*sizeof(Song));
Song * selectedSong = &selectedSong_ref;
    {int ret; ret = (int)(RESULT_VALUE_SIZE * 3); }
    {char price; price = (char)(RESULT_VALUE_SIZE * 3); }
    {void * tlv4; tlv4 = (void *)(RESULT_VALUE_SIZE * 3); }
    {void * tlv3; tlv3 = (void *)(RESULT_VALUE_SIZE * 3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(RESULT_VALUE_SIZE * 3); }
    {int tlv7; tlv7 = (int)(RESULT_VALUE_SIZE * 3); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(RESULT_VALUE_SIZE * 3); }
    {int tlv10; tlv10 = (int)(RESULT_VALUE_SIZE * 3); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(RESULT_VALUE_SIZE * 3); }
    {unsigned int tlv11; tlv11 = (unsigned int)(RESULT_VALUE_SIZE * 3); }
    {unsigned int tlv12; tlv12 = (unsigned int)(RESULT_VALUE_SIZE * 3); }
}
void fix_ingred_service_13_3(){
fix_ingred_service_13_3_1();
fix_ingred_service_13_3_2();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('int', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4718b38>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=1/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
unique : ('int', 'socket', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=3/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=4/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=6/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=8/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=9/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=11/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=14/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=13/18][j=4/12][dd=15/18][k=0/6] | type: int ; var : tlv7 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
not unique: ('int', 'socket', None) ... continue!
----
UNIQ_INIT: ('int','socket','None','None');

==== Scope 1 ====
void fix_ingred_service_13_4_0(){
int socket;
    bzero(&socket,sizeof(int));
    {char price; price = (char)(socket); }
    {void * tlv4; tlv4 = (void *)(socket); }
    {void * tlv3; tlv3 = (void *)(socket); }
    {int tlv7; tlv7 = (int)(socket); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(socket); }
    {int tlv10; tlv10 = (int)(socket); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(socket); }
    {unsigned int tlv11; tlv11 = (unsigned int)(socket); }
    {unsigned int tlv12; tlv12 = (unsigned int)(socket); }
}
void fix_ingred_service_13_4(){
fix_ingred_service_13_4_0();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv13': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c81a58>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>), ('int', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4718b38>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=0/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
unique : ('const char *', 'tlv13', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=1/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=3/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=4/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=5/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=6/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=8/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=9/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=11/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=14/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv13)' - False OR  False
[i=13/18][j=5/12][dd=15/18][k=0/7] | type: cgc_size_t ; var : tlv5 ; varinfo :  ; value_node : cgc_strlen ( tlv13 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv13,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv13 [vtype=const char *]
not unique: ('const char *', 'tlv13', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv13','None','None');

==== Scope 1 ====
void fix_ingred_service_13_5_0(){
char tlv13_ref;
    bzero(&tlv13_ref,1*sizeof(char));
const char * tlv13 = &tlv13_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv13 )); }
    {char price; price = (char)(cgc_strlen ( tlv13 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv13 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv13 )); }
    {int tlv7; tlv7 = (int)(cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv13 )); }
    {int tlv10; tlv10 = (int)(cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_strlen ( tlv13 )); }
    {unsigned int tlv11; tlv11 = (unsigned int)(cgc_strlen ( tlv13 )); }
    {unsigned int tlv12; tlv12 = (unsigned int)(cgc_strlen ( tlv13 )); }
}
void fix_ingred_service_13_5(){
fix_ingred_service_13_5_0();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4caf9e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cafd68>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=1/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=3/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=6/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=8/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=9/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=11/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=14/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=13/18][j=6/12][dd=15/18][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_13_6_5(){
int ret;
    bzero(&ret,sizeof(int));
    {char price; price = (char)(ret); }
    {void * tlv4; tlv4 = (void *)(ret); }
    {int tlv7; tlv7 = (int)(ret); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(ret); }
    {int tlv10; tlv10 = (int)(ret); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(ret); }
    {unsigned int tlv11; tlv11 = (unsigned int)(ret); }
    {unsigned int tlv12; tlv12 = (unsigned int)(ret); }
}
void fix_ingred_service_13_6(){
fix_ingred_service_13_6_5();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv11': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c73ba8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4caf9e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cafd68>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=1/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=3/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=4/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=6/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=8/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=9/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=11/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=14/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=13/18][j=7/12][dd=15/18][k=0/8] | type: unsigned int ; var : tlv11 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
----
==== Scope 1 ====
void fix_ingred_service_13_7_0(){
    {char price; price = (char)(10); }
    {void * tlv4; tlv4 = (void *)(10); }
    {void * tlv3; tlv3 = (void *)(10); }
    {int tlv7; tlv7 = (int)(10); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(10); }
    {int tlv10; tlv10 = (int)(10); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(10); }
    {unsigned int tlv11; tlv11 = (unsigned int)(10); }
    {unsigned int tlv12; tlv12 = (unsigned int)(10); }
}
void fix_ingred_service_13_7(){
fix_ingred_service_13_7_0();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv10': 'int', 'tlv9': 'const char *', 'tlv9 [ ]': 'const char', 'tlv8': 'cgc_size_t'}'
val_s=>'[('int', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7e198>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv10': 'int', 'tlv9': 'const char *', 'tlv9 [ ]': 'const char', 'tlv8': 'cgc_size_t', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char'}'
val_s=>'[('cgc_size_t', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7fc18>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>), ('int', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7e198>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=0/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
unique : ('const char', 'tlv14 [ ]', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=1/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=3/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=4/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=5/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=6/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=8/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=9/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=11/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=14/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv14)' - False OR  False
[i=13/18][j=9/12][dd=15/18][k=0/7] | type: cgc_size_t ; var : tlv8 ; varinfo :  ; value_node : cgc_strlen ( tlv14 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv14,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv14 [vtype=const char *]
BEFORE => literal (False) tlv14 => const char *
AFTER => literal (False) tlv14 [ ] => const char [size=]
not unique: ('const char', 'tlv14 [ ]', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char','tlv14 [ ]','None','None');

==== Scope 1 ====
void fix_ingred_service_13_9_0(){
const char tlv14 [0];
    bzero(&tlv14 [0],sizeof(char));
    {int ret; ret = (int)(cgc_strlen ( tlv14 )); }
    {char price; price = (char)(cgc_strlen ( tlv14 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv14 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv14 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv14 )); }
    {int tlv7; tlv7 = (int)(cgc_strlen ( tlv14 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv14 )); }
    {int tlv10; tlv10 = (int)(cgc_strlen ( tlv14 )); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_strlen ( tlv14 )); }
    {unsigned int tlv11; tlv11 = (unsigned int)(cgc_strlen ( tlv14 )); }
    {unsigned int tlv12; tlv12 = (unsigned int)(cgc_strlen ( tlv14 )); }
}
void fix_ingred_service_13_9(){
fix_ingred_service_13_9_0();
}

sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv10': 'int', 'tlv9': 'const char *', 'tlv9 [ ]': 'const char', 'tlv8': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4c77ba8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4c77f28>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'selectedSong': 'Song *', 'mySongList': 'SongList *', 'ret': 'int', 'price': 'char', 'tlv1': 'const char *', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv7': 'int', 'tlv6': 'const char *', 'tlv5': 'cgc_size_t', 'tlv10': 'int', 'tlv9': 'const char *', 'tlv9 [ ]': 'const char', 'tlv8': 'cgc_size_t', 'tlv12': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c8cd68>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47262e8>), ('char', 'price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4732198>), ('UNDEF', 'mySongList -> balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb472d668>)]'
cval_s=>'[('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723ac8>), ('SongList *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb4723dd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4c77ba8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4c77f28>)]'
Checking 'cgc__terminate( tlv11 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv11 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv12 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv12 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_service_13_0_0(){
    {char price; price = (char)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {int tlv10; tlv10 = (int)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {unsigned int tlv11; tlv11 = (unsigned int)(0); }
    {unsigned int tlv12; tlv12 = (unsigned int)(0); }
}
void fix_ingred_service_13_0_1(){
    {int ret; ret = (int)(0); }
    {char price; price = (char)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {int tlv10; tlv10 = (int)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {unsigned int tlv11; tlv11 = (unsigned int)(0); }
    {unsigned int tlv12; tlv12 = (unsigned int)(0); }
}
void fix_ingred_service_13_0(){
fix_ingred_service_13_0_0();
fix_ingred_service_13_0_1();
}
void fix_ingred_service_13_3_1(){
Song selectedSong_ref;
    bzero(&selectedSong_ref,1*sizeof(Song));
Song * selectedSong = &selectedSong_ref;
    {int ret; ret = (int)(selectedSong); }
    {char price; price = (char)(selectedSong); }
    {void * tlv4; tlv4 = (void *)(selectedSong); }
    {void * tlv3; tlv3 = (void *)(selectedSong); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(selectedSong); }
    {int tlv7; tlv7 = (int)(selectedSong); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(selectedSong); }
    {int tlv10; tlv10 = (int)(selectedSong); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(selectedSong); }
    {unsigned int tlv11; tlv11 = (unsigned int)(selectedSong); }
    {unsigned int tlv12; tlv12 = (unsigned int)(selectedSong); }
}
void fix_ingred_service_13_3_2(){
Song selectedSong_ref;
    bzero(&selectedSong_ref,1*sizeof(Song));
Song * selectedSong = &selectedSong_ref;
    {int ret; ret = (int)(RESULT_VALUE_SIZE * 3); }
    {char price; price = (char)(RESULT_VALUE_SIZE * 3); }
    {void * tlv4; tlv4 = (void *)(RESULT_VALUE_SIZE * 3); }
    {void * tlv3; tlv3 = (void *)(RESULT_VALUE_SIZE * 3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(RESULT_VALUE_SIZE * 3); }
    {int tlv7; tlv7 = (int)(RESULT_VALUE_SIZE * 3); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(RESULT_VALUE_SIZE * 3); }
    {int tlv10; tlv10 = (int)(RESULT_VALUE_SIZE * 3); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(RESULT_VALUE_SIZE * 3); }
    {unsigned int tlv11; tlv11 = (unsigned int)(RESULT_VALUE_SIZE * 3); }
    {unsigned int tlv12; tlv12 = (unsigned int)(RESULT_VALUE_SIZE * 3); }
}
void fix_ingred_service_13_3(){
fix_ingred_service_13_3_1();
fix_ingred_service_13_3_2();
}
void fix_ingred_service_13_4_0(){
int socket;
    bzero(&socket,sizeof(int));
    {char price; price = (char)(socket); }
    {void * tlv4; tlv4 = (void *)(socket); }
    {void * tlv3; tlv3 = (void *)(socket); }
    {int tlv7; tlv7 = (int)(socket); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(socket); }
    {int tlv10; tlv10 = (int)(socket); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(socket); }
    {unsigned int tlv11; tlv11 = (unsigned int)(socket); }
    {unsigned int tlv12; tlv12 = (unsigned int)(socket); }
}
void fix_ingred_service_13_4(){
fix_ingred_service_13_4_0();
}
void fix_ingred_service_13_5_0(){
char tlv13_ref;
    bzero(&tlv13_ref,1*sizeof(char));
const char * tlv13 = &tlv13_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv13 )); }
    {char price; price = (char)(cgc_strlen ( tlv13 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv13 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv13 )); }
    {int tlv7; tlv7 = (int)(cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv13 )); }
    {int tlv10; tlv10 = (int)(cgc_strlen ( tlv13 )); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_strlen ( tlv13 )); }
    {unsigned int tlv11; tlv11 = (unsigned int)(cgc_strlen ( tlv13 )); }
    {unsigned int tlv12; tlv12 = (unsigned int)(cgc_strlen ( tlv13 )); }
}
void fix_ingred_service_13_5(){
fix_ingred_service_13_5_0();
}
void fix_ingred_service_13_6_5(){
int ret;
    bzero(&ret,sizeof(int));
    {char price; price = (char)(ret); }
    {void * tlv4; tlv4 = (void *)(ret); }
    {int tlv7; tlv7 = (int)(ret); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(ret); }
    {int tlv10; tlv10 = (int)(ret); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(ret); }
    {unsigned int tlv11; tlv11 = (unsigned int)(ret); }
    {unsigned int tlv12; tlv12 = (unsigned int)(ret); }
}
void fix_ingred_service_13_6(){
fix_ingred_service_13_6_5();
}
void fix_ingred_service_13_7_0(){
    {char price; price = (char)(10); }
    {void * tlv4; tlv4 = (void *)(10); }
    {void * tlv3; tlv3 = (void *)(10); }
    {int tlv7; tlv7 = (int)(10); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(10); }
    {int tlv10; tlv10 = (int)(10); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(10); }
    {unsigned int tlv11; tlv11 = (unsigned int)(10); }
    {unsigned int tlv12; tlv12 = (unsigned int)(10); }
}
void fix_ingred_service_13_7(){
fix_ingred_service_13_7_0();
}
void fix_ingred_service_13_9_0(){
const char tlv14 [0];
    bzero(&tlv14 [0],sizeof(char));
    {int ret; ret = (int)(cgc_strlen ( tlv14 )); }
    {char price; price = (char)(cgc_strlen ( tlv14 )); }
    {void * tlv4; tlv4 = (void *)(cgc_strlen ( tlv14 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv14 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv14 )); }
    {int tlv7; tlv7 = (int)(cgc_strlen ( tlv14 )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_strlen ( tlv14 )); }
    {int tlv10; tlv10 = (int)(cgc_strlen ( tlv14 )); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_strlen ( tlv14 )); }
    {unsigned int tlv11; tlv11 = (unsigned int)(cgc_strlen ( tlv14 )); }
    {unsigned int tlv12; tlv12 = (unsigned int)(cgc_strlen ( tlv14 )); }
}
void fix_ingred_service_13_9(){
fix_ingred_service_13_9_0();
}
void fix_ingred_service_13(){
fix_ingred_service_13_0();
fix_ingred_service_13_3();
fix_ingred_service_13_4();
fix_ingred_service_13_5();
fix_ingred_service_13_6();
fix_ingred_service_13_7();
fix_ingred_service_13_9();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_13_0_0();
void fix_ingred_service_13_0_1();
void fix_ingred_service_13_0();
void fix_ingred_service_13_3_1();
void fix_ingred_service_13_3_2();
void fix_ingred_service_13_3();
void fix_ingred_service_13_4_0();
void fix_ingred_service_13_4();
void fix_ingred_service_13_5_0();
void fix_ingred_service_13_5();
void fix_ingred_service_13_6_5();
void fix_ingred_service_13_6();
void fix_ingred_service_13_7_0();
void fix_ingred_service_13_7();
void fix_ingred_service_13_9_0();
void fix_ingred_service_13_9();
void fix_ingred_service_13();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : char * search_string ;
def_vars[2]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : Request tlv1 ;
def_vars[3]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[4]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv3 = search_string ;
def_vars[5]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[6]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = search_string ;
def_vars[7]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[8]: [cgc_sendSearchString] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'socket': 'int', 'request': 'Request', 'ret': 'int', 'search_string': 'char *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cabe48>), ('char *', 'search_string', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7ddd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=14/18][j=0/6][dd=1/9][k=0/2] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=14/18][j=0/6][dd=1/9][k=1/2] | type: char * ; var : search_string ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=14/18][j=0/6][dd=7/9][k=1/2] | type: char * ; var : search_string ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
----
==== Scope 1 ====
void fix_ingred_service_14_0_0(){
    {char * search_string; search_string = (char *)(0); }
}
void fix_ingred_service_14_0_1(){
    {char * search_string; search_string = (char *)(NULL); }
    {unsigned int tlv5; tlv5 = (unsigned int)(NULL); }
}
void fix_ingred_service_14_0(){
fix_ingred_service_14_0_0();
fix_ingred_service_14_0_1();
}

sym_lut=>'{'socket': 'int', 'request': 'Request', 'ret': 'int', 'search_string': 'char *', 'tlv1': 'Request'}'
val_s=>'[('Request', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cb2eb8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cabe48>), ('char *', 'search_string', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7ddd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'socket': 'int', 'request': 'Request', 'ret': 'int', 'search_string': 'char *', 'tlv1': 'Request', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cb0c88>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cabe48>), ('char *', 'search_string', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7ddd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'socket' - False OR  False
[i=14/18][j=2/6][dd=1/9][k=0/3] | type: int ; var : tlv4 ; varinfo :  ; value_node : socket (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : socket
 => is literal (False) | is operator (False) socket [vtype=int]
unique : ('int', 'socket', None)
----
UNIQ_INIT: ('int','socket','None','None');

==== Scope 1 ====
void fix_ingred_service_14_2_0(){
int socket;
    bzero(&socket,sizeof(int));
    {char * search_string; search_string = (char *)(socket); }
}
void fix_ingred_service_14_2(){
fix_ingred_service_14_2_0();
}

sym_lut=>'{'socket': 'int', 'request': 'Request', 'ret': 'int', 'search_string': 'char *', 'tlv1': 'Request', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv2': 'cgc_size_t', 'tlv6': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c8a828>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cabe48>), ('char *', 'search_string', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7ddd8>), ('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cb0c88>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=14/18][j=3/6][dd=0/9][k=0/4] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
unique : ('const char *', 'tlv6', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=14/18][j=3/6][dd=1/9][k=0/4] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=14/18][j=3/6][dd=3/9][k=0/4] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=14/18][j=3/6][dd=5/9][k=0/4] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6)' - False OR  False
[i=14/18][j=3/6][dd=7/9][k=0/4] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : cgc_strlen ( tlv6 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv6','None','None');

==== Scope 1 ====
void fix_ingred_service_14_3_0(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv6 )); }
    {char * search_string; search_string = (char *)(cgc_strlen ( tlv6 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(cgc_strlen ( tlv6 )); }
}
void fix_ingred_service_14_3(){
fix_ingred_service_14_3_0();
}

sym_lut=>'{'socket': 'int', 'request': 'Request', 'ret': 'int', 'search_string': 'char *', 'tlv1': 'Request', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cabe48>), ('char *', 'search_string', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7ddd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cac7b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cacb38>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=14/18][j=4/6][dd=1/9][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_14_4_2(){
int ret;
    bzero(&ret,sizeof(int));
    {char * search_string; search_string = (char *)(ret); }
}
void fix_ingred_service_14_4(){
fix_ingred_service_14_4_2();
}

sym_lut=>'{'socket': 'int', 'request': 'Request', 'ret': 'int', 'search_string': 'char *', 'tlv1': 'Request', 'tlv4': 'int', 'tlv3': 'const char *', 'tlv2': 'cgc_size_t', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4768978>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4cabe48>), ('char *', 'search_string', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4c7ddd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cac7b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4cacb38>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=14/18][j=5/6][dd=0/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=14/18][j=5/6][dd=1/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=14/18][j=5/6][dd=3/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=14/18][j=5/6][dd=5/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
is_func_ [4] => '[False, False, False]'
has_multiptr_refs '4' - False OR  False
[i=14/18][j=5/6][dd=7/9][k=0/5] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 4 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 4
 => is literal (True) | is operator (False) 4
----
==== Scope 1 ====
void fix_ingred_service_14_5_0(){
    {int ret; ret = (int)(4); }
    {char * search_string; search_string = (char *)(4); }
    {int tlv4; tlv4 = (int)(4); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(4); }
    {unsigned int tlv5; tlv5 = (unsigned int)(4); }
}
void fix_ingred_service_14_5(){
fix_ingred_service_14_5_0();
}

==== Scope 2 ====
void fix_ingred_service_14_0_0(){
    {char * search_string; search_string = (char *)(0); }
}
void fix_ingred_service_14_0_1(){
    {char * search_string; search_string = (char *)(NULL); }
    {unsigned int tlv5; tlv5 = (unsigned int)(NULL); }
}
void fix_ingred_service_14_0(){
fix_ingred_service_14_0_0();
fix_ingred_service_14_0_1();
}
void fix_ingred_service_14_2_0(){
int socket;
    bzero(&socket,sizeof(int));
    {char * search_string; search_string = (char *)(socket); }
}
void fix_ingred_service_14_2(){
fix_ingred_service_14_2_0();
}
void fix_ingred_service_14_3_0(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv6 )); }
    {char * search_string; search_string = (char *)(cgc_strlen ( tlv6 )); }
    {int tlv4; tlv4 = (int)(cgc_strlen ( tlv6 )); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(cgc_strlen ( tlv6 )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(cgc_strlen ( tlv6 )); }
}
void fix_ingred_service_14_3(){
fix_ingred_service_14_3_0();
}
void fix_ingred_service_14_4_2(){
int ret;
    bzero(&ret,sizeof(int));
    {char * search_string; search_string = (char *)(ret); }
}
void fix_ingred_service_14_4(){
fix_ingred_service_14_4_2();
}
void fix_ingred_service_14_5_0(){
    {int ret; ret = (int)(4); }
    {char * search_string; search_string = (char *)(4); }
    {int tlv4; tlv4 = (int)(4); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(4); }
    {unsigned int tlv5; tlv5 = (unsigned int)(4); }
}
void fix_ingred_service_14_5(){
fix_ingred_service_14_5_0();
}
void fix_ingred_service_14(){
fix_ingred_service_14_0();
fix_ingred_service_14_2();
fix_ingred_service_14_3();
fix_ingred_service_14_4();
fix_ingred_service_14_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_14_0_0();
void fix_ingred_service_14_0_1();
void fix_ingred_service_14_0();
void fix_ingred_service_14_2_0();
void fix_ingred_service_14_2();
void fix_ingred_service_14_3_0();
void fix_ingred_service_14_3();
void fix_ingred_service_14_4_2();
void fix_ingred_service_14_4();
void fix_ingred_service_14_5_0();
void fix_ingred_service_14_5();
void fix_ingred_service_14();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t size ;
def_vars[1]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : char * gift_card ;
def_vars[2]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : char * buffer ;
def_vars[3]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[4]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv10 ;
def_vars[5]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv13 ;
def_vars[6]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : int tlv12 ;
def_vars[7]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : void * * tlv11 ;
def_vars[8]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[9]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[10]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv1 ;
def_vars[11]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : char * tlv5 ;
def_vars[12]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : const char tlv4 [ ] = "ID=" ;
def_vars[13]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[14]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = gift_card ;
def_vars[15]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : char * tlv9 ;
def_vars[16]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : const char tlv8 [ ] = "\n" ;
def_vars[17]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : void * tlv15 ;
def_vars[18]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv14 ;
def_vars[19]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : int tlv18 ;
def_vars[20]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv17 = buffer ;
def_vars[21]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv16 ;
def_vars[22]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : void * tlv20 ;
def_vars[23]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv19 ;
def_vars[24]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : int tlv21 ;
def_vars[25]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv24 ;
def_vars[26]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : int tlv23 ;
def_vars[27]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : void * * tlv22 ;
def_vars[28]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv30 = buffer ;
def_vars[29]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv25 ;
def_vars[30]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv25 ) ;
def_vars[31]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv26 ;
def_vars[32]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv26 ) ;
def_vars[33]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv27 ;
def_vars[34]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv27 ) ;
def_vars[35]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv28 ;
def_vars[36]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv28 ) ;
def_vars[37]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv29 ;
def_vars[38]: [cgc_getBalance] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv29 ) ;
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=0/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=0/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=0/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=1/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=1/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=1/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=2/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=5/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=5/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=5/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=6/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=6/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=6/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=9/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=10/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=11/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=13/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=15/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=17/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=17/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=17/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=18/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=18/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=18/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=19/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=19/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=19/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=21/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=21/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=21/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=22/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=22/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=22/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=23/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=23/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=23/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=24/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=24/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=24/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=25/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=25/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=25/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=26/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=26/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=26/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=29/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=29/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=29/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=30/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=30/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=30/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=31/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=31/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=31/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=32/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=32/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=32/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=33/39][k=0/4] | type: cgc_size_t ; var : size ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=15/18][j=0/23][dd=33/39][k=1/4] | type: char * ; var : gift_card ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=15/18][j=0/23][dd=33/39][k=3/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
----
==== Scope 1 ====
void fix_ingred_service_15_0_0(){
    {cgc_size_t size; size = (cgc_size_t)(0); }
    {char * gift_card; gift_card = (char *)(0); }
    {char * buffer; buffer = (char *)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {char * tlv5; tlv5 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(0); }
    {int tlv18; tlv18 = (int)(0); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(0); }
    {int tlv21; tlv21 = (int)(0); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(0); }
    {int tlv23; tlv23 = (int)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {unsigned int tlv26; tlv26 = (unsigned int)(0); }
    {unsigned int tlv27; tlv27 = (unsigned int)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {unsigned int tlv29; tlv29 = (unsigned int)(0); }
}
void fix_ingred_service_15_0_1(){
    {cgc_size_t size; size = (cgc_size_t)(NULL); }
    {char * gift_card; gift_card = (char *)(NULL); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(NULL); }
    {int tlv12; tlv12 = (int)(NULL); }
    {void * tlv15; tlv15 = (void *)(NULL); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(NULL); }
    {int tlv18; tlv18 = (int)(NULL); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(NULL); }
    {void * tlv20; tlv20 = (void *)(NULL); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(NULL); }
    {int tlv21; tlv21 = (int)(NULL); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(NULL); }
    {int tlv23; tlv23 = (int)(NULL); }
    {unsigned int tlv25; tlv25 = (unsigned int)(NULL); }
    {unsigned int tlv26; tlv26 = (unsigned int)(NULL); }
    {unsigned int tlv27; tlv27 = (unsigned int)(NULL); }
    {unsigned int tlv28; tlv28 = (unsigned int)(NULL); }
    {unsigned int tlv29; tlv29 = (unsigned int)(NULL); }
}
void fix_ingred_service_15_0_3(){
    {cgc_size_t size; size = (cgc_size_t)(0); }
    {char * gift_card; gift_card = (char *)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(0); }
    {int tlv18; tlv18 = (int)(0); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(0); }
    {int tlv21; tlv21 = (int)(0); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(0); }
    {int tlv23; tlv23 = (int)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {unsigned int tlv26; tlv26 = (unsigned int)(0); }
    {unsigned int tlv27; tlv27 = (unsigned int)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {unsigned int tlv29; tlv29 = (unsigned int)(0); }
}
void fix_ingred_service_15_0(){
fix_ingred_service_15_0_0();
fix_ingred_service_15_0_1();
fix_ingred_service_15_0_3();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *'}'
val_s=>'[('char * *', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4766f28>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *'}'
val_s=>'[('cgc_size_t', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb476feb8>), ('int', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4764358>), ('void * *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb476d2e8>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=0/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
unique : ('cgc_size_t', 'size', None)
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=1/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=2/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=3/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=5/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=6/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=8/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=9/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=10/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=11/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=13/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=15/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=17/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=18/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=19/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=21/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=22/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=23/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=24/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=25/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=26/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=29/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=30/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=31/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=32/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size+sizeof("ID=")+sizeof("\n")+1' - False OR  False
[i=15/18][j=2/23][dd=33/39][k=0/7] | type: cgc_size_t ; var : tlv13 ; varinfo :  ; value_node : size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,+,sizeof,(,"ID=",),+,sizeof,(,"\n",),+,1
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "ID=" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) "\n" [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
not valid - cgc_size_t size; size = ((cgc_size_t)size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1);

----
UNIQ_INIT: ('cgc_size_t','size','None','None');

==== Scope 1 ====
void fix_ingred_service_15_2_0(){
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {char * gift_card; gift_card = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * buffer; buffer = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int ret; ret = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv12; tlv12 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {void * tlv3; tlv3 = (void *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv2; tlv2 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * tlv5; tlv5 = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * tlv7; tlv7 = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * tlv9; tlv9 = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {void * tlv15; tlv15 = (void *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv18; tlv18 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {void * tlv20; tlv20 = (void *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv21; tlv21 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv23; tlv23 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv25; tlv25 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv26; tlv26 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv27; tlv27 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv28; tlv28 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv29; tlv29 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
}
void fix_ingred_service_15_2(){
fix_ingred_service_15_2_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *'}'
val_s=>'[('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4759438>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb47597b8>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=0/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=1/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=5/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=6/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=17/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=18/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=19/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=21/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=22/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=23/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=24/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=25/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=26/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=29/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=30/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=31/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=32/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=15/18][j=3/23][dd=33/39][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_15_3_4(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t size; size = (cgc_size_t)(ret); }
    {char * gift_card; gift_card = (char *)(ret); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ret); }
    {int tlv12; tlv12 = (int)(ret); }
    {void * tlv15; tlv15 = (void *)(ret); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(ret); }
    {int tlv18; tlv18 = (int)(ret); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(ret); }
    {void * tlv20; tlv20 = (void *)(ret); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(ret); }
    {int tlv21; tlv21 = (int)(ret); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(ret); }
    {int tlv23; tlv23 = (int)(ret); }
    {unsigned int tlv25; tlv25 = (unsigned int)(ret); }
    {unsigned int tlv26; tlv26 = (unsigned int)(ret); }
    {unsigned int tlv27; tlv27 = (unsigned int)(ret); }
    {unsigned int tlv28; tlv28 = (unsigned int)(ret); }
    {unsigned int tlv29; tlv29 = (unsigned int)(ret); }
}
void fix_ingred_service_15_3(){
fix_ingred_service_15_3_4();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv25': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv25', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb475d5f8>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4759438>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb47597b8>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=0/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=1/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=5/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=6/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=17/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=18/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=19/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=21/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=22/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=23/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=24/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=25/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=26/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=29/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=30/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=31/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=32/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=15/18][j=4/23][dd=33/39][k=0/7] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
----
==== Scope 1 ====
void fix_ingred_service_15_4_0(){
    {cgc_size_t size; size = (cgc_size_t)(3); }
    {char * gift_card; gift_card = (char *)(3); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(3); }
    {int tlv12; tlv12 = (int)(3); }
    {void * tlv15; tlv15 = (void *)(3); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(3); }
    {int tlv18; tlv18 = (int)(3); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(3); }
    {void * tlv20; tlv20 = (void *)(3); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(3); }
    {int tlv21; tlv21 = (int)(3); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(3); }
    {int tlv23; tlv23 = (int)(3); }
    {unsigned int tlv25; tlv25 = (unsigned int)(3); }
    {unsigned int tlv26; tlv26 = (unsigned int)(3); }
    {unsigned int tlv27; tlv27 = (unsigned int)(3); }
    {unsigned int tlv28; tlv28 = (unsigned int)(3); }
    {unsigned int tlv29; tlv29 = (unsigned int)(3); }
}
void fix_ingred_service_15_4(){
fix_ingred_service_15_4_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb475fc88>), ('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4769b38>), ('cgc_size_t', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4763a58>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=0/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=1/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=5/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=6/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=17/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=18/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=19/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=21/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=22/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=23/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=24/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=25/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=26/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=29/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=30/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=31/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=32/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=5/23][dd=33/39][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
----
UNIQ_INIT: ('char *','buffer','None','None');

==== Scope 1 ====
void fix_ingred_service_15_5_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {cgc_size_t size; size = (cgc_size_t)(buffer); }
    {char * gift_card; gift_card = (char *)(buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(buffer); }
    {int tlv12; tlv12 = (int)(buffer); }
    {void * tlv15; tlv15 = (void *)(buffer); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(buffer); }
    {int tlv18; tlv18 = (int)(buffer); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(buffer); }
    {void * tlv20; tlv20 = (void *)(buffer); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(buffer); }
    {int tlv21; tlv21 = (int)(buffer); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(buffer); }
    {int tlv23; tlv23 = (int)(buffer); }
    {unsigned int tlv25; tlv25 = (unsigned int)(buffer); }
    {unsigned int tlv26; tlv26 = (unsigned int)(buffer); }
    {unsigned int tlv27; tlv27 = (unsigned int)(buffer); }
    {unsigned int tlv28; tlv28 = (unsigned int)(buffer); }
    {unsigned int tlv29; tlv29 = (unsigned int)(buffer); }
}
void fix_ingred_service_15_5(){
fix_ingred_service_15_5_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char'}'
val_s=>'[('char *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4761048>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=0/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
unique : ('char *', 'buffer', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=1/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=5/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=6/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=17/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=18/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=19/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=21/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=22/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=23/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=24/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=25/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=26/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=29/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=30/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=31/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=32/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=15/18][j=6/23][dd=33/39][k=0/5] | type: char * ; var : tlv5 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
not unique: ('char *', 'buffer', None) ... continue!
----
UNIQ_INIT: ('char *','buffer','None','None');

==== Scope 1 ====
void fix_ingred_service_15_6_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {cgc_size_t size; size = (cgc_size_t)(buffer); }
    {char * gift_card; gift_card = (char *)(buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(buffer); }
    {int tlv12; tlv12 = (int)(buffer); }
    {void * tlv15; tlv15 = (void *)(buffer); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(buffer); }
    {int tlv18; tlv18 = (int)(buffer); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(buffer); }
    {void * tlv20; tlv20 = (void *)(buffer); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(buffer); }
    {int tlv21; tlv21 = (int)(buffer); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(buffer); }
    {int tlv23; tlv23 = (int)(buffer); }
    {unsigned int tlv25; tlv25 = (unsigned int)(buffer); }
    {unsigned int tlv26; tlv26 = (unsigned int)(buffer); }
    {unsigned int tlv27; tlv27 = (unsigned int)(buffer); }
    {unsigned int tlv28; tlv28 = (unsigned int)(buffer); }
    {unsigned int tlv29; tlv29 = (unsigned int)(buffer); }
}
void fix_ingred_service_15_6(){
fix_ingred_service_15_6_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *'}'
val_s=>'[('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb475ab38>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char'}'
val_s=>'[('char *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb496e6d8>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4945208>), ('cgc_size_t', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb496c128>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=0/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
unique : ('char *', 'gift_card', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=0/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
unique : ('cgc_size_t', 'size', None)
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=1/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=1/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=2/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=2/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=3/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=3/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=5/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=5/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=6/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=6/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=8/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=8/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=9/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=9/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=10/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=10/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=11/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=11/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=13/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=13/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=15/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=15/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=17/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=17/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=18/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=18/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=19/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=19/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=21/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=21/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=22/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=22/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=23/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=23/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=24/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=24/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=25/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=25/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=26/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=26/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=29/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=29/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=30/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=30/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=31/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=31/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=32/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=32/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gift_card' - False OR  False
[i=15/18][j=9/23][dd=33/39][k=0/6] | type: void * ; var : tlv15 ; varinfo :  ; value_node : gift_card (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gift_card
 => is literal (False) | is operator (False) gift_card [vtype=char *]
not unique: ('char *', 'gift_card', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=15/18][j=9/23][dd=33/39][k=1/6] | type: cgc_size_t ; var : tlv14 ; varinfo :  ; value_node : size (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
not valid - char * gift_card; gift_card = ((char *)gift_card);

----
UNIQ_INIT: ('char *','gift_card','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

not valid - cgc_size_t size; size = ((cgc_size_t)size);

----
UNIQ_INIT: ('char *','gift_card','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

==== Scope 1 ====
void fix_ingred_service_15_9_0(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * gift_card = &gift_card_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {cgc_size_t size; size = (cgc_size_t)(gift_card); }
    {char * buffer; buffer = (char *)(gift_card); }
    {int ret; ret = (int)(gift_card); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(gift_card); }
    {int tlv12; tlv12 = (int)(gift_card); }
    {void * tlv3; tlv3 = (void *)(gift_card); }
    {int tlv2; tlv2 = (int)(gift_card); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(gift_card); }
    {char * tlv5; tlv5 = (char *)(gift_card); }
    {char * tlv7; tlv7 = (char *)(gift_card); }
    {char * tlv9; tlv9 = (char *)(gift_card); }
    {void * tlv15; tlv15 = (void *)(gift_card); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(gift_card); }
    {int tlv18; tlv18 = (int)(gift_card); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(gift_card); }
    {void * tlv20; tlv20 = (void *)(gift_card); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(gift_card); }
    {int tlv21; tlv21 = (int)(gift_card); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(gift_card); }
    {int tlv23; tlv23 = (int)(gift_card); }
    {unsigned int tlv25; tlv25 = (unsigned int)(gift_card); }
    {unsigned int tlv26; tlv26 = (unsigned int)(gift_card); }
    {unsigned int tlv27; tlv27 = (unsigned int)(gift_card); }
    {unsigned int tlv28; tlv28 = (unsigned int)(gift_card); }
    {unsigned int tlv29; tlv29 = (unsigned int)(gift_card); }
}
void fix_ingred_service_15_9_1(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * gift_card = &gift_card_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {char * gift_card; gift_card = (char *)(size); }
    {char * buffer; buffer = (char *)(size); }
    {int ret; ret = (int)(size); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(size); }
    {int tlv12; tlv12 = (int)(size); }
    {void * tlv3; tlv3 = (void *)(size); }
    {int tlv2; tlv2 = (int)(size); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(size); }
    {char * tlv5; tlv5 = (char *)(size); }
    {char * tlv7; tlv7 = (char *)(size); }
    {char * tlv9; tlv9 = (char *)(size); }
    {void * tlv15; tlv15 = (void *)(size); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(size); }
    {int tlv18; tlv18 = (int)(size); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(size); }
    {void * tlv20; tlv20 = (void *)(size); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(size); }
    {int tlv21; tlv21 = (int)(size); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(size); }
    {int tlv23; tlv23 = (int)(size); }
    {unsigned int tlv25; tlv25 = (unsigned int)(size); }
    {unsigned int tlv26; tlv26 = (unsigned int)(size); }
    {unsigned int tlv27; tlv27 = (unsigned int)(size); }
    {unsigned int tlv28; tlv28 = (unsigned int)(size); }
    {unsigned int tlv29; tlv29 = (unsigned int)(size); }
}
void fix_ingred_service_15_9(){
fix_ingred_service_15_9_0();
fix_ingred_service_15_9_1();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4970c88>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb493c048>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv26': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv26', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb493ce48>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4970c88>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb493c048>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t'}'
val_s=>'[('int', 'tlv18', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb496f438>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=0/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=1/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=2/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=3/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=5/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=6/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=8/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=9/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=10/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=11/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=13/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=15/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=17/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=18/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=19/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=21/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=22/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=23/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=24/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=25/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=26/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=29/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=30/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=31/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=32/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=15/18][j=12/23][dd=33/39][k=0/5] | type: int ; var : tlv18 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
----
==== Scope 1 ====
void fix_ingred_service_15_12_0(){
    {cgc_size_t size; size = (cgc_size_t)(STDOUT); }
    {char * gift_card; gift_card = (char *)(STDOUT); }
    {char * buffer; buffer = (char *)(STDOUT); }
    {int ret; ret = (int)(STDOUT); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(STDOUT); }
    {int tlv12; tlv12 = (int)(STDOUT); }
    {void * tlv3; tlv3 = (void *)(STDOUT); }
    {int tlv2; tlv2 = (int)(STDOUT); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(STDOUT); }
    {char * tlv5; tlv5 = (char *)(STDOUT); }
    {char * tlv7; tlv7 = (char *)(STDOUT); }
    {char * tlv9; tlv9 = (char *)(STDOUT); }
    {void * tlv15; tlv15 = (void *)(STDOUT); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(STDOUT); }
    {int tlv18; tlv18 = (int)(STDOUT); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(STDOUT); }
    {void * tlv20; tlv20 = (void *)(STDOUT); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(STDOUT); }
    {int tlv21; tlv21 = (int)(STDOUT); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(STDOUT); }
    {int tlv23; tlv23 = (int)(STDOUT); }
    {unsigned int tlv25; tlv25 = (unsigned int)(STDOUT); }
    {unsigned int tlv26; tlv26 = (unsigned int)(STDOUT); }
    {unsigned int tlv27; tlv27 = (unsigned int)(STDOUT); }
    {unsigned int tlv28; tlv28 = (unsigned int)(STDOUT); }
    {unsigned int tlv29; tlv29 = (unsigned int)(STDOUT); }
}
void fix_ingred_service_15_12(){
fix_ingred_service_15_12_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv30': 'const char *'}'
val_s=>'[('cgc_size_t', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb493df98>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>), ('int', 'tlv18', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb496f438>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=0/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
unique : ('const char *', 'tlv30', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=1/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=2/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=3/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=5/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=6/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=8/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=9/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=10/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=11/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=13/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=15/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=17/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=18/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=19/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=21/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=22/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=23/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=24/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=25/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=26/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=29/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=30/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=31/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=32/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv30)' - False OR  False
[i=15/18][j=13/23][dd=33/39][k=0/6] | type: cgc_size_t ; var : tlv16 ; varinfo :  ; value_node : cgc_strlen ( tlv30 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv30,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv30 [vtype=const char *]
not unique: ('const char *', 'tlv30', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv30','None','None');

==== Scope 1 ====
void fix_ingred_service_15_13_0(){
char tlv30_ref;
    bzero(&tlv30_ref,1*sizeof(char));
const char * tlv30 = &tlv30_ref;
    {cgc_size_t size; size = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {char * gift_card; gift_card = (char *)(cgc_strlen ( tlv30 )); }
    {char * buffer; buffer = (char *)(cgc_strlen ( tlv30 )); }
    {int ret; ret = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv12; tlv12 = (int)(cgc_strlen ( tlv30 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv30 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {char * tlv5; tlv5 = (char *)(cgc_strlen ( tlv30 )); }
    {char * tlv7; tlv7 = (char *)(cgc_strlen ( tlv30 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv30 )); }
    {void * tlv15; tlv15 = (void *)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv18; tlv18 = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {void * tlv20; tlv20 = (void *)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv21; tlv21 = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv23; tlv23 = (int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv26; tlv26 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv27; tlv27 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv29; tlv29 = (unsigned int)(cgc_strlen ( tlv30 )); }
}
void fix_ingred_service_15_13(){
fix_ingred_service_15_13_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb494af28>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49442e8>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv27': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv27', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb496b128>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb494af28>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb49442e8>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=0/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=1/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=2/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=5/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=6/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=9/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=10/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=11/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=15/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=17/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=18/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=19/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=21/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=22/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=23/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=24/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=25/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=26/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=29/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=30/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=31/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=32/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=15/18][j=15/23][dd=33/39][k=0/7] | type: unsigned int ; var : tlv27 ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
----
==== Scope 1 ====
void fix_ingred_service_15_15_0(){
    {cgc_size_t size; size = (cgc_size_t)(10); }
    {char * gift_card; gift_card = (char *)(10); }
    {char * buffer; buffer = (char *)(10); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(10); }
    {int tlv12; tlv12 = (int)(10); }
    {int tlv2; tlv2 = (int)(10); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(10); }
    {char * tlv5; tlv5 = (char *)(10); }
    {char * tlv9; tlv9 = (char *)(10); }
    {void * tlv15; tlv15 = (void *)(10); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(10); }
    {int tlv18; tlv18 = (int)(10); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(10); }
    {void * tlv20; tlv20 = (void *)(10); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(10); }
    {int tlv21; tlv21 = (int)(10); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(10); }
    {int tlv23; tlv23 = (int)(10); }
    {unsigned int tlv25; tlv25 = (unsigned int)(10); }
    {unsigned int tlv26; tlv26 = (unsigned int)(10); }
    {unsigned int tlv27; tlv27 = (unsigned int)(10); }
    {unsigned int tlv28; tlv28 = (unsigned int)(10); }
    {unsigned int tlv29; tlv29 = (unsigned int)(10); }
}
void fix_ingred_service_15_15(){
fix_ingred_service_15_15_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv20', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb494b7b8>), ('cgc_size_t', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb49406d8>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4946828>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4946ba8>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t', 'tlv28': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv28', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb495f9e8>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4946828>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4946ba8>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t', 'tlv21': 'int'}'
val_s=>'[('int', 'tlv21', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb494cf98>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=0/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=1/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=2/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=3/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=5/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=6/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=8/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=9/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=10/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=11/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=13/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=15/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=17/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=18/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=19/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=21/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=22/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=23/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=24/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=25/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=26/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=29/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=30/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=31/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=32/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=15/18][j=19/23][dd=33/39][k=0/5] | type: int ; var : tlv21 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
----
==== Scope 1 ====
void fix_ingred_service_15_19_0(){
    {cgc_size_t size; size = (cgc_size_t)(STDIN); }
    {char * gift_card; gift_card = (char *)(STDIN); }
    {char * buffer; buffer = (char *)(STDIN); }
    {int ret; ret = (int)(STDIN); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(STDIN); }
    {int tlv12; tlv12 = (int)(STDIN); }
    {void * tlv3; tlv3 = (void *)(STDIN); }
    {int tlv2; tlv2 = (int)(STDIN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(STDIN); }
    {char * tlv5; tlv5 = (char *)(STDIN); }
    {char * tlv7; tlv7 = (char *)(STDIN); }
    {char * tlv9; tlv9 = (char *)(STDIN); }
    {void * tlv15; tlv15 = (void *)(STDIN); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(STDIN); }
    {int tlv18; tlv18 = (int)(STDIN); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(STDIN); }
    {void * tlv20; tlv20 = (void *)(STDIN); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(STDIN); }
    {int tlv21; tlv21 = (int)(STDIN); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(STDIN); }
    {int tlv23; tlv23 = (int)(STDIN); }
    {unsigned int tlv25; tlv25 = (unsigned int)(STDIN); }
    {unsigned int tlv26; tlv26 = (unsigned int)(STDIN); }
    {unsigned int tlv27; tlv27 = (unsigned int)(STDIN); }
    {unsigned int tlv28; tlv28 = (unsigned int)(STDIN); }
    {unsigned int tlv29; tlv29 = (unsigned int)(STDIN); }
}
void fix_ingred_service_15_19(){
fix_ingred_service_15_19_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t', 'tlv21': 'int', 'tlv24': 'cgc_size_t', 'tlv23': 'int', 'tlv22': 'void * *'}'
val_s=>'[('cgc_size_t', 'tlv24', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb435add8>), ('int', 'tlv23', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb435c5f8>), ('void * *', 'tlv22', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4359588>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=0/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
unique : ('SongList *', 'mySongList', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=1/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=2/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=3/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=5/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=6/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=8/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=9/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=10/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=11/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=13/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=15/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=17/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=18/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=19/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=21/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=22/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=23/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=24/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=25/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=26/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=29/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=30/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=31/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=32/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*mySongList->balance' - False OR  False
[i=15/18][j=20/23][dd=33/39][k=0/7] | type: cgc_size_t ; var : tlv24 ; varinfo :  ; value_node : sizeof ( Song ) * mySongList -> balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,mySongList,->,balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) mySongList [vtype=SongList *]
not unique: ('SongList *', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) balance [vtype=None]
----
UNIQ_INIT: ('SongList *','mySongList','None','None');

==== Scope 1 ====
void fix_ingred_service_15_20_0(){
SongList mySongList_ref;
    bzero(&mySongList_ref,1*sizeof(SongList));
SongList * mySongList = &mySongList_ref;
    {cgc_size_t size; size = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {char * gift_card; gift_card = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {char * buffer; buffer = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {int ret; ret = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv12; tlv12 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {void * tlv3; tlv3 = (void *)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv2; tlv2 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {char * tlv5; tlv5 = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {char * tlv7; tlv7 = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {char * tlv9; tlv9 = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {void * tlv15; tlv15 = (void *)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv18; tlv18 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {void * tlv20; tlv20 = (void *)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv21; tlv21 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv23; tlv23 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv26; tlv26 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv27; tlv27 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv29; tlv29 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
}
void fix_ingred_service_15_20(){
fix_ingred_service_15_20_0();
}

sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t', 'tlv21': 'int', 'tlv24': 'cgc_size_t', 'tlv23': 'int', 'tlv22': 'void * *'}'
val_s=>'[('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb435e6d8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb435ea58>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
sym_lut=>'{'mySongList': 'SongList *', 'size': 'cgc_size_t', 'gift_card': 'char *', 'buffer': 'char *', 'ret': 'int', 'tlv10': 'char * *', 'tlv13': 'cgc_size_t', 'tlv12': 'int', 'tlv11': 'void * *', 'tlv3': 'void *', 'tlv2': 'int', 'tlv1': 'cgc_size_t', 'tlv5': 'char *', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv7': 'char *', 'tlv6': 'const char *', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv15': 'void *', 'tlv14': 'cgc_size_t', 'tlv18': 'int', 'tlv17': 'const char *', 'tlv16': 'cgc_size_t', 'tlv20': 'void *', 'tlv19': 'cgc_size_t', 'tlv21': 'int', 'tlv24': 'cgc_size_t', 'tlv23': 'int', 'tlv22': 'void * *', 'tlv29': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv29', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4361898>), ('cgc_size_t', 'size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758048>), ('char *', 'gift_card', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4758f98>), ('char *', 'buffer', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4765f28>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4771dd8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb435e6d8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb435ea58>)]'
Checking 'cgc__terminate( tlv25 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv25 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv26 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv26 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv27 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv27 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv28 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv28 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv29 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv29 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_service_15_0_0(){
    {cgc_size_t size; size = (cgc_size_t)(0); }
    {char * gift_card; gift_card = (char *)(0); }
    {char * buffer; buffer = (char *)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(0); }
    {char * tlv5; tlv5 = (char *)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(0); }
    {int tlv18; tlv18 = (int)(0); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(0); }
    {int tlv21; tlv21 = (int)(0); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(0); }
    {int tlv23; tlv23 = (int)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {unsigned int tlv26; tlv26 = (unsigned int)(0); }
    {unsigned int tlv27; tlv27 = (unsigned int)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {unsigned int tlv29; tlv29 = (unsigned int)(0); }
}
void fix_ingred_service_15_0_1(){
    {cgc_size_t size; size = (cgc_size_t)(NULL); }
    {char * gift_card; gift_card = (char *)(NULL); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(NULL); }
    {int tlv12; tlv12 = (int)(NULL); }
    {void * tlv15; tlv15 = (void *)(NULL); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(NULL); }
    {int tlv18; tlv18 = (int)(NULL); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(NULL); }
    {void * tlv20; tlv20 = (void *)(NULL); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(NULL); }
    {int tlv21; tlv21 = (int)(NULL); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(NULL); }
    {int tlv23; tlv23 = (int)(NULL); }
    {unsigned int tlv25; tlv25 = (unsigned int)(NULL); }
    {unsigned int tlv26; tlv26 = (unsigned int)(NULL); }
    {unsigned int tlv27; tlv27 = (unsigned int)(NULL); }
    {unsigned int tlv28; tlv28 = (unsigned int)(NULL); }
    {unsigned int tlv29; tlv29 = (unsigned int)(NULL); }
}
void fix_ingred_service_15_0_3(){
    {cgc_size_t size; size = (cgc_size_t)(0); }
    {char * gift_card; gift_card = (char *)(0); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(0); }
    {int tlv18; tlv18 = (int)(0); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(0); }
    {int tlv21; tlv21 = (int)(0); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(0); }
    {int tlv23; tlv23 = (int)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {unsigned int tlv26; tlv26 = (unsigned int)(0); }
    {unsigned int tlv27; tlv27 = (unsigned int)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {unsigned int tlv29; tlv29 = (unsigned int)(0); }
}
void fix_ingred_service_15_0(){
fix_ingred_service_15_0_0();
fix_ingred_service_15_0_1();
fix_ingred_service_15_0_3();
}
void fix_ingred_service_15_2_0(){
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {char * gift_card; gift_card = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * buffer; buffer = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int ret; ret = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv12; tlv12 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {void * tlv3; tlv3 = (void *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv2; tlv2 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * tlv5; tlv5 = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * tlv7; tlv7 = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {char * tlv9; tlv9 = (char *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {void * tlv15; tlv15 = (void *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv18; tlv18 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {void * tlv20; tlv20 = (void *)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv21; tlv21 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {int tlv23; tlv23 = (int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv25; tlv25 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv26; tlv26 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv27; tlv27 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv28; tlv28 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
    {unsigned int tlv29; tlv29 = (unsigned int)(size + sizeof ( "ID=" ) + sizeof ( "\n" ) + 1); }
}
void fix_ingred_service_15_2(){
fix_ingred_service_15_2_0();
}
void fix_ingred_service_15_3_4(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t size; size = (cgc_size_t)(ret); }
    {char * gift_card; gift_card = (char *)(ret); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(ret); }
    {int tlv12; tlv12 = (int)(ret); }
    {void * tlv15; tlv15 = (void *)(ret); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(ret); }
    {int tlv18; tlv18 = (int)(ret); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(ret); }
    {void * tlv20; tlv20 = (void *)(ret); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(ret); }
    {int tlv21; tlv21 = (int)(ret); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(ret); }
    {int tlv23; tlv23 = (int)(ret); }
    {unsigned int tlv25; tlv25 = (unsigned int)(ret); }
    {unsigned int tlv26; tlv26 = (unsigned int)(ret); }
    {unsigned int tlv27; tlv27 = (unsigned int)(ret); }
    {unsigned int tlv28; tlv28 = (unsigned int)(ret); }
    {unsigned int tlv29; tlv29 = (unsigned int)(ret); }
}
void fix_ingred_service_15_3(){
fix_ingred_service_15_3_4();
}
void fix_ingred_service_15_4_0(){
    {cgc_size_t size; size = (cgc_size_t)(3); }
    {char * gift_card; gift_card = (char *)(3); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(3); }
    {int tlv12; tlv12 = (int)(3); }
    {void * tlv15; tlv15 = (void *)(3); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(3); }
    {int tlv18; tlv18 = (int)(3); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(3); }
    {void * tlv20; tlv20 = (void *)(3); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(3); }
    {int tlv21; tlv21 = (int)(3); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(3); }
    {int tlv23; tlv23 = (int)(3); }
    {unsigned int tlv25; tlv25 = (unsigned int)(3); }
    {unsigned int tlv26; tlv26 = (unsigned int)(3); }
    {unsigned int tlv27; tlv27 = (unsigned int)(3); }
    {unsigned int tlv28; tlv28 = (unsigned int)(3); }
    {unsigned int tlv29; tlv29 = (unsigned int)(3); }
}
void fix_ingred_service_15_4(){
fix_ingred_service_15_4_0();
}
void fix_ingred_service_15_5_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {cgc_size_t size; size = (cgc_size_t)(buffer); }
    {char * gift_card; gift_card = (char *)(buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(buffer); }
    {int tlv12; tlv12 = (int)(buffer); }
    {void * tlv15; tlv15 = (void *)(buffer); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(buffer); }
    {int tlv18; tlv18 = (int)(buffer); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(buffer); }
    {void * tlv20; tlv20 = (void *)(buffer); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(buffer); }
    {int tlv21; tlv21 = (int)(buffer); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(buffer); }
    {int tlv23; tlv23 = (int)(buffer); }
    {unsigned int tlv25; tlv25 = (unsigned int)(buffer); }
    {unsigned int tlv26; tlv26 = (unsigned int)(buffer); }
    {unsigned int tlv27; tlv27 = (unsigned int)(buffer); }
    {unsigned int tlv28; tlv28 = (unsigned int)(buffer); }
    {unsigned int tlv29; tlv29 = (unsigned int)(buffer); }
}
void fix_ingred_service_15_5(){
fix_ingred_service_15_5_0();
}
void fix_ingred_service_15_6_0(){
char buffer_ref;
    bzero(&buffer_ref,1*sizeof(char));
char * buffer = &buffer_ref;
    {cgc_size_t size; size = (cgc_size_t)(buffer); }
    {char * gift_card; gift_card = (char *)(buffer); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(buffer); }
    {int tlv12; tlv12 = (int)(buffer); }
    {void * tlv15; tlv15 = (void *)(buffer); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(buffer); }
    {int tlv18; tlv18 = (int)(buffer); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(buffer); }
    {void * tlv20; tlv20 = (void *)(buffer); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(buffer); }
    {int tlv21; tlv21 = (int)(buffer); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(buffer); }
    {int tlv23; tlv23 = (int)(buffer); }
    {unsigned int tlv25; tlv25 = (unsigned int)(buffer); }
    {unsigned int tlv26; tlv26 = (unsigned int)(buffer); }
    {unsigned int tlv27; tlv27 = (unsigned int)(buffer); }
    {unsigned int tlv28; tlv28 = (unsigned int)(buffer); }
    {unsigned int tlv29; tlv29 = (unsigned int)(buffer); }
}
void fix_ingred_service_15_6(){
fix_ingred_service_15_6_0();
}
void fix_ingred_service_15_9_0(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * gift_card = &gift_card_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {cgc_size_t size; size = (cgc_size_t)(gift_card); }
    {char * buffer; buffer = (char *)(gift_card); }
    {int ret; ret = (int)(gift_card); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(gift_card); }
    {int tlv12; tlv12 = (int)(gift_card); }
    {void * tlv3; tlv3 = (void *)(gift_card); }
    {int tlv2; tlv2 = (int)(gift_card); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(gift_card); }
    {char * tlv5; tlv5 = (char *)(gift_card); }
    {char * tlv7; tlv7 = (char *)(gift_card); }
    {char * tlv9; tlv9 = (char *)(gift_card); }
    {void * tlv15; tlv15 = (void *)(gift_card); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(gift_card); }
    {int tlv18; tlv18 = (int)(gift_card); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(gift_card); }
    {void * tlv20; tlv20 = (void *)(gift_card); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(gift_card); }
    {int tlv21; tlv21 = (int)(gift_card); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(gift_card); }
    {int tlv23; tlv23 = (int)(gift_card); }
    {unsigned int tlv25; tlv25 = (unsigned int)(gift_card); }
    {unsigned int tlv26; tlv26 = (unsigned int)(gift_card); }
    {unsigned int tlv27; tlv27 = (unsigned int)(gift_card); }
    {unsigned int tlv28; tlv28 = (unsigned int)(gift_card); }
    {unsigned int tlv29; tlv29 = (unsigned int)(gift_card); }
}
void fix_ingred_service_15_9_1(){
char gift_card_ref;
    bzero(&gift_card_ref,1*sizeof(char));
char * gift_card = &gift_card_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {char * gift_card; gift_card = (char *)(size); }
    {char * buffer; buffer = (char *)(size); }
    {int ret; ret = (int)(size); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(size); }
    {int tlv12; tlv12 = (int)(size); }
    {void * tlv3; tlv3 = (void *)(size); }
    {int tlv2; tlv2 = (int)(size); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(size); }
    {char * tlv5; tlv5 = (char *)(size); }
    {char * tlv7; tlv7 = (char *)(size); }
    {char * tlv9; tlv9 = (char *)(size); }
    {void * tlv15; tlv15 = (void *)(size); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(size); }
    {int tlv18; tlv18 = (int)(size); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(size); }
    {void * tlv20; tlv20 = (void *)(size); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(size); }
    {int tlv21; tlv21 = (int)(size); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(size); }
    {int tlv23; tlv23 = (int)(size); }
    {unsigned int tlv25; tlv25 = (unsigned int)(size); }
    {unsigned int tlv26; tlv26 = (unsigned int)(size); }
    {unsigned int tlv27; tlv27 = (unsigned int)(size); }
    {unsigned int tlv28; tlv28 = (unsigned int)(size); }
    {unsigned int tlv29; tlv29 = (unsigned int)(size); }
}
void fix_ingred_service_15_9(){
fix_ingred_service_15_9_0();
fix_ingred_service_15_9_1();
}
void fix_ingred_service_15_12_0(){
    {cgc_size_t size; size = (cgc_size_t)(STDOUT); }
    {char * gift_card; gift_card = (char *)(STDOUT); }
    {char * buffer; buffer = (char *)(STDOUT); }
    {int ret; ret = (int)(STDOUT); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(STDOUT); }
    {int tlv12; tlv12 = (int)(STDOUT); }
    {void * tlv3; tlv3 = (void *)(STDOUT); }
    {int tlv2; tlv2 = (int)(STDOUT); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(STDOUT); }
    {char * tlv5; tlv5 = (char *)(STDOUT); }
    {char * tlv7; tlv7 = (char *)(STDOUT); }
    {char * tlv9; tlv9 = (char *)(STDOUT); }
    {void * tlv15; tlv15 = (void *)(STDOUT); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(STDOUT); }
    {int tlv18; tlv18 = (int)(STDOUT); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(STDOUT); }
    {void * tlv20; tlv20 = (void *)(STDOUT); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(STDOUT); }
    {int tlv21; tlv21 = (int)(STDOUT); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(STDOUT); }
    {int tlv23; tlv23 = (int)(STDOUT); }
    {unsigned int tlv25; tlv25 = (unsigned int)(STDOUT); }
    {unsigned int tlv26; tlv26 = (unsigned int)(STDOUT); }
    {unsigned int tlv27; tlv27 = (unsigned int)(STDOUT); }
    {unsigned int tlv28; tlv28 = (unsigned int)(STDOUT); }
    {unsigned int tlv29; tlv29 = (unsigned int)(STDOUT); }
}
void fix_ingred_service_15_12(){
fix_ingred_service_15_12_0();
}
void fix_ingred_service_15_13_0(){
char tlv30_ref;
    bzero(&tlv30_ref,1*sizeof(char));
const char * tlv30 = &tlv30_ref;
    {cgc_size_t size; size = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {char * gift_card; gift_card = (char *)(cgc_strlen ( tlv30 )); }
    {char * buffer; buffer = (char *)(cgc_strlen ( tlv30 )); }
    {int ret; ret = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv12; tlv12 = (int)(cgc_strlen ( tlv30 )); }
    {void * tlv3; tlv3 = (void *)(cgc_strlen ( tlv30 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {char * tlv5; tlv5 = (char *)(cgc_strlen ( tlv30 )); }
    {char * tlv7; tlv7 = (char *)(cgc_strlen ( tlv30 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv30 )); }
    {void * tlv15; tlv15 = (void *)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv18; tlv18 = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {void * tlv20; tlv20 = (void *)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv21; tlv21 = (int)(cgc_strlen ( tlv30 )); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(cgc_strlen ( tlv30 )); }
    {int tlv23; tlv23 = (int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv26; tlv26 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv27; tlv27 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(cgc_strlen ( tlv30 )); }
    {unsigned int tlv29; tlv29 = (unsigned int)(cgc_strlen ( tlv30 )); }
}
void fix_ingred_service_15_13(){
fix_ingred_service_15_13_0();
}
void fix_ingred_service_15_15_0(){
    {cgc_size_t size; size = (cgc_size_t)(10); }
    {char * gift_card; gift_card = (char *)(10); }
    {char * buffer; buffer = (char *)(10); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(10); }
    {int tlv12; tlv12 = (int)(10); }
    {int tlv2; tlv2 = (int)(10); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(10); }
    {char * tlv5; tlv5 = (char *)(10); }
    {char * tlv9; tlv9 = (char *)(10); }
    {void * tlv15; tlv15 = (void *)(10); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(10); }
    {int tlv18; tlv18 = (int)(10); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(10); }
    {void * tlv20; tlv20 = (void *)(10); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(10); }
    {int tlv21; tlv21 = (int)(10); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(10); }
    {int tlv23; tlv23 = (int)(10); }
    {unsigned int tlv25; tlv25 = (unsigned int)(10); }
    {unsigned int tlv26; tlv26 = (unsigned int)(10); }
    {unsigned int tlv27; tlv27 = (unsigned int)(10); }
    {unsigned int tlv28; tlv28 = (unsigned int)(10); }
    {unsigned int tlv29; tlv29 = (unsigned int)(10); }
}
void fix_ingred_service_15_15(){
fix_ingred_service_15_15_0();
}
void fix_ingred_service_15_19_0(){
    {cgc_size_t size; size = (cgc_size_t)(STDIN); }
    {char * gift_card; gift_card = (char *)(STDIN); }
    {char * buffer; buffer = (char *)(STDIN); }
    {int ret; ret = (int)(STDIN); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(STDIN); }
    {int tlv12; tlv12 = (int)(STDIN); }
    {void * tlv3; tlv3 = (void *)(STDIN); }
    {int tlv2; tlv2 = (int)(STDIN); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(STDIN); }
    {char * tlv5; tlv5 = (char *)(STDIN); }
    {char * tlv7; tlv7 = (char *)(STDIN); }
    {char * tlv9; tlv9 = (char *)(STDIN); }
    {void * tlv15; tlv15 = (void *)(STDIN); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(STDIN); }
    {int tlv18; tlv18 = (int)(STDIN); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(STDIN); }
    {void * tlv20; tlv20 = (void *)(STDIN); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(STDIN); }
    {int tlv21; tlv21 = (int)(STDIN); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(STDIN); }
    {int tlv23; tlv23 = (int)(STDIN); }
    {unsigned int tlv25; tlv25 = (unsigned int)(STDIN); }
    {unsigned int tlv26; tlv26 = (unsigned int)(STDIN); }
    {unsigned int tlv27; tlv27 = (unsigned int)(STDIN); }
    {unsigned int tlv28; tlv28 = (unsigned int)(STDIN); }
    {unsigned int tlv29; tlv29 = (unsigned int)(STDIN); }
}
void fix_ingred_service_15_19(){
fix_ingred_service_15_19_0();
}
void fix_ingred_service_15_20_0(){
SongList mySongList_ref;
    bzero(&mySongList_ref,1*sizeof(SongList));
SongList * mySongList = &mySongList_ref;
    {cgc_size_t size; size = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {char * gift_card; gift_card = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {char * buffer; buffer = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {int ret; ret = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv13; tlv13 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv12; tlv12 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {void * tlv3; tlv3 = (void *)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv2; tlv2 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv1; tlv1 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {char * tlv5; tlv5 = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {char * tlv7; tlv7 = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {char * tlv9; tlv9 = (char *)(sizeof ( Song ) * mySongList -> balance); }
    {void * tlv15; tlv15 = (void *)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv14; tlv14 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv18; tlv18 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv16; tlv16 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {void * tlv20; tlv20 = (void *)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv19; tlv19 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv21; tlv21 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {cgc_size_t tlv24; tlv24 = (cgc_size_t)(sizeof ( Song ) * mySongList -> balance); }
    {int tlv23; tlv23 = (int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv26; tlv26 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv27; tlv27 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
    {unsigned int tlv29; tlv29 = (unsigned int)(sizeof ( Song ) * mySongList -> balance); }
}
void fix_ingred_service_15_20(){
fix_ingred_service_15_20_0();
}
void fix_ingred_service_15(){
fix_ingred_service_15_0();
fix_ingred_service_15_2();
fix_ingred_service_15_3();
fix_ingred_service_15_4();
fix_ingred_service_15_5();
fix_ingred_service_15_6();
fix_ingred_service_15_9();
fix_ingred_service_15_12();
fix_ingred_service_15_13();
fix_ingred_service_15_15();
fix_ingred_service_15_19();
fix_ingred_service_15_20();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_15_0_0();
void fix_ingred_service_15_0_1();
void fix_ingred_service_15_0_3();
void fix_ingred_service_15_0();
void fix_ingred_service_15_2_0();
void fix_ingred_service_15_2();
void fix_ingred_service_15_3_4();
void fix_ingred_service_15_3();
void fix_ingred_service_15_4_0();
void fix_ingred_service_15_4();
void fix_ingred_service_15_5_0();
void fix_ingred_service_15_5();
void fix_ingred_service_15_6_0();
void fix_ingred_service_15_6();
void fix_ingred_service_15_9_0();
void fix_ingred_service_15_9_1();
void fix_ingred_service_15_9();
void fix_ingred_service_15_12_0();
void fix_ingred_service_15_12();
void fix_ingred_service_15_13_0();
void fix_ingred_service_15_13();
void fix_ingred_service_15_15_0();
void fix_ingred_service_15_15();
void fix_ingred_service_15_19_0();
void fix_ingred_service_15_19();
void fix_ingred_service_15_20_0();
void fix_ingred_service_15_20();
void fix_ingred_service_15();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'results': 'SongList', 'request': 'Request'}'
val_s=>'[]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_service_16(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_16();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [main] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [main] : <class 'CParser.CParser.DeclarationContext'> : int starting_balance ;
def_vars[2]: [main] : <class 'CParser.CParser.DeclarationContext'> : SongList mySongList = { 0 , NULL , 0 } ;
def_vars[3]: [main] : <class 'CParser.CParser.DeclarationContext'> : SongList results = { 0 , NULL , 0 } ;
def_vars[4]: [main] : <class 'CParser.CParser.DeclarationContext'> : Request request = { 0 , 0 , 0 } ;
def_vars[5]: [main] : <class 'CParser.CParser.DeclarationContext'> : Song songs [ RESULT_LIMIT ] = { 0 } ;
def_vars[6]: [main] : <class 'CParser.CParser.DeclarationContext'> : Song * selectedSong ;
def_vars[7]: [main] : <class 'CParser.CParser.DeclarationContext'> : SongList * tlv1 ;
def_vars[8]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_getBalance ( tlv1 ) ;
def_vars[9]: [main] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[10]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[11]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_receiveBalance ( STDIN ) ;
def_vars[12]: [main] : <class 'CParser.CParser.DeclarationContext'> : Request * tlv4 ;
def_vars[13]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_createRandomRequest ( tlv4 ) ;
def_vars[14]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv6 ;
def_vars[15]: [main] : <class 'CParser.CParser.DeclarationContext'> : Request tlv5 ;
def_vars[16]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv9 ;
def_vars[17]: [main] : <class 'CParser.CParser.DeclarationContext'> : SongList * tlv8 ;
def_vars[18]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv7 ;
def_vars[19]: [main] : <class 'CParser.CParser.DeclarationContext'> : SongList tlv12 ;
def_vars[20]: [main] : <class 'CParser.CParser.DeclarationContext'> : Request tlv11 ;
def_vars[21]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv15 ;
def_vars[22]: [main] : <class 'CParser.CParser.DeclarationContext'> : Song * tlv14 ;
def_vars[23]: [main] : <class 'CParser.CParser.DeclarationContext'> : SongList * tlv13 ;
def_vars[24]: [main] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv10 ;
def_vars[25]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv10 ) ;
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>)]'
cval_s=>'[]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=0/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
unique : ('SongList', 'mySongList', None)
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=17/18][j=0/12][dd=1/26][k=0/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=1/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
Skipping RESULT_LIMIT => #define
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=8/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=9/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=17/18][j=0/12][dd=11/26][k=0/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=11/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=17/18][j=0/12][dd=13/26][k=0/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=13/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=15/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=17/18][j=0/12][dd=18/26][k=0/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=18/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=17/18][j=0/12][dd=21/26][k=0/5] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.balance' - False OR  False
[i=17/18][j=0/12][dd=21/26][k=4/5] | type: int ; var : starting_balance ; varinfo :  ; value_node : mySongList . balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,balance
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) balance [vtype=None]
----
UNIQ_INIT: ('SongList','mySongList','None','None');

----
UNIQ_INIT: ('SongList','mySongList','None','None');

==== Scope 1 ====
void fix_ingred_service_17_0_0(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
    {int starting_balance; starting_balance = (int)(0); }
    {int tlv6; tlv6 = (int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {int tlv15; tlv15 = (int)(0); }
    {unsigned int tlv10; tlv10 = (unsigned int)(0); }
}
void fix_ingred_service_17_0_4(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
    {int ret; ret = (int)(mySongList . balance); }
    {int starting_balance; starting_balance = (int)(mySongList . balance); }
    {void * tlv3; tlv3 = (void *)(mySongList . balance); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(mySongList . balance); }
    {int tlv6; tlv6 = (int)(mySongList . balance); }
    {int tlv9; tlv9 = (int)(mySongList . balance); }
    {int tlv7; tlv7 = (int)(mySongList . balance); }
    {int tlv15; tlv15 = (int)(mySongList . balance); }
    {unsigned int tlv10; tlv10 = (unsigned int)(mySongList . balance); }
}
void fix_ingred_service_17_0(){
fix_ingred_service_17_0_0();
fix_ingred_service_17_0_4();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *'}'
val_s=>'[('SongList *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb479d438>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>)]'
cval_s=>'[]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
Skipping RESULT_LIMIT => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *'}'
val_s=>'[('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
Skipping RESULT_LIMIT => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv4': 'Request *'}'
val_s=>'[('Request *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47ac048>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>), ('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
Skipping RESULT_LIMIT => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv4': 'Request *', 'tlv6': 'int', 'tlv5': 'Request'}'
val_s=>'[('int', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4799748>), ('Request', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a7668>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>), ('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=1/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
Skipping RESULT_LIMIT => #define
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=9/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=11/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=13/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=15/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=18/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=17/18][j=4/12][dd=21/26][k=0/10] | type: int ; var : tlv6 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
----
==== Scope 1 ====
void fix_ingred_service_17_4_0(){
    {int starting_balance; starting_balance = (int)(STDOUT); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDOUT); }
    {int tlv6; tlv6 = (int)(STDOUT); }
    {int tlv9; tlv9 = (int)(STDOUT); }
    {int tlv7; tlv7 = (int)(STDOUT); }
    {int tlv15; tlv15 = (int)(STDOUT); }
    {unsigned int tlv10; tlv10 = (unsigned int)(STDOUT); }
}
void fix_ingred_service_17_4(){
fix_ingred_service_17_4_0();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv4': 'Request *', 'tlv6': 'int', 'tlv5': 'Request', 'tlv9': 'int', 'tlv8': 'SongList *', 'tlv7': 'int'}'
val_s=>'[('int', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47823c8>), ('SongList *', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47753c8>), ('int', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a23c8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>), ('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=0/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=1/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=1/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
Skipping RESULT_LIMIT => #define
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=8/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=9/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=9/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=11/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=11/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=13/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=13/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=15/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=15/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=18/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=18/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=17/18][j=5/12][dd=21/26][k=0/11] | type: int ; var : tlv9 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [R] => '[False, False, False]'
has_multiptr_refs 'RESULT_LIMIT' - False OR  False
[i=17/18][j=5/12][dd=21/26][k=2/11] | type: int ; var : tlv7 ; varinfo :  ; value_node : RESULT_LIMIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : RESULT_LIMIT
 => is literal (False) | is operator (False) RESULT_LIMIT [vtype=None]
----
----
==== Scope 1 ====
void fix_ingred_service_17_5_0(){
    {int starting_balance; starting_balance = (int)(STDIN); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDIN); }
    {int tlv6; tlv6 = (int)(STDIN); }
    {int tlv9; tlv9 = (int)(STDIN); }
    {int tlv7; tlv7 = (int)(STDIN); }
    {int tlv15; tlv15 = (int)(STDIN); }
    {unsigned int tlv10; tlv10 = (unsigned int)(STDIN); }
}
void fix_ingred_service_17_5_2(){
    {int ret; ret = (int)(RESULT_LIMIT); }
    {int starting_balance; starting_balance = (int)(RESULT_LIMIT); }
    {void * tlv3; tlv3 = (void *)(RESULT_LIMIT); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(RESULT_LIMIT); }
    {int tlv6; tlv6 = (int)(RESULT_LIMIT); }
    {int tlv9; tlv9 = (int)(RESULT_LIMIT); }
    {int tlv7; tlv7 = (int)(RESULT_LIMIT); }
    {int tlv15; tlv15 = (int)(RESULT_LIMIT); }
    {unsigned int tlv10; tlv10 = (unsigned int)(RESULT_LIMIT); }
}
void fix_ingred_service_17_5(){
fix_ingred_service_17_5_0();
fix_ingred_service_17_5_2();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv4': 'Request *', 'tlv6': 'int', 'tlv5': 'Request', 'tlv9': 'int', 'tlv8': 'SongList *', 'tlv7': 'int', 'tlv12': 'SongList', 'tlv11': 'Request'}'
val_s=>'[('SongList', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47ad358>), ('Request', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb477f278>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>), ('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
Skipping RESULT_LIMIT => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv4': 'Request *', 'tlv6': 'int', 'tlv5': 'Request', 'tlv9': 'int', 'tlv8': 'SongList *', 'tlv7': 'int', 'tlv12': 'SongList', 'tlv11': 'Request', 'tlv15': 'int', 'tlv14': 'Song *', 'tlv13': 'SongList *'}'
val_s=>'[('int', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4785208>), ('Song *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4791208>), ('SongList *', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4788208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>), ('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
Skipping RESULT_LIMIT => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv4': 'Request *', 'tlv6': 'int', 'tlv5': 'Request', 'tlv9': 'int', 'tlv8': 'SongList *', 'tlv7': 'int', 'tlv12': 'SongList', 'tlv11': 'Request', 'tlv15': 'int', 'tlv14': 'Song *', 'tlv13': 'SongList *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>), ('UNDEF', 'results . size', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47a1e48>)]'
cval_s=>'[('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a12e8>), ('SongList', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14adb47a15f8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb47b10b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb47b1438>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=0/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=17/18][j=8/12][dd=1/26][k=8/10] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=1/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
Skipping RESULT_LIMIT => #define
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=8/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=9/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=17/18][j=8/12][dd=11/26][k=8/10] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=11/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=17/18][j=8/12][dd=13/26][k=8/10] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=13/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=15/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=17/18][j=8/12][dd=18/26][k=8/10] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=18/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=17/18][j=8/12][dd=21/26][k=8/10] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [L] => '[False, False, False]'
has_multiptr_refs 'LOW_BALANCE' - False OR  False
[i=17/18][j=8/12][dd=21/26][k=9/10] | type: int ; var :  ; varinfo :  ; value_node : LOW_BALANCE (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : LOW_BALANCE
 => is literal (False) | is operator (False) LOW_BALANCE [vtype=None]
----
UNIQ_INIT: ('int','ret','None','None');

----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_service_17_8_8(){
int ret;
    bzero(&ret,sizeof(int));
    {int starting_balance; starting_balance = (int)(ret); }
    {int tlv6; tlv6 = (int)(ret); }
    {int tlv9; tlv9 = (int)(ret); }
    {int tlv15; tlv15 = (int)(ret); }
    {unsigned int tlv10; tlv10 = (unsigned int)(ret); }
}
void fix_ingred_service_17_8_9(){
int ret;
    bzero(&ret,sizeof(int));
    {int ret; ret = (int)(LOW_BALANCE); }
    {int starting_balance; starting_balance = (int)(LOW_BALANCE); }
    {void * tlv3; tlv3 = (void *)(LOW_BALANCE); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(LOW_BALANCE); }
    {int tlv6; tlv6 = (int)(LOW_BALANCE); }
    {int tlv9; tlv9 = (int)(LOW_BALANCE); }
    {int tlv7; tlv7 = (int)(LOW_BALANCE); }
    {int tlv15; tlv15 = (int)(LOW_BALANCE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(LOW_BALANCE); }
}
void fix_ingred_service_17_8(){
fix_ingred_service_17_8_8();
fix_ingred_service_17_8_9();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb478b9e8>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4787908>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>)]'
cval_s=>'[]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=0/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
unique : ('SongList', 'mySongList', None)
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
unique : ('Song', 'songs [ RESULT_LIMIT ]', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=0/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
unique : ('int', 'starting_balance', None)
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=1/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=1/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
Skipping RESULT_LIMIT => #define
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=8/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=8/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=9/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=9/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=11/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=11/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=13/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=13/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=15/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=15/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=18/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=18/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
is_func_ [m] => '[False, False, False]'
has_multiptr_refs 'mySongList.songs' - False OR  False
[i=17/18][j=9/12][dd=21/26][k=0/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : mySongList . songs (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : mySongList,.,songs
 => is literal (False) | is operator (False) mySongList [vtype=SongList]
not unique: ('SongList', 'mySongList', None) ... continue!
 => is literal (False) | is operator (True) .
 => is literal (False) | is operator (False) songs [vtype=Song *]
BEFORE => literal (False) songs => Song *
AFTER => literal (False) songs [ RESULT_LIMIT ] => Song [size=RESULT_LIMIT]
Array size is variable => 'RESULT_LIMIT'
not unique: ('Song', 'songs [ RESULT_LIMIT ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Song)*starting_balance' - False OR  False
[i=17/18][j=9/12][dd=21/26][k=1/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Song ) * starting_balance (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Song,),*,starting_balance
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Song [vtype=None]
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (False) starting_balance [vtype=int]
not unique: ('int', 'starting_balance', None) ... continue!
----
UNIQ_INIT: ('SongList','mySongList','None','None');

UNIQ_INIT: ('Song','songs [ RESULT_LIMIT ]','None','None');

UNIQ_INIT: ('int','starting_balance','None','None');

not valid - int starting_balance; starting_balance = ((int)sizeof ( Song ) * starting_balance);

----
UNIQ_INIT: ('SongList','mySongList','None','None');

UNIQ_INIT: ('Song','songs [ RESULT_LIMIT ]','None','None');

UNIQ_INIT: ('int','starting_balance','None','None');

==== Scope 1 ====
void fix_ingred_service_17_9_0(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
Song songs [ RESULT_LIMIT ];
    bzero(&songs,( RESULT_LIMIT *sizeof(Song) ) );
int starting_balance;
    bzero(&starting_balance,sizeof(int));
    {int ret; ret = (int)(mySongList . songs); }
    {int starting_balance; starting_balance = (int)(mySongList . songs); }
    {void * tlv3; tlv3 = (void *)(mySongList . songs); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(mySongList . songs); }
    {int tlv6; tlv6 = (int)(mySongList . songs); }
    {int tlv9; tlv9 = (int)(mySongList . songs); }
    {int tlv7; tlv7 = (int)(mySongList . songs); }
    {int tlv15; tlv15 = (int)(mySongList . songs); }
    {unsigned int tlv10; tlv10 = (unsigned int)(mySongList . songs); }
}
void fix_ingred_service_17_9_1(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
Song songs [ RESULT_LIMIT ];
    bzero(&songs,( RESULT_LIMIT *sizeof(Song) ) );
int starting_balance;
    bzero(&starting_balance,sizeof(int));
    {int ret; ret = (int)(sizeof ( Song ) * starting_balance); }
    {void * tlv3; tlv3 = (void *)(sizeof ( Song ) * starting_balance); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( Song ) * starting_balance); }
    {int tlv6; tlv6 = (int)(sizeof ( Song ) * starting_balance); }
    {int tlv9; tlv9 = (int)(sizeof ( Song ) * starting_balance); }
    {int tlv7; tlv7 = (int)(sizeof ( Song ) * starting_balance); }
    {int tlv15; tlv15 = (int)(sizeof ( Song ) * starting_balance); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( Song ) * starting_balance); }
}
void fix_ingred_service_17_9(){
fix_ingred_service_17_9_0();
fix_ingred_service_17_9_1();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb47a6dd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4774198>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
Skipping RESULT_LIMIT => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'ret': 'int', 'starting_balance': 'int', 'mySongList': 'SongList', 'results': 'SongList', 'request': 'Request', 'songs': 'Song *', 'songs [ RESULT_LIMIT ]': 'Song', 'selectedSong': 'Song *', 'tlv1': 'SongList *', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv10': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4774f98>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436b048>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb436beb8>), ('Song *', 'selectedSong', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4370748>), ('UNDEF', 'results . songs', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb4371278>), ('int', 'starting_balance', '', <CParser.CParser.AssignmentExpressionContext object at 0x14adb47895f8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb47a6dd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14adb4774198>)]'
Checking 'cgc_getBalance( tlv1 )' - is_func=True, is_func_ptr=False
cgc_getBalance( tlv1 ) is a function.
Skipping.
Checking 'cgc_receiveBalance( STDIN )' - is_func=True, is_func_ptr=False
cgc_receiveBalance( STDIN ) is a function.
Skipping.
Checking 'cgc_createRandomRequest( tlv4 )' - is_func=True, is_func_ptr=False
cgc_createRandomRequest( tlv4 ) is a function.
Skipping.
Checking 'cgc__terminate( tlv10 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv10 ) is a function.
Skipping.
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=1/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
Skipping RESULT_LIMIT => #define
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=9/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=11/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=13/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=15/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=18/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
is_func_ [3] => '[False, False, False]'
has_multiptr_refs '3' - False OR  False
[i=17/18][j=11/12][dd=21/26][k=0/8] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : 3 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 3
 => is literal (True) | is operator (False) 3
----
==== Scope 1 ====
void fix_ingred_service_17_11_0(){
    {int starting_balance; starting_balance = (int)(3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(3); }
    {int tlv6; tlv6 = (int)(3); }
    {int tlv9; tlv9 = (int)(3); }
    {int tlv7; tlv7 = (int)(3); }
    {int tlv15; tlv15 = (int)(3); }
    {unsigned int tlv10; tlv10 = (unsigned int)(3); }
}
void fix_ingred_service_17_11(){
fix_ingred_service_17_11_0();
}

==== Scope 2 ====
void fix_ingred_service_17_0_0(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
    {int starting_balance; starting_balance = (int)(0); }
    {int tlv6; tlv6 = (int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {int tlv15; tlv15 = (int)(0); }
    {unsigned int tlv10; tlv10 = (unsigned int)(0); }
}
void fix_ingred_service_17_0_4(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
    {int ret; ret = (int)(mySongList . balance); }
    {int starting_balance; starting_balance = (int)(mySongList . balance); }
    {void * tlv3; tlv3 = (void *)(mySongList . balance); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(mySongList . balance); }
    {int tlv6; tlv6 = (int)(mySongList . balance); }
    {int tlv9; tlv9 = (int)(mySongList . balance); }
    {int tlv7; tlv7 = (int)(mySongList . balance); }
    {int tlv15; tlv15 = (int)(mySongList . balance); }
    {unsigned int tlv10; tlv10 = (unsigned int)(mySongList . balance); }
}
void fix_ingred_service_17_0(){
fix_ingred_service_17_0_0();
fix_ingred_service_17_0_4();
}
void fix_ingred_service_17_4_0(){
    {int starting_balance; starting_balance = (int)(STDOUT); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDOUT); }
    {int tlv6; tlv6 = (int)(STDOUT); }
    {int tlv9; tlv9 = (int)(STDOUT); }
    {int tlv7; tlv7 = (int)(STDOUT); }
    {int tlv15; tlv15 = (int)(STDOUT); }
    {unsigned int tlv10; tlv10 = (unsigned int)(STDOUT); }
}
void fix_ingred_service_17_4(){
fix_ingred_service_17_4_0();
}
void fix_ingred_service_17_5_0(){
    {int starting_balance; starting_balance = (int)(STDIN); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDIN); }
    {int tlv6; tlv6 = (int)(STDIN); }
    {int tlv9; tlv9 = (int)(STDIN); }
    {int tlv7; tlv7 = (int)(STDIN); }
    {int tlv15; tlv15 = (int)(STDIN); }
    {unsigned int tlv10; tlv10 = (unsigned int)(STDIN); }
}
void fix_ingred_service_17_5_2(){
    {int ret; ret = (int)(RESULT_LIMIT); }
    {int starting_balance; starting_balance = (int)(RESULT_LIMIT); }
    {void * tlv3; tlv3 = (void *)(RESULT_LIMIT); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(RESULT_LIMIT); }
    {int tlv6; tlv6 = (int)(RESULT_LIMIT); }
    {int tlv9; tlv9 = (int)(RESULT_LIMIT); }
    {int tlv7; tlv7 = (int)(RESULT_LIMIT); }
    {int tlv15; tlv15 = (int)(RESULT_LIMIT); }
    {unsigned int tlv10; tlv10 = (unsigned int)(RESULT_LIMIT); }
}
void fix_ingred_service_17_5(){
fix_ingred_service_17_5_0();
fix_ingred_service_17_5_2();
}
void fix_ingred_service_17_8_8(){
int ret;
    bzero(&ret,sizeof(int));
    {int starting_balance; starting_balance = (int)(ret); }
    {int tlv6; tlv6 = (int)(ret); }
    {int tlv9; tlv9 = (int)(ret); }
    {int tlv15; tlv15 = (int)(ret); }
    {unsigned int tlv10; tlv10 = (unsigned int)(ret); }
}
void fix_ingred_service_17_8_9(){
int ret;
    bzero(&ret,sizeof(int));
    {int ret; ret = (int)(LOW_BALANCE); }
    {int starting_balance; starting_balance = (int)(LOW_BALANCE); }
    {void * tlv3; tlv3 = (void *)(LOW_BALANCE); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(LOW_BALANCE); }
    {int tlv6; tlv6 = (int)(LOW_BALANCE); }
    {int tlv9; tlv9 = (int)(LOW_BALANCE); }
    {int tlv7; tlv7 = (int)(LOW_BALANCE); }
    {int tlv15; tlv15 = (int)(LOW_BALANCE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(LOW_BALANCE); }
}
void fix_ingred_service_17_8(){
fix_ingred_service_17_8_8();
fix_ingred_service_17_8_9();
}
void fix_ingred_service_17_9_0(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
Song songs [ RESULT_LIMIT ];
    bzero(&songs,( RESULT_LIMIT *sizeof(Song) ) );
int starting_balance;
    bzero(&starting_balance,sizeof(int));
    {int ret; ret = (int)(mySongList . songs); }
    {int starting_balance; starting_balance = (int)(mySongList . songs); }
    {void * tlv3; tlv3 = (void *)(mySongList . songs); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(mySongList . songs); }
    {int tlv6; tlv6 = (int)(mySongList . songs); }
    {int tlv9; tlv9 = (int)(mySongList . songs); }
    {int tlv7; tlv7 = (int)(mySongList . songs); }
    {int tlv15; tlv15 = (int)(mySongList . songs); }
    {unsigned int tlv10; tlv10 = (unsigned int)(mySongList . songs); }
}
void fix_ingred_service_17_9_1(){
SongList mySongList;
    bzero(&mySongList,sizeof(SongList));
Song songs [ RESULT_LIMIT ];
    bzero(&songs,( RESULT_LIMIT *sizeof(Song) ) );
int starting_balance;
    bzero(&starting_balance,sizeof(int));
    {int ret; ret = (int)(sizeof ( Song ) * starting_balance); }
    {void * tlv3; tlv3 = (void *)(sizeof ( Song ) * starting_balance); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(sizeof ( Song ) * starting_balance); }
    {int tlv6; tlv6 = (int)(sizeof ( Song ) * starting_balance); }
    {int tlv9; tlv9 = (int)(sizeof ( Song ) * starting_balance); }
    {int tlv7; tlv7 = (int)(sizeof ( Song ) * starting_balance); }
    {int tlv15; tlv15 = (int)(sizeof ( Song ) * starting_balance); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( Song ) * starting_balance); }
}
void fix_ingred_service_17_9(){
fix_ingred_service_17_9_0();
fix_ingred_service_17_9_1();
}
void fix_ingred_service_17_11_0(){
    {int starting_balance; starting_balance = (int)(3); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(3); }
    {int tlv6; tlv6 = (int)(3); }
    {int tlv9; tlv9 = (int)(3); }
    {int tlv7; tlv7 = (int)(3); }
    {int tlv15; tlv15 = (int)(3); }
    {unsigned int tlv10; tlv10 = (unsigned int)(3); }
}
void fix_ingred_service_17_11(){
fix_ingred_service_17_11_0();
}
void fix_ingred_service_17(){
fix_ingred_service_17_0();
fix_ingred_service_17_4();
fix_ingred_service_17_5();
fix_ingred_service_17_8();
fix_ingred_service_17_9();
fix_ingred_service_17_11();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_service_17_0_0();
void fix_ingred_service_17_0_4();
void fix_ingred_service_17_0();
void fix_ingred_service_17_4_0();
void fix_ingred_service_17_4();
void fix_ingred_service_17_5_0();
void fix_ingred_service_17_5_2();
void fix_ingred_service_17_5();
void fix_ingred_service_17_8_8();
void fix_ingred_service_17_8_9();
void fix_ingred_service_17_8();
void fix_ingred_service_17_9_0();
void fix_ingred_service_17_9_1();
void fix_ingred_service_17_9();
void fix_ingred_service_17_11_0();
void fix_ingred_service_17_11();
void fix_ingred_service_17();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_service_0_0_0
- fix_ingred_service_0_0_1
- fix_ingred_service_0_0_3
- fix_ingred_service_0_0_4
- fix_ingred_service_0_0
- fix_ingred_service_0_1_5
- fix_ingred_service_0_1_6
- fix_ingred_service_0_1_7
- fix_ingred_service_0_1_8
- fix_ingred_service_0_1
- fix_ingred_service_0_2_0
- fix_ingred_service_0_2_1
- fix_ingred_service_0_2_2
- fix_ingred_service_0_2
- fix_ingred_service_0
- fix_ingred_service_1_0_0
- fix_ingred_service_1_0_2
- fix_ingred_service_1_0_4
- fix_ingred_service_1_0_7
- fix_ingred_service_1_0_8
- fix_ingred_service_1_0
- fix_ingred_service_1_1_10
- fix_ingred_service_1_1_11
- fix_ingred_service_1_1_12
- fix_ingred_service_1_1_13
- fix_ingred_service_1_1
- fix_ingred_service_1_2_0
- fix_ingred_service_1_2_1
- fix_ingred_service_1_2_2
- fix_ingred_service_1_2
- fix_ingred_service_1_4_10
- fix_ingred_service_1_4
- fix_ingred_service_1_5_0
- fix_ingred_service_1_5_1
- fix_ingred_service_1_5
- fix_ingred_service_1
- fix_ingred_service_2_0_0
- fix_ingred_service_2_0_2
- fix_ingred_service_2_0_4
- fix_ingred_service_2_0_7
- fix_ingred_service_2_0_8
- fix_ingred_service_2_0
- fix_ingred_service_2_1_10
- fix_ingred_service_2_1_11
- fix_ingred_service_2_1_12
- fix_ingred_service_2_1_13
- fix_ingred_service_2_1
- fix_ingred_service_2_2_0
- fix_ingred_service_2_2_1
- fix_ingred_service_2_2_2
- fix_ingred_service_2_2
- fix_ingred_service_2_4_10
- fix_ingred_service_2_4
- fix_ingred_service_2_5_0
- fix_ingred_service_2_5_1
- fix_ingred_service_2_5
- fix_ingred_service_2_7_12
- fix_ingred_service_2_7_15
- fix_ingred_service_2_7
- fix_ingred_service_2
- fix_ingred_service_3_0_0
- fix_ingred_service_3_0_2
- fix_ingred_service_3_0_4
- fix_ingred_service_3_0_6
- fix_ingred_service_3_0
- fix_ingred_service_3_1_0
- fix_ingred_service_3_1_2
- fix_ingred_service_3_1
- fix_ingred_service_3_2_0
- fix_ingred_service_3_2
- fix_ingred_service_3_3_9
- fix_ingred_service_3_3_10
- fix_ingred_service_3_3_11
- fix_ingred_service_3_3_12
- fix_ingred_service_3_3
- fix_ingred_service_3_4_0
- fix_ingred_service_3_4_1
- fix_ingred_service_3_4_2
- fix_ingred_service_3_4
- fix_ingred_service_3_6_9
- fix_ingred_service_3_6
- fix_ingred_service_3_7_0
- fix_ingred_service_3_7_1
- fix_ingred_service_3_7
- fix_ingred_service_3_10_9
- fix_ingred_service_3_10
- fix_ingred_service_3_11_1
- fix_ingred_service_3_11
- fix_ingred_service_3_14_9
- fix_ingred_service_3_14
- fix_ingred_service_3_15_1
- fix_ingred_service_3_15
- fix_ingred_service_3_18_9
- fix_ingred_service_3_18
- fix_ingred_service_3_19_1
- fix_ingred_service_3_19
- fix_ingred_service_3_22_9
- fix_ingred_service_3_22
- fix_ingred_service_3_23_1
- fix_ingred_service_3_23
- fix_ingred_service_3_25_2
- fix_ingred_service_3_25
- fix_ingred_service_3
- fix_ingred_service_4_0_0
- fix_ingred_service_4_0
- fix_ingred_service_4_1_0
- fix_ingred_service_4_1_1
- fix_ingred_service_4_1_2
- fix_ingred_service_4_1
- fix_ingred_service_4_2_2
- fix_ingred_service_4_2
- fix_ingred_service_4_3_0
- fix_ingred_service_4_3
- fix_ingred_service_4
- fix_ingred_service_5_1_0
- fix_ingred_service_5_1_1
- fix_ingred_service_5_1_2
- fix_ingred_service_5_1
- fix_ingred_service_5_2_2
- fix_ingred_service_5_2
- fix_ingred_service_5_3_0
- fix_ingred_service_5_3
- fix_ingred_service_5_6_2
- fix_ingred_service_5_6
- fix_ingred_service_5
- fix_ingred_service_6_0_0
- fix_ingred_service_6_0
- fix_ingred_service_6_1_0
- fix_ingred_service_6_1
- fix_ingred_service_6_3_1
- fix_ingred_service_6_3_2
- fix_ingred_service_6_3
- fix_ingred_service_6_4_3
- fix_ingred_service_6_4
- fix_ingred_service_6_5_0
- fix_ingred_service_6_5
- fix_ingred_service_6_9_5
- fix_ingred_service_6_9
- fix_ingred_service_6_10_0
- fix_ingred_service_6_10
- fix_ingred_service_6
- fix_ingred_service_7_0_0
- fix_ingred_service_7_0_1
- fix_ingred_service_7_0
- fix_ingred_service_7_1_0
- fix_ingred_service_7_1
- fix_ingred_service_7_2_2
- fix_ingred_service_7_2
- fix_ingred_service_7_3_0
- fix_ingred_service_7_3
- fix_ingred_service_7_4_0
- fix_ingred_service_7_4
- fix_ingred_service_7_5_0
- fix_ingred_service_7_5
- fix_ingred_service_7
- fix_ingred_service_8_0_0
- fix_ingred_service_8_0_1
- fix_ingred_service_8_0_2
- fix_ingred_service_8_0_3
- fix_ingred_service_8_0_4
- fix_ingred_service_8_0
- fix_ingred_service_8_1_0
- fix_ingred_service_8_1_1
- fix_ingred_service_8_1
- fix_ingred_service_8_2_3
- fix_ingred_service_8_2
- fix_ingred_service_8_3_0
- fix_ingred_service_8_3
- fix_ingred_service_8_4_4
- fix_ingred_service_8_4_5
- fix_ingred_service_8_4
- fix_ingred_service_8_5_0
- fix_ingred_service_8_5
- fix_ingred_service_8
- fix_ingred_service_9_0_0
- fix_ingred_service_9_0
- fix_ingred_service_9_1_0
- fix_ingred_service_9_1
- fix_ingred_service_9_2_0
- fix_ingred_service_9_2_1
- fix_ingred_service_9_2
- fix_ingred_service_9_3_0
- fix_ingred_service_9_3
- fix_ingred_service_9
- fix_ingred_service_10_0_0
- fix_ingred_service_10_0_2
- fix_ingred_service_10_0
- fix_ingred_service_10_1_3
- fix_ingred_service_10_1
- fix_ingred_service_10_2_0
- fix_ingred_service_10_2
- fix_ingred_service_10_3_0
- fix_ingred_service_10_3
- fix_ingred_service_10_4_5
- fix_ingred_service_10_4_6
- fix_ingred_service_10_4
- fix_ingred_service_10_5_0
- fix_ingred_service_10_5
- fix_ingred_service_10
- fix_ingred_service_11_1_0
- fix_ingred_service_11_1_1
- fix_ingred_service_11_1_2
- fix_ingred_service_11_1
- fix_ingred_service_11_2_0
- fix_ingred_service_11_2_1
- fix_ingred_service_11_2_2
- fix_ingred_service_11_2
- fix_ingred_service_11
- fix_ingred_service_12_0_0
- fix_ingred_service_12_0_1
- fix_ingred_service_12_0
- fix_ingred_service_12_1_0
- fix_ingred_service_12_1
- fix_ingred_service_12_2_4
- fix_ingred_service_12_2
- fix_ingred_service_12_3_0
- fix_ingred_service_12_3
- fix_ingred_service_12_4_0
- fix_ingred_service_12_4_2
- fix_ingred_service_12_4
- fix_ingred_service_12_5_0
- fix_ingred_service_12_5
- fix_ingred_service_12_6_6
- fix_ingred_service_12_6_7
- fix_ingred_service_12_6
- fix_ingred_service_12_7_0
- fix_ingred_service_12_7
- fix_ingred_service_12
- fix_ingred_service_13_0_0
- fix_ingred_service_13_0_1
- fix_ingred_service_13_0
- fix_ingred_service_13_3_1
- fix_ingred_service_13_3_2
- fix_ingred_service_13_3
- fix_ingred_service_13_4_0
- fix_ingred_service_13_4
- fix_ingred_service_13_5_0
- fix_ingred_service_13_5
- fix_ingred_service_13_6_5
- fix_ingred_service_13_6
- fix_ingred_service_13_7_0
- fix_ingred_service_13_7
- fix_ingred_service_13_9_0
- fix_ingred_service_13_9
- fix_ingred_service_13
- fix_ingred_service_14_0_0
- fix_ingred_service_14_0_1
- fix_ingred_service_14_0
- fix_ingred_service_14_2_0
- fix_ingred_service_14_2
- fix_ingred_service_14_3_0
- fix_ingred_service_14_3
- fix_ingred_service_14_4_2
- fix_ingred_service_14_4
- fix_ingred_service_14_5_0
- fix_ingred_service_14_5
- fix_ingred_service_14
- fix_ingred_service_15_0_0
- fix_ingred_service_15_0_1
- fix_ingred_service_15_0_3
- fix_ingred_service_15_0
- fix_ingred_service_15_2_0
- fix_ingred_service_15_2
- fix_ingred_service_15_3_4
- fix_ingred_service_15_3
- fix_ingred_service_15_4_0
- fix_ingred_service_15_4
- fix_ingred_service_15_5_0
- fix_ingred_service_15_5
- fix_ingred_service_15_6_0
- fix_ingred_service_15_6
- fix_ingred_service_15_9_0
- fix_ingred_service_15_9_1
- fix_ingred_service_15_9
- fix_ingred_service_15_12_0
- fix_ingred_service_15_12
- fix_ingred_service_15_13_0
- fix_ingred_service_15_13
- fix_ingred_service_15_15_0
- fix_ingred_service_15_15
- fix_ingred_service_15_19_0
- fix_ingred_service_15_19
- fix_ingred_service_15_20_0
- fix_ingred_service_15_20
- fix_ingred_service_15
- fix_ingred_service_16
- fix_ingred_service_17_0_0
- fix_ingred_service_17_0_4
- fix_ingred_service_17_0
- fix_ingred_service_17_4_0
- fix_ingred_service_17_4
- fix_ingred_service_17_5_0
- fix_ingred_service_17_5_2
- fix_ingred_service_17_5
- fix_ingred_service_17_8_8
- fix_ingred_service_17_8_9
- fix_ingred_service_17_8
- fix_ingred_service_17_9_0
- fix_ingred_service_17_9_1
- fix_ingred_service_17_9
- fix_ingred_service_17_11_0
- fix_ingred_service_17_11
- fix_ingred_service_17
