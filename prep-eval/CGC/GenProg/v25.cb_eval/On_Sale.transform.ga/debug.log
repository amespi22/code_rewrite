[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBE'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x0E'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBE'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x0E'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xC4'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xEC'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x4E'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xEE'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xAD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xDD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xAD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xDD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xDE'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xAD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xDE'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xAD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x04'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xD4'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x7E'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x00'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x54'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x13'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x54'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x13'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x0F'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x0F'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x0F'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x0F'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x11'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x44'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x11'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\x44'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xFF'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xFF'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xFF'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xFF'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 2
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xED'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\0'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBB'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBB'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBB'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBB'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 4
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : '\xBD'
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 0
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static unsigned int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_next_update_serial ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int base'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [base] = unsigned int 
var: base (base) = * ( unsigned int * ) FLAG_PAGE
var: unsigned int base (base) = * ( unsigned int * ) FLAG_PAGE
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int next_update_serial'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [next_update_serial] = unsigned int 
var: next_update_serial (next_update_serial) = base + cgc_update_serial
var: unsigned int next_update_serial (next_update_serial) = base + cgc_update_serial
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; }
Assigns = [('unsigned int', 'base', '', '* ( unsigned int * ) FLAG_PAGE'), ('unsigned int', 'next_update_serial', '', 'base + cgc_update_serial')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static unsigned int cgc_get_next_update_serial ( void ) { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static unsigned char'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_prod_has_bc ( const void * product , void * barcode )')]
ParameterDeclaration : type = const void *, var = product [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['product']
[enterParameterDeclaration] const void * : product
sym_dict [product] = const void * 
ParameterDeclaration : type = void *, var = barcode [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['barcode']
[enterParameterDeclaration] void * : barcode
sym_dict [barcode] = void * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = ( Product * ) product
var: Product * p (p) = ( Product * ) product
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned char * bc'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bc] = unsigned char * 
var: bc (bc) = ( unsigned char * ) barcode
var: unsigned char * bc (bc) = ( unsigned char * ) barcode
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * 
var: tlv4 (tlv4) = p -> barcode
var: void * tlv4 (tlv4) = p -> barcode
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = bc
var: void * tlv3 (tlv3) = bc
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = unsigned int 
var: tlv2 (tlv2) = BARCODE_SZ
var: unsigned int tlv2 (tlv2) = BARCODE_SZ
var: tlv1 (tlv1) = cgc_memcmp ( tlv4 , tlv3 , tlv2 )
var: int tlv1 (tlv1) = cgc_memcmp ( tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('void *', 'tlv4', '', 'p -> barcode'), ('void *', 'tlv3', '', 'bc'), ('unsigned int', 'tlv2', '', 'BARCODE_SZ'), ('int', 'tlv1', '', 'cgc_memcmp ( tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv1
=> ['0', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return TRUE ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv1 ) { return TRUE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return TRUE ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv1 ) { return TRUE ; } ]
Assigns = [('Product *', 'p', '', '( Product * ) product'), ('unsigned char *', 'bc', '', '( unsigned char * ) barcode')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static unsigned char cgc_prod_has_bc ( const void * product , void * barcode ) { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static Product *'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_get_product_by_barcode ( char bc [ ] )')]
ParameterDeclaration : type = char, var = bc [ ] [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['bc [ ]']
[enterParameterDeclaration] char : bc [ ]
sym_dict [bc] = char * 
sym_dict [bc [ ]] = char 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * np'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [np] = struct node * 
var: np (np) = NULL
var: struct node * np (np) = NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = struct list * 
var: tlv3 (tlv3) = & inv
var: struct list * tlv3 (tlv3) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned char * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = unsigned char * 
var: tlv2 (tlv2) = cgc_prod_has_bc
var: unsigned char * tlv2 (tlv2) = cgc_prod_has_bc
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = void * 
var: tlv1 (tlv1) = ( void * ) bc
var: void * tlv1 (tlv1) = ( void * ) bc
var: np (np) = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 )
var: struct node * np (np) = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('struct list *', 'tlv3', '', '& inv'), ('unsigned char *', 'tlv2', '', 'cgc_prod_has_bc'), ('void *', 'tlv1', '', '( void * ) bc'), ('struct node *', 'np', '', 'cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == np
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => np
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == np
=> ['NULL', 'np']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : np
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['np']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['np']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['np']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['np']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['np']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['np']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['np']
FOUND IT! [2.2]  struct node * : np
Resolved type: [2.3]  struct node * : np
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == np ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return NULL ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == np ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return NULL ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( Product * ) np -> data ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return NULL ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( Product * ) np -> data ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } ]
Assigns = [('struct node *', 'np', '', 'NULL')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static Product * cgc_get_product_by_barcode ( char bc [ ] ) { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_buy ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p_copy'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p_copy] = Product * 
var: p_copy (p_copy) = NULL
var: Product * p_copy (p_copy) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buy_status [ 4 ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buy_status] = char * 
[C-t-3] sym_dict [buy_status [ 4 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'bc [ BARCODE_SZ ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [bc] = char * 
[C-t-3] sym_dict [bc [ BARCODE_SZ ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'double cost'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [cost] = double 
var: cost (cost) = 0.0
var: double cost (cost) = 0.0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list buy_list'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [buy_list] = struct list 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = struct list * 
var: tlv3 (tlv3) = & buy_list
var: struct list * tlv3 (tlv3) = & buy_list
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'nodeDataFreeFn'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv2 = cgc_free'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = nodeDataFreeFn 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; }
Assigns = [('struct list *', 'tlv3', '', '& buy_list')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned long tlv_size_0'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv_size_0] = unsigned long 
var: tlv_size_0 (tlv_size_0) = sizeof ( BUY_MORE )
var: unsigned long tlv_size_0 (tlv_size_0) = sizeof ( BUY_MORE )
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )
=> ['0', 'cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 )']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ArgumentExpressionListContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['cgc_memcmp', '(', 'buy_status , ( void * ) BUY_MORE , tlv_size_0', ')']
Resolved type: [2.3]  UNDEF : cgc_memcmp
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = char * * 
var: tlv14 (tlv14) = bc
var: char * * tlv14 (tlv14) = bc
var: p (p) = cgc_get_product_by_barcode ( tlv14 )
var: Product * p (p) = cgc_get_product_by_barcode ( tlv14 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; }
Assigns = [('char * *', 'tlv14', '', 'bc'), ('Product *', 'p', '', 'cgc_get_product_by_barcode ( tlv14 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => p
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
=> ['NULL', 'p']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : p
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['p']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [2.2]  Product * : p
Resolved type: [2.3]  Product * : p
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == p ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = struct list * 
var: tlv16 (tlv16) = & buy_list
var: struct list * tlv16 (tlv16) = & buy_list
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_list_destroy'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv16 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; }
Assigns = [('struct list *', 'tlv16', '', '& buy_list')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = cgc_size_t 
var: tlv15 (tlv15) = sizeof ( Product )
var: cgc_size_t tlv15 (tlv15) = sizeof ( Product )
var: p_copy (p_copy) = cgc_malloc ( tlv15 )
var: Product * p_copy (p_copy) = cgc_malloc ( tlv15 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; }
Assigns = [('cgc_size_t', 'tlv15', '', 'sizeof ( Product )'), ('Product *', 'p_copy', '', 'cgc_malloc ( tlv15 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'MALLOC_OK'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( p_copy )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = void * 
var: tlv10 (tlv10) = p_copy
var: void * tlv10 (tlv10) = p_copy
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = void * 
var: tlv9 (tlv9) = p
var: void * tlv9 (tlv9) = p
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = unsigned int 
var: tlv8 (tlv8) = sizeof ( Product )
var: unsigned int tlv8 (tlv8) = sizeof ( Product )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }
Assigns = [('void *', 'tlv10', '', 'p_copy'), ('void *', 'tlv9', '', 'p'), ('unsigned int', 'tlv8', '', 'sizeof ( Product )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = struct list * 
var: tlv12 (tlv12) = & buy_list
var: struct list * tlv12 (tlv12) = & buy_list
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = void * 
var: tlv11 (tlv11) = p_copy
var: void * tlv11 (tlv11) = p_copy
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }
Assigns = [('struct list *', 'tlv12', '', '& buy_list'), ('void *', 'tlv11', '', 'p_copy')]
Compares = []
var: cost (cost) = p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )
var: double cost (cost) = p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } ]
Assigns = [('double', 'cost', '', 'p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = void * 
var: tlv7 (tlv7) = buy_status
var: void * tlv7 (tlv7) = buy_status
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = void * 
var: tlv6 (tlv6) = ( void * ) BUY_TERM
var: void * tlv6 (tlv6) = ( void * ) BUY_TERM
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = sizeof ( BUY_TERM )
var: unsigned int tlv5 (tlv5) = sizeof ( BUY_TERM )
var: tlv1 (tlv1) = cgc_memcmp ( tlv7 , tlv6 , tlv5 )
var: int tlv1 (tlv1) = cgc_memcmp ( tlv7 , tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }
Assigns = [('void *', 'tlv7', '', 'buy_status'), ('void *', 'tlv6', '', '( void * ) BUY_TERM'), ('unsigned int', 'tlv5', '', 'sizeof ( BUY_TERM )'), ('int', 'tlv1', '', 'cgc_memcmp ( tlv7 , tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 != tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 != tlv1
=> ['0', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 != tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = struct list * 
var: tlv13 (tlv13) = & buy_list
var: struct list * tlv13 (tlv13) = & buy_list
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_list_destroy'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv13 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; }
Assigns = [('struct list *', 'tlv13', '', '& buy_list')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = struct list * 
var: tlv4 (tlv4) = & buy_list
var: struct list * tlv4 (tlv4) = & buy_list
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_list_destroy'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }
Assigns = [('struct list *', 'tlv4', '', '& buy_list')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_buy ( void ) { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_check ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'bc [ BARCODE_SZ ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [bc] = char * 
[C-t-3] sym_dict [bc [ BARCODE_SZ ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'float sale_price'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [sale_price] = float 
var: sale_price (sale_price) = 0.0
var: float sale_price (sale_price) = 0.0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int d_len'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [d_len] = unsigned int 
var: d_len (d_len) = 0
var: unsigned int d_len (d_len) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = char * * 
var: tlv1 (tlv1) = bc
var: char * * tlv1 (tlv1) = bc
var: p (p) = cgc_get_product_by_barcode ( tlv1 )
var: Product * p (p) = cgc_get_product_by_barcode ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
Assigns = [('char * *', 'tlv1', '', 'bc'), ('Product *', 'p', '', 'cgc_get_product_by_barcode ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => p
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
=> ['NULL', 'p']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : p
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['p']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [2.2]  Product * : p
Resolved type: [2.3]  Product * : p
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == p ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == p ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
var: sale_price (sale_price) = p -> sfn ( p -> model_num , p -> cost )
var: float sale_price (sale_price) = p -> sfn ( p -> model_num , p -> cost )
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 = p -> desc'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char 
var: tlv2 (tlv2) = '\0'
var: char tlv2 (tlv2) = '\0'
var: d_len (d_len) = cgc_strlen ( tlv3 , tlv2 )
var: unsigned int d_len (d_len) = cgc_strlen ( tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; }
Assigns = [('char', 'tlv2', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 < d_len
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => d_len
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 < d_len
=> ['0', 'd_len']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : d_len
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['d_len']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['d_len']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['d_len']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['d_len']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['d_len']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['d_len']
FOUND IT! [1.2]  unsigned int : d_len
Resolved type: [1.3]  unsigned int : d_len
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 < d_len ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SEND ( STDOUT , p -> desc , d_len ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SEND ( STDOUT , p -> desc , d_len ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == p ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_check ( void ) { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_add ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p2] = Product * 
var: p2 (p2) = NULL
var: Product * p2 (p2) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int bytes_recvd'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_recvd] = int 
var: bytes_recvd (bytes_recvd) = 0
var: int bytes_recvd (bytes_recvd) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
var: tlv3 (tlv3) = sizeof ( Product )
var: cgc_size_t tlv3 (tlv3) = sizeof ( Product )
var: p (p) = cgc_malloc ( tlv3 )
var: Product * p (p) = cgc_malloc ( tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'cgc_malloc ( tlv3 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'MALLOC_OK'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( p )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
var: p -> sfn (p -> sfn) = onsale_fn [ 0 ]
var: UNDEF p -> sfn (p -> sfn) = onsale_fn [ 0 ]
var: p -> update_serial (p -> update_serial) = 0
var: UNDEF p -> update_serial (p -> update_serial) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = char * * 
var: tlv4 (tlv4) = ( char * ) p -> barcode
var: char * * tlv4 (tlv4) = ( char * ) p -> barcode
var: p2 (p2) = cgc_get_product_by_barcode ( tlv4 )
var: Product * p2 (p2) = cgc_get_product_by_barcode ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; }
Assigns = [('char * *', 'tlv4', '', '( char * ) p -> barcode'), ('Product *', 'p2', '', 'cgc_get_product_by_barcode ( tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL != p2
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => p2
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL != p2
=> ['NULL', 'p2']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : p2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['p2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p2']
FOUND IT! [2.2]  Product * : p2
Resolved type: [2.3]  Product * : p2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL != p2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_free'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( p )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_free ( p ) ; return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_free ( p ) ; return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = int 
var: tlv8 (tlv8) = STDIN
var: int tlv8 (tlv8) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char 
var: tlv7 (tlv7) = DESC_TERM [ 0 ]
var: char tlv7 (tlv7) = DESC_TERM [ 0 ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = char * 
var: tlv6 (tlv6) = ( char * ) p -> desc
var: char * tlv6 (tlv6) = ( char * ) p -> desc
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = sizeof ( Product )
var: unsigned int tlv5 (tlv5) = sizeof ( Product )
var: bytes_recvd (bytes_recvd) = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 )
var: int bytes_recvd (bytes_recvd) = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; }
Assigns = [('int', 'tlv8', '', 'STDIN'), ('char', 'tlv7', '', 'DESC_TERM [ 0 ]'), ('char *', 'tlv6', '', '( char * ) p -> desc'), ('unsigned int', 'tlv5', '', 'sizeof ( Product )'), ('int', 'bytes_recvd', '', 'cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 >= bytes_recvd
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_recvd
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 >= bytes_recvd
=> ['0', 'bytes_recvd']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_recvd
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_recvd']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_recvd']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_recvd']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_recvd']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_recvd']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_recvd']
FOUND IT! [1.2]  int : bytes_recvd
Resolved type: [1.3]  int : bytes_recvd
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 >= bytes_recvd ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( ERRNO_RECV )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc__terminate ( ERRNO_RECV ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc__terminate ( ERRNO_RECV ) ; } ]
var: p -> desc  (p -> desc [ bytes_recvd - 1 ]) = '\0'
var: UNDEF p -> desc  (p -> desc [ bytes_recvd - 1 ]) = '\0'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = struct list * 
var: tlv2 (tlv2) = & inv
var: struct list * tlv2 (tlv2) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = void * 
var: tlv1 (tlv1) = p
var: void * tlv1 (tlv1) = p
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }
Assigns = [('struct list *', 'tlv2', '', '& inv'), ('void *', 'tlv1', '', 'p')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0'), ('UNDEF', 'p -> desc ', '[ bytes_recvd - 1 ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_add ( void ) { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_rm ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'bc [ BARCODE_SZ ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [bc] = char * 
[C-t-3] sym_dict [bc [ BARCODE_SZ ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * np'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [np] = struct node * 
var: np (np) = NULL
var: struct node * np (np) = NULL
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = struct list * 
var: tlv7 (tlv7) = & inv
var: struct list * tlv7 (tlv7) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned char * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = unsigned char * 
var: tlv6 (tlv6) = cgc_prod_has_bc
var: unsigned char * tlv6 (tlv6) = cgc_prod_has_bc
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = void * 
var: tlv5 (tlv5) = ( void * ) bc
var: void * tlv5 (tlv5) = ( void * ) bc
var: np (np) = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 )
var: struct node * np (np) = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; }
Assigns = [('struct list *', 'tlv7', '', '& inv'), ('unsigned char *', 'tlv6', '', 'cgc_prod_has_bc'), ('void *', 'tlv5', '', '( void * ) bc'), ('struct node *', 'np', '', 'cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == np
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => np
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == np
=> ['NULL', 'np']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : np
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['np']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['np']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['np']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['np']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['np']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['np']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['np']
FOUND IT! [2.2]  struct node * : np
Resolved type: [2.3]  struct node * : np
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == np ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == np ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = struct list * 
var: tlv2 (tlv2) = & inv
var: struct list * tlv2 (tlv2) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = struct node * 
var: tlv1 (tlv1) = np
var: struct node * tlv1 (tlv1) = np
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; }
Assigns = [('struct list *', 'tlv2', '', '& inv'), ('struct node *', 'tlv1', '', 'np')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = struct list * 
var: tlv4 (tlv4) = & inv
var: struct list * tlv4 (tlv4) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = struct node * * 
var: tlv3 (tlv3) = & np
var: struct node * * tlv3 (tlv3) = & np
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; }
Assigns = [('struct list *', 'tlv4', '', '& inv'), ('struct node * *', 'tlv3', '', '& np')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == np ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_rm ( void ) { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_update ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int bytes_recvd'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [bytes_recvd] = int 
var: bytes_recvd (bytes_recvd) = 0
var: int bytes_recvd (bytes_recvd) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [( * desc_copy )] = unsigned int * 
[B-t-3] sym_dict [(] = unsigned int ** 
[C-t-3] sym_dict [( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )] = unsigned int 
[C-t-4] sym_dict [* desc_copy] = unsigned int 
[C-t-5] sym_dict [dst] = unsigned int 
[C-t-6] sym_dict [src] = unsigned int 
[C-t-7] sym_dict [cnt] = unsigned int 
ParameterDeclaration : type = void *, var = dst [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['dst']
[enterParameterDeclaration] void * : dst
sym_dict [dst] = void * 
ParameterDeclaration : type = const void *, var = src [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['src']
[enterParameterDeclaration] const void * : src
sym_dict [src] = const void * 
ParameterDeclaration : type = unsigned int, var = cnt [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cnt']
[enterParameterDeclaration] unsigned int : cnt
sym_dict [cnt] = unsigned int 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'bc [ BARCODE_SZ ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [bc] = char * 
[C-t-3] sym_dict [bc [ BARCODE_SZ ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'desc_buf [ MAX_DESC_LEN ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [desc_buf] = char * 
[C-t-3] sym_dict [desc_buf [ MAX_DESC_LEN ]] = char 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = char * * 
var: tlv1 (tlv1) = ( char * ) bc
var: char * * tlv1 (tlv1) = ( char * ) bc
var: p (p) = cgc_get_product_by_barcode ( tlv1 )
var: Product * p (p) = cgc_get_product_by_barcode ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
Assigns = [('char * *', 'tlv1', '', '( char * ) bc'), ('Product *', 'p', '', 'cgc_get_product_by_barcode ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => p
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
=> ['NULL', 'p']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : p
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['p']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [2.2]  Product * : p
Resolved type: [2.3]  Product * : p
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == p ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == p ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
var: tlv5 (tlv5) = STDIN
var: int tlv5 (tlv5) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = char 
var: tlv4 (tlv4) = DESC_TERM [ 0 ]
var: char tlv4 (tlv4) = DESC_TERM [ 0 ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = char * 
var: tlv3 (tlv3) = desc_buf
var: char * tlv3 (tlv3) = desc_buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = unsigned int 
var: tlv2 (tlv2) = sizeof ( Product )
var: unsigned int tlv2 (tlv2) = sizeof ( Product )
var: bytes_recvd (bytes_recvd) = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 )
var: int bytes_recvd (bytes_recvd) = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }
Assigns = [('int', 'tlv5', '', 'STDIN'), ('char', 'tlv4', '', 'DESC_TERM [ 0 ]'), ('char *', 'tlv3', '', 'desc_buf'), ('unsigned int', 'tlv2', '', 'sizeof ( Product )'), ('int', 'bytes_recvd', '', 'cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 >= bytes_recvd
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => bytes_recvd
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 >= bytes_recvd
=> ['0', 'bytes_recvd']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : bytes_recvd
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['bytes_recvd']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['bytes_recvd']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['bytes_recvd']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['bytes_recvd']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['bytes_recvd']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['bytes_recvd']
FOUND IT! [1.2]  int : bytes_recvd
Resolved type: [1.3]  int : bytes_recvd
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 >= bytes_recvd ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( ERRNO_RECV )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc__terminate ( ERRNO_RECV ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc__terminate ( ERRNO_RECV ) ; } ]
var: desc_buf  (desc_buf [ bytes_recvd - 1 ]) = '\0'
var: UNDEF desc_buf  (desc_buf [ bytes_recvd - 1 ]) = '\0'
var: p -> update_serial (p -> update_serial) = cgc_get_next_update_serial ( )
var: UNDEF p -> update_serial (p -> update_serial) = cgc_get_next_update_serial ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == p ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } ]
Assigns = [('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL'), ('UNDEF', 'desc_buf ', '[ bytes_recvd - 1 ]', "'\\0'"), ('UNDEF', 'p -> update_serial', '', 'cgc_get_next_update_serial ( )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_update ( void ) { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_onsale ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'bc [ BARCODE_SZ ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [bc] = char * 
[C-t-3] sym_dict [bc [ BARCODE_SZ ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int sale_percent'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [sale_percent] = unsigned int 
var: sale_percent (sale_percent) = 0
var: unsigned int sale_percent (sale_percent) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = char * * 
var: tlv1 (tlv1) = bc
var: char * * tlv1 (tlv1) = bc
var: p (p) = cgc_get_product_by_barcode ( tlv1 )
var: Product * p (p) = cgc_get_product_by_barcode ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
Assigns = [('char * *', 'tlv1', '', 'bc'), ('Product *', 'p', '', 'cgc_get_product_by_barcode ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => p
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
=> ['NULL', 'p']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : p
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['p']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [2.2]  Product * : p
Resolved type: [2.3]  Product * : p
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == p ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == p ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 100 <= sale_percent
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 100
[2] <class 'CParser.CParser.ShiftExpressionContext'> => sale_percent
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 100 <= sale_percent
=> ['100', 'sale_percent']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 100
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['100']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['100']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['100']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['100']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['100']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['100']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : sale_percent
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['sale_percent']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['sale_percent']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['sale_percent']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['sale_percent']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['sale_percent']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['sale_percent']
FOUND IT! [1.2]  unsigned int : sale_percent
Resolved type: [1.3]  unsigned int : sale_percent
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 100 <= sale_percent ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 100 <= sale_percent ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
var: p -> sfn (p -> sfn) = onsale_fn [ sale_percent ]
var: UNDEF p -> sfn (p -> sfn) = onsale_fn [ sale_percent ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == p ) { return - 1 ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 100 <= sale_percent ) { return - 1 ; } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ sale_percent ]')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_onsale ( void ) { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_nosale ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'bc [ BARCODE_SZ ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [bc] = char * 
[C-t-3] sym_dict [bc [ BARCODE_SZ ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int sale_percent'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [sale_percent] = unsigned int 
var: sale_percent (sale_percent) = 0
var: unsigned int sale_percent (sale_percent) = 0
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = char * * 
var: tlv1 (tlv1) = bc
var: char * * tlv1 (tlv1) = bc
var: p (p) = cgc_get_product_by_barcode ( tlv1 )
var: Product * p (p) = cgc_get_product_by_barcode ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
Assigns = [('char * *', 'tlv1', '', 'bc'), ('Product *', 'p', '', 'cgc_get_product_by_barcode ( tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => p
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL == p
=> ['NULL', 'p']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : p
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['p']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['p']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['p']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['p']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['p']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['p']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['p']
FOUND IT! [2.2]  Product * : p
Resolved type: [2.3]  Product * : p
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ NULL == p ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( NULL == p ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
var: p -> sfn (p -> sfn) = onsale_fn [ 0 ]
var: UNDEF p -> sfn (p -> sfn) = onsale_fn [ 0 ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( NULL == p ) { return - 1 ; } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_nosale ( void ) { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'static int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_do_list ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Product * p'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [p] = Product * 
var: p (p) = NULL
var: Product * p (p) = NULL
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'options [ 4 ] = { 0 }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [options] = char * 
[C-t-3] sym_dict [options [ 4 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = unsigned int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = struct list * 
var: tlv1 (tlv1) = & inv
var: struct list * tlv1 (tlv1) = & inv
var: count (count) = cgc_list_length ( tlv1 )
var: unsigned int count (count) = cgc_list_length ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; }
Assigns = [('struct list *', 'tlv1', '', '& inv'), ('unsigned int', 'count', '', 'cgc_list_length ( tlv1 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int d_len'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [d_len] = unsigned int 
var: d_len (d_len) = 0
var: unsigned int d_len (d_len) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'float sale_price'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [sale_price] = float 
var: sale_price (sale_price) = 0.0
var: float sale_price (sale_price) = 0.0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * cur'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [cur] = struct node * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = struct list * 
var: tlv2 (tlv2) = & inv
var: struct list * tlv2 (tlv2) = & inv
var: cur (cur) = cgc_list_head_node ( tlv2 )
var: struct node * cur (cur) = cgc_list_head_node ( tlv2 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; }
Assigns = [('struct list *', 'tlv2', '', '& inv'), ('struct node *', 'cur', '', 'cgc_list_head_node ( tlv2 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * end'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [end] = struct node * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = struct list * 
var: tlv3 (tlv3) = & inv
var: struct list * tlv3 (tlv3) = & inv
var: end (end) = cgc_list_end_marker ( tlv3 )
var: struct node * end (end) = cgc_list_end_marker ( tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; }
Assigns = [('struct list *', 'tlv3', '', '& inv'), ('struct node *', 'end', '', 'cgc_list_end_marker ( tlv3 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => count
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == count
=> ['0', 'count']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [2.2]  unsigned int : count
Resolved type: [2.3]  unsigned int : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == count ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return - 1 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == count ) { return - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return - 1 ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => NULL != cur
[0] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[2] <class 'CParser.CParser.RelationalExpressionContext'> => cur
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => NULL != cur
=> ['NULL', 'cur']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : NULL
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['NULL']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['NULL']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['NULL']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['NULL']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['NULL']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['NULL']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cur']
FOUND IT! [2.2]  struct node * : cur
Resolved type: [2.3]  struct node * : cur
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => cur != end
[0] <class 'CParser.CParser.RelationalExpressionContext'> => cur
[2] <class 'CParser.CParser.RelationalExpressionContext'> => end
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => cur != end
=> ['cur', 'end']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : cur
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['cur']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['cur']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['cur']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['cur']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['cur']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['cur']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['cur']
FOUND IT! [2.2]  struct node * : cur
Resolved type: [2.3]  struct node * : cur
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: p (p) = ( Product * ) cur -> data
var: Product * p (p) = ( Product * ) cur -> data
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == options [ 0 ] % 2
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => options [ 0 ] % 2
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == options [ 0 ] % 2
=> ['0', 'options [ 0 ] % 2']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : options [ 0 ] % 2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['options [ 0 ] % 2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['options [ 0 ] % 2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['options [ 0 ] % 2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.CastExpressionContext'>] ['options [ 0 ]', '%', '2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['options [ 0 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['options [ 0 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['options', '[', '0', ']']
FOUND IT! [2.2]  char * : options
Resolved type: [2.3]  char * : options
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == options [ 0 ] % 2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 != options [ 1 ] % 2
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => options [ 1 ] % 2
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 != options [ 1 ] % 2
=> ['0', 'options [ 1 ] % 2']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : options [ 1 ] % 2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['options [ 1 ] % 2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['options [ 1 ] % 2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['options [ 1 ] % 2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.CastExpressionContext'>] ['options [ 1 ]', '%', '2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['options [ 1 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['options [ 1 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['options', '[', '1', ']']
FOUND IT! [2.2]  char * : options
Resolved type: [2.3]  char * : options
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 != options [ 1 ] % 2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == options [ 2 ] % 2
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => options [ 2 ] % 2
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == options [ 2 ] % 2
=> ['0', 'options [ 2 ] % 2']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : options [ 2 ] % 2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['options [ 2 ] % 2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['options [ 2 ] % 2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['options [ 2 ] % 2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.CastExpressionContext'>] ['options [ 2 ]', '%', '2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['options [ 2 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['options [ 2 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['options', '[', '2', ']']
FOUND IT! [2.2]  char * : options
Resolved type: [2.3]  char * : options
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == options [ 2 ] % 2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: sale_price (sale_price) = p -> sfn ( p -> model_num , p -> cost )
var: float sale_price (sale_price) = p -> sfn ( p -> model_num , p -> cost )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; }
Assigns = [('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 != options [ 3 ] % 2
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => options [ 3 ] % 2
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 != options [ 3 ] % 2
=> ['0', 'options [ 3 ] % 2']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : options [ 3 ] % 2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['options [ 3 ] % 2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['options [ 3 ] % 2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['options [ 3 ] % 2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.CastExpressionContext'>] ['options [ 3 ]', '%', '2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['options [ 3 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['options [ 3 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['options', '[', '3', ']']
FOUND IT! [2.2]  char * : options
Resolved type: [2.3]  char * : options
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 != options [ 3 ] % 2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 = p -> desc'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = char 
var: tlv5 (tlv5) = '\0'
var: char tlv5 (tlv5) = '\0'
var: d_len (d_len) = cgc_strlen ( tlv6 , tlv5 )
var: unsigned int d_len (d_len) = cgc_strlen ( tlv6 , tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; }
Assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => 0 < d_len
[0] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[2] <class 'CParser.CParser.ShiftExpressionContext'> => d_len
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => 0 < d_len
=> ['0', 'd_len']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : 0
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : d_len
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['d_len']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['d_len']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['d_len']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['d_len']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['d_len']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['d_len']
FOUND IT! [1.2]  unsigned int : d_len
Resolved type: [1.3]  unsigned int : d_len
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 < d_len ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { SEND ( STDOUT , p -> desc , d_len ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { SEND ( STDOUT , p -> desc , d_len ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct node * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = struct node * 
var: tlv4 (tlv4) = cur
var: struct node * tlv4 (tlv4) = cur
var: cur (cur) = cgc_list_next_node ( tlv4 )
var: struct node * cur (cur) = cgc_list_next_node ( tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }
Assigns = [('struct node *', 'tlv4', '', 'cur'), ('struct node *', 'cur', '', 'cgc_list_next_node ( tlv4 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } ]
 4 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } ]
Assigns = [('Product *', 'p', '', '( Product * ) cur -> data')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == count ) { return - 1 ; } ]
 4 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } ]
Assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : static int cgc_do_list ( void ) { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_setup ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'struct list * tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = struct list * 
var: tlv2 (tlv2) = & inv
var: struct list * tlv2 (tlv2) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'nodeDataFreeFn'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 = cgc_free'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = nodeDataFreeFn 
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; }
Assigns = [('struct list *', 'tlv2', '', '& inv')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'Inventory * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = Inventory * 
var: tlv3 (tlv3) = & inv
var: Inventory * tlv3 (tlv3) = & inv
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_load_inventory'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv3 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; }
Assigns = [('Inventory *', 'tlv3', '', '& inv')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_setup ( void ) { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'short'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_process_cmd ( void )')]
[CORNER CASE] ParameterDeclaration : children = [(<class 'CParser.CParser.DeclarationSpecifiers2Context'>, 'void')] => setting default type to 'int'
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'cmd [ 4 ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [cmd] = char * 
[C-t-3] sym_dict [cmd [ 4 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'short ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = short 
var: ret (ret) = 0
var: short ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = void * 
var: tlv12 (tlv12) = ( void * ) CMD_BUY
var: void * tlv12 (tlv12) = ( void * ) CMD_BUY
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = void * 
var: tlv11 (tlv11) = cmd
var: void * tlv11 (tlv11) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = unsigned int 
var: tlv10 (tlv10) = sizeof ( CMD_BUY )
var: unsigned int tlv10 (tlv10) = sizeof ( CMD_BUY )
var: tlv1 (tlv1) = cgc_memcmp ( tlv12 , tlv11 , tlv10 )
var: int tlv1 (tlv1) = cgc_memcmp ( tlv12 , tlv11 , tlv10 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; }
Assigns = [('void *', 'tlv12', '', '( void * ) CMD_BUY'), ('void *', 'tlv11', '', 'cmd'), ('unsigned int', 'tlv10', '', 'sizeof ( CMD_BUY )'), ('int', 'tlv1', '', 'cgc_memcmp ( tlv12 , tlv11 , tlv10 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv1
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv1
=> ['0', 'tlv1']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_buy ( )
var: short ret (ret) = cgc_do_buy ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_buy ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_buy ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv1 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_buy ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = void * 
var: tlv15 (tlv15) = ( void * ) CMD_CHECK
var: void * tlv15 (tlv15) = ( void * ) CMD_CHECK
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = void * 
var: tlv14 (tlv14) = cmd
var: void * tlv14 (tlv14) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = unsigned int 
var: tlv13 (tlv13) = sizeof ( CMD_CHECK )
var: unsigned int tlv13 (tlv13) = sizeof ( CMD_CHECK )
var: tlv2 (tlv2) = cgc_memcmp ( tlv15 , tlv14 , tlv13 )
var: int tlv2 (tlv2) = cgc_memcmp ( tlv15 , tlv14 , tlv13 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; }
Assigns = [('void *', 'tlv15', '', '( void * ) CMD_CHECK'), ('void *', 'tlv14', '', 'cmd'), ('unsigned int', 'tlv13', '', 'sizeof ( CMD_CHECK )'), ('int', 'tlv2', '', 'cgc_memcmp ( tlv15 , tlv14 , tlv13 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv2
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv2
=> ['0', 'tlv2']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [2.2]  int : tlv2
Resolved type: [2.3]  int : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_check ( )
var: short ret (ret) = cgc_do_check ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_check ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_check ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv2 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_check ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv18'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv18] = void * 
var: tlv18 (tlv18) = ( void * ) CMD_ADD
var: void * tlv18 (tlv18) = ( void * ) CMD_ADD
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv17'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = void * 
var: tlv17 (tlv17) = cmd
var: void * tlv17 (tlv17) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = unsigned int 
var: tlv16 (tlv16) = sizeof ( CMD_ADD )
var: unsigned int tlv16 (tlv16) = sizeof ( CMD_ADD )
var: tlv3 (tlv3) = cgc_memcmp ( tlv18 , tlv17 , tlv16 )
var: int tlv3 (tlv3) = cgc_memcmp ( tlv18 , tlv17 , tlv16 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; }
Assigns = [('void *', 'tlv18', '', '( void * ) CMD_ADD'), ('void *', 'tlv17', '', 'cmd'), ('unsigned int', 'tlv16', '', 'sizeof ( CMD_ADD )'), ('int', 'tlv3', '', 'cgc_memcmp ( tlv18 , tlv17 , tlv16 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv3
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv3
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv3
=> ['0', 'tlv3']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv3
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv3']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv3']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv3']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv3']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv3']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv3']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv3']
FOUND IT! [2.2]  int : tlv3
Resolved type: [2.3]  int : tlv3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv3 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_add ( )
var: short ret (ret) = cgc_do_add ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_add ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_add ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv3 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_add ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv21'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv21] = void * 
var: tlv21 (tlv21) = ( void * ) CMD_RM
var: void * tlv21 (tlv21) = ( void * ) CMD_RM
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv20'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv20] = void * 
var: tlv20 (tlv20) = cmd
var: void * tlv20 (tlv20) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv19'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = unsigned int 
var: tlv19 (tlv19) = sizeof ( CMD_RM )
var: unsigned int tlv19 (tlv19) = sizeof ( CMD_RM )
var: tlv4 (tlv4) = cgc_memcmp ( tlv21 , tlv20 , tlv19 )
var: int tlv4 (tlv4) = cgc_memcmp ( tlv21 , tlv20 , tlv19 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; }
Assigns = [('void *', 'tlv21', '', '( void * ) CMD_RM'), ('void *', 'tlv20', '', 'cmd'), ('unsigned int', 'tlv19', '', 'sizeof ( CMD_RM )'), ('int', 'tlv4', '', 'cgc_memcmp ( tlv21 , tlv20 , tlv19 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv4
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv4
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv4
=> ['0', 'tlv4']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv4
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv4']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv4']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv4']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv4']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv4']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv4']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv4']
FOUND IT! [2.2]  int : tlv4
Resolved type: [2.3]  int : tlv4
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv4 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_rm ( )
var: short ret (ret) = cgc_do_rm ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_rm ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_rm ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv4 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_rm ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv24'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv24] = void * 
var: tlv24 (tlv24) = ( void * ) CMD_UPDATE
var: void * tlv24 (tlv24) = ( void * ) CMD_UPDATE
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv23'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv23] = void * 
var: tlv23 (tlv23) = cmd
var: void * tlv23 (tlv23) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv22'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv22] = unsigned int 
var: tlv22 (tlv22) = sizeof ( CMD_UPDATE )
var: unsigned int tlv22 (tlv22) = sizeof ( CMD_UPDATE )
var: tlv5 (tlv5) = cgc_memcmp ( tlv24 , tlv23 , tlv22 )
var: int tlv5 (tlv5) = cgc_memcmp ( tlv24 , tlv23 , tlv22 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; }
Assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )'), ('int', 'tlv5', '', 'cgc_memcmp ( tlv24 , tlv23 , tlv22 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv5
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv5
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv5
=> ['0', 'tlv5']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv5
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv5']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv5']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv5']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv5']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv5']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv5']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv5']
FOUND IT! [2.2]  int : tlv5
Resolved type: [2.3]  int : tlv5
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv5 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_update ( )
var: short ret (ret) = cgc_do_update ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_update ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_update ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv5 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_update ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv27'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv27] = void * 
var: tlv27 (tlv27) = ( void * ) CMD_ONSALE
var: void * tlv27 (tlv27) = ( void * ) CMD_ONSALE
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv26'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv26] = void * 
var: tlv26 (tlv26) = cmd
var: void * tlv26 (tlv26) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv25'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv25] = unsigned int 
var: tlv25 (tlv25) = sizeof ( CMD_ONSALE )
var: unsigned int tlv25 (tlv25) = sizeof ( CMD_ONSALE )
var: tlv6 (tlv6) = cgc_memcmp ( tlv27 , tlv26 , tlv25 )
var: int tlv6 (tlv6) = cgc_memcmp ( tlv27 , tlv26 , tlv25 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; }
Assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('int', 'tlv6', '', 'cgc_memcmp ( tlv27 , tlv26 , tlv25 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv6
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv6
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv6
=> ['0', 'tlv6']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv6
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv6']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv6']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv6']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv6']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv6']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv6']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv6']
FOUND IT! [2.2]  int : tlv6
Resolved type: [2.3]  int : tlv6
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv6 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_onsale ( )
var: short ret (ret) = cgc_do_onsale ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_onsale ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_onsale ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv6 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_onsale ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv30'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv30] = void * 
var: tlv30 (tlv30) = ( void * ) CMD_NOSALE
var: void * tlv30 (tlv30) = ( void * ) CMD_NOSALE
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv29'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv29] = void * 
var: tlv29 (tlv29) = cmd
var: void * tlv29 (tlv29) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv28'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv28] = unsigned int 
var: tlv28 (tlv28) = sizeof ( CMD_NOSALE )
var: unsigned int tlv28 (tlv28) = sizeof ( CMD_NOSALE )
var: tlv7 (tlv7) = cgc_memcmp ( tlv30 , tlv29 , tlv28 )
var: int tlv7 (tlv7) = cgc_memcmp ( tlv30 , tlv29 , tlv28 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; }
Assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('int', 'tlv7', '', 'cgc_memcmp ( tlv30 , tlv29 , tlv28 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv7
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv7
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv7
=> ['0', 'tlv7']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv7
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv7']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv7']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv7']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv7']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv7']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv7']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv7']
FOUND IT! [2.2]  int : tlv7
Resolved type: [2.3]  int : tlv7
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv7 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_nosale ( )
var: short ret (ret) = cgc_do_nosale ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_nosale ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_nosale ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv7 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_nosale ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv33'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv33] = void * 
var: tlv33 (tlv33) = ( void * ) CMD_LIST
var: void * tlv33 (tlv33) = ( void * ) CMD_LIST
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv32'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv32] = void * 
var: tlv32 (tlv32) = cmd
var: void * tlv32 (tlv32) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv31'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv31] = unsigned int 
var: tlv31 (tlv31) = sizeof ( CMD_LIST )
var: unsigned int tlv31 (tlv31) = sizeof ( CMD_LIST )
var: tlv8 (tlv8) = cgc_memcmp ( tlv33 , tlv32 , tlv31 )
var: int tlv8 (tlv8) = cgc_memcmp ( tlv33 , tlv32 , tlv31 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; }
Assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('int', 'tlv8', '', 'cgc_memcmp ( tlv33 , tlv32 , tlv31 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv8
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv8
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv8
=> ['0', 'tlv8']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv8
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv8']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv8']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv8']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv8']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv8']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv8']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv8']
FOUND IT! [2.2]  int : tlv8
Resolved type: [2.3]  int : tlv8
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv8 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = cgc_do_list ( )
var: short ret (ret) = cgc_do_list ( )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = cgc_do_list ( ) ; }
Assigns = [('short', 'ret', '', 'cgc_do_list ( )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv8 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = cgc_do_list ( ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv36'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv36] = void * 
var: tlv36 (tlv36) = ( void * ) CMD_QUIT
var: void * tlv36 (tlv36) = ( void * ) CMD_QUIT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv35'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv35] = void * 
var: tlv35 (tlv35) = cmd
var: void * tlv35 (tlv35) = cmd
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv34'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv34] = unsigned int 
var: tlv34 (tlv34) = sizeof ( CMD_QUIT )
var: unsigned int tlv34 (tlv34) = sizeof ( CMD_QUIT )
var: tlv9 (tlv9) = cgc_memcmp ( tlv36 , tlv35 , tlv34 )
var: int tlv9 (tlv9) = cgc_memcmp ( tlv36 , tlv35 , tlv34 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; }
Assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('int', 'tlv9', '', 'cgc_memcmp ( tlv36 , tlv35 , tlv34 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv9
[0] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[2] <class 'CParser.CParser.RelationalExpressionContext'> => tlv9
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => 0 == tlv9
=> ['0', 'tlv9']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : 0
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['0']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['0']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['0']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['0']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['0']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['0']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv9
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv9']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv9']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv9']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv9']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv9']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv9']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv9']
FOUND IT! [2.2]  int : tlv9
Resolved type: [2.3]  int : tlv9
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv9 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = - 2
var: short ret (ret) = - 2
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = - 2 ; }
Assigns = [('short', 'ret', '', '- 2')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ 0 == tlv9 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret = - 2 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: ret (ret) = - 1
var: short ret (ret) = - 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = - 1 ; }
Assigns = [('short', 'ret', '', '- 1')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = - 2 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = - 1 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_list ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_nosale ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_onsale ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_update ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_rm ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_add ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_check ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = cgc_do_buy ( ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } ]
Assigns = [('short', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : short cgc_process_cmd ( void ) { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; } ]
compound scope 0 : { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; } ] 
p_decls = [('unsigned int', 'base', None), ('unsigned int', 'next_update_serial', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'base', None), ('unsigned int', 'next_update_serial', None)]
assigns = [('unsigned int', 'base', '', '* ( unsigned int * ) FLAG_PAGE'), ('unsigned int', 'next_update_serial', '', 'base + cgc_update_serial')]
compares = []
===> context { unsigned int base ; base = * ( unsigned int * ) FLAG_PAGE ; unsigned int next_update_serial ; next_update_serial = base + cgc_update_serial ; cgc_update_serial ++ ; return next_update_serial ; }
ignore sibs: []
0 : |  decl_scope  | type: unsigned int, var: base
1 : |  decl_scope  | type: unsigned int, var: next_update_serial
0 : | assign_scope | type: unsigned int, value: * ( unsigned int * ) FLAG_PAGE
1 : | assign_scope | type: unsigned int, value: base + cgc_update_serial
=======END=======
compound scope 0 : { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; }
compound scope 1 : { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; }
compound scope 2 : { return TRUE ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; } ] 
p_decls = [('Product *', 'p', None), ('unsigned char *', 'bc', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('unsigned char *', 'bc', None), ('int', 'tlv1', None), ('const void *', 'product', None), ('void *', 'barcode', None)]
assigns = [('Product *', 'p', '', '( Product * ) product'), ('unsigned char *', 'bc', '', '( unsigned char * ) barcode')]
compares = []
===> context { Product * p ; p = ( Product * ) product ; unsigned char * bc ; bc = ( unsigned char * ) barcode ; int tlv1 ; { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } if ( 0 == tlv1 ) { return TRUE ; } return FALSE ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: unsigned char *, var: bc
2 : |  decl_scope  | type: int, var: tlv1
3 : |  decl_scope  | type: const void *, var: product
4 : |  decl_scope  | type: void *, var: barcode
0 : | assign_scope | type: Product *, value: ( Product * ) product
1 : | assign_scope | type: unsigned char *, value: ( unsigned char * ) barcode
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('unsigned int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('unsigned int', 'tlv2', None), ('const void *', 'product', None), ('void *', 'barcode', None)]
assigns = [('void *', 'tlv4', '', 'p -> barcode'), ('void *', 'tlv3', '', 'bc'), ('unsigned int', 'tlv2', '', 'BARCODE_SZ')]
compares = []
decls = [('void *', 'tlv4', None), ('void *', 'tlv3', None), ('unsigned int', 'tlv2', None), ('const void *', 'product', None), ('void *', 'barcode', None), ('Product *', 'p', None), ('unsigned char *', 'bc', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv4', '', 'p -> barcode'), ('void *', 'tlv3', '', 'bc'), ('unsigned int', 'tlv2', '', 'BARCODE_SZ'), ('Product *', 'p', '', '( Product * ) product'), ('unsigned char *', 'bc', '', '( unsigned char * ) barcode')]
compares = []
===> context { void * tlv4 ; tlv4 = p -> barcode ; void * tlv3 ; tlv3 = bc ; unsigned int tlv2 ; tlv2 = BARCODE_SZ ; tlv1 = cgc_memcmp ( tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( 0 == tlv1 ) { return TRUE ; }', 'return FALSE ;', '}']
0 : |  decl_scope  | type: void *, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: unsigned int, var: tlv2
3 : |  decl_scope  | type: const void *, var: product
4 : |  decl_scope  | type: void *, var: barcode
5 : |  decl_scope  | type: Product *, var: p
6 : |  decl_scope  | type: unsigned char *, var: bc
7 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: void *, value: p -> barcode
1 : | assign_scope | type: void *, value: bc
2 : | assign_scope | type: unsigned int, value: BARCODE_SZ
3 : | assign_scope | type: Product *, value: ( Product * ) product
4 : | assign_scope | type: unsigned char *, value: ( unsigned char * ) barcode
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return TRUE ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return TRUE ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const void *', 'product', None), ('void *', 'barcode', None)]
assigns = []
compares = []
decls = [('const void *', 'product', None), ('void *', 'barcode', None), ('Product *', 'p', None), ('unsigned char *', 'bc', None), ('int', 'tlv1', None)]
assigns = [('Product *', 'p', '', '( Product * ) product'), ('unsigned char *', 'bc', '', '( unsigned char * ) barcode')]
compares = []
decls = [('const void *', 'product', None), ('void *', 'barcode', None), ('Product *', 'p', None), ('unsigned char *', 'bc', None), ('int', 'tlv1', None)]
assigns = [('Product *', 'p', '', '( Product * ) product'), ('unsigned char *', 'bc', '', '( unsigned char * ) barcode')]
compares = ['', '']
===> context { return TRUE ; }
ignore sibs: ['return FALSE ;', '}']
0 : |  decl_scope  | type: const void *, var: product
1 : |  decl_scope  | type: void *, var: barcode
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: unsigned char *, var: bc
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: Product *, value: ( Product * ) product
1 : | assign_scope | type: unsigned char *, value: ( unsigned char * ) barcode
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv1
=======END=======
compound scope 0 : { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } }
compound scope 1 : { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { return NULL ; }
compound scope 3 : { return ( Product * ) np -> data ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } } ] 
p_decls = [('struct node *', 'np', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct node *', 'np', None), ('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None)]
assigns = [('struct node *', 'np', '', 'NULL')]
compares = []
===> context { struct node * np ; np = NULL ; { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; } }
ignore sibs: []
0 : |  decl_scope  | type: struct node *, var: np
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ ]
0 : | assign_scope | type: struct node *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('struct list *', 'tlv3', None), ('unsigned char *', 'tlv2', None), ('void *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv3', None), ('unsigned char *', 'tlv2', None), ('void *', 'tlv1', None), ('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None)]
assigns = [('struct list *', 'tlv3', '', '& inv'), ('void *', 'tlv1', '', '( void * ) bc')]
compares = []
decls = [('struct list *', 'tlv3', None), ('unsigned char *', 'tlv2', None), ('void *', 'tlv1', None), ('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None), ('struct node *', 'np', None)]
assigns = [('struct list *', 'tlv3', '', '& inv'), ('void *', 'tlv1', '', '( void * ) bc'), ('struct node *', 'np', '', 'NULL')]
compares = []
===> context { struct list * tlv3 ; tlv3 = & inv ; unsigned char * tlv2 ; tlv2 = cgc_prod_has_bc ; void * tlv1 ; tlv1 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( NULL == np ) { return NULL ; } else { return ( Product * ) np -> data ; }', '}']
0 : |  decl_scope  | type: struct list *, var: tlv3
1 : |  decl_scope  | type: unsigned char *, var: tlv2
2 : |  decl_scope  | type: void *, var: tlv1
3 : |  decl_scope  | type: char *, var: bc
4 : |  decl_scope  | type: char, var: bc [ ]
5 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: void *, value: ( void * ) bc
2 : | assign_scope | type: struct node *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return NULL ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return NULL ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None)]
assigns = []
compares = []
decls = [('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None), ('struct node *', 'np', None)]
assigns = [('struct node *', 'np', '', 'NULL')]
compares = []
decls = [('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None), ('struct node *', 'np', None)]
assigns = [('struct node *', 'np', '', 'NULL')]
compares = ['', '']
===> context { return NULL ; }
ignore sibs: ['else', '{ return ( Product * ) np -> data ; }', '}']
0 : |  decl_scope  | type: char *, var: bc
1 : |  decl_scope  | type: char, var: bc [ ]
2 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: struct node *, value: NULL
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: np
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( Product * ) np -> data ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( Product * ) np -> data ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None)]
assigns = []
compares = []
decls = [('char *', 'bc', ' [ ]'), ('char', 'bc [ ]', None), ('struct node *', 'np', None)]
assigns = [('struct node *', 'np', '', 'NULL')]
compares = []
===> context { return ( Product * ) np -> data ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: char *, var: bc
1 : |  decl_scope  | type: char, var: bc [ ]
2 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: struct node *, value: NULL
=======END=======
compound scope 0 : { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; }
compound scope 1 : { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; }
compound scope 2 : { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; }
compound scope 3 : { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; }
compound scope 4 : { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; }
compound scope 5 : { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; }
compound scope 6 : { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; }
compound scope 7 : { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }
compound scope 8 : { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }
compound scope 9 : { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }
compound scope 10 : { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }
compound scope 11 : { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; }
compound scope 12 : { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }
len(compound_scope) : 13
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
===> context { Product * p ; p = NULL ; Product * p_copy ; p_copy = NULL ; char buy_status [ 4 ] ; char bc [ BARCODE_SZ ] = { 0 } ; double cost ; cost = 0.0 ; struct list buy_list ; { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; unsigned long tlv_size_0 ; tlv_size_0 = sizeof ( BUY_MORE ) ; while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } int tlv1 ; { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ; { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p_copy
2 : |  decl_scope  | type: char *, var: buy_status
3 : |  decl_scope  | type: char, var: buy_status [ 4 ]
4 : |  decl_scope  | type: char *, var: bc
5 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
6 : |  decl_scope  | type: double, var: cost
7 : |  decl_scope  | type: struct list, var: buy_list
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: double, value: 0.0
3 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; } ] 
p_decls = [('struct list *', 'tlv3', None), ('nodeDataFreeFn', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv3', None), ('nodeDataFreeFn', 'tlv2', None)]
assigns = [('struct list *', 'tlv3', '', '& buy_list')]
compares = []
decls = [('struct list *', 'tlv3', None), ('nodeDataFreeFn', 'tlv2', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None)]
assigns = [('struct list *', 'tlv3', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0')]
compares = []
===> context { struct list * tlv3 ; tlv3 = & buy_list ; nodeDataFreeFn tlv2 = cgc_free ; cgc_list_init ( tlv3 , tlv2 ) ; }
ignore sibs: ['RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', 'unsigned long tlv_size_0 ;', 'tlv_size_0 = sizeof ( BUY_MORE ) ;', 'while ( 0 == cgc_memcmp ( buy_status , ( void * ) BUY_MORE , tlv_size_0 ) ) { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; }', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv3
1 : |  decl_scope  | type: nodeDataFreeFn, var: tlv2
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: Product *, var: p_copy
4 : |  decl_scope  | type: char *, var: buy_status
5 : |  decl_scope  | type: char, var: buy_status [ 4 ]
6 : |  decl_scope  | type: char *, var: bc
7 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
8 : |  decl_scope  | type: double, var: cost
9 : |  decl_scope  | type: struct list, var: buy_list
0 : | assign_scope | type: struct list *, value: & buy_list
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('double', 'cost', '', 'p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )')]
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('double', 'cost', '', 'p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('double', 'cost', '', 'p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
===> context { RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } MALLOC_OK ( p_copy ) ; { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ; RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ; }
ignore sibs: ['int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p_copy
2 : |  decl_scope  | type: char *, var: buy_status
3 : |  decl_scope  | type: char, var: buy_status [ 4 ]
4 : |  decl_scope  | type: char *, var: bc
5 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
6 : |  decl_scope  | type: double, var: cost
7 : |  decl_scope  | type: struct list, var: buy_list
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: double, value: p_copy -> sfn ( p_copy -> model_num , p_copy -> cost )
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
4 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; } ] 
p_decls = [('char * *', 'tlv14', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv14', None)]
assigns = [('char * *', 'tlv14', '', 'bc')]
compares = []
decls = [('char * *', 'tlv14', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('char * *', 'tlv14', '', 'bc'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('char * *', 'tlv14', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('char * *', 'tlv14', '', 'bc'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('char * *', 'tlv14', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('char * *', 'tlv14', '', 'bc'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
===> context { char * * tlv14 ; tlv14 = bc ; p = cgc_get_product_by_barcode ( tlv14 ) ; }
ignore sibs: ['if ( NULL == p ) { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; }', '{ cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; }', 'MALLOC_OK ( p_copy ) ;', '{ void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }', '{ struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }', 'cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ;', 'RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', '}', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv14
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p_copy
3 : |  decl_scope  | type: char *, var: buy_status
4 : |  decl_scope  | type: char, var: buy_status [ 4 ]
5 : |  decl_scope  | type: char *, var: bc
6 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
7 : |  decl_scope  | type: double, var: cost
8 : |  decl_scope  | type: struct list, var: buy_list
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: char * *, value: bc
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
4 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['', '', '']
===> context { { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } return - 1 ; }
ignore sibs: ['{ cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; }', 'MALLOC_OK ( p_copy ) ;', '{ void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }', '{ struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }', 'cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ;', 'RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', '}', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p_copy
2 : |  decl_scope  | type: char *, var: buy_status
3 : |  decl_scope  | type: char, var: buy_status [ 4 ]
4 : |  decl_scope  | type: char *, var: bc
5 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
6 : |  decl_scope  | type: double, var: cost
7 : |  decl_scope  | type: struct list, var: buy_list
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: double, value: 0.0
3 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
1 : |compare_scopes| type: Product *, value: NULL
2 : |compare_scopes| type: Product *, value: p
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; } ] 
p_decls = [('struct list *', 'tlv16', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv16', None)]
assigns = [('struct list *', 'tlv16', '', '& buy_list')]
compares = []
decls = [('struct list *', 'tlv16', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv16', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('struct list *', 'tlv16', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv16', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('struct list *', 'tlv16', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv16', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('struct list *', 'tlv16', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv16', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['', '', '']
decls = [('struct list *', 'tlv16', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv16', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['', '', '']
===> context { struct list * tlv16 ; tlv16 = & buy_list ; cgc_list_destroy ( tlv16 ) ; }
ignore sibs: ['return - 1 ;', '}', '{ cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; }', 'MALLOC_OK ( p_copy ) ;', '{ void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }', '{ struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }', 'cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ;', 'RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', '}', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv16
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p_copy
3 : |  decl_scope  | type: char *, var: buy_status
4 : |  decl_scope  | type: char, var: buy_status [ 4 ]
5 : |  decl_scope  | type: char *, var: bc
6 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
7 : |  decl_scope  | type: double, var: cost
8 : |  decl_scope  | type: struct list, var: buy_list
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: struct list *, value: & buy_list
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
4 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
1 : |compare_scopes| type: Product *, value: NULL
2 : |compare_scopes| type: Product *, value: p
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv15', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv15', None)]
assigns = [('cgc_size_t', 'tlv15', '', 'sizeof ( Product )')]
compares = []
decls = [('cgc_size_t', 'tlv15', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('cgc_size_t', 'tlv15', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('cgc_size_t', 'tlv15', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('cgc_size_t', 'tlv15', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('cgc_size_t', 'tlv15', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('cgc_size_t', 'tlv15', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
===> context { cgc_size_t tlv15 ; tlv15 = sizeof ( Product ) ; p_copy = cgc_malloc ( tlv15 ) ; }
ignore sibs: ['MALLOC_OK ( p_copy ) ;', '{ void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }', '{ struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }', 'cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ;', 'RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', '}', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv15
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p_copy
3 : |  decl_scope  | type: char *, var: buy_status
4 : |  decl_scope  | type: char, var: buy_status [ 4 ]
5 : |  decl_scope  | type: char *, var: bc
6 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
7 : |  decl_scope  | type: double, var: cost
8 : |  decl_scope  | type: struct list, var: buy_list
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: cgc_size_t, value: sizeof ( Product )
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
4 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; } ] 
p_decls = [('void *', 'tlv10', None), ('void *', 'tlv9', None), ('unsigned int', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv10', None), ('void *', 'tlv9', None), ('unsigned int', 'tlv8', None)]
assigns = [('void *', 'tlv10', '', 'p_copy'), ('void *', 'tlv9', '', 'p'), ('unsigned int', 'tlv8', '', 'sizeof ( Product )')]
compares = []
decls = [('void *', 'tlv10', None), ('void *', 'tlv9', None), ('unsigned int', 'tlv8', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('void *', 'tlv10', '', 'p_copy'), ('void *', 'tlv9', '', 'p'), ('unsigned int', 'tlv8', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('void *', 'tlv10', None), ('void *', 'tlv9', None), ('unsigned int', 'tlv8', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('void *', 'tlv10', '', 'p_copy'), ('void *', 'tlv9', '', 'p'), ('unsigned int', 'tlv8', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('void *', 'tlv10', None), ('void *', 'tlv9', None), ('unsigned int', 'tlv8', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('void *', 'tlv10', '', 'p_copy'), ('void *', 'tlv9', '', 'p'), ('unsigned int', 'tlv8', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
===> context { void * tlv10 ; tlv10 = p_copy ; void * tlv9 ; tlv9 = p ; unsigned int tlv8 ; tlv8 = sizeof ( Product ) ; cgc_memcpy ( tlv10 , tlv9 , tlv8 ) ; }
ignore sibs: ['{ struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }', 'cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ;', 'RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', '}', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: void *, var: tlv10
1 : |  decl_scope  | type: void *, var: tlv9
2 : |  decl_scope  | type: unsigned int, var: tlv8
3 : |  decl_scope  | type: Product *, var: p
4 : |  decl_scope  | type: Product *, var: p_copy
5 : |  decl_scope  | type: char *, var: buy_status
6 : |  decl_scope  | type: char, var: buy_status [ 4 ]
7 : |  decl_scope  | type: char *, var: bc
8 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
9 : |  decl_scope  | type: double, var: cost
10 : |  decl_scope  | type: struct list, var: buy_list
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: void *, value: p_copy
1 : | assign_scope | type: void *, value: p
2 : | assign_scope | type: unsigned int, value: sizeof ( Product )
3 : | assign_scope | type: Product *, value: NULL
4 : | assign_scope | type: Product *, value: NULL
5 : | assign_scope | type: double, value: 0.0
6 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; } ] 
p_decls = [('struct list *', 'tlv12', None), ('void *', 'tlv11', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv12', None), ('void *', 'tlv11', None)]
assigns = [('struct list *', 'tlv12', '', '& buy_list'), ('void *', 'tlv11', '', 'p_copy')]
compares = []
decls = [('struct list *', 'tlv12', None), ('void *', 'tlv11', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv12', '', '& buy_list'), ('void *', 'tlv11', '', 'p_copy'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('struct list *', 'tlv12', None), ('void *', 'tlv11', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv12', '', '& buy_list'), ('void *', 'tlv11', '', 'p_copy'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
decls = [('struct list *', 'tlv12', None), ('void *', 'tlv11', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None)]
assigns = [('struct list *', 'tlv12', '', '& buy_list'), ('void *', 'tlv11', '', 'p_copy'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['']
===> context { struct list * tlv12 ; tlv12 = & buy_list ; void * tlv11 ; tlv11 = p_copy ; cgc_list_insert_at_end ( tlv12 , tlv11 ) ; }
ignore sibs: ['cost += p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) ;', 'RECV ( STDIN , buy_status , sizeof ( buy_status ) ) ;', '}', 'int tlv1 ;', '{ void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv12
1 : |  decl_scope  | type: void *, var: tlv11
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: Product *, var: p_copy
4 : |  decl_scope  | type: char *, var: buy_status
5 : |  decl_scope  | type: char, var: buy_status [ 4 ]
6 : |  decl_scope  | type: char *, var: bc
7 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
8 : |  decl_scope  | type: double, var: cost
9 : |  decl_scope  | type: struct list, var: buy_list
10 : |  decl_scope  | type: unsigned long, var: tlv_size_0
0 : | assign_scope | type: struct list *, value: & buy_list
1 : | assign_scope | type: void *, value: p_copy
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: Product *, value: NULL
4 : | assign_scope | type: double, value: 0.0
5 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; } ] 
p_decls = [('void *', 'tlv7', None), ('void *', 'tlv6', None), ('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv7', None), ('void *', 'tlv6', None), ('unsigned int', 'tlv5', None)]
assigns = [('void *', 'tlv7', '', 'buy_status'), ('void *', 'tlv6', '', '( void * ) BUY_TERM'), ('unsigned int', 'tlv5', '', 'sizeof ( BUY_TERM )')]
compares = []
decls = [('void *', 'tlv7', None), ('void *', 'tlv6', None), ('unsigned int', 'tlv5', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv7', '', 'buy_status'), ('void *', 'tlv6', '', '( void * ) BUY_TERM'), ('unsigned int', 'tlv5', '', 'sizeof ( BUY_TERM )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
===> context { void * tlv7 ; tlv7 = buy_status ; void * tlv6 ; tlv6 = ( void * ) BUY_TERM ; unsigned int tlv5 ; tlv5 = sizeof ( BUY_TERM ) ; tlv1 = cgc_memcmp ( tlv7 , tlv6 , tlv5 ) ; }
ignore sibs: ['if ( 0 != tlv1 ) { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: void *, var: tlv7
1 : |  decl_scope  | type: void *, var: tlv6
2 : |  decl_scope  | type: unsigned int, var: tlv5
3 : |  decl_scope  | type: Product *, var: p
4 : |  decl_scope  | type: Product *, var: p_copy
5 : |  decl_scope  | type: char *, var: buy_status
6 : |  decl_scope  | type: char, var: buy_status [ 4 ]
7 : |  decl_scope  | type: char *, var: bc
8 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
9 : |  decl_scope  | type: double, var: cost
10 : |  decl_scope  | type: struct list, var: buy_list
11 : |  decl_scope  | type: unsigned long, var: tlv_size_0
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: void *, value: buy_status
1 : | assign_scope | type: void *, value: ( void * ) BUY_TERM
2 : | assign_scope | type: unsigned int, value: sizeof ( BUY_TERM )
3 : | assign_scope | type: Product *, value: NULL
4 : | assign_scope | type: Product *, value: NULL
5 : | assign_scope | type: double, value: 0.0
6 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['', '']
===> context { { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } return - 1 ; }
ignore sibs: ['SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p_copy
2 : |  decl_scope  | type: char *, var: buy_status
3 : |  decl_scope  | type: char, var: buy_status [ 4 ]
4 : |  decl_scope  | type: char *, var: bc
5 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
6 : |  decl_scope  | type: double, var: cost
7 : |  decl_scope  | type: struct list, var: buy_list
8 : |  decl_scope  | type: unsigned long, var: tlv_size_0
9 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: double, value: 0.0
3 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; } ] 
p_decls = [('struct list *', 'tlv13', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv13', None)]
assigns = [('struct list *', 'tlv13', '', '& buy_list')]
compares = []
decls = [('struct list *', 'tlv13', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('struct list *', 'tlv13', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
decls = [('struct list *', 'tlv13', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('struct list *', 'tlv13', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['', '']
decls = [('struct list *', 'tlv13', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('struct list *', 'tlv13', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = ['', '']
===> context { struct list * tlv13 ; tlv13 = & buy_list ; cgc_list_destroy ( tlv13 ) ; }
ignore sibs: ['return - 1 ;', '}', 'SEND ( STDOUT , ( char * ) & cost , sizeof ( cost ) ) ;', '{ struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv13
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p_copy
3 : |  decl_scope  | type: char *, var: buy_status
4 : |  decl_scope  | type: char, var: buy_status [ 4 ]
5 : |  decl_scope  | type: char *, var: bc
6 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
7 : |  decl_scope  | type: double, var: cost
8 : |  decl_scope  | type: struct list, var: buy_list
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: struct list *, value: & buy_list
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
4 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; } ] 
p_decls = [('struct list *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv4', None)]
assigns = [('struct list *', 'tlv4', '', '& buy_list')]
compares = []
decls = [('struct list *', 'tlv4', None), ('Product *', 'p', None), ('Product *', 'p_copy', None), ('char *', 'buy_status', ' [ 4 ]'), ('char', 'buy_status [ 4 ]', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('double', 'cost', None), ('struct list', 'buy_list', None), ('unsigned long', 'tlv_size_0', None), ('int', 'tlv1', None)]
assigns = [('struct list *', 'tlv4', '', '& buy_list'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p_copy', '', 'NULL'), ('double', 'cost', '', '0.0'), ('unsigned long', 'tlv_size_0', '', 'sizeof ( BUY_MORE )')]
compares = []
===> context { struct list * tlv4 ; tlv4 = & buy_list ; cgc_list_destroy ( tlv4 ) ; }
ignore sibs: ['return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv4
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p_copy
3 : |  decl_scope  | type: char *, var: buy_status
4 : |  decl_scope  | type: char, var: buy_status [ 4 ]
5 : |  decl_scope  | type: char *, var: bc
6 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
7 : |  decl_scope  | type: double, var: cost
8 : |  decl_scope  | type: struct list, var: buy_list
9 : |  decl_scope  | type: unsigned long, var: tlv_size_0
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: struct list *, value: & buy_list
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: double, value: 0.0
4 : | assign_scope | type: unsigned long, value: sizeof ( BUY_MORE )
=======END=======
compound scope 0 : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; }
compound scope 1 : { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
compound scope 2 : { return - 1 ; }
compound scope 3 : { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; }
compound scope 4 : { SEND ( STDOUT , p -> desc , d_len ) ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
compares = []
===> context { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; float sale_price ; sale_price = 0.0 ; unsigned int d_len ; d_len = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: float, var: sale_price
4 : |  decl_scope  | type: unsigned int, var: d_len
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: float, value: 0.0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: p -> sfn ( p -> model_num , p -> cost )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
p_decls = [('char * *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv1', None)]
assigns = [('char * *', 'tlv1', '', 'bc')]
compares = []
decls = [('char * *', 'tlv1', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('char * *', 'tlv1', '', 'bc'), ('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0')]
compares = []
===> context { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
ignore sibs: ['if ( NULL == p ) { return - 1 ; }', 'SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'sale_price = p -> sfn ( p -> model_num , p -> cost ) ;', 'SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ;', "{ const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; }", 'if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; }', 'SEND ( STDOUT , DESC_TERM , 1 ) ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv1
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: bc
3 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
4 : |  decl_scope  | type: float, var: sale_price
5 : |  decl_scope  | type: unsigned int, var: d_len
0 : | assign_scope | type: char * *, value: bc
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: float, value: 0.0
3 : | assign_scope | type: unsigned int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'sale_price = p -> sfn ( p -> model_num , p -> cost ) ;', 'SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ;', "{ const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; }", 'if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; }', 'SEND ( STDOUT , DESC_TERM , 1 ) ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: float, var: sale_price
4 : |  decl_scope  | type: unsigned int, var: d_len
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: float, value: 0.0
2 : | assign_scope | type: unsigned int, value: 0
0 : |compare_scopes| type: Product *, value: NULL
1 : |compare_scopes| type: Product *, value: p
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; } ] 
p_decls = [('const char *', 'tlv3', None), ('char', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv3', None), ('char', 'tlv2', None)]
assigns = [('char', 'tlv2', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv3 , tlv2 )')]
compares = []
decls = [('const char *', 'tlv3', None), ('char', 'tlv2', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('char', 'tlv2', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv3 , tlv2 )'), ('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
compares = []
===> context { const char * tlv3 = p -> desc ; char tlv2 ; tlv2 = '\0' ; d_len = cgc_strlen ( tlv3 , tlv2 ) ; }
ignore sibs: ['if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; }', 'SEND ( STDOUT , DESC_TERM , 1 ) ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv3
1 : |  decl_scope  | type: char, var: tlv2
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: char *, var: bc
4 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: unsigned int, var: d_len
0 : | assign_scope | type: char, value: '\0'
1 : | assign_scope | type: unsigned int, value: cgc_strlen ( tlv3 , tlv2 )
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: float, value: 0.0
4 : | assign_scope | type: unsigned int, value: 0
5 : | assign_scope | type: float, value: p -> sfn ( p -> model_num , p -> cost )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , p -> desc , d_len ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , p -> desc , d_len ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('float', 'sale_price', None), ('unsigned int', 'd_len', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('float', 'sale_price', '', '0.0'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
compares = ['', '']
===> context { SEND ( STDOUT , p -> desc , d_len ) ; }
ignore sibs: ['SEND ( STDOUT , DESC_TERM , 1 ) ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: float, var: sale_price
4 : |  decl_scope  | type: unsigned int, var: d_len
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: float, value: 0.0
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: p -> sfn ( p -> model_num , p -> cost )
0 : |compare_scopes| type: unsigned int, value: 0
1 : |compare_scopes| type: unsigned int, value: d_len
=======END=======
compound scope 0 : { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; }
compound scope 1 : { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; }
compound scope 2 : { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; }
compound scope 3 : { cgc_free ( p ) ; return - 1 ; }
compound scope 4 : { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; }
compound scope 5 : { cgc__terminate ( ERRNO_RECV ) ; }
compound scope 6 : { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0'), ('UNDEF', 'p -> desc ', '[ bytes_recvd - 1 ]', "'\\0'")]
compares = []
===> context { Product * p ; p = NULL ; Product * p2 ; p2 = NULL ; int bytes_recvd ; bytes_recvd = 0 ; { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } MALLOC_OK ( p ) ; p -> sfn = onsale_fn [ 0 ] ; p -> update_serial = 0 ; RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ; { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } p -> desc [ bytes_recvd - 1 ] = '\0' ; { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p2
2 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
4 : | assign_scope | type: UNDEF, value: 0
5 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv3', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( Product )')]
compares = []
decls = [('cgc_size_t', 'tlv3', None), ('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0')]
compares = []
===> context { cgc_size_t tlv3 ; tlv3 = sizeof ( Product ) ; p = cgc_malloc ( tlv3 ) ; }
ignore sibs: ['MALLOC_OK ( p ) ;', 'p -> sfn = onsale_fn [ 0 ] ;', 'p -> update_serial = 0 ;', 'RECV ( STDIN , ( char * ) p -> barcode , BARCODE_SZ ) ;', '{ char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; }', 'if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; }', 'RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ;', '{ int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "p -> desc [ bytes_recvd - 1 ] = '\\0' ;", '{ struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv3
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p2
3 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: cgc_size_t, value: sizeof ( Product )
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; } ] 
p_decls = [('char * *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv4', None)]
assigns = [('char * *', 'tlv4', '', '( char * ) p -> barcode')]
compares = []
decls = [('char * *', 'tlv4', None), ('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('char * *', 'tlv4', '', '( char * ) p -> barcode'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0')]
compares = []
===> context { char * * tlv4 ; tlv4 = ( char * ) p -> barcode ; p2 = cgc_get_product_by_barcode ( tlv4 ) ; }
ignore sibs: ['if ( NULL != p2 ) { cgc_free ( p ) ; return - 1 ; }', 'RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ;', '{ int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "p -> desc [ bytes_recvd - 1 ] = '\\0' ;", '{ struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv4
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: Product *, var: p2
3 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: char * *, value: ( char * ) p -> barcode
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
5 : | assign_scope | type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( p ) ; return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_free ( p ) ; return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0')]
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0')]
compares = ['', '']
===> context { cgc_free ( p ) ; return - 1 ; }
ignore sibs: ['RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ;', '{ int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; }', 'if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "p -> desc [ bytes_recvd - 1 ] = '\\0' ;", '{ struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p2
2 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
4 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: Product *, value: NULL
1 : |compare_scopes| type: Product *, value: p2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; } ] 
p_decls = [('int', 'tlv8', None), ('char', 'tlv7', None), ('char *', 'tlv6', None), ('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv8', None), ('char', 'tlv7', None), ('char *', 'tlv6', None), ('unsigned int', 'tlv5', None)]
assigns = [('int', 'tlv8', '', 'STDIN'), ('char', 'tlv7', '', 'DESC_TERM [ 0 ]'), ('char *', 'tlv6', '', '( char * ) p -> desc'), ('unsigned int', 'tlv5', '', 'sizeof ( Product )')]
compares = []
decls = [('int', 'tlv8', None), ('char', 'tlv7', None), ('char *', 'tlv6', None), ('unsigned int', 'tlv5', None), ('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('int', 'tlv8', '', 'STDIN'), ('char', 'tlv7', '', 'DESC_TERM [ 0 ]'), ('char *', 'tlv6', '', '( char * ) p -> desc'), ('unsigned int', 'tlv5', '', 'sizeof ( Product )'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0')]
compares = []
===> context { int tlv8 ; tlv8 = STDIN ; char tlv7 ; tlv7 = DESC_TERM [ 0 ] ; char * tlv6 ; tlv6 = ( char * ) p -> desc ; unsigned int tlv5 ; tlv5 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv8 , tlv7 , tlv6 , tlv5 ) ; }
ignore sibs: ['if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "p -> desc [ bytes_recvd - 1 ] = '\\0' ;", '{ struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: int, var: tlv8
1 : |  decl_scope  | type: char, var: tlv7
2 : |  decl_scope  | type: char *, var: tlv6
3 : |  decl_scope  | type: unsigned int, var: tlv5
4 : |  decl_scope  | type: Product *, var: p
5 : |  decl_scope  | type: Product *, var: p2
6 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: char, value: DESC_TERM [ 0 ]
2 : | assign_scope | type: char *, value: ( char * ) p -> desc
3 : | assign_scope | type: unsigned int, value: sizeof ( Product )
4 : | assign_scope | type: Product *, value: NULL
5 : | assign_scope | type: Product *, value: NULL
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
8 : | assign_scope | type: UNDEF, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc__terminate ( ERRNO_RECV ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc__terminate ( ERRNO_RECV ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0')]
compares = []
decls = [('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0')]
compares = ['', '']
===> context { cgc__terminate ( ERRNO_RECV ) ; }
ignore sibs: ["p -> desc [ bytes_recvd - 1 ] = '\\0' ;", '{ struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: Product *, var: p2
2 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
4 : | assign_scope | type: UNDEF, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: bytes_recvd
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; } ] 
p_decls = [('struct list *', 'tlv2', None), ('void *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv2', None), ('void *', 'tlv1', None)]
assigns = [('struct list *', 'tlv2', '', '& inv'), ('void *', 'tlv1', '', 'p')]
compares = []
decls = [('struct list *', 'tlv2', None), ('void *', 'tlv1', None), ('Product *', 'p', None), ('Product *', 'p2', None), ('int', 'bytes_recvd', None)]
assigns = [('struct list *', 'tlv2', '', '& inv'), ('void *', 'tlv1', '', 'p'), ('Product *', 'p', '', 'NULL'), ('Product *', 'p2', '', 'NULL'), ('int', 'bytes_recvd', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]'), ('UNDEF', 'p -> update_serial', '', '0'), ('UNDEF', 'p -> desc ', '[ bytes_recvd - 1 ]', "'\\0'")]
compares = []
===> context { struct list * tlv2 ; tlv2 = & inv ; void * tlv1 ; tlv1 = p ; cgc_list_insert_at_end ( tlv2 , tlv1 ) ; }
ignore sibs: ['return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv2
1 : |  decl_scope  | type: void *, var: tlv1
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: Product *, var: p2
4 : |  decl_scope  | type: int, var: bytes_recvd
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: void *, value: p
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: Product *, value: NULL
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
6 : | assign_scope | type: UNDEF, value: 0
7 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
compound scope 0 : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; }
compound scope 1 : { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; }
compound scope 2 : { return - 1 ; }
compound scope 3 : { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; }
compound scope 4 : { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
compares = []
===> context { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; struct node * np ; np = NULL ; RECV ( STDIN , bc , BARCODE_SZ ) ; { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } if ( NULL == np ) { return - 1 ; } { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: struct node *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; } ] 
p_decls = [('struct list *', 'tlv7', None), ('unsigned char *', 'tlv6', None), ('void *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv7', None), ('unsigned char *', 'tlv6', None), ('void *', 'tlv5', None)]
assigns = [('struct list *', 'tlv7', '', '& inv'), ('void *', 'tlv5', '', '( void * ) bc')]
compares = []
decls = [('struct list *', 'tlv7', None), ('unsigned char *', 'tlv6', None), ('void *', 'tlv5', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
assigns = [('struct list *', 'tlv7', '', '& inv'), ('void *', 'tlv5', '', '( void * ) bc'), ('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
compares = []
===> context { struct list * tlv7 ; tlv7 = & inv ; unsigned char * tlv6 ; tlv6 = cgc_prod_has_bc ; void * tlv5 ; tlv5 = ( void * ) bc ; np = cgc_list_find_node_with_data ( tlv7 , tlv6 , tlv5 ) ; }
ignore sibs: ['if ( NULL == np ) { return - 1 ; }', '{ struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; }', '{ struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv7
1 : |  decl_scope  | type: unsigned char *, var: tlv6
2 : |  decl_scope  | type: void *, var: tlv5
3 : |  decl_scope  | type: Product *, var: p
4 : |  decl_scope  | type: char *, var: bc
5 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
6 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: void *, value: ( void * ) bc
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: struct node *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['{ struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; }', '{ struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: struct node *, value: NULL
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: np
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; } ] 
p_decls = [('struct list *', 'tlv2', None), ('struct node *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv2', None), ('struct node *', 'tlv1', None)]
assigns = [('struct list *', 'tlv2', '', '& inv'), ('struct node *', 'tlv1', '', 'np')]
compares = []
decls = [('struct list *', 'tlv2', None), ('struct node *', 'tlv1', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
assigns = [('struct list *', 'tlv2', '', '& inv'), ('struct node *', 'tlv1', '', 'np'), ('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
compares = []
===> context { struct list * tlv2 ; tlv2 = & inv ; struct node * tlv1 ; tlv1 = np ; cgc_list_remove_node ( tlv2 , tlv1 ) ; }
ignore sibs: ['{ struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; }', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv2
1 : |  decl_scope  | type: struct node *, var: tlv1
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: char *, var: bc
4 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
5 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: struct node *, value: np
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: struct node *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; } ] 
p_decls = [('struct list *', 'tlv4', None), ('struct node * *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv4', None), ('struct node * *', 'tlv3', None)]
assigns = [('struct list *', 'tlv4', '', '& inv'), ('struct node * *', 'tlv3', '', '& np')]
compares = []
decls = [('struct list *', 'tlv4', None), ('struct node * *', 'tlv3', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('struct node *', 'np', None)]
assigns = [('struct list *', 'tlv4', '', '& inv'), ('struct node * *', 'tlv3', '', '& np'), ('Product *', 'p', '', 'NULL'), ('struct node *', 'np', '', 'NULL')]
compares = []
===> context { struct list * tlv4 ; tlv4 = & inv ; struct node * * tlv3 ; tlv3 = & np ; cgc_list_destroy_node ( tlv4 , tlv3 ) ; }
ignore sibs: ['return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv4
1 : |  decl_scope  | type: struct node * *, var: tlv3
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: char *, var: bc
4 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
5 : |  decl_scope  | type: struct node *, var: np
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: struct node * *, value: & np
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: struct node *, value: NULL
=======END=======
compound scope 0 : { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; }
compound scope 1 : { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
compound scope 2 : { return - 1 ; }
compound scope 3 : { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }
compound scope 4 : { cgc__terminate ( ERRNO_RECV ) ; }
len(compound_scope) : 5
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; } ] 
p_decls = [('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL'), ('UNDEF', 'desc_buf ', '[ bytes_recvd - 1 ]', "'\\0'")]
compares = []
===> context { int bytes_recvd ; bytes_recvd = 0 ; Product * p ; p = NULL ; unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ; char bc [ BARCODE_SZ ] = { 0 } ; char desc_buf [ MAX_DESC_LEN ] = { 0 } ; RECV ( STDIN , ( char * ) bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ; { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; } desc_buf [ bytes_recvd - 1 ] = '\0' ; desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ; p -> update_serial = cgc_get_next_update_serial ( ) ; ; return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: bytes_recvd
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: unsigned int *, var: ( * desc_copy )
3 : |  decl_scope  | type: unsigned int **, var: (
4 : |  decl_scope  | type: unsigned int, var: ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )
5 : |  decl_scope  | type: unsigned int, var: * desc_copy
6 : |  decl_scope  | type: unsigned int, var: dst
7 : |  decl_scope  | type: unsigned int, var: src
8 : |  decl_scope  | type: unsigned int, var: cnt
9 : |  decl_scope  | type: void *, var: dst
10 : |  decl_scope  | type: const void *, var: src
11 : |  decl_scope  | type: unsigned int, var: cnt
12 : |  decl_scope  | type: char *, var: bc
13 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
14 : |  decl_scope  | type: char *, var: desc_buf
15 : |  decl_scope  | type: char, var: desc_buf [ MAX_DESC_LEN ]
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
p_decls = [('char * *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv1', None)]
assigns = [('char * *', 'tlv1', '', '( char * ) bc')]
compares = []
decls = [('char * *', 'tlv1', None), ('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('char * *', 'tlv1', '', '( char * ) bc'), ('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL')]
compares = []
===> context { char * * tlv1 ; tlv1 = ( char * ) bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
ignore sibs: ['if ( NULL == p ) { return - 1 ; }', 'RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ;', '{ int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }', 'if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "desc_buf [ bytes_recvd - 1 ] = '\\0' ;", 'desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ;', 'p -> update_serial = cgc_get_next_update_serial ( ) ;', ';', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv1
1 : |  decl_scope  | type: int, var: bytes_recvd
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: unsigned int *, var: ( * desc_copy )
4 : |  decl_scope  | type: unsigned int **, var: (
5 : |  decl_scope  | type: unsigned int, var: ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )
6 : |  decl_scope  | type: unsigned int, var: * desc_copy
7 : |  decl_scope  | type: unsigned int, var: dst
8 : |  decl_scope  | type: unsigned int, var: src
9 : |  decl_scope  | type: unsigned int, var: cnt
10 : |  decl_scope  | type: void *, var: dst
11 : |  decl_scope  | type: const void *, var: src
12 : |  decl_scope  | type: unsigned int, var: cnt
13 : |  decl_scope  | type: char *, var: bc
14 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
15 : |  decl_scope  | type: char *, var: desc_buf
16 : |  decl_scope  | type: char, var: desc_buf [ MAX_DESC_LEN ]
0 : | assign_scope | type: char * *, value: ( char * ) bc
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: Product *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL')]
compares = []
decls = [('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['RECV ( STDIN , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ;', 'RECV ( STDIN , ( char * ) & p -> cost , sizeof ( float ) ) ;', '{ int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }', 'if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "desc_buf [ bytes_recvd - 1 ] = '\\0' ;", 'desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ;', 'p -> update_serial = cgc_get_next_update_serial ( ) ;', ';', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: int, var: bytes_recvd
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: unsigned int *, var: ( * desc_copy )
3 : |  decl_scope  | type: unsigned int **, var: (
4 : |  decl_scope  | type: unsigned int, var: ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )
5 : |  decl_scope  | type: unsigned int, var: * desc_copy
6 : |  decl_scope  | type: unsigned int, var: dst
7 : |  decl_scope  | type: unsigned int, var: src
8 : |  decl_scope  | type: unsigned int, var: cnt
9 : |  decl_scope  | type: void *, var: dst
10 : |  decl_scope  | type: const void *, var: src
11 : |  decl_scope  | type: unsigned int, var: cnt
12 : |  decl_scope  | type: char *, var: bc
13 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
14 : |  decl_scope  | type: char *, var: desc_buf
15 : |  decl_scope  | type: char, var: desc_buf [ MAX_DESC_LEN ]
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: Product *, value: NULL
0 : |compare_scopes| type: Product *, value: NULL
1 : |compare_scopes| type: Product *, value: p
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; } ] 
p_decls = [('int', 'tlv5', None), ('char', 'tlv4', None), ('char *', 'tlv3', None), ('unsigned int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv5', None), ('char', 'tlv4', None), ('char *', 'tlv3', None), ('unsigned int', 'tlv2', None)]
assigns = [('int', 'tlv5', '', 'STDIN'), ('char', 'tlv4', '', 'DESC_TERM [ 0 ]'), ('char *', 'tlv3', '', 'desc_buf'), ('unsigned int', 'tlv2', '', 'sizeof ( Product )')]
compares = []
decls = [('int', 'tlv5', None), ('char', 'tlv4', None), ('char *', 'tlv3', None), ('unsigned int', 'tlv2', None), ('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('int', 'tlv5', '', 'STDIN'), ('char', 'tlv4', '', 'DESC_TERM [ 0 ]'), ('char *', 'tlv3', '', 'desc_buf'), ('unsigned int', 'tlv2', '', 'sizeof ( Product )'), ('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL')]
compares = []
===> context { int tlv5 ; tlv5 = STDIN ; char tlv4 ; tlv4 = DESC_TERM [ 0 ] ; char * tlv3 ; tlv3 = desc_buf ; unsigned int tlv2 ; tlv2 = sizeof ( Product ) ; bytes_recvd = cgc_recv_until_delim_n ( tlv5 , tlv4 , tlv3 , tlv2 ) ; }
ignore sibs: ['if ( 0 >= bytes_recvd ) { cgc__terminate ( ERRNO_RECV ) ; }', "desc_buf [ bytes_recvd - 1 ] = '\\0' ;", 'desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ;', 'p -> update_serial = cgc_get_next_update_serial ( ) ;', ';', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: int, var: tlv5
1 : |  decl_scope  | type: char, var: tlv4
2 : |  decl_scope  | type: char *, var: tlv3
3 : |  decl_scope  | type: unsigned int, var: tlv2
4 : |  decl_scope  | type: int, var: bytes_recvd
5 : |  decl_scope  | type: Product *, var: p
6 : |  decl_scope  | type: unsigned int *, var: ( * desc_copy )
7 : |  decl_scope  | type: unsigned int **, var: (
8 : |  decl_scope  | type: unsigned int, var: ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )
9 : |  decl_scope  | type: unsigned int, var: * desc_copy
10 : |  decl_scope  | type: unsigned int, var: dst
11 : |  decl_scope  | type: unsigned int, var: src
12 : |  decl_scope  | type: unsigned int, var: cnt
13 : |  decl_scope  | type: void *, var: dst
14 : |  decl_scope  | type: const void *, var: src
15 : |  decl_scope  | type: unsigned int, var: cnt
16 : |  decl_scope  | type: char *, var: bc
17 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
18 : |  decl_scope  | type: char *, var: desc_buf
19 : |  decl_scope  | type: char, var: desc_buf [ MAX_DESC_LEN ]
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: char, value: DESC_TERM [ 0 ]
2 : | assign_scope | type: char *, value: desc_buf
3 : | assign_scope | type: unsigned int, value: sizeof ( Product )
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: Product *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc__terminate ( ERRNO_RECV ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc__terminate ( ERRNO_RECV ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL')]
compares = []
decls = [('int', 'bytes_recvd', None), ('Product *', 'p', None), ('unsigned int *', '( * desc_copy )', ' ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int **', '(', ' ( void * dst , const void * src , unsigned int cnt ) ( void * dst , const void * src , unsigned int cnt )'), ('unsigned int', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )', None), ('unsigned int', '* desc_copy', None), ('unsigned int', 'dst', None), ('unsigned int', 'src', None), ('unsigned int', 'cnt', None), ('void *', 'dst', None), ('const void *', 'src', None), ('unsigned int', 'cnt', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('char *', 'desc_buf', ' [ MAX_DESC_LEN ]'), ('char', 'desc_buf [ MAX_DESC_LEN ]', None)]
assigns = [('int', 'bytes_recvd', '', '0'), ('Product *', 'p', '', 'NULL')]
compares = ['', '']
===> context { cgc__terminate ( ERRNO_RECV ) ; }
ignore sibs: ["desc_buf [ bytes_recvd - 1 ] = '\\0' ;", 'desc_copy ( p -> desc , desc_buf , MAX_DESC_LEN ) ;', 'p -> update_serial = cgc_get_next_update_serial ( ) ;', ';', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: int, var: bytes_recvd
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: unsigned int *, var: ( * desc_copy )
3 : |  decl_scope  | type: unsigned int **, var: (
4 : |  decl_scope  | type: unsigned int, var: ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )
5 : |  decl_scope  | type: unsigned int, var: * desc_copy
6 : |  decl_scope  | type: unsigned int, var: dst
7 : |  decl_scope  | type: unsigned int, var: src
8 : |  decl_scope  | type: unsigned int, var: cnt
9 : |  decl_scope  | type: void *, var: dst
10 : |  decl_scope  | type: const void *, var: src
11 : |  decl_scope  | type: unsigned int, var: cnt
12 : |  decl_scope  | type: char *, var: bc
13 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
14 : |  decl_scope  | type: char *, var: desc_buf
15 : |  decl_scope  | type: char, var: desc_buf [ MAX_DESC_LEN ]
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: Product *, value: NULL
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: bytes_recvd
=======END=======
compound scope 0 : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; }
compound scope 1 : { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
compound scope 2 : { return - 1 ; }
compound scope 3 : { return - 1 ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ sale_percent ]')]
compares = []
===> context { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ; if ( 100 <= sale_percent ) { return - 1 ; } p -> sfn = onsale_fn [ sale_percent ] ; return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: UNDEF, value: onsale_fn [ sale_percent ]
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
p_decls = [('char * *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv1', None)]
assigns = [('char * *', 'tlv1', '', 'bc')]
compares = []
decls = [('char * *', 'tlv1', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('char * *', 'tlv1', '', 'bc'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = []
===> context { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
ignore sibs: ['if ( NULL == p ) { return - 1 ; }', 'RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ;', 'if ( 100 <= sale_percent ) { return - 1 ; }', 'p -> sfn = onsale_fn [ sale_percent ] ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv1
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: bc
3 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
4 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: char * *, value: bc
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['RECV ( STDIN , ( char * ) & sale_percent , sizeof ( unsigned int ) ) ;', 'if ( 100 <= sale_percent ) { return - 1 ; }', 'p -> sfn = onsale_fn [ sale_percent ] ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
0 : |compare_scopes| type: Product *, value: NULL
1 : |compare_scopes| type: Product *, value: p
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['p -> sfn = onsale_fn [ sale_percent ] ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
0 : |compare_scopes| type: unsigned int, value: 100
1 : |compare_scopes| type: unsigned int, value: sale_percent
=======END=======
compound scope 0 : { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; }
compound scope 1 : { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
compound scope 2 : { return - 1 ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0'), ('UNDEF', 'p -> sfn', '', 'onsale_fn [ 0 ]')]
compares = []
===> context { Product * p ; p = NULL ; char bc [ BARCODE_SZ ] = { 0 } ; unsigned int sale_percent ; sale_percent = 0 ; RECV ( STDIN , bc , BARCODE_SZ ) ; { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } if ( NULL == p ) { return - 1 ; } p -> sfn = onsale_fn [ 0 ] ; return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: UNDEF, value: onsale_fn [ 0 ]
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; } ] 
p_decls = [('char * *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char * *', 'tlv1', None)]
assigns = [('char * *', 'tlv1', '', 'bc')]
compares = []
decls = [('char * *', 'tlv1', None), ('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('char * *', 'tlv1', '', 'bc'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = []
===> context { char * * tlv1 ; tlv1 = bc ; p = cgc_get_product_by_barcode ( tlv1 ) ; }
ignore sibs: ['if ( NULL == p ) { return - 1 ; }', 'p -> sfn = onsale_fn [ 0 ] ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: char * *, var: tlv1
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: bc
3 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
4 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: char * *, value: bc
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'bc', ' [ BARCODE_SZ ]'), ('char', 'bc [ BARCODE_SZ ]', None), ('unsigned int', 'sale_percent', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'sale_percent', '', '0')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ['p -> sfn = onsale_fn [ 0 ] ;', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: bc
2 : |  decl_scope  | type: char, var: bc [ BARCODE_SZ ]
3 : |  decl_scope  | type: unsigned int, var: sale_percent
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
0 : |compare_scopes| type: Product *, value: NULL
1 : |compare_scopes| type: Product *, value: p
=======END=======
compound scope 0 : { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; }
compound scope 1 : { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; }
compound scope 2 : { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; }
compound scope 3 : { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; }
compound scope 4 : { return - 1 ; }
compound scope 5 : { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }
compound scope 6 : { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; }
compound scope 7 : { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; }
compound scope 8 : { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; }
compound scope 9 : { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }
compound scope 10 : { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; }
compound scope 11 : { SEND ( STDOUT , p -> desc , d_len ) ; }
compound scope 12 : { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }
len(compound_scope) : 13
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; } ] 
p_decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
===> context { Product * p ; p = NULL ; char options [ 4 ] = { 0 } ; unsigned int count ; { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } unsigned int d_len ; d_len = 0 ; float sale_price ; sale_price = 0.0 ; struct node * cur ; { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } struct node * end ; { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } RECV ( STDIN , options , sizeof ( options ) ) ; if ( 0 == count ) { return - 1 ; } while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } return SUCCESS ; }
ignore sibs: []
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: float, value: 0.0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; } ] 
p_decls = [('struct list *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv1', None)]
assigns = [('struct list *', 'tlv1', '', '& inv')]
compares = []
decls = [('struct list *', 'tlv1', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None)]
assigns = [('struct list *', 'tlv1', '', '& inv'), ('Product *', 'p', '', 'NULL')]
compares = []
===> context { struct list * tlv1 ; tlv1 = & inv ; count = cgc_list_length ( tlv1 ) ; }
ignore sibs: ['unsigned int d_len ;', 'd_len = 0 ;', 'float sale_price ;', 'sale_price = 0.0 ;', 'struct node * cur ;', '{ struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; }', 'struct node * end ;', '{ struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; }', 'RECV ( STDIN , options , sizeof ( options ) ) ;', 'if ( 0 == count ) { return - 1 ; }', "while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }", 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv1
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: options
3 : |  decl_scope  | type: char, var: options [ 4 ]
4 : |  decl_scope  | type: unsigned int, var: count
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: Product *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; } ] 
p_decls = [('struct list *', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv2', None)]
assigns = [('struct list *', 'tlv2', '', '& inv')]
compares = []
decls = [('struct list *', 'tlv2', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None)]
assigns = [('struct list *', 'tlv2', '', '& inv'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
===> context { struct list * tlv2 ; tlv2 = & inv ; cur = cgc_list_head_node ( tlv2 ) ; }
ignore sibs: ['struct node * end ;', '{ struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; }', 'RECV ( STDIN , options , sizeof ( options ) ) ;', 'if ( 0 == count ) { return - 1 ; }', "while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }", 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv2
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: options
3 : |  decl_scope  | type: char, var: options [ 4 ]
4 : |  decl_scope  | type: unsigned int, var: count
5 : |  decl_scope  | type: unsigned int, var: d_len
6 : |  decl_scope  | type: float, var: sale_price
7 : |  decl_scope  | type: struct node *, var: cur
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: 0.0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; } ] 
p_decls = [('struct list *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv3', None)]
assigns = [('struct list *', 'tlv3', '', '& inv')]
compares = []
decls = [('struct list *', 'tlv3', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('struct list *', 'tlv3', '', '& inv'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
===> context { struct list * tlv3 ; tlv3 = & inv ; end = cgc_list_end_marker ( tlv3 ) ; }
ignore sibs: ['RECV ( STDIN , options , sizeof ( options ) ) ;', 'if ( 0 == count ) { return - 1 ; }', "while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }", 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct list *, var: tlv3
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: options
3 : |  decl_scope  | type: char, var: options [ 4 ]
4 : |  decl_scope  | type: unsigned int, var: count
5 : |  decl_scope  | type: unsigned int, var: d_len
6 : |  decl_scope  | type: float, var: sale_price
7 : |  decl_scope  | type: struct node *, var: cur
8 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: struct list *, value: & inv
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: 0.0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '']
===> context { return - 1 ; }
ignore sibs: ["while ( ( NULL != cur ) && ( cur != end ) ) { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }", 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: float, value: 0.0
0 : |compare_scopes| type: unsigned int, value: 0
1 : |compare_scopes| type: unsigned int, value: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('Product *', 'p', '', '( Product * ) cur -> data')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', '( Product * ) cur -> data'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', '( Product * ) cur -> data'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
===> context { p = ( Product * ) cur -> data ; SEND ( STDOUT , ( char * ) p -> barcode , BARCODE_SZ ) ; if ( 0 == options [ 0 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } }
ignore sibs: ['return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: 0.0
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
===> context { SEND ( STDOUT , ( char * ) & p -> model_num , sizeof ( unsigned int ) ) ; }
ignore sibs: ['if ( 0 != options [ 1 ] % 2 ) { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; }', 'if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; }', "if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }", '{ struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }', '}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: float, value: 0.0
3 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
4 : |compare_scopes| type: char *, value: 0
5 : |compare_scopes| type: char *, value: options [ 0 ] % 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
===> context { SEND ( STDOUT , ( char * ) & p -> cost , sizeof ( float ) ) ; }
ignore sibs: ['if ( 0 == options [ 2 ] % 2 ) { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; }', "if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }", '{ struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }', '}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: float, value: 0.0
3 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
4 : |compare_scopes| type: char *, value: 0
5 : |compare_scopes| type: char *, value: options [ 1 ] % 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('float', 'sale_price', '', 'p -> sfn ( p -> model_num , p -> cost )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
===> context { sale_price = p -> sfn ( p -> model_num , p -> cost ) ; SEND ( STDOUT , ( char * ) & sale_price , sizeof ( float ) ) ; }
ignore sibs: ["if ( 0 != options [ 3 ] % 2 ) { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }", '{ struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }', '}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: float, value: p -> sfn ( p -> model_num , p -> cost )
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: 0.0
4 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
4 : |compare_scopes| type: char *, value: 0
5 : |compare_scopes| type: char *, value: options [ 2 ] % 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
===> context { { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; } SEND ( STDOUT , DESC_TERM , 1 ) ; }
ignore sibs: ['{ struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }', '}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: float, value: 0.0
3 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
4 : |compare_scopes| type: char *, value: 0
5 : |compare_scopes| type: char *, value: options [ 3 ] % 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None)]
assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )')]
compares = []
decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
decls = [('const char *', 'tlv6', None), ('char', 'tlv5', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('char', 'tlv5', '', "'\\0'"), ('unsigned int', 'd_len', '', 'cgc_strlen ( tlv6 , tlv5 )'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
===> context { const char * tlv6 = p -> desc ; char tlv5 ; tlv5 = '\0' ; d_len = cgc_strlen ( tlv6 , tlv5 ) ; }
ignore sibs: ['if ( 0 < d_len ) { SEND ( STDOUT , p -> desc , d_len ) ; }', 'SEND ( STDOUT , DESC_TERM , 1 ) ;', '}', '{ struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }', '}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: char, var: tlv5
2 : |  decl_scope  | type: Product *, var: p
3 : |  decl_scope  | type: char *, var: options
4 : |  decl_scope  | type: char, var: options [ 4 ]
5 : |  decl_scope  | type: unsigned int, var: count
6 : |  decl_scope  | type: unsigned int, var: d_len
7 : |  decl_scope  | type: float, var: sale_price
8 : |  decl_scope  | type: struct node *, var: cur
9 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: char, value: '\0'
1 : | assign_scope | type: unsigned int, value: cgc_strlen ( tlv6 , tlv5 )
2 : | assign_scope | type: Product *, value: NULL
3 : | assign_scope | type: unsigned int, value: 0
4 : | assign_scope | type: float, value: 0.0
5 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
4 : |compare_scopes| type: char *, value: 0
5 : |compare_scopes| type: char *, value: options [ 3 ] % 2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , p -> desc , d_len ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { SEND ( STDOUT , p -> desc , d_len ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '']
decls = [('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '', '', '', '', '']
===> context { SEND ( STDOUT , p -> desc , d_len ) ; }
ignore sibs: ['SEND ( STDOUT , DESC_TERM , 1 ) ;', '}', '{ struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }', '}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: Product *, var: p
1 : |  decl_scope  | type: char *, var: options
2 : |  decl_scope  | type: char, var: options [ 4 ]
3 : |  decl_scope  | type: unsigned int, var: count
4 : |  decl_scope  | type: unsigned int, var: d_len
5 : |  decl_scope  | type: float, var: sale_price
6 : |  decl_scope  | type: struct node *, var: cur
7 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: Product *, value: NULL
1 : | assign_scope | type: unsigned int, value: 0
2 : | assign_scope | type: float, value: 0.0
3 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
4 : |compare_scopes| type: char *, value: 0
5 : |compare_scopes| type: char *, value: options [ 3 ] % 2
6 : |compare_scopes| type: unsigned int, value: 0
7 : |compare_scopes| type: unsigned int, value: d_len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; } ] 
p_decls = [('struct node *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct node *', 'tlv4', None)]
assigns = [('struct node *', 'tlv4', '', 'cur')]
compares = []
decls = [('struct node *', 'tlv4', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('struct node *', 'tlv4', '', 'cur'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = []
decls = [('struct node *', 'tlv4', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('struct node *', 'tlv4', '', 'cur'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0')]
compares = ['', '', '', '']
decls = [('struct node *', 'tlv4', None), ('Product *', 'p', None), ('char *', 'options', ' [ 4 ]'), ('char', 'options [ 4 ]', None), ('unsigned int', 'count', None), ('unsigned int', 'd_len', None), ('float', 'sale_price', None), ('struct node *', 'cur', None), ('struct node *', 'end', None)]
assigns = [('struct node *', 'tlv4', '', 'cur'), ('Product *', 'p', '', 'NULL'), ('unsigned int', 'd_len', '', '0'), ('float', 'sale_price', '', '0.0'), ('Product *', 'p', '', '( Product * ) cur -> data')]
compares = ['', '', '', '']
===> context { struct node * tlv4 ; tlv4 = cur ; cur = cgc_list_next_node ( tlv4 ) ; }
ignore sibs: ['}', 'return SUCCESS ;', '}']
0 : |  decl_scope  | type: struct node *, var: tlv4
1 : |  decl_scope  | type: Product *, var: p
2 : |  decl_scope  | type: char *, var: options
3 : |  decl_scope  | type: char, var: options [ 4 ]
4 : |  decl_scope  | type: unsigned int, var: count
5 : |  decl_scope  | type: unsigned int, var: d_len
6 : |  decl_scope  | type: float, var: sale_price
7 : |  decl_scope  | type: struct node *, var: cur
8 : |  decl_scope  | type: struct node *, var: end
0 : | assign_scope | type: struct node *, value: cur
1 : | assign_scope | type: Product *, value: NULL
2 : | assign_scope | type: unsigned int, value: 0
3 : | assign_scope | type: float, value: 0.0
4 : | assign_scope | type: Product *, value: ( Product * ) cur -> data
0 : |compare_scopes| type: struct node *, value: NULL
1 : |compare_scopes| type: struct node *, value: cur
2 : |compare_scopes| type: struct node *, value: cur
3 : |compare_scopes| type: struct node *, value: end
=======END=======
compound scope 0 : { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } }
compound scope 1 : { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; }
compound scope 2 : { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
===> context { { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } }
ignore sibs: []
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; } ] 
p_decls = [('struct list *', 'tlv2', None), ('nodeDataFreeFn', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('struct list *', 'tlv2', None), ('nodeDataFreeFn', 'tlv1', None)]
assigns = [('struct list *', 'tlv2', '', '& inv')]
compares = []
decls = [('struct list *', 'tlv2', None), ('nodeDataFreeFn', 'tlv1', None)]
assigns = [('struct list *', 'tlv2', '', '& inv')]
compares = []
===> context { struct list * tlv2 ; tlv2 = & inv ; nodeDataFreeFn tlv1 = cgc_free ; cgc_list_init ( tlv2 , tlv1 ) ; }
ignore sibs: ['{ Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; }', '}']
0 : |  decl_scope  | type: struct list *, var: tlv2
1 : |  decl_scope  | type: nodeDataFreeFn, var: tlv1
0 : | assign_scope | type: struct list *, value: & inv
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; } ] 
p_decls = [('Inventory *', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('Inventory *', 'tlv3', None)]
assigns = [('Inventory *', 'tlv3', '', '& inv')]
compares = []
decls = [('Inventory *', 'tlv3', None)]
assigns = [('Inventory *', 'tlv3', '', '& inv')]
compares = []
===> context { Inventory * tlv3 ; tlv3 = & inv ; cgc_load_inventory ( tlv3 ) ; }
ignore sibs: ['}']
0 : |  decl_scope  | type: Inventory *, var: tlv3
0 : | assign_scope | type: Inventory *, value: & inv
=======END=======
compound scope 0 : { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; }
compound scope 1 : { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; }
compound scope 2 : { ret = cgc_do_buy ( ) ; }
compound scope 3 : { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } }
compound scope 4 : { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; }
compound scope 5 : { ret = cgc_do_check ( ) ; }
compound scope 6 : { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } }
compound scope 7 : { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; }
compound scope 8 : { ret = cgc_do_add ( ) ; }
compound scope 9 : { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } }
compound scope 10 : { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; }
compound scope 11 : { ret = cgc_do_rm ( ) ; }
compound scope 12 : { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } }
compound scope 13 : { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; }
compound scope 14 : { ret = cgc_do_update ( ) ; }
compound scope 15 : { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } }
compound scope 16 : { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; }
compound scope 17 : { ret = cgc_do_onsale ( ) ; }
compound scope 18 : { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } }
compound scope 19 : { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; }
compound scope 20 : { ret = cgc_do_nosale ( ) ; }
compound scope 21 : { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } }
compound scope 22 : { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; }
compound scope 23 : { ret = cgc_do_list ( ) ; }
compound scope 24 : { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } }
compound scope 25 : { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; }
compound scope 26 : { ret = - 2 ; }
compound scope 27 : { ret = - 1 ; }
len(compound_scope) : 28
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; } ] 
p_decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { char cmd [ 4 ] ; short ret ; ret = 0 ; RECV ( STDIN , cmd , sizeof ( cmd ) ) ; int tlv1 ; { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } return ret ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; } ] 
p_decls = [('void *', 'tlv12', None), ('void *', 'tlv11', None), ('unsigned int', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv12', None), ('void *', 'tlv11', None), ('unsigned int', 'tlv10', None)]
assigns = [('void *', 'tlv12', '', '( void * ) CMD_BUY'), ('void *', 'tlv11', '', 'cmd'), ('unsigned int', 'tlv10', '', 'sizeof ( CMD_BUY )')]
compares = []
decls = [('void *', 'tlv12', None), ('void *', 'tlv11', None), ('unsigned int', 'tlv10', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv12', '', '( void * ) CMD_BUY'), ('void *', 'tlv11', '', 'cmd'), ('unsigned int', 'tlv10', '', 'sizeof ( CMD_BUY )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv12 ; tlv12 = ( void * ) CMD_BUY ; void * tlv11 ; tlv11 = cmd ; unsigned int tlv10 ; tlv10 = sizeof ( CMD_BUY ) ; tlv1 = cgc_memcmp ( tlv12 , tlv11 , tlv10 ) ; }
ignore sibs: ['if ( 0 == tlv1 ) { ret = cgc_do_buy ( ) ; } else { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } }', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv12
1 : |  decl_scope  | type: void *, var: tlv11
2 : |  decl_scope  | type: unsigned int, var: tlv10
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: void *, value: ( void * ) CMD_BUY
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_BUY )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_buy ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_buy ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_buy ( ) ; }
ignore sibs: ['else', '{ int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } }', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } } ] 
p_decls = [('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv2', None)]
assigns = []
compares = []
decls = [('int', 'tlv2', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv2 ; { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } }
ignore sibs: ['return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv2
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; } ] 
p_decls = [('void *', 'tlv15', None), ('void *', 'tlv14', None), ('unsigned int', 'tlv13', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv15', None), ('void *', 'tlv14', None), ('unsigned int', 'tlv13', None)]
assigns = [('void *', 'tlv15', '', '( void * ) CMD_CHECK'), ('void *', 'tlv14', '', 'cmd'), ('unsigned int', 'tlv13', '', 'sizeof ( CMD_CHECK )')]
compares = []
decls = [('void *', 'tlv15', None), ('void *', 'tlv14', None), ('unsigned int', 'tlv13', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv15', '', '( void * ) CMD_CHECK'), ('void *', 'tlv14', '', 'cmd'), ('unsigned int', 'tlv13', '', 'sizeof ( CMD_CHECK )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv15', None), ('void *', 'tlv14', None), ('unsigned int', 'tlv13', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv15', '', '( void * ) CMD_CHECK'), ('void *', 'tlv14', '', 'cmd'), ('unsigned int', 'tlv13', '', 'sizeof ( CMD_CHECK )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv15 ; tlv15 = ( void * ) CMD_CHECK ; void * tlv14 ; tlv14 = cmd ; unsigned int tlv13 ; tlv13 = sizeof ( CMD_CHECK ) ; tlv2 = cgc_memcmp ( tlv15 , tlv14 , tlv13 ) ; }
ignore sibs: ['if ( 0 == tlv2 ) { ret = cgc_do_check ( ) ; } else { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } }', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv15
1 : |  decl_scope  | type: void *, var: tlv14
2 : |  decl_scope  | type: unsigned int, var: tlv13
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: void *, value: ( void * ) CMD_CHECK
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_CHECK )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_check ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_check ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_check ( ) ; }
ignore sibs: ['else', '{ int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } }', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv2
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } } ] 
p_decls = [('int', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None)]
assigns = []
compares = []
decls = [('int', 'tlv3', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv3', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv3 ; { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } }
ignore sibs: ['}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; } ] 
p_decls = [('void *', 'tlv18', None), ('void *', 'tlv17', None), ('unsigned int', 'tlv16', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv18', None), ('void *', 'tlv17', None), ('unsigned int', 'tlv16', None)]
assigns = [('void *', 'tlv18', '', '( void * ) CMD_ADD'), ('void *', 'tlv17', '', 'cmd'), ('unsigned int', 'tlv16', '', 'sizeof ( CMD_ADD )')]
compares = []
decls = [('void *', 'tlv18', None), ('void *', 'tlv17', None), ('unsigned int', 'tlv16', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv18', '', '( void * ) CMD_ADD'), ('void *', 'tlv17', '', 'cmd'), ('unsigned int', 'tlv16', '', 'sizeof ( CMD_ADD )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv18', None), ('void *', 'tlv17', None), ('unsigned int', 'tlv16', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv18', '', '( void * ) CMD_ADD'), ('void *', 'tlv17', '', 'cmd'), ('unsigned int', 'tlv16', '', 'sizeof ( CMD_ADD )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv18', None), ('void *', 'tlv17', None), ('unsigned int', 'tlv16', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv18', '', '( void * ) CMD_ADD'), ('void *', 'tlv17', '', 'cmd'), ('unsigned int', 'tlv16', '', 'sizeof ( CMD_ADD )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv18 ; tlv18 = ( void * ) CMD_ADD ; void * tlv17 ; tlv17 = cmd ; unsigned int tlv16 ; tlv16 = sizeof ( CMD_ADD ) ; tlv3 = cgc_memcmp ( tlv18 , tlv17 , tlv16 ) ; }
ignore sibs: ['if ( 0 == tlv3 ) { ret = cgc_do_add ( ) ; } else { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } }', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv18
1 : |  decl_scope  | type: void *, var: tlv17
2 : |  decl_scope  | type: unsigned int, var: tlv16
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: void *, value: ( void * ) CMD_ADD
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_ADD )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_add ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_add ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_add ( ) ; }
ignore sibs: ['else', '{ int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } }', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv3
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } } ] 
p_decls = [('int', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None)]
assigns = []
compares = []
decls = [('int', 'tlv4', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv4 ; { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } }
ignore sibs: ['}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; } ] 
p_decls = [('void *', 'tlv21', None), ('void *', 'tlv20', None), ('unsigned int', 'tlv19', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv21', None), ('void *', 'tlv20', None), ('unsigned int', 'tlv19', None)]
assigns = [('void *', 'tlv21', '', '( void * ) CMD_RM'), ('void *', 'tlv20', '', 'cmd'), ('unsigned int', 'tlv19', '', 'sizeof ( CMD_RM )')]
compares = []
decls = [('void *', 'tlv21', None), ('void *', 'tlv20', None), ('unsigned int', 'tlv19', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv21', '', '( void * ) CMD_RM'), ('void *', 'tlv20', '', 'cmd'), ('unsigned int', 'tlv19', '', 'sizeof ( CMD_RM )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv21', None), ('void *', 'tlv20', None), ('unsigned int', 'tlv19', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv21', '', '( void * ) CMD_RM'), ('void *', 'tlv20', '', 'cmd'), ('unsigned int', 'tlv19', '', 'sizeof ( CMD_RM )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv21', None), ('void *', 'tlv20', None), ('unsigned int', 'tlv19', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv21', '', '( void * ) CMD_RM'), ('void *', 'tlv20', '', 'cmd'), ('unsigned int', 'tlv19', '', 'sizeof ( CMD_RM )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv21', None), ('void *', 'tlv20', None), ('unsigned int', 'tlv19', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('void *', 'tlv21', '', '( void * ) CMD_RM'), ('void *', 'tlv20', '', 'cmd'), ('unsigned int', 'tlv19', '', 'sizeof ( CMD_RM )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv21 ; tlv21 = ( void * ) CMD_RM ; void * tlv20 ; tlv20 = cmd ; unsigned int tlv19 ; tlv19 = sizeof ( CMD_RM ) ; tlv4 = cgc_memcmp ( tlv21 , tlv20 , tlv19 ) ; }
ignore sibs: ['if ( 0 == tlv4 ) { ret = cgc_do_rm ( ) ; } else { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } }', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv21
1 : |  decl_scope  | type: void *, var: tlv20
2 : |  decl_scope  | type: unsigned int, var: tlv19
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
9 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: void *, value: ( void * ) CMD_RM
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_RM )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_rm ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_rm ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_rm ( ) ; }
ignore sibs: ['else', '{ int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } }', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv4
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } } ] 
p_decls = [('int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv5', None)]
assigns = []
compares = []
decls = [('int', 'tlv5', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv5', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv5 ; { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } }
ignore sibs: ['}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv5
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: int, var: tlv3
7 : |  decl_scope  | type: int, var: tlv4
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; } ] 
p_decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None)]
assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )')]
compares = []
decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv24', None), ('void *', 'tlv23', None), ('unsigned int', 'tlv22', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('void *', 'tlv24', '', '( void * ) CMD_UPDATE'), ('void *', 'tlv23', '', 'cmd'), ('unsigned int', 'tlv22', '', 'sizeof ( CMD_UPDATE )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv24 ; tlv24 = ( void * ) CMD_UPDATE ; void * tlv23 ; tlv23 = cmd ; unsigned int tlv22 ; tlv22 = sizeof ( CMD_UPDATE ) ; tlv5 = cgc_memcmp ( tlv24 , tlv23 , tlv22 ) ; }
ignore sibs: ['if ( 0 == tlv5 ) { ret = cgc_do_update ( ) ; } else { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } }', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv24
1 : |  decl_scope  | type: void *, var: tlv23
2 : |  decl_scope  | type: unsigned int, var: tlv22
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
9 : |  decl_scope  | type: int, var: tlv4
10 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: void *, value: ( void * ) CMD_UPDATE
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_UPDATE )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_update ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_update ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_update ( ) ; }
ignore sibs: ['else', '{ int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } }', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
7 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv5
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } } ] 
p_decls = [('int', 'tlv6', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv6', None)]
assigns = []
compares = []
decls = [('int', 'tlv6', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv6', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv6', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv6', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv6', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv6 ; { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } }
ignore sibs: ['}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv6
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: int, var: tlv3
7 : |  decl_scope  | type: int, var: tlv4
8 : |  decl_scope  | type: int, var: tlv5
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; } ] 
p_decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )')]
compares = []
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv27', None), ('void *', 'tlv26', None), ('unsigned int', 'tlv25', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('void *', 'tlv27', '', '( void * ) CMD_ONSALE'), ('void *', 'tlv26', '', 'cmd'), ('unsigned int', 'tlv25', '', 'sizeof ( CMD_ONSALE )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv27 ; tlv27 = ( void * ) CMD_ONSALE ; void * tlv26 ; tlv26 = cmd ; unsigned int tlv25 ; tlv25 = sizeof ( CMD_ONSALE ) ; tlv6 = cgc_memcmp ( tlv27 , tlv26 , tlv25 ) ; }
ignore sibs: ['if ( 0 == tlv6 ) { ret = cgc_do_onsale ( ) ; } else { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } }', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv27
1 : |  decl_scope  | type: void *, var: tlv26
2 : |  decl_scope  | type: unsigned int, var: tlv25
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
9 : |  decl_scope  | type: int, var: tlv4
10 : |  decl_scope  | type: int, var: tlv5
11 : |  decl_scope  | type: int, var: tlv6
0 : | assign_scope | type: void *, value: ( void * ) CMD_ONSALE
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_ONSALE )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_onsale ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_onsale ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_onsale ( ) ; }
ignore sibs: ['else', '{ int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } }', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
7 : |  decl_scope  | type: int, var: tlv5
8 : |  decl_scope  | type: int, var: tlv6
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv6
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } } ] 
p_decls = [('int', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv7', None)]
assigns = []
compares = []
decls = [('int', 'tlv7', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv7', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv7', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv7', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv7', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv7', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv7 ; { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } }
ignore sibs: ['}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv7
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: int, var: tlv3
7 : |  decl_scope  | type: int, var: tlv4
8 : |  decl_scope  | type: int, var: tlv5
9 : |  decl_scope  | type: int, var: tlv6
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; } ] 
p_decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv30', None), ('void *', 'tlv29', None), ('unsigned int', 'tlv28', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('void *', 'tlv30', '', '( void * ) CMD_NOSALE'), ('void *', 'tlv29', '', 'cmd'), ('unsigned int', 'tlv28', '', 'sizeof ( CMD_NOSALE )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv30 ; tlv30 = ( void * ) CMD_NOSALE ; void * tlv29 ; tlv29 = cmd ; unsigned int tlv28 ; tlv28 = sizeof ( CMD_NOSALE ) ; tlv7 = cgc_memcmp ( tlv30 , tlv29 , tlv28 ) ; }
ignore sibs: ['if ( 0 == tlv7 ) { ret = cgc_do_nosale ( ) ; } else { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } }', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv30
1 : |  decl_scope  | type: void *, var: tlv29
2 : |  decl_scope  | type: unsigned int, var: tlv28
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
9 : |  decl_scope  | type: int, var: tlv4
10 : |  decl_scope  | type: int, var: tlv5
11 : |  decl_scope  | type: int, var: tlv6
12 : |  decl_scope  | type: int, var: tlv7
0 : | assign_scope | type: void *, value: ( void * ) CMD_NOSALE
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_NOSALE )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_nosale ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_nosale ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_nosale ( ) ; }
ignore sibs: ['else', '{ int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } }', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
7 : |  decl_scope  | type: int, var: tlv5
8 : |  decl_scope  | type: int, var: tlv6
9 : |  decl_scope  | type: int, var: tlv7
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv7
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } } ] 
p_decls = [('int', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv8', None)]
assigns = []
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv8', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv8 ; { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } }
ignore sibs: ['}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv8
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: int, var: tlv3
7 : |  decl_scope  | type: int, var: tlv4
8 : |  decl_scope  | type: int, var: tlv5
9 : |  decl_scope  | type: int, var: tlv6
10 : |  decl_scope  | type: int, var: tlv7
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; } ] 
p_decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv33', None), ('void *', 'tlv32', None), ('unsigned int', 'tlv31', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('void *', 'tlv33', '', '( void * ) CMD_LIST'), ('void *', 'tlv32', '', 'cmd'), ('unsigned int', 'tlv31', '', 'sizeof ( CMD_LIST )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv33 ; tlv33 = ( void * ) CMD_LIST ; void * tlv32 ; tlv32 = cmd ; unsigned int tlv31 ; tlv31 = sizeof ( CMD_LIST ) ; tlv8 = cgc_memcmp ( tlv33 , tlv32 , tlv31 ) ; }
ignore sibs: ['if ( 0 == tlv8 ) { ret = cgc_do_list ( ) ; } else { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } }', '}', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv33
1 : |  decl_scope  | type: void *, var: tlv32
2 : |  decl_scope  | type: unsigned int, var: tlv31
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
9 : |  decl_scope  | type: int, var: tlv4
10 : |  decl_scope  | type: int, var: tlv5
11 : |  decl_scope  | type: int, var: tlv6
12 : |  decl_scope  | type: int, var: tlv7
13 : |  decl_scope  | type: int, var: tlv8
0 : | assign_scope | type: void *, value: ( void * ) CMD_LIST
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_LIST )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_list ( ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = cgc_do_list ( ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = []
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = cgc_do_list ( ) ; }
ignore sibs: ['else', '{ int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } }', '}', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
7 : |  decl_scope  | type: int, var: tlv5
8 : |  decl_scope  | type: int, var: tlv6
9 : |  decl_scope  | type: int, var: tlv7
10 : |  decl_scope  | type: int, var: tlv8
0 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv8
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } } ] 
p_decls = [('int', 'tlv9', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv9', None)]
assigns = []
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv9', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('short', 'ret', '', '0')]
compares = []
===> context { int tlv9 ; { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; } }
ignore sibs: ['}', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: int, var: tlv9
1 : |  decl_scope  | type: char *, var: cmd
2 : |  decl_scope  | type: char, var: cmd [ 4 ]
3 : |  decl_scope  | type: short, var: ret
4 : |  decl_scope  | type: int, var: tlv1
5 : |  decl_scope  | type: int, var: tlv2
6 : |  decl_scope  | type: int, var: tlv3
7 : |  decl_scope  | type: int, var: tlv4
8 : |  decl_scope  | type: int, var: tlv5
9 : |  decl_scope  | type: int, var: tlv6
10 : |  decl_scope  | type: int, var: tlv7
11 : |  decl_scope  | type: int, var: tlv8
0 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; } ] 
p_decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
decls = [('void *', 'tlv36', None), ('void *', 'tlv35', None), ('unsigned int', 'tlv34', None), ('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None), ('int', 'tlv9', None)]
assigns = [('void *', 'tlv36', '', '( void * ) CMD_QUIT'), ('void *', 'tlv35', '', 'cmd'), ('unsigned int', 'tlv34', '', 'sizeof ( CMD_QUIT )'), ('short', 'ret', '', '0')]
compares = []
===> context { void * tlv36 ; tlv36 = ( void * ) CMD_QUIT ; void * tlv35 ; tlv35 = cmd ; unsigned int tlv34 ; tlv34 = sizeof ( CMD_QUIT ) ; tlv9 = cgc_memcmp ( tlv36 , tlv35 , tlv34 ) ; }
ignore sibs: ['if ( 0 == tlv9 ) { ret = - 2 ; } else { ret = - 1 ; }', '}', '}', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: void *, var: tlv36
1 : |  decl_scope  | type: void *, var: tlv35
2 : |  decl_scope  | type: unsigned int, var: tlv34
3 : |  decl_scope  | type: char *, var: cmd
4 : |  decl_scope  | type: char, var: cmd [ 4 ]
5 : |  decl_scope  | type: short, var: ret
6 : |  decl_scope  | type: int, var: tlv1
7 : |  decl_scope  | type: int, var: tlv2
8 : |  decl_scope  | type: int, var: tlv3
9 : |  decl_scope  | type: int, var: tlv4
10 : |  decl_scope  | type: int, var: tlv5
11 : |  decl_scope  | type: int, var: tlv6
12 : |  decl_scope  | type: int, var: tlv7
13 : |  decl_scope  | type: int, var: tlv8
14 : |  decl_scope  | type: int, var: tlv9
0 : | assign_scope | type: void *, value: ( void * ) CMD_QUIT
1 : | assign_scope | type: void *, value: cmd
2 : | assign_scope | type: unsigned int, value: sizeof ( CMD_QUIT )
3 : | assign_scope | type: short, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = - 2 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = - 2 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [10] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('short', 'ret', '', '- 2')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None), ('int', 'tlv9', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None), ('int', 'tlv9', None)]
assigns = [('short', 'ret', '', '- 2'), ('short', 'ret', '', '0')]
compares = ['', '']
===> context { ret = - 2 ; }
ignore sibs: ['else', '{ ret = - 1 ; }', '}', '}', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
7 : |  decl_scope  | type: int, var: tlv5
8 : |  decl_scope  | type: int, var: tlv6
9 : |  decl_scope  | type: int, var: tlv7
10 : |  decl_scope  | type: int, var: tlv8
11 : |  decl_scope  | type: int, var: tlv9
0 : | assign_scope | type: short, value: - 2
1 : | assign_scope | type: short, value: 0
0 : |compare_scopes| type: int, value: 0
1 : |compare_scopes| type: int, value: tlv9
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = - 1 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = - 1 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [7] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [8] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [9] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('short', 'ret', '', '- 1')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
decls = [('char *', 'cmd', ' [ 4 ]'), ('char', 'cmd [ 4 ]', None), ('short', 'ret', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'tlv3', None), ('int', 'tlv4', None), ('int', 'tlv5', None), ('int', 'tlv6', None), ('int', 'tlv7', None), ('int', 'tlv8', None), ('int', 'tlv9', None)]
assigns = [('short', 'ret', '', '- 1'), ('short', 'ret', '', '0')]
compares = []
===> context { ret = - 1 ; }
ignore sibs: ['}', '}', '}', '}', '}', '}', '}', '}', 'return ret ;', '}']
0 : |  decl_scope  | type: char *, var: cmd
1 : |  decl_scope  | type: char, var: cmd [ 4 ]
2 : |  decl_scope  | type: short, var: ret
3 : |  decl_scope  | type: int, var: tlv1
4 : |  decl_scope  | type: int, var: tlv2
5 : |  decl_scope  | type: int, var: tlv3
6 : |  decl_scope  | type: int, var: tlv4
7 : |  decl_scope  | type: int, var: tlv5
8 : |  decl_scope  | type: int, var: tlv6
9 : |  decl_scope  | type: int, var: tlv7
10 : |  decl_scope  | type: int, var: tlv8
11 : |  decl_scope  | type: int, var: tlv9
0 : | assign_scope | type: short, value: - 1
1 : | assign_scope | type: short, value: 0
=======END=======
def_vars[0]: [cgc_get_next_update_serial] : <class 'CParser.CParser.DeclarationContext'> : unsigned int base ;
def_vars[1]: [cgc_get_next_update_serial] : <class 'CParser.CParser.DeclarationContext'> : unsigned int next_update_serial ;
sym_lut=>'{'void': 'int', 'base': 'unsigned int', 'next_update_serial': 'unsigned int'}'
val_s=>'[('unsigned int', 'base', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712f828>), ('unsigned int', 'next_update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff679f1ac8>)]'
cval_s=>'[]'
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(unsignedint*)FLAG_PAGE' - False OR  False
[i=0/13][j=0/1][dd=0/2][k=0/2] | type: unsigned int ; var : base ; varinfo :  ; value_node : * ( unsigned int * ) FLAG_PAGE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,unsigned,int,*,),FLAG_PAGE
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) unsigned [vtype=None]
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) FLAG_PAGE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'base+cgc_update_serial' - False OR  False
[i=0/13][j=0/1][dd=0/2][k=1/2] | type: unsigned int ; var : next_update_serial ; varinfo :  ; value_node : base + cgc_update_serial (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : base,+,cgc_update_serial
 => is literal (False) | is operator (False) base [vtype=unsigned int]
unique : ('unsigned int', 'base', None)
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_update_serial [vtype=None]
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*(unsignedint*)FLAG_PAGE' - False OR  False
[i=0/13][j=0/1][dd=1/2][k=0/2] | type: unsigned int ; var : base ; varinfo :  ; value_node : * ( unsigned int * ) FLAG_PAGE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,unsigned,int,*,),FLAG_PAGE
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) unsigned [vtype=None]
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) FLAG_PAGE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'base+cgc_update_serial' - False OR  False
[i=0/13][j=0/1][dd=1/2][k=1/2] | type: unsigned int ; var : next_update_serial ; varinfo :  ; value_node : base + cgc_update_serial (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : base,+,cgc_update_serial
 => is literal (False) | is operator (False) base [vtype=unsigned int]
not unique: ('unsigned int', 'base', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (False) | is operator (False) cgc_update_serial [vtype=None]
----
UNIQ_INIT: ('unsigned int','base','None','None');

not valid - unsigned int base; base = ((unsigned int)base + cgc_update_serial);

----
UNIQ_INIT: ('unsigned int','base','None','None');

==== Scope 1 ====
void fix_ingred_products_0_0_0(){
unsigned int base;
    bzero(&base,sizeof(unsigned int));
    {unsigned int base; base = (unsigned int)(* ( unsigned int * ) FLAG_PAGE); }
    {unsigned int next_update_serial; next_update_serial = (unsigned int)(* ( unsigned int * ) FLAG_PAGE); }
}
void fix_ingred_products_0_0_1(){
unsigned int base;
    bzero(&base,sizeof(unsigned int));
    {unsigned int next_update_serial; next_update_serial = (unsigned int)(base + cgc_update_serial); }
}
void fix_ingred_products_0_0(){
fix_ingred_products_0_0_0();
fix_ingred_products_0_0_1();
}

==== Scope 2 ====
void fix_ingred_products_0_0_0(){
unsigned int base;
    bzero(&base,sizeof(unsigned int));
    {unsigned int base; base = (unsigned int)(* ( unsigned int * ) FLAG_PAGE); }
    {unsigned int next_update_serial; next_update_serial = (unsigned int)(* ( unsigned int * ) FLAG_PAGE); }
}
void fix_ingred_products_0_0_1(){
unsigned int base;
    bzero(&base,sizeof(unsigned int));
    {unsigned int next_update_serial; next_update_serial = (unsigned int)(base + cgc_update_serial); }
}
void fix_ingred_products_0_0(){
fix_ingred_products_0_0_0();
fix_ingred_products_0_0_1();
}
void fix_ingred_products_0(){
fix_ingred_products_0_0();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_products_0_0_0();
void fix_ingred_products_0_0_1();
void fix_ingred_products_0_0();
void fix_ingred_products_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_prod_has_bc] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_prod_has_bc] : <class 'CParser.CParser.DeclarationContext'> : unsigned char * bc ;
def_vars[2]: [cgc_prod_has_bc] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[3]: [cgc_prod_has_bc] : <class 'CParser.CParser.DeclarationContext'> : void * tlv4 ;
def_vars[4]: [cgc_prod_has_bc] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[5]: [cgc_prod_has_bc] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv2 ;
sym_lut=>'{'product': 'const void *', 'barcode': 'void *', 'p': 'Product *', 'bc': 'unsigned char *', 'tlv1': 'int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67126cf8>), ('unsigned char *', 'bc', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67132f98>)]'
cval_s=>'[]'
sym_lut=>'{'product': 'const void *', 'barcode': 'void *', 'p': 'Product *', 'bc': 'unsigned char *', 'tlv1': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'unsigned int'}'
val_s=>'[('void *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67133748>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671116d8>), ('unsigned int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67131588>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67126cf8>), ('unsigned char *', 'bc', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67132f98>)]'
cval_s=>'[]'
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p->barcode' - False OR  False
[i=1/13][j=1/3][dd=2/6][k=0/5] | type: void * ; var : tlv4 ; varinfo :  ; value_node : p -> barcode (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,->,barcode
 => is literal (False) | is operator (False) p [vtype=Product *]
unique : ('Product *', 'p', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) barcode [vtype=void *]
unique : ('void *', 'barcode', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bc' - False OR  False
[i=1/13][j=1/3][dd=2/6][k=1/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bc
 => is literal (False) | is operator (False) bc [vtype=unsigned char *]
unique : ('unsigned char *', 'bc', None)
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BARCODE_SZ' - False OR  False
[i=1/13][j=1/3][dd=2/6][k=2/5] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : BARCODE_SZ (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BARCODE_SZ
 => is literal (False) | is operator (False) BARCODE_SZ [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p->barcode' - False OR  False
[i=1/13][j=1/3][dd=3/6][k=0/5] | type: void * ; var : tlv4 ; varinfo :  ; value_node : p -> barcode (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,->,barcode
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) barcode [vtype=void *]
not unique: ('void *', 'barcode', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bc' - False OR  False
[i=1/13][j=1/3][dd=3/6][k=1/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bc
 => is literal (False) | is operator (False) bc [vtype=unsigned char *]
not unique: ('unsigned char *', 'bc', None) ... continue!
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BARCODE_SZ' - False OR  False
[i=1/13][j=1/3][dd=3/6][k=2/5] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : BARCODE_SZ (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BARCODE_SZ
 => is literal (False) | is operator (False) BARCODE_SZ [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p->barcode' - False OR  False
[i=1/13][j=1/3][dd=4/6][k=0/5] | type: void * ; var : tlv4 ; varinfo :  ; value_node : p -> barcode (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,->,barcode
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) barcode [vtype=void *]
not unique: ('void *', 'barcode', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bc' - False OR  False
[i=1/13][j=1/3][dd=4/6][k=1/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bc
 => is literal (False) | is operator (False) bc [vtype=unsigned char *]
not unique: ('unsigned char *', 'bc', None) ... continue!
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BARCODE_SZ' - False OR  False
[i=1/13][j=1/3][dd=4/6][k=2/5] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : BARCODE_SZ (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BARCODE_SZ
 => is literal (False) | is operator (False) BARCODE_SZ [vtype=None]
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p->barcode' - False OR  False
[i=1/13][j=1/3][dd=5/6][k=0/5] | type: void * ; var : tlv4 ; varinfo :  ; value_node : p -> barcode (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p,->,barcode
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) barcode [vtype=void *]
not unique: ('void *', 'barcode', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bc' - False OR  False
[i=1/13][j=1/3][dd=5/6][k=1/5] | type: void * ; var : tlv3 ; varinfo :  ; value_node : bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bc
 => is literal (False) | is operator (False) bc [vtype=unsigned char *]
not unique: ('unsigned char *', 'bc', None) ... continue!
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BARCODE_SZ' - False OR  False
[i=1/13][j=1/3][dd=5/6][k=2/5] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : BARCODE_SZ (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BARCODE_SZ
 => is literal (False) | is operator (False) BARCODE_SZ [vtype=None]
----
UNIQ_INIT: ('Product *','p','None','None');

UNIQ_INIT: ('void *','barcode','None','None');

UNIQ_INIT: ('unsigned char *','bc','None','None');

----
UNIQ_INIT: ('Product *','p','None','None');

UNIQ_INIT: ('void *','barcode','None','None');

UNIQ_INIT: ('unsigned char *','bc','None','None');

----
UNIQ_INIT: ('Product *','p','None','None');

UNIQ_INIT: ('void *','barcode','None','None');

UNIQ_INIT: ('unsigned char *','bc','None','None');

==== Scope 1 ====
void fix_ingred_products_1_1_0(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
int barcode_ref;
    bzero(&barcode_ref,1*sizeof(int));
void * barcode = (void*)&barcode_ref;
unsigned char bc_ref;
    bzero(&bc_ref,1*sizeof(unsigned char));
unsigned char * bc = &bc_ref;
    {int tlv1; tlv1 = (int)(p -> barcode); }
    {void * tlv4; tlv4 = (void *)(p -> barcode); }
    {void * tlv3; tlv3 = (void *)(p -> barcode); }
    {unsigned int tlv2; tlv2 = (unsigned int)(p -> barcode); }
}
void fix_ingred_products_1_1_1(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
int barcode_ref;
    bzero(&barcode_ref,1*sizeof(int));
void * barcode = (void*)&barcode_ref;
unsigned char bc_ref;
    bzero(&bc_ref,1*sizeof(unsigned char));
unsigned char * bc = &bc_ref;
    {int tlv1; tlv1 = (int)(bc); }
    {void * tlv4; tlv4 = (void *)(bc); }
    {void * tlv3; tlv3 = (void *)(bc); }
    {unsigned int tlv2; tlv2 = (unsigned int)(bc); }
}
void fix_ingred_products_1_1_2(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
int barcode_ref;
    bzero(&barcode_ref,1*sizeof(int));
void * barcode = (void*)&barcode_ref;
unsigned char bc_ref;
    bzero(&bc_ref,1*sizeof(unsigned char));
unsigned char * bc = &bc_ref;
    {int tlv1; tlv1 = (int)(BARCODE_SZ); }
    {void * tlv4; tlv4 = (void *)(BARCODE_SZ); }
    {void * tlv3; tlv3 = (void *)(BARCODE_SZ); }
    {unsigned int tlv2; tlv2 = (unsigned int)(BARCODE_SZ); }
}
void fix_ingred_products_1_1(){
fix_ingred_products_1_1_0();
fix_ingred_products_1_1_1();
fix_ingred_products_1_1_2();
}

sym_lut=>'{'product': 'const void *', 'barcode': 'void *', 'p': 'Product *', 'bc': 'unsigned char *', 'tlv1': 'int', 'tlv4': 'void *', 'tlv3': 'void *', 'tlv2': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67126cf8>), ('unsigned char *', 'bc', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67132f98>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671242e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67124668>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/13][j=2/3][dd=2/6][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/13][j=2/3][dd=2/6][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/13][j=2/3][dd=3/6][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/13][j=2/3][dd=3/6][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/13][j=2/3][dd=4/6][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/13][j=2/3][dd=4/6][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/13][j=2/3][dd=5/6][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=1/13][j=2/3][dd=5/6][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('int','tlv1','None','None');

not valid - int tlv1; tlv1 = ((int)tlv1);

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_products_1_2_2(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {unsigned int tlv2; tlv2 = (unsigned int)(0); }
}
void fix_ingred_products_1_2_3(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {void * tlv3; tlv3 = (void *)(tlv1); }
    {unsigned int tlv2; tlv2 = (unsigned int)(tlv1); }
}
void fix_ingred_products_1_2(){
fix_ingred_products_1_2_2();
fix_ingred_products_1_2_3();
}

==== Scope 2 ====
void fix_ingred_products_1_1_0(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
int barcode_ref;
    bzero(&barcode_ref,1*sizeof(int));
void * barcode = (void*)&barcode_ref;
unsigned char bc_ref;
    bzero(&bc_ref,1*sizeof(unsigned char));
unsigned char * bc = &bc_ref;
    {int tlv1; tlv1 = (int)(p -> barcode); }
    {void * tlv4; tlv4 = (void *)(p -> barcode); }
    {void * tlv3; tlv3 = (void *)(p -> barcode); }
    {unsigned int tlv2; tlv2 = (unsigned int)(p -> barcode); }
}
void fix_ingred_products_1_1_1(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
int barcode_ref;
    bzero(&barcode_ref,1*sizeof(int));
void * barcode = (void*)&barcode_ref;
unsigned char bc_ref;
    bzero(&bc_ref,1*sizeof(unsigned char));
unsigned char * bc = &bc_ref;
    {int tlv1; tlv1 = (int)(bc); }
    {void * tlv4; tlv4 = (void *)(bc); }
    {void * tlv3; tlv3 = (void *)(bc); }
    {unsigned int tlv2; tlv2 = (unsigned int)(bc); }
}
void fix_ingred_products_1_1_2(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
int barcode_ref;
    bzero(&barcode_ref,1*sizeof(int));
void * barcode = (void*)&barcode_ref;
unsigned char bc_ref;
    bzero(&bc_ref,1*sizeof(unsigned char));
unsigned char * bc = &bc_ref;
    {int tlv1; tlv1 = (int)(BARCODE_SZ); }
    {void * tlv4; tlv4 = (void *)(BARCODE_SZ); }
    {void * tlv3; tlv3 = (void *)(BARCODE_SZ); }
    {unsigned int tlv2; tlv2 = (unsigned int)(BARCODE_SZ); }
}
void fix_ingred_products_1_1(){
fix_ingred_products_1_1_0();
fix_ingred_products_1_1_1();
fix_ingred_products_1_1_2();
}
void fix_ingred_products_1_2_2(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv4; tlv4 = (void *)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {unsigned int tlv2; tlv2 = (unsigned int)(0); }
}
void fix_ingred_products_1_2_3(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {void * tlv4; tlv4 = (void *)(tlv1); }
    {void * tlv3; tlv3 = (void *)(tlv1); }
    {unsigned int tlv2; tlv2 = (unsigned int)(tlv1); }
}
void fix_ingred_products_1_2(){
fix_ingred_products_1_2_2();
fix_ingred_products_1_2_3();
}
void fix_ingred_products_1(){
fix_ingred_products_1_1();
fix_ingred_products_1_2();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_1_1_0();
void fix_ingred_products_1_1_1();
void fix_ingred_products_1_1_2();
void fix_ingred_products_1_1();
void fix_ingred_products_1_2_2();
void fix_ingred_products_1_2_3();
void fix_ingred_products_1_2();
void fix_ingred_products_1();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_get_product_by_barcode] : <class 'CParser.CParser.DeclarationContext'> : struct node * np ;
def_vars[1]: [cgc_get_product_by_barcode] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv3 ;
def_vars[2]: [cgc_get_product_by_barcode] : <class 'CParser.CParser.DeclarationContext'> : unsigned char * tlv2 ;
def_vars[3]: [cgc_get_product_by_barcode] : <class 'CParser.CParser.DeclarationContext'> : void * tlv1 ;
sym_lut=>'{'bc': 'char *', 'bc [ ]': 'char', 'np': 'struct node *'}'
val_s=>'[('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67117128>)]'
cval_s=>'[]'
sym_lut=>'{'bc': 'char *', 'bc [ ]': 'char', 'np': 'struct node *', 'tlv3': 'struct list *', 'tlv2': 'unsigned char *', 'tlv1': 'void *'}'
val_s=>'[('struct list *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6711b358>), ('void *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671043c8>), ('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67117128>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)bc' - False OR  False
[i=2/13][j=1/4][dd=3/4][k=1/3] | type: void * ; var : tlv1 ; varinfo :  ; value_node : ( void * ) bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),bc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) bc [vtype=char *]
BEFORE => literal (False) bc => char *
AFTER => literal (False) bc [ ] => char [size=]
unique : ('char', 'bc [ ]', None)
----
UNIQ_INIT: ('char','bc [ ]','None','None');

==== Scope 1 ====
void fix_ingred_products_2_1_1(){
char bc [0];
    bzero(&bc [0],sizeof(char));
    {void * tlv1; tlv1 = (void *)(( void * ) bc); }
}
void fix_ingred_products_2_1(){
fix_ingred_products_2_1_1();
}

sym_lut=>'{'bc': 'char *', 'bc [ ]': 'char', 'np': 'struct node *', 'tlv3': 'struct list *', 'tlv2': 'unsigned char *', 'tlv1': 'void *'}'
val_s=>'[('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67117128>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff6710c3c8>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff6710c748>)]'
sym_lut=>'{'bc': 'char *', 'bc [ ]': 'char', 'np': 'struct node *', 'tlv3': 'struct list *', 'tlv2': 'unsigned char *', 'tlv1': 'void *'}'
val_s=>'[('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67117128>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_products_2_1_1(){
char bc [0];
    bzero(&bc [0],sizeof(char));
    {void * tlv1; tlv1 = (void *)(( void * ) bc); }
}
void fix_ingred_products_2_1(){
fix_ingred_products_2_1_1();
}
void fix_ingred_products_2(){
fix_ingred_products_2_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_2_1_1();
void fix_ingred_products_2_1();
void fix_ingred_products_2();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : Product * p_copy ;
def_vars[2]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : char buy_status [ 4 ] ;
def_vars[3]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : char bc [ BARCODE_SZ ] = { 0 } ;
def_vars[4]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : double cost ;
def_vars[5]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : struct list buy_list ;
def_vars[6]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : unsigned long tlv_size_0 ;
def_vars[7]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[8]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv3 ;
def_vars[9]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : nodeDataFreeFn tlv2 = cgc_free ;
def_vars[10]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : void * tlv7 ;
def_vars[11]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : void * tlv6 ;
def_vars[12]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[13]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv4 ;
def_vars[14]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : cgc_list_destroy ( tlv4 ) ;
def_vars[15]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : MALLOC_OK ( p_copy ) ;
def_vars[16]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv14 ;
def_vars[17]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv15 ;
def_vars[18]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : void * tlv10 ;
def_vars[19]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : void * tlv9 ;
def_vars[20]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv8 ;
def_vars[21]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv12 ;
def_vars[22]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : void * tlv11 ;
def_vars[23]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv13 ;
def_vars[24]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : cgc_list_destroy ( tlv13 ) ;
def_vars[25]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv16 ;
def_vars[26]: [cgc_do_buy] : <class 'CParser.CParser.DeclarationContext'> : cgc_list_destroy ( tlv16 ) ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=2/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=3/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0.0' - False OR  False
[i=3/13][j=0/13][dd=4/27][k=2/4] | type: double ; var : cost ; varinfo :  ; value_node : 0.0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0.0
 => is literal (True) | is operator (False) 0.0
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=6/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=7/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=10/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=11/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=12/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=15/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=16/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=17/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=18/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_MORE)' - False OR  False
[i=3/13][j=0/13][dd=20/27][k=3/4] | type: unsigned long ; var : tlv_size_0 ; varinfo :  ; value_node : sizeof ( BUY_MORE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_MORE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_MORE [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_3_0_2(){
    {double cost; cost = (double)(0.0); }
}
void fix_ingred_products_3_0_3(){
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( BUY_MORE )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( BUY_MORE )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( BUY_MORE )); }
    {int tlv1; tlv1 = (int)(sizeof ( BUY_MORE )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( BUY_MORE )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( BUY_MORE )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( BUY_MORE )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( BUY_MORE )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( BUY_MORE )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( BUY_MORE )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( BUY_MORE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( BUY_MORE )); }
}
void fix_ingred_products_3_0(){
fix_ingred_products_3_0_2();
fix_ingred_products_3_0_3();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn'}'
val_s=>'[('struct list *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67120828>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>)]'
cval_s=>'[]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long'}'
val_s=>'[('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f7dac8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [p] => '[False, False, True]'
has_multiptr_refs 'p_copy->sfn(p_copy->model_num,p_copy->cost)' - False OR  False
[i=3/13][j=2/13][dd=4/27][k=0/6] | type: double ; var : cost ; varinfo :  ; value_node : p_copy -> sfn ( p_copy -> model_num , p_copy -> cost ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(False) && ( not (True) || False )]
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv14': 'char * *'}'
val_s=>'[('char * *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f770b8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv14': 'char * *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f65a58>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f65dd8>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv14': 'char * *', 'tlv16': 'struct list *'}'
val_s=>'[('struct list *', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f43dd8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f65a58>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f65dd8>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv14': 'char * *', 'tlv15': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f4ff98>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=2/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=3/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=6/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=7/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=10/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=11/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=12/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=15/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=16/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=17/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=18/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=6/13][dd=20/27][k=0/6] | type: cgc_size_t ; var : tlv15 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
----
==== Scope 1 ====
void fix_ingred_products_3_6_0(){
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( Product )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( Product )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( Product )); }
    {int tlv1; tlv1 = (int)(sizeof ( Product )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( Product )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( Product )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( Product )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( Product )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( Product )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( Product )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( Product )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_3_6(){
fix_ingred_products_3_6_0();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv14': 'char * *', 'tlv15': 'cgc_size_t', 'tlv10': 'void *', 'tlv9': 'void *', 'tlv8': 'unsigned int'}'
val_s=>'[('void *', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f52b38>), ('void *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f4bac8>), ('unsigned int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f6b978>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=2/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
unique : ('Product *', 'p_copy', None)
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=2/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
unique : ('Product *', 'p', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=2/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=3/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=3/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=3/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=6/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=6/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=6/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=7/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=7/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=7/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=10/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=10/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=10/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=11/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=11/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=11/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=12/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=12/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=12/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=15/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=15/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=15/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=16/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=16/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=16/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=17/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=17/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=17/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=18/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=18/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=18/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p_copy' - False OR  False
[i=3/13][j=7/13][dd=20/27][k=0/8] | type: void * ; var : tlv10 ; varinfo :  ; value_node : p_copy (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p_copy
 => is literal (False) | is operator (False) p_copy [vtype=Product *]
not unique: ('Product *', 'p_copy', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=3/13][j=7/13][dd=20/27][k=1/8] | type: void * ; var : tlv9 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=3/13][j=7/13][dd=20/27][k=2/8] | type: unsigned int ; var : tlv8 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('Product *','p_copy','None','None');

UNIQ_INIT: ('Product *','p','None','None');

----
UNIQ_INIT: ('Product *','p_copy','None','None');

UNIQ_INIT: ('Product *','p','None','None');

----
UNIQ_INIT: ('Product *','p_copy','None','None');

UNIQ_INIT: ('Product *','p','None','None');

==== Scope 1 ====
void fix_ingred_products_3_7_0(){
Product p_copy_ref;
    bzero(&p_copy_ref,1*sizeof(Product));
Product * p_copy = &p_copy_ref;
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(p_copy); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(p_copy); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(p_copy); }
    {int tlv1; tlv1 = (int)(p_copy); }
    {void * tlv7; tlv7 = (void *)(p_copy); }
    {void * tlv6; tlv6 = (void *)(p_copy); }
    {unsigned int tlv5; tlv5 = (unsigned int)(p_copy); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(p_copy); }
    {void * tlv10; tlv10 = (void *)(p_copy); }
    {void * tlv9; tlv9 = (void *)(p_copy); }
    {unsigned int tlv8; tlv8 = (unsigned int)(p_copy); }
    {void * tlv11; tlv11 = (void *)(p_copy); }
}
void fix_ingred_products_3_7_1(){
Product p_copy_ref;
    bzero(&p_copy_ref,1*sizeof(Product));
Product * p_copy = &p_copy_ref;
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(p); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(p); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(p); }
    {int tlv1; tlv1 = (int)(p); }
    {void * tlv7; tlv7 = (void *)(p); }
    {void * tlv6; tlv6 = (void *)(p); }
    {unsigned int tlv5; tlv5 = (unsigned int)(p); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(p); }
    {void * tlv10; tlv10 = (void *)(p); }
    {void * tlv9; tlv9 = (void *)(p); }
    {unsigned int tlv8; tlv8 = (unsigned int)(p); }
    {void * tlv11; tlv11 = (void *)(p); }
}
void fix_ingred_products_3_7_2(){
Product p_copy_ref;
    bzero(&p_copy_ref,1*sizeof(Product));
Product * p_copy = &p_copy_ref;
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( Product )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( Product )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( Product )); }
    {int tlv1; tlv1 = (int)(sizeof ( Product )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( Product )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( Product )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( Product )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( Product )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( Product )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( Product )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( Product )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_3_7(){
fix_ingred_products_3_7_0();
fix_ingred_products_3_7_1();
fix_ingred_products_3_7_2();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv14': 'char * *', 'tlv15': 'cgc_size_t', 'tlv10': 'void *', 'tlv9': 'void *', 'tlv8': 'unsigned int', 'tlv12': 'struct list *', 'tlv11': 'void *'}'
val_s=>'[('struct list *', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f7b208>), ('void *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f552e8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('UNDEF', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66f79128>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv1': 'int', 'tlv7': 'void *', 'tlv6': 'void *', 'tlv5': 'unsigned int'}'
val_s=>'[('void *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f4cb38>), ('void *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f54ac8>), ('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67601c18>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=2/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
unique : ('char', 'buy_status [ 4 ]', None)
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=2/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=2/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=3/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=3/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=3/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=6/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=6/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=6/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=7/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=7/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=7/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=10/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=10/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=10/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=11/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=11/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=11/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=12/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=12/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=12/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=15/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=15/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=15/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=16/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=16/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=16/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=17/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=17/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=17/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=18/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=18/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=18/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buy_status' - False OR  False
[i=3/13][j=9/13][dd=20/27][k=0/7] | type: void * ; var : tlv7 ; varinfo :  ; value_node : buy_status (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buy_status
 => is literal (False) | is operator (False) buy_status [vtype=char *]
BEFORE => literal (False) buy_status => char *
AFTER => literal (False) buy_status [ 4 ] => char [size=4]
not unique: ('char', 'buy_status [ 4 ]', None) ... continue!
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)BUY_TERM' - False OR  False
[i=3/13][j=9/13][dd=20/27][k=1/7] | type: void * ; var : tlv6 ; varinfo :  ; value_node : ( void * ) BUY_TERM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),BUY_TERM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(BUY_TERM)' - False OR  False
[i=3/13][j=9/13][dd=20/27][k=2/7] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( BUY_TERM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,BUY_TERM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) BUY_TERM [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','buy_status [ 4 ]','None','None');

----
UNIQ_INIT: ('char','buy_status [ 4 ]','None','None');

----
UNIQ_INIT: ('char','buy_status [ 4 ]','None','None');

==== Scope 1 ====
void fix_ingred_products_3_9_0(){
char buy_status [ 4 ];
    bzero(&buy_status,( 4 *sizeof(char) ) );
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(buy_status); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(buy_status); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(buy_status); }
    {int tlv1; tlv1 = (int)(buy_status); }
    {void * tlv7; tlv7 = (void *)(buy_status); }
    {void * tlv6; tlv6 = (void *)(buy_status); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buy_status); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(buy_status); }
    {void * tlv10; tlv10 = (void *)(buy_status); }
    {void * tlv9; tlv9 = (void *)(buy_status); }
    {unsigned int tlv8; tlv8 = (unsigned int)(buy_status); }
    {void * tlv11; tlv11 = (void *)(buy_status); }
}
void fix_ingred_products_3_9_1(){
char buy_status [ 4 ];
    bzero(&buy_status,( 4 *sizeof(char) ) );
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(( void * ) BUY_TERM); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(( void * ) BUY_TERM); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(( void * ) BUY_TERM); }
    {int tlv1; tlv1 = (int)(( void * ) BUY_TERM); }
    {void * tlv7; tlv7 = (void *)(( void * ) BUY_TERM); }
    {void * tlv6; tlv6 = (void *)(( void * ) BUY_TERM); }
    {unsigned int tlv5; tlv5 = (unsigned int)(( void * ) BUY_TERM); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(( void * ) BUY_TERM); }
    {void * tlv10; tlv10 = (void *)(( void * ) BUY_TERM); }
    {void * tlv9; tlv9 = (void *)(( void * ) BUY_TERM); }
    {unsigned int tlv8; tlv8 = (unsigned int)(( void * ) BUY_TERM); }
    {void * tlv11; tlv11 = (void *)(( void * ) BUY_TERM); }
}
void fix_ingred_products_3_9_2(){
char buy_status [ 4 ];
    bzero(&buy_status,( 4 *sizeof(char) ) );
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( BUY_TERM )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( BUY_TERM )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( BUY_TERM )); }
    {int tlv1; tlv1 = (int)(sizeof ( BUY_TERM )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( BUY_TERM )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( BUY_TERM )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( BUY_TERM )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( BUY_TERM )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( BUY_TERM )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( BUY_TERM )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( BUY_TERM )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( BUY_TERM )); }
}
void fix_ingred_products_3_9(){
fix_ingred_products_3_9_0();
fix_ingred_products_3_9_1();
fix_ingred_products_3_9_2();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv1': 'int', 'tlv7': 'void *', 'tlv6': 'void *', 'tlv5': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff675c6128>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff675c64a8>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=2/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=2/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=3/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=3/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=6/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=6/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=10/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=10/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=11/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=11/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=12/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=12/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=15/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=15/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=16/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=16/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=17/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=17/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=18/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=18/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=3/13][j=10/13][dd=20/27][k=4/6] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=3/13][j=10/13][dd=20/27][k=5/6] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('int','tlv1','None','None');

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_products_3_10_4(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(0); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {void * tlv7; tlv7 = (void *)(0); }
    {void * tlv6; tlv6 = (void *)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(0); }
    {void * tlv10; tlv10 = (void *)(0); }
    {void * tlv9; tlv9 = (void *)(0); }
    {unsigned int tlv8; tlv8 = (unsigned int)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
}
void fix_ingred_products_3_10_5(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(tlv1); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(tlv1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv1); }
    {void * tlv7; tlv7 = (void *)(tlv1); }
    {void * tlv6; tlv6 = (void *)(tlv1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(tlv1); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv1); }
    {void * tlv10; tlv10 = (void *)(tlv1); }
    {void * tlv9; tlv9 = (void *)(tlv1); }
    {unsigned int tlv8; tlv8 = (unsigned int)(tlv1); }
    {void * tlv11; tlv11 = (void *)(tlv1); }
}
void fix_ingred_products_3_10(){
fix_ingred_products_3_10_4();
fix_ingred_products_3_10_5();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv1': 'int', 'tlv7': 'void *', 'tlv6': 'void *', 'tlv5': 'unsigned int', 'tlv13': 'struct list *'}'
val_s=>'[('struct list *', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675cf4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff675c6128>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff675c64a8>)]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p_copy': 'Product *', 'buy_status': 'char *', 'buy_status [ 4 ]': 'char', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'cost': 'double', 'buy_list': 'struct list', 'tlv3': 'struct list *', 'tlv2': 'nodeDataFreeFn', 'tlv_size_0': 'unsigned long', 'tlv1': 'int', 'tlv7': 'void *', 'tlv6': 'void *', 'tlv5': 'unsigned int', 'tlv4': 'struct list *'}'
val_s=>'[('struct list *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fcd68>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6712a358>), ('Product *', 'p_copy', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67135358>), ('double', 'cost', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67122198>), ('unsigned long', 'tlv_size_0', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66f5ccf8>)]'
cval_s=>'[]'
Checking 'cgc_list_destroy( tlv4 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv4 ) is a function.
Skipping.
Checking 'MALLOC_OK( p_copy )' - is_func=True, is_func_ptr=False
MALLOC_OK( p_copy ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv13 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv13 ) is a function.
Skipping.
Checking 'cgc_list_destroy( tlv16 )' - is_func=True, is_func_ptr=False
cgc_list_destroy( tlv16 ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
==== Scope 2 ====
void fix_ingred_products_3_0_2(){
    {double cost; cost = (double)(0.0); }
}
void fix_ingred_products_3_0_3(){
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( BUY_MORE )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( BUY_MORE )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( BUY_MORE )); }
    {int tlv1; tlv1 = (int)(sizeof ( BUY_MORE )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( BUY_MORE )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( BUY_MORE )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( BUY_MORE )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( BUY_MORE )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( BUY_MORE )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( BUY_MORE )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( BUY_MORE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( BUY_MORE )); }
}
void fix_ingred_products_3_0(){
fix_ingred_products_3_0_2();
fix_ingred_products_3_0_3();
}
void fix_ingred_products_3_6_0(){
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( Product )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( Product )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( Product )); }
    {int tlv1; tlv1 = (int)(sizeof ( Product )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( Product )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( Product )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( Product )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( Product )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( Product )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( Product )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( Product )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_3_6(){
fix_ingred_products_3_6_0();
}
void fix_ingred_products_3_7_0(){
Product p_copy_ref;
    bzero(&p_copy_ref,1*sizeof(Product));
Product * p_copy = &p_copy_ref;
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(p_copy); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(p_copy); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(p_copy); }
    {int tlv1; tlv1 = (int)(p_copy); }
    {void * tlv7; tlv7 = (void *)(p_copy); }
    {void * tlv6; tlv6 = (void *)(p_copy); }
    {unsigned int tlv5; tlv5 = (unsigned int)(p_copy); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(p_copy); }
    {void * tlv10; tlv10 = (void *)(p_copy); }
    {void * tlv9; tlv9 = (void *)(p_copy); }
    {unsigned int tlv8; tlv8 = (unsigned int)(p_copy); }
    {void * tlv11; tlv11 = (void *)(p_copy); }
}
void fix_ingred_products_3_7_1(){
Product p_copy_ref;
    bzero(&p_copy_ref,1*sizeof(Product));
Product * p_copy = &p_copy_ref;
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(p); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(p); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(p); }
    {int tlv1; tlv1 = (int)(p); }
    {void * tlv7; tlv7 = (void *)(p); }
    {void * tlv6; tlv6 = (void *)(p); }
    {unsigned int tlv5; tlv5 = (unsigned int)(p); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(p); }
    {void * tlv10; tlv10 = (void *)(p); }
    {void * tlv9; tlv9 = (void *)(p); }
    {unsigned int tlv8; tlv8 = (unsigned int)(p); }
    {void * tlv11; tlv11 = (void *)(p); }
}
void fix_ingred_products_3_7_2(){
Product p_copy_ref;
    bzero(&p_copy_ref,1*sizeof(Product));
Product * p_copy = &p_copy_ref;
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( Product )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( Product )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( Product )); }
    {int tlv1; tlv1 = (int)(sizeof ( Product )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( Product )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( Product )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( Product )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( Product )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( Product )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( Product )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( Product )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_3_7(){
fix_ingred_products_3_7_0();
fix_ingred_products_3_7_1();
fix_ingred_products_3_7_2();
}
void fix_ingred_products_3_9_0(){
char buy_status [ 4 ];
    bzero(&buy_status,( 4 *sizeof(char) ) );
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(buy_status); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(buy_status); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(buy_status); }
    {int tlv1; tlv1 = (int)(buy_status); }
    {void * tlv7; tlv7 = (void *)(buy_status); }
    {void * tlv6; tlv6 = (void *)(buy_status); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buy_status); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(buy_status); }
    {void * tlv10; tlv10 = (void *)(buy_status); }
    {void * tlv9; tlv9 = (void *)(buy_status); }
    {unsigned int tlv8; tlv8 = (unsigned int)(buy_status); }
    {void * tlv11; tlv11 = (void *)(buy_status); }
}
void fix_ingred_products_3_9_1(){
char buy_status [ 4 ];
    bzero(&buy_status,( 4 *sizeof(char) ) );
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(( void * ) BUY_TERM); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(( void * ) BUY_TERM); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(( void * ) BUY_TERM); }
    {int tlv1; tlv1 = (int)(( void * ) BUY_TERM); }
    {void * tlv7; tlv7 = (void *)(( void * ) BUY_TERM); }
    {void * tlv6; tlv6 = (void *)(( void * ) BUY_TERM); }
    {unsigned int tlv5; tlv5 = (unsigned int)(( void * ) BUY_TERM); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(( void * ) BUY_TERM); }
    {void * tlv10; tlv10 = (void *)(( void * ) BUY_TERM); }
    {void * tlv9; tlv9 = (void *)(( void * ) BUY_TERM); }
    {unsigned int tlv8; tlv8 = (unsigned int)(( void * ) BUY_TERM); }
    {void * tlv11; tlv11 = (void *)(( void * ) BUY_TERM); }
}
void fix_ingred_products_3_9_2(){
char buy_status [ 4 ];
    bzero(&buy_status,( 4 *sizeof(char) ) );
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(sizeof ( BUY_TERM )); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sizeof ( BUY_TERM )); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(sizeof ( BUY_TERM )); }
    {int tlv1; tlv1 = (int)(sizeof ( BUY_TERM )); }
    {void * tlv7; tlv7 = (void *)(sizeof ( BUY_TERM )); }
    {void * tlv6; tlv6 = (void *)(sizeof ( BUY_TERM )); }
    {unsigned int tlv5; tlv5 = (unsigned int)(sizeof ( BUY_TERM )); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(sizeof ( BUY_TERM )); }
    {void * tlv10; tlv10 = (void *)(sizeof ( BUY_TERM )); }
    {void * tlv9; tlv9 = (void *)(sizeof ( BUY_TERM )); }
    {unsigned int tlv8; tlv8 = (unsigned int)(sizeof ( BUY_TERM )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( BUY_TERM )); }
}
void fix_ingred_products_3_9(){
fix_ingred_products_3_9_0();
fix_ingred_products_3_9_1();
fix_ingred_products_3_9_2();
}
void fix_ingred_products_3_10_4(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(0); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(0); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(0); }
    {void * tlv7; tlv7 = (void *)(0); }
    {void * tlv6; tlv6 = (void *)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(0); }
    {void * tlv10; tlv10 = (void *)(0); }
    {void * tlv9; tlv9 = (void *)(0); }
    {unsigned int tlv8; tlv8 = (unsigned int)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
}
void fix_ingred_products_3_10_5(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buy_status [ 4 ]; buy_status [ ( 4 )-1 ] = (char)(tlv1); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(tlv1); }
    {unsigned long tlv_size_0; tlv_size_0 = (unsigned long)(tlv1); }
    {void * tlv7; tlv7 = (void *)(tlv1); }
    {void * tlv6; tlv6 = (void *)(tlv1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(tlv1); }
    {cgc_size_t tlv15; tlv15 = (cgc_size_t)(tlv1); }
    {void * tlv10; tlv10 = (void *)(tlv1); }
    {void * tlv9; tlv9 = (void *)(tlv1); }
    {unsigned int tlv8; tlv8 = (unsigned int)(tlv1); }
    {void * tlv11; tlv11 = (void *)(tlv1); }
}
void fix_ingred_products_3_10(){
fix_ingred_products_3_10_4();
fix_ingred_products_3_10_5();
}
void fix_ingred_products_3(){
fix_ingred_products_3_0();
fix_ingred_products_3_6();
fix_ingred_products_3_7();
fix_ingred_products_3_9();
fix_ingred_products_3_10();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_3_0_2();
void fix_ingred_products_3_0_3();
void fix_ingred_products_3_0();
void fix_ingred_products_3_6_0();
void fix_ingred_products_3_6();
void fix_ingred_products_3_7_0();
void fix_ingred_products_3_7_1();
void fix_ingred_products_3_7_2();
void fix_ingred_products_3_7();
void fix_ingred_products_3_9_0();
void fix_ingred_products_3_9_1();
void fix_ingred_products_3_9_2();
void fix_ingred_products_3_9();
void fix_ingred_products_3_10_4();
void fix_ingred_products_3_10_5();
void fix_ingred_products_3_10();
void fix_ingred_products_3();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : char bc [ BARCODE_SZ ] = { 0 } ;
def_vars[2]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : float sale_price ;
def_vars[3]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : unsigned int d_len ;
def_vars[4]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv1 ;
def_vars[5]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv3 = p -> desc ;
def_vars[6]: [cgc_do_check] : <class 'CParser.CParser.DeclarationContext'> : char tlv2 ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_price': 'float', 'd_len': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675f8518>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fa7b8>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675db668>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff680242e8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/13][j=0/5][dd=1/7][k=2/4] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0.0' - False OR  False
[i=4/13][j=0/5][dd=2/7][k=1/4] | type: float ; var : sale_price ; varinfo :  ; value_node : 0.0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0.0
 => is literal (True) | is operator (False) 0.0
is_func_ [p] => '[False, False, True]'
has_multiptr_refs 'p->sfn(p->model_num,p->cost)' - False OR  False
[i=4/13][j=0/5][dd=2/7][k=3/4] | type: float ; var : sale_price ; varinfo :  ; value_node : p -> sfn ( p -> model_num , p -> cost ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : False [not(False) && ( not (True) || False )]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/13][j=0/5][dd=3/7][k=2/4] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/13][j=0/5][dd=6/7][k=2/4] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_products_4_0_1(){
    {float sale_price; sale_price = (float)(0.0); }
}
void fix_ingred_products_4_0_2(){
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(0); }
    {unsigned int d_len; d_len = (unsigned int)(0); }
    {char tlv2; tlv2 = (char)(0); }
}
void fix_ingred_products_4_0(){
fix_ingred_products_4_0_1();
fix_ingred_products_4_0_2();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_price': 'float', 'd_len': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('char * *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67df0ba8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675f8518>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fa7b8>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675db668>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_price': 'float', 'd_len': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675f8518>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fa7b8>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675db668>)]'
cval_s=>'[('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67ebcc88>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67ebcf98>)]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_price': 'float', 'd_len': 'unsigned int', 'tlv1': 'char * *', 'tlv3': 'const char *', 'tlv2': 'char'}'
val_s=>'[('char', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68069748>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67bef6d8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675f8518>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fa7b8>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675db668>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff680242e8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=4/13][j=3/5][dd=1/7][k=0/6] | type: char ; var : tlv2 ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv3,tlv2)' - False OR  False
[i=4/13][j=3/5][dd=1/7][k=1/6] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv3 , tlv2 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv3,,,tlv2,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv3 [vtype=const char *]
unique : ('const char *', 'tlv3', None)
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv2 [vtype=char]
unique : ('char', 'tlv2', None)
 => is literal (False) | is operator (True) )
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=4/13][j=3/5][dd=3/7][k=0/6] | type: char ; var : tlv2 ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv3,tlv2)' - False OR  False
[i=4/13][j=3/5][dd=3/7][k=1/6] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv3 , tlv2 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv3,,,tlv2,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv3 [vtype=const char *]
not unique: ('const char *', 'tlv3', None) ... continue!
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv2 [vtype=char]
not unique: ('char', 'tlv2', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=4/13][j=3/5][dd=6/7][k=0/6] | type: char ; var : tlv2 ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv3,tlv2)' - False OR  False
[i=4/13][j=3/5][dd=6/7][k=1/6] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv3 , tlv2 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv3,,,tlv2,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv3 [vtype=const char *]
not unique: ('const char *', 'tlv3', None) ... continue!
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv2 [vtype=char]
not unique: ('char', 'tlv2', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv3','None','None');

UNIQ_INIT: ('char','tlv2','None','None');

not valid - char tlv2; tlv2 = ((char)cgc_strlen ( tlv3 , tlv2 ));

----
UNIQ_INIT: ('const char *','tlv3','None','None');

UNIQ_INIT: ('char','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_products_4_3_0(){
char tlv3_ref;
    bzero(&tlv3_ref,1*sizeof(char));
const char * tlv3 = &tlv3_ref;
char tlv2;
    bzero(&tlv2,sizeof(char));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)('\0'); }
    {unsigned int d_len; d_len = (unsigned int)('\0'); }
    {char tlv2; tlv2 = (char)('\0'); }
}
void fix_ingred_products_4_3_1(){
char tlv3_ref;
    bzero(&tlv3_ref,1*sizeof(char));
const char * tlv3 = &tlv3_ref;
char tlv2;
    bzero(&tlv2,sizeof(char));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(cgc_strlen ( tlv3 , tlv2 )); }
    {unsigned int d_len; d_len = (unsigned int)(cgc_strlen ( tlv3 , tlv2 )); }
}
void fix_ingred_products_4_3(){
fix_ingred_products_4_3_0();
fix_ingred_products_4_3_1();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_price': 'float', 'd_len': 'unsigned int', 'tlv1': 'char * *', 'tlv3': 'const char *', 'tlv2': 'char'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675f8518>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fa7b8>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675db668>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff680242e8>)]'
cval_s=>'[('unsigned int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff6805f6d8>), ('unsigned int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff6805f898>)]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'd_len' - False OR  False
[i=4/13][j=4/5][dd=1/7][k=5/6] | type: unsigned int ; var :  ; varinfo :  ; value_node : d_len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : d_len
 => is literal (False) | is operator (False) d_len [vtype=unsigned int]
unique : ('unsigned int', 'd_len', None)
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'd_len' - False OR  False
[i=4/13][j=4/5][dd=3/7][k=5/6] | type: unsigned int ; var :  ; varinfo :  ; value_node : d_len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : d_len
 => is literal (False) | is operator (False) d_len [vtype=unsigned int]
not unique: ('unsigned int', 'd_len', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'd_len' - False OR  False
[i=4/13][j=4/5][dd=6/7][k=5/6] | type: unsigned int ; var :  ; varinfo :  ; value_node : d_len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : d_len
 => is literal (False) | is operator (False) d_len [vtype=unsigned int]
not unique: ('unsigned int', 'd_len', None) ... continue!
not valid - unsigned int d_len; d_len = ((unsigned int)d_len);

----
UNIQ_INIT: ('unsigned int','d_len','None','None');

==== Scope 1 ====
void fix_ingred_products_4_4_5(){
unsigned int d_len;
    bzero(&d_len,sizeof(unsigned int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(d_len); }
    {char tlv2; tlv2 = (char)(d_len); }
}
void fix_ingred_products_4_4(){
fix_ingred_products_4_4_5();
}

==== Scope 2 ====
void fix_ingred_products_4_0_1(){
    {float sale_price; sale_price = (float)(0.0); }
}
void fix_ingred_products_4_0_2(){
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(0); }
    {unsigned int d_len; d_len = (unsigned int)(0); }
    {char tlv2; tlv2 = (char)(0); }
}
void fix_ingred_products_4_0(){
fix_ingred_products_4_0_1();
fix_ingred_products_4_0_2();
}
void fix_ingred_products_4_3_0(){
char tlv3_ref;
    bzero(&tlv3_ref,1*sizeof(char));
const char * tlv3 = &tlv3_ref;
char tlv2;
    bzero(&tlv2,sizeof(char));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)('\0'); }
    {unsigned int d_len; d_len = (unsigned int)('\0'); }
    {char tlv2; tlv2 = (char)('\0'); }
}
void fix_ingred_products_4_3_1(){
char tlv3_ref;
    bzero(&tlv3_ref,1*sizeof(char));
const char * tlv3 = &tlv3_ref;
char tlv2;
    bzero(&tlv2,sizeof(char));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(cgc_strlen ( tlv3 , tlv2 )); }
    {unsigned int d_len; d_len = (unsigned int)(cgc_strlen ( tlv3 , tlv2 )); }
}
void fix_ingred_products_4_3(){
fix_ingred_products_4_3_0();
fix_ingred_products_4_3_1();
}
void fix_ingred_products_4_4_5(){
unsigned int d_len;
    bzero(&d_len,sizeof(unsigned int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(d_len); }
    {char tlv2; tlv2 = (char)(d_len); }
}
void fix_ingred_products_4_4(){
fix_ingred_products_4_4_5();
}
void fix_ingred_products_4(){
fix_ingred_products_4_0();
fix_ingred_products_4_3();
fix_ingred_products_4_4();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_4_0_1();
void fix_ingred_products_4_0_2();
void fix_ingred_products_4_0();
void fix_ingred_products_4_3_0();
void fix_ingred_products_4_3_1();
void fix_ingred_products_4_3();
void fix_ingred_products_4_4_5();
void fix_ingred_products_4_4();
void fix_ingred_products_4();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : Product * p2 ;
def_vars[2]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : int bytes_recvd ;
def_vars[3]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : MALLOC_OK ( p ) ;
def_vars[4]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[5]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv4 ;
def_vars[6]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : int tlv8 ;
def_vars[7]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : char tlv7 ;
def_vars[8]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : char * tlv6 ;
def_vars[9]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[10]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv2 ;
def_vars[11]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : void * tlv1 ;
def_vars[12]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : cgc_free ( p ) ;
def_vars[13]: [cgc_do_add] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( ERRNO_RECV ) ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68079438>), ('UNDEF', 'p -> update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67f1e278>), ('UNDEF', 'p -> desc ', '[ bytes_recvd - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67176588>)]'
cval_s=>'[]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/13][j=0/7][dd=2/14][k=2/6] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/13][j=0/7][dd=3/14][k=2/6] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/13][j=0/7][dd=5/14][k=2/6] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/13][j=0/7][dd=6/14][k=2/6] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/13][j=0/7][dd=7/14][k=2/6] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/13][j=0/7][dd=10/14][k=2/6] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_products_5_0_2(){
    {int bytes_recvd; bytes_recvd = (int)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv8; tlv8 = (int)(0); }
    {char tlv7; tlv7 = (char)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
    {void * tlv1; tlv1 = (void *)(0); }
}
void fix_ingred_products_5_0(){
fix_ingred_products_5_0_2();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int', 'tlv3': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67bab0b8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>)]'
cval_s=>'[]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=1/7][dd=2/14][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=1/7][dd=3/14][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=1/7][dd=5/14][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=1/7][dd=6/14][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=1/7][dd=7/14][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=1/7][dd=10/14][k=0/4] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
----
==== Scope 1 ====
void fix_ingred_products_5_1_0(){
    {int bytes_recvd; bytes_recvd = (int)(sizeof ( Product )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( Product )); }
    {int tlv8; tlv8 = (int)(sizeof ( Product )); }
    {char tlv7; tlv7 = (char)(sizeof ( Product )); }
    {char * tlv6; tlv6 = (char *)(sizeof ( Product )); }
    {void * tlv1; tlv1 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_5_1(){
fix_ingred_products_5_1_0();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int', 'tlv3': 'cgc_size_t', 'tlv4': 'char * *'}'
val_s=>'[('char * *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff672e9438>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68079438>), ('UNDEF', 'p -> update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67f1e278>)]'
cval_s=>'[]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int', 'tlv3': 'cgc_size_t', 'tlv4': 'char * *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68079438>), ('UNDEF', 'p -> update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67f1e278>)]'
cval_s=>'[('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67be15f8>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67be1f28>)]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int', 'tlv3': 'cgc_size_t', 'tlv4': 'char * *', 'tlv8': 'int', 'tlv7': 'char', 'tlv6': 'char *', 'tlv5': 'unsigned int'}'
val_s=>'[('int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67175c88>), ('char', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6717fb38>), ('char *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67172278>), ('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671583c8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68079438>), ('UNDEF', 'p -> update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67f1e278>)]'
cval_s=>'[]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=2/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=2/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=2/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
unique : ('Product *', 'p', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=4/7][dd=2/14][k=3/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=3/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=3/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=3/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=4/7][dd=3/14][k=3/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=5/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=5/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=5/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=4/7][dd=5/14][k=3/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=6/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=6/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=6/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=4/7][dd=6/14][k=3/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=7/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=7/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=7/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=4/7][dd=7/14][k=3/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=8/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=8/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=8/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=5/13][j=4/7][dd=10/14][k=0/9] | type: int ; var : tlv8 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=5/13][j=4/7][dd=10/14][k=1/9] | type: char ; var : tlv7 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(char*)p->desc' - False OR  False
[i=5/13][j=4/7][dd=10/14][k=2/9] | type: char * ; var : tlv6 ; varinfo :  ; value_node : ( char * ) p -> desc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,char,*,),p,->,desc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) desc [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=5/13][j=4/7][dd=10/14][k=3/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('Product *','p','None','None');

----
UNIQ_INIT: ('Product *','p','None','None');

----
UNIQ_INIT: ('Product *','p','None','None');

----
UNIQ_INIT: ('Product *','p','None','None');

==== Scope 1 ====
void fix_ingred_products_5_4_0(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(STDIN); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(STDIN); }
    {int tlv8; tlv8 = (int)(STDIN); }
    {char tlv7; tlv7 = (char)(STDIN); }
    {char * tlv6; tlv6 = (char *)(STDIN); }
    {unsigned int tlv5; tlv5 = (unsigned int)(STDIN); }
    {void * tlv1; tlv1 = (void *)(STDIN); }
}
void fix_ingred_products_5_4_1(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {if (DESC_TERM){int bytes_recvd; bytes_recvd = (int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){cgc_size_t tlv3; tlv3 = (cgc_size_t)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){int tlv8; tlv8 = (int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char tlv7; tlv7 = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char * tlv6; tlv6 = (char *)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){unsigned int tlv5; tlv5 = (unsigned int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){void * tlv1; tlv1 = (void *)(DESC_TERM [ 0 ]); }}
}
void fix_ingred_products_5_4_2(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(( char * ) p -> desc); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(( char * ) p -> desc); }
    {int tlv8; tlv8 = (int)(( char * ) p -> desc); }
    {char tlv7; tlv7 = (char)(( char * ) p -> desc); }
    {char * tlv6; tlv6 = (char *)(( char * ) p -> desc); }
    {unsigned int tlv5; tlv5 = (unsigned int)(( char * ) p -> desc); }
    {void * tlv1; tlv1 = (void *)(( char * ) p -> desc); }
}
void fix_ingred_products_5_4_3(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(sizeof ( Product )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( Product )); }
    {int tlv8; tlv8 = (int)(sizeof ( Product )); }
    {char tlv7; tlv7 = (char)(sizeof ( Product )); }
    {char * tlv6; tlv6 = (char *)(sizeof ( Product )); }
    {void * tlv1; tlv1 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_5_4(){
fix_ingred_products_5_4_0();
fix_ingred_products_5_4_1();
fix_ingred_products_5_4_2();
fix_ingred_products_5_4_3();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int', 'tlv3': 'cgc_size_t', 'tlv4': 'char * *', 'tlv8': 'int', 'tlv7': 'char', 'tlv6': 'char *', 'tlv5': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68079438>), ('UNDEF', 'p -> update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67f1e278>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff67163ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff67163dd8>)]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=2/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
unique : ('int', 'bytes_recvd', None)
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=3/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=5/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=6/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=7/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=8/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=5/13][j=5/7][dd=10/14][k=6/7] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
not valid - int bytes_recvd; bytes_recvd = ((int)bytes_recvd);

----
UNIQ_INIT: ('int','bytes_recvd','None','None');

==== Scope 1 ====
void fix_ingred_products_5_5_6(){
int bytes_recvd;
    bzero(&bytes_recvd,sizeof(int));
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(bytes_recvd); }
    {int tlv8; tlv8 = (int)(bytes_recvd); }
    {char tlv7; tlv7 = (char)(bytes_recvd); }
    {char * tlv6; tlv6 = (char *)(bytes_recvd); }
    {unsigned int tlv5; tlv5 = (unsigned int)(bytes_recvd); }
    {void * tlv1; tlv1 = (void *)(bytes_recvd); }
}
void fix_ingred_products_5_5(){
fix_ingred_products_5_5_6();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'p2': 'Product *', 'bytes_recvd': 'int', 'tlv3': 'cgc_size_t', 'tlv4': 'char * *', 'tlv8': 'int', 'tlv7': 'char', 'tlv6': 'char *', 'tlv5': 'unsigned int', 'tlv2': 'struct list *', 'tlv1': 'void *'}'
val_s=>'[('struct list *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671817b8>), ('void *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6717e898>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67beac88>), ('Product *', 'p2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6709b5f8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67b7a908>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff68079438>), ('UNDEF', 'p -> update_serial', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67f1e278>), ('UNDEF', 'p -> desc ', '[ bytes_recvd - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67176588>)]'
cval_s=>'[]'
Checking 'MALLOC_OK( p )' - is_func=True, is_func_ptr=False
MALLOC_OK( p ) is a function.
Skipping.
Checking 'cgc_free( p )' - is_func=True, is_func_ptr=False
cgc_free( p ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=5/13][j=6/7][dd=2/14][k=1/8] | type: void * ; var : tlv1 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
unique : ('Product *', 'p', None)
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=5/13][j=6/7][dd=3/14][k=1/8] | type: void * ; var : tlv1 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=5/13][j=6/7][dd=5/14][k=1/8] | type: void * ; var : tlv1 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=5/13][j=6/7][dd=6/14][k=1/8] | type: void * ; var : tlv1 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=5/13][j=6/7][dd=7/14][k=1/8] | type: void * ; var : tlv1 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'p' - False OR  False
[i=5/13][j=6/7][dd=10/14][k=1/8] | type: void * ; var : tlv1 ; varinfo :  ; value_node : p (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : p
 => is literal (False) | is operator (False) p [vtype=Product *]
not unique: ('Product *', 'p', None) ... continue!
----
UNIQ_INIT: ('Product *','p','None','None');

==== Scope 1 ====
void fix_ingred_products_5_6_1(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(p); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(p); }
    {int tlv8; tlv8 = (int)(p); }
    {char tlv7; tlv7 = (char)(p); }
    {char * tlv6; tlv6 = (char *)(p); }
    {void * tlv1; tlv1 = (void *)(p); }
}
void fix_ingred_products_5_6(){
fix_ingred_products_5_6_1();
}

==== Scope 2 ====
void fix_ingred_products_5_0_2(){
    {int bytes_recvd; bytes_recvd = (int)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv8; tlv8 = (int)(0); }
    {char tlv7; tlv7 = (char)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
    {void * tlv1; tlv1 = (void *)(0); }
}
void fix_ingred_products_5_0(){
fix_ingred_products_5_0_2();
}
void fix_ingred_products_5_1_0(){
    {int bytes_recvd; bytes_recvd = (int)(sizeof ( Product )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( Product )); }
    {int tlv8; tlv8 = (int)(sizeof ( Product )); }
    {char tlv7; tlv7 = (char)(sizeof ( Product )); }
    {char * tlv6; tlv6 = (char *)(sizeof ( Product )); }
    {void * tlv1; tlv1 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_5_1(){
fix_ingred_products_5_1_0();
}
void fix_ingred_products_5_4_0(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(STDIN); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(STDIN); }
    {int tlv8; tlv8 = (int)(STDIN); }
    {char tlv7; tlv7 = (char)(STDIN); }
    {char * tlv6; tlv6 = (char *)(STDIN); }
    {unsigned int tlv5; tlv5 = (unsigned int)(STDIN); }
    {void * tlv1; tlv1 = (void *)(STDIN); }
}
void fix_ingred_products_5_4_1(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {if (DESC_TERM){int bytes_recvd; bytes_recvd = (int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){cgc_size_t tlv3; tlv3 = (cgc_size_t)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){int tlv8; tlv8 = (int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char tlv7; tlv7 = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char * tlv6; tlv6 = (char *)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){unsigned int tlv5; tlv5 = (unsigned int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){void * tlv1; tlv1 = (void *)(DESC_TERM [ 0 ]); }}
}
void fix_ingred_products_5_4_2(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(( char * ) p -> desc); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(( char * ) p -> desc); }
    {int tlv8; tlv8 = (int)(( char * ) p -> desc); }
    {char tlv7; tlv7 = (char)(( char * ) p -> desc); }
    {char * tlv6; tlv6 = (char *)(( char * ) p -> desc); }
    {unsigned int tlv5; tlv5 = (unsigned int)(( char * ) p -> desc); }
    {void * tlv1; tlv1 = (void *)(( char * ) p -> desc); }
}
void fix_ingred_products_5_4_3(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(sizeof ( Product )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( Product )); }
    {int tlv8; tlv8 = (int)(sizeof ( Product )); }
    {char tlv7; tlv7 = (char)(sizeof ( Product )); }
    {char * tlv6; tlv6 = (char *)(sizeof ( Product )); }
    {void * tlv1; tlv1 = (void *)(sizeof ( Product )); }
}
void fix_ingred_products_5_4(){
fix_ingred_products_5_4_0();
fix_ingred_products_5_4_1();
fix_ingred_products_5_4_2();
fix_ingred_products_5_4_3();
}
void fix_ingred_products_5_5_6(){
int bytes_recvd;
    bzero(&bytes_recvd,sizeof(int));
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(bytes_recvd); }
    {int tlv8; tlv8 = (int)(bytes_recvd); }
    {char tlv7; tlv7 = (char)(bytes_recvd); }
    {char * tlv6; tlv6 = (char *)(bytes_recvd); }
    {unsigned int tlv5; tlv5 = (unsigned int)(bytes_recvd); }
    {void * tlv1; tlv1 = (void *)(bytes_recvd); }
}
void fix_ingred_products_5_5(){
fix_ingred_products_5_5_6();
}
void fix_ingred_products_5_6_1(){
Product p_ref;
    bzero(&p_ref,1*sizeof(Product));
Product * p = &p_ref;
    {int bytes_recvd; bytes_recvd = (int)(p); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(p); }
    {int tlv8; tlv8 = (int)(p); }
    {char tlv7; tlv7 = (char)(p); }
    {char * tlv6; tlv6 = (char *)(p); }
    {void * tlv1; tlv1 = (void *)(p); }
}
void fix_ingred_products_5_6(){
fix_ingred_products_5_6_1();
}
void fix_ingred_products_5(){
fix_ingred_products_5_0();
fix_ingred_products_5_1();
fix_ingred_products_5_4();
fix_ingred_products_5_5();
fix_ingred_products_5_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_5_0_2();
void fix_ingred_products_5_0();
void fix_ingred_products_5_1_0();
void fix_ingred_products_5_1();
void fix_ingred_products_5_4_0();
void fix_ingred_products_5_4_1();
void fix_ingred_products_5_4_2();
void fix_ingred_products_5_4_3();
void fix_ingred_products_5_4();
void fix_ingred_products_5_5_6();
void fix_ingred_products_5_5();
void fix_ingred_products_5_6_1();
void fix_ingred_products_5_6();
void fix_ingred_products_5();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : char bc [ BARCODE_SZ ] = { 0 } ;
def_vars[2]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : struct node * np ;
def_vars[3]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv7 ;
def_vars[4]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : unsigned char * tlv6 ;
def_vars[5]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : void * tlv5 ;
def_vars[6]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv2 ;
def_vars[7]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : struct node * tlv1 ;
def_vars[8]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv4 ;
def_vars[9]: [cgc_do_rm] : <class 'CParser.CParser.DeclarationContext'> : struct node * * tlv3 ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'np': 'struct node *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d63668>), ('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d82ac8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'np': 'struct node *', 'tlv7': 'struct list *', 'tlv6': 'unsigned char *', 'tlv5': 'void *'}'
val_s=>'[('struct list *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d75ba8>), ('void *', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d6cc18>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d63668>), ('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d82ac8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)bc' - False OR  False
[i=6/13][j=1/5][dd=1/10][k=1/4] | type: void * ; var : tlv5 ; varinfo :  ; value_node : ( void * ) bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),bc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) bc [vtype=char *]
BEFORE => literal (False) bc => char *
AFTER => literal (False) bc [ BARCODE_SZ ] => char [size=BARCODE_SZ]
Array size is variable => 'BARCODE_SZ'
unique : ('char', 'bc [ BARCODE_SZ ]', None)
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)bc' - False OR  False
[i=6/13][j=1/5][dd=5/10][k=1/4] | type: void * ; var : tlv5 ; varinfo :  ; value_node : ( void * ) bc (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),bc
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) bc [vtype=char *]
BEFORE => literal (False) bc => char *
AFTER => literal (False) bc [ BARCODE_SZ ] => char [size=BARCODE_SZ]
Array size is variable => 'BARCODE_SZ'
not unique: ('char', 'bc [ BARCODE_SZ ]', None) ... continue!
----
UNIQ_INIT: ('char','bc [ BARCODE_SZ ]','None','None');

==== Scope 1 ====
void fix_ingred_products_6_1_1(){
char bc [ BARCODE_SZ ];
    bzero(&bc,( BARCODE_SZ *sizeof(char) ) );
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(( void * ) bc); }
    {void * tlv5; tlv5 = (void *)(( void * ) bc); }
}
void fix_ingred_products_6_1(){
fix_ingred_products_6_1_1();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'np': 'struct node *', 'tlv7': 'struct list *', 'tlv6': 'unsigned char *', 'tlv5': 'void *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d63668>), ('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d82ac8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67d52c18>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67d52f98>)]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'np': 'struct node *', 'tlv7': 'struct list *', 'tlv6': 'unsigned char *', 'tlv5': 'void *', 'tlv2': 'struct list *', 'tlv1': 'struct node *'}'
val_s=>'[('struct list *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d819e8>), ('struct node *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d73ba8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d63668>), ('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d82ac8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'np': 'struct node *', 'tlv7': 'struct list *', 'tlv6': 'unsigned char *', 'tlv5': 'void *', 'tlv2': 'struct list *', 'tlv1': 'struct node *', 'tlv4': 'struct list *', 'tlv3': 'struct node * *'}'
val_s=>'[('struct list *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6788bac8>), ('struct node * *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67883c88>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d63668>), ('struct node *', 'np', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67d82ac8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
==== Scope 2 ====
void fix_ingred_products_6_1_1(){
char bc [ BARCODE_SZ ];
    bzero(&bc,( BARCODE_SZ *sizeof(char) ) );
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(( void * ) bc); }
    {void * tlv5; tlv5 = (void *)(( void * ) bc); }
}
void fix_ingred_products_6_1(){
fix_ingred_products_6_1_1();
}
void fix_ingred_products_6(){
fix_ingred_products_6_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_6_1_1();
void fix_ingred_products_6_1();
void fix_ingred_products_6();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : int bytes_recvd ;
def_vars[1]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[2]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : unsigned int ( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) = cgc_memcpy ;
def_vars[3]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : char bc [ BARCODE_SZ ] = { 0 } ;
def_vars[4]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : char desc_buf [ MAX_DESC_LEN ] = { 0 } ;
def_vars[5]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv1 ;
def_vars[6]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[7]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : char tlv4 ;
def_vars[8]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : char * tlv3 ;
def_vars[9]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv2 ;
def_vars[10]: [cgc_do_update] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( ERRNO_RECV ) ;
sym_lut=>'{'void': 'int', 'bytes_recvd': 'int', 'p': 'Product *', '( * desc_copy )': 'unsigned int *', '(': 'unsigned int **', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )': 'unsigned int', '* desc_copy': 'unsigned int', 'dst': 'void *', 'src': 'const void *', 'cnt': 'unsigned int', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'desc_buf': 'char *', 'desc_buf [ MAX_DESC_LEN ]': 'char'}'
val_s=>'[('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67891a58>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67894a58>), ('UNDEF', 'desc_buf ', '[ bytes_recvd - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674c3f98>)]'
cval_s=>'[]'
Checking 'unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )' - is_func=False, is_func_ptr=True
unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
vtype==>int,vname==>MAX_DESC_LEN 
Skipping MAX_DESC_LEN => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/13][j=0/5][dd=3/11][k=0/3] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/13][j=0/5][dd=5/11][k=0/3] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/13][j=0/5][dd=6/11][k=0/3] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/13][j=0/5][dd=7/11][k=0/3] | type: int ; var : bytes_recvd ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_products_7_0_0(){
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char tlv4; tlv4 = (char)(0); }
    {char * tlv3; tlv3 = (char *)(0); }
}
void fix_ingred_products_7_0(){
fix_ingred_products_7_0_0();
}

sym_lut=>'{'void': 'int', 'bytes_recvd': 'int', 'p': 'Product *', '( * desc_copy )': 'unsigned int *', '(': 'unsigned int **', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )': 'unsigned int', '* desc_copy': 'unsigned int', 'dst': 'void *', 'src': 'const void *', 'cnt': 'unsigned int', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'desc_buf': 'char *', 'desc_buf [ MAX_DESC_LEN ]': 'char', 'tlv1': 'char * *'}'
val_s=>'[('char * *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676023c8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67891a58>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67894a58>)]'
cval_s=>'[]'
Checking 'unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )' - is_func=False, is_func_ptr=True
unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
vtype==>int,vname==>MAX_DESC_LEN 
Skipping MAX_DESC_LEN => #define
sym_lut=>'{'void': 'int', 'bytes_recvd': 'int', 'p': 'Product *', '( * desc_copy )': 'unsigned int *', '(': 'unsigned int **', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )': 'unsigned int', '* desc_copy': 'unsigned int', 'dst': 'void *', 'src': 'const void *', 'cnt': 'unsigned int', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'desc_buf': 'char *', 'desc_buf [ MAX_DESC_LEN ]': 'char', 'tlv1': 'char * *'}'
val_s=>'[('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67891a58>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67894a58>)]'
cval_s=>'[('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff675f7048>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff675f73c8>)]'
Checking 'unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )' - is_func=False, is_func_ptr=True
unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
vtype==>int,vname==>MAX_DESC_LEN 
Skipping MAX_DESC_LEN => #define
sym_lut=>'{'void': 'int', 'bytes_recvd': 'int', 'p': 'Product *', '( * desc_copy )': 'unsigned int *', '(': 'unsigned int **', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )': 'unsigned int', '* desc_copy': 'unsigned int', 'dst': 'void *', 'src': 'const void *', 'cnt': 'unsigned int', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'desc_buf': 'char *', 'desc_buf [ MAX_DESC_LEN ]': 'char', 'tlv1': 'char * *', 'tlv5': 'int', 'tlv4': 'char', 'tlv3': 'char *', 'tlv2': 'unsigned int'}'
val_s=>'[('int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675fe978>), ('char', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675f0828>), ('char *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675ecf28>), ('unsigned int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff675ccdd8>), ('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67891a58>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67894a58>)]'
cval_s=>'[]'
Checking 'unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )' - is_func=False, is_func_ptr=True
unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=0/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
unique : ('char', 'desc_buf [ MAX_DESC_LEN ]', None)
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=7/13][j=3/5][dd=2/11][k=0/6] | type: int ; var : tlv5 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=7/13][j=3/5][dd=2/11][k=1/6] | type: char ; var : tlv4 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=2/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
not unique: ('char', 'desc_buf [ MAX_DESC_LEN ]', None) ... continue!
vtype==>int,vname==>MAX_DESC_LEN 
Skipping MAX_DESC_LEN => #define
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=7/13][j=3/5][dd=3/11][k=0/6] | type: int ; var : tlv5 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=7/13][j=3/5][dd=3/11][k=1/6] | type: char ; var : tlv4 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=3/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
not unique: ('char', 'desc_buf [ MAX_DESC_LEN ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=7/13][j=3/5][dd=3/11][k=3/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=7/13][j=3/5][dd=5/11][k=0/6] | type: int ; var : tlv5 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=7/13][j=3/5][dd=5/11][k=1/6] | type: char ; var : tlv4 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=5/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
not unique: ('char', 'desc_buf [ MAX_DESC_LEN ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=7/13][j=3/5][dd=5/11][k=3/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=7/13][j=3/5][dd=6/11][k=0/6] | type: int ; var : tlv5 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=7/13][j=3/5][dd=6/11][k=1/6] | type: char ; var : tlv4 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=6/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
not unique: ('char', 'desc_buf [ MAX_DESC_LEN ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=7/13][j=3/5][dd=6/11][k=3/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=7/13][j=3/5][dd=7/11][k=0/6] | type: int ; var : tlv5 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=7/13][j=3/5][dd=7/11][k=1/6] | type: char ; var : tlv4 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=7/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
not unique: ('char', 'desc_buf [ MAX_DESC_LEN ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=7/13][j=3/5][dd=7/11][k=3/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=7/13][j=3/5][dd=8/11][k=0/6] | type: int ; var : tlv5 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [D] => '[False, False, False]'
has_multiptr_refs 'DESC_TERM[0]' - False OR  False
[i=7/13][j=3/5][dd=8/11][k=1/6] | type: char ; var : tlv4 ; varinfo :  ; value_node : DESC_TERM [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : DESC_TERM,[,0,]
 => is literal (False) | is operator (False) DESC_TERM [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'desc_buf' - False OR  False
[i=7/13][j=3/5][dd=8/11][k=2/6] | type: char * ; var : tlv3 ; varinfo :  ; value_node : desc_buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : desc_buf
 => is literal (False) | is operator (False) desc_buf [vtype=char *]
BEFORE => literal (False) desc_buf => char *
AFTER => literal (False) desc_buf [ MAX_DESC_LEN ] => char [size=MAX_DESC_LEN]
Array size is variable => 'MAX_DESC_LEN'
not unique: ('char', 'desc_buf [ MAX_DESC_LEN ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(Product)' - False OR  False
[i=7/13][j=3/5][dd=8/11][k=3/6] | type: unsigned int ; var : tlv2 ; varinfo :  ; value_node : sizeof ( Product ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,Product,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) Product [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','desc_buf [ MAX_DESC_LEN ]','None','None');

----
UNIQ_INIT: ('char','desc_buf [ MAX_DESC_LEN ]','None','None');

----
UNIQ_INIT: ('char','desc_buf [ MAX_DESC_LEN ]','None','None');

----
UNIQ_INIT: ('char','desc_buf [ MAX_DESC_LEN ]','None','None');

==== Scope 1 ====
void fix_ingred_products_7_3_0(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(STDIN); }
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(STDIN); }
    {int tlv5; tlv5 = (int)(STDIN); }
    {char tlv4; tlv4 = (char)(STDIN); }
    {char * tlv3; tlv3 = (char *)(STDIN); }
    {unsigned int tlv2; tlv2 = (unsigned int)(STDIN); }
}
void fix_ingred_products_7_3_1(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {if (DESC_TERM){char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){int tlv5; tlv5 = (int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char tlv4; tlv4 = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char * tlv3; tlv3 = (char *)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){unsigned int tlv2; tlv2 = (unsigned int)(DESC_TERM [ 0 ]); }}
}
void fix_ingred_products_7_3_2(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {int bytes_recvd; bytes_recvd = (int)(desc_buf); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(desc_buf); }
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(desc_buf); }
    {int tlv5; tlv5 = (int)(desc_buf); }
    {char tlv4; tlv4 = (char)(desc_buf); }
    {char * tlv3; tlv3 = (char *)(desc_buf); }
    {unsigned int tlv2; tlv2 = (unsigned int)(desc_buf); }
}
void fix_ingred_products_7_3_3(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(sizeof ( Product )); }
    {int tlv5; tlv5 = (int)(sizeof ( Product )); }
    {char tlv4; tlv4 = (char)(sizeof ( Product )); }
    {char * tlv3; tlv3 = (char *)(sizeof ( Product )); }
    {unsigned int tlv2; tlv2 = (unsigned int)(sizeof ( Product )); }
}
void fix_ingred_products_7_3(){
fix_ingred_products_7_3_0();
fix_ingred_products_7_3_1();
fix_ingred_products_7_3_2();
fix_ingred_products_7_3_3();
}

sym_lut=>'{'void': 'int', 'bytes_recvd': 'int', 'p': 'Product *', '( * desc_copy )': 'unsigned int *', '(': 'unsigned int **', '( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )': 'unsigned int', '* desc_copy': 'unsigned int', 'dst': 'void *', 'src': 'const void *', 'cnt': 'unsigned int', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'desc_buf': 'char *', 'desc_buf [ MAX_DESC_LEN ]': 'char', 'tlv1': 'char * *', 'tlv5': 'int', 'tlv4': 'char', 'tlv3': 'char *', 'tlv2': 'unsigned int'}'
val_s=>'[('int', 'bytes_recvd', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67891a58>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67894a58>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff674e3518>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff674e3828>)]'
Checking 'unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt )' - is_func=False, is_func_ptr=True
unsigned int( * desc_copy ) ( void * dst , const void * src , unsigned int cnt ) is a function.
Skipping.
Checking 'cgc__terminate( ERRNO_RECV )' - is_func=True, is_func_ptr=False
cgc__terminate( ERRNO_RECV ) is a function.
Skipping.
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=7/13][j=4/5][dd=2/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
unique : ('int', 'bytes_recvd', None)
vtype==>int,vname==>MAX_DESC_LEN 
Skipping MAX_DESC_LEN => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=7/13][j=4/5][dd=3/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=7/13][j=4/5][dd=5/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=7/13][j=4/5][dd=6/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=7/13][j=4/5][dd=7/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'bytes_recvd' - False OR  False
[i=7/13][j=4/5][dd=8/11][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : bytes_recvd (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : bytes_recvd
 => is literal (False) | is operator (False) bytes_recvd [vtype=int]
not unique: ('int', 'bytes_recvd', None) ... continue!
----
UNIQ_INIT: ('int','bytes_recvd','None','None');

==== Scope 1 ====
void fix_ingred_products_7_4_3(){
int bytes_recvd;
    bzero(&bytes_recvd,sizeof(int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(bytes_recvd); }
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(bytes_recvd); }
    {int tlv5; tlv5 = (int)(bytes_recvd); }
    {char tlv4; tlv4 = (char)(bytes_recvd); }
    {char * tlv3; tlv3 = (char *)(bytes_recvd); }
    {unsigned int tlv2; tlv2 = (unsigned int)(bytes_recvd); }
}
void fix_ingred_products_7_4(){
fix_ingred_products_7_4_3();
}

==== Scope 2 ====
void fix_ingred_products_7_0_0(){
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char tlv4; tlv4 = (char)(0); }
    {char * tlv3; tlv3 = (char *)(0); }
}
void fix_ingred_products_7_0(){
fix_ingred_products_7_0_0();
}
void fix_ingred_products_7_3_0(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(STDIN); }
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(STDIN); }
    {int tlv5; tlv5 = (int)(STDIN); }
    {char tlv4; tlv4 = (char)(STDIN); }
    {char * tlv3; tlv3 = (char *)(STDIN); }
    {unsigned int tlv2; tlv2 = (unsigned int)(STDIN); }
}
void fix_ingred_products_7_3_1(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {if (DESC_TERM){char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){int tlv5; tlv5 = (int)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char tlv4; tlv4 = (char)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){char * tlv3; tlv3 = (char *)(DESC_TERM [ 0 ]); }}
    {if (DESC_TERM){unsigned int tlv2; tlv2 = (unsigned int)(DESC_TERM [ 0 ]); }}
}
void fix_ingred_products_7_3_2(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {int bytes_recvd; bytes_recvd = (int)(desc_buf); }
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(desc_buf); }
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(desc_buf); }
    {int tlv5; tlv5 = (int)(desc_buf); }
    {char tlv4; tlv4 = (char)(desc_buf); }
    {char * tlv3; tlv3 = (char *)(desc_buf); }
    {unsigned int tlv2; tlv2 = (unsigned int)(desc_buf); }
}
void fix_ingred_products_7_3_3(){
char desc_buf [ MAX_DESC_LEN ];
    bzero(&desc_buf,( MAX_DESC_LEN *sizeof(char) ) );
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(sizeof ( Product )); }
    {int tlv5; tlv5 = (int)(sizeof ( Product )); }
    {char tlv4; tlv4 = (char)(sizeof ( Product )); }
    {char * tlv3; tlv3 = (char *)(sizeof ( Product )); }
    {unsigned int tlv2; tlv2 = (unsigned int)(sizeof ( Product )); }
}
void fix_ingred_products_7_3(){
fix_ingred_products_7_3_0();
fix_ingred_products_7_3_1();
fix_ingred_products_7_3_2();
fix_ingred_products_7_3_3();
}
void fix_ingred_products_7_4_3(){
int bytes_recvd;
    bzero(&bytes_recvd,sizeof(int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(bytes_recvd); }
    {char desc_buf [ MAX_DESC_LEN ]; desc_buf [ ( MAX_DESC_LEN )-1 ] = (char)(bytes_recvd); }
    {int tlv5; tlv5 = (int)(bytes_recvd); }
    {char tlv4; tlv4 = (char)(bytes_recvd); }
    {char * tlv3; tlv3 = (char *)(bytes_recvd); }
    {unsigned int tlv2; tlv2 = (unsigned int)(bytes_recvd); }
}
void fix_ingred_products_7_4(){
fix_ingred_products_7_4_3();
}
void fix_ingred_products_7(){
fix_ingred_products_7_0();
fix_ingred_products_7_3();
fix_ingred_products_7_4();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_7_0_0();
void fix_ingred_products_7_0();
void fix_ingred_products_7_3_0();
void fix_ingred_products_7_3_1();
void fix_ingred_products_7_3_2();
void fix_ingred_products_7_3_3();
void fix_ingred_products_7_3();
void fix_ingred_products_7_4_3();
void fix_ingred_products_7_4();
void fix_ingred_products_7();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_onsale] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_onsale] : <class 'CParser.CParser.DeclarationContext'> : char bc [ BARCODE_SZ ] = { 0 } ;
def_vars[2]: [cgc_do_onsale] : <class 'CParser.CParser.DeclarationContext'> : unsigned int sale_percent ;
def_vars[3]: [cgc_do_onsale] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv1 ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f9198>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674e7438>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674e5ac8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=8/13][j=0/4][dd=2/4][k=1/3] | type: unsigned int ; var : sale_percent ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_products_8_0_1(){
    {unsigned int sale_percent; sale_percent = (unsigned int)(0); }
}
void fix_ingred_products_8_0(){
fix_ingred_products_8_0_1();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('char * *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674ec438>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f9198>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674e7438>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f9198>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674e7438>)]'
cval_s=>'[('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff674d0dd8>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67501198>)]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f9198>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674e7438>)]'
cval_s=>'[('unsigned int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff674d8518>), ('unsigned int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff674d8828>)]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '100' - False OR  False
[i=8/13][j=3/4][dd=1/4][k=2/4] | type: unsigned int ; var :  ; varinfo :  ; value_node : 100 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 100
 => is literal (True) | is operator (False) 100
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'sale_percent' - False OR  False
[i=8/13][j=3/4][dd=1/4][k=3/4] | type: unsigned int ; var :  ; varinfo :  ; value_node : sale_percent (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : sale_percent
 => is literal (False) | is operator (False) sale_percent [vtype=unsigned int]
unique : ('unsigned int', 'sale_percent', None)
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '100' - False OR  False
[i=8/13][j=3/4][dd=2/4][k=2/4] | type: unsigned int ; var :  ; varinfo :  ; value_node : 100 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 100
 => is literal (True) | is operator (False) 100
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'sale_percent' - False OR  False
[i=8/13][j=3/4][dd=2/4][k=3/4] | type: unsigned int ; var :  ; varinfo :  ; value_node : sale_percent (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : sale_percent
 => is literal (False) | is operator (False) sale_percent [vtype=unsigned int]
not unique: ('unsigned int', 'sale_percent', None) ... continue!
----
UNIQ_INIT: ('unsigned int','sale_percent','None','None');

not valid - unsigned int sale_percent; sale_percent = ((unsigned int)sale_percent);

----
UNIQ_INIT: ('unsigned int','sale_percent','None','None');

==== Scope 1 ====
void fix_ingred_products_8_3_2(){
unsigned int sale_percent;
    bzero(&sale_percent,sizeof(unsigned int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(100); }
    {unsigned int sale_percent; sale_percent = (unsigned int)(100); }
}
void fix_ingred_products_8_3_3(){
unsigned int sale_percent;
    bzero(&sale_percent,sizeof(unsigned int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sale_percent); }
}
void fix_ingred_products_8_3(){
fix_ingred_products_8_3_2();
fix_ingred_products_8_3_3();
}

==== Scope 2 ====
void fix_ingred_products_8_0_1(){
    {unsigned int sale_percent; sale_percent = (unsigned int)(0); }
}
void fix_ingred_products_8_0(){
fix_ingred_products_8_0_1();
}
void fix_ingred_products_8_3_2(){
unsigned int sale_percent;
    bzero(&sale_percent,sizeof(unsigned int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(100); }
    {unsigned int sale_percent; sale_percent = (unsigned int)(100); }
}
void fix_ingred_products_8_3_3(){
unsigned int sale_percent;
    bzero(&sale_percent,sizeof(unsigned int));
    {char bc [ BARCODE_SZ ]; bc [ ( BARCODE_SZ )-1 ] = (char)(sale_percent); }
}
void fix_ingred_products_8_3(){
fix_ingred_products_8_3_2();
fix_ingred_products_8_3_3();
}
void fix_ingred_products_8(){
fix_ingred_products_8_0();
fix_ingred_products_8_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_8_0_1();
void fix_ingred_products_8_0();
void fix_ingred_products_8_3_2();
void fix_ingred_products_8_3_3();
void fix_ingred_products_8_3();
void fix_ingred_products_8();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_nosale] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_nosale] : <class 'CParser.CParser.DeclarationContext'> : char bc [ BARCODE_SZ ] = { 0 } ;
def_vars[2]: [cgc_do_nosale] : <class 'CParser.CParser.DeclarationContext'> : unsigned int sale_percent ;
def_vars[3]: [cgc_do_nosale] : <class 'CParser.CParser.DeclarationContext'> : char * * tlv1 ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674c9358>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674d95f8>), ('UNDEF', 'p -> sfn', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674ea668>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('char * *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674d35f8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674c9358>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674d95f8>)]'
cval_s=>'[]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
sym_lut=>'{'void': 'int', 'p': 'Product *', 'bc': 'char *', 'bc [ BARCODE_SZ ]': 'char', 'sale_percent': 'unsigned int', 'tlv1': 'char * *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674c9358>), ('unsigned int', 'sale_percent', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674d95f8>)]'
cval_s=>'[('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff674d5f98>), ('Product *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff674e0358>)]'
vtype==>int,vname==>BARCODE_SZ 
Skipping BARCODE_SZ => #define
==== Scope 2 ====
void fix_ingred_products_9(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_9();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : Product * p ;
def_vars[1]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : char options [ 4 ] = { 0 } ;
def_vars[2]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : unsigned int count ;
def_vars[3]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : unsigned int d_len ;
def_vars[4]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : float sale_price ;
def_vars[5]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : struct node * cur ;
def_vars[6]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : struct node * end ;
def_vars[7]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv1 ;
def_vars[8]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv2 ;
def_vars[9]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv3 ;
def_vars[10]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : struct node * tlv4 ;
def_vars[11]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv6 = p -> desc ;
def_vars[12]: [cgc_do_list] : <class 'CParser.CParser.DeclarationContext'> : char tlv5 ;
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=0/13][dd=1/13][k=1/3] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=0/13][dd=2/13][k=1/3] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=0/13][dd=12/13][k=1/3] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_products_10_0_1(){
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(0); }
    {unsigned int count; count = (unsigned int)(0); }
    {char tlv5; tlv5 = (char)(0); }
}
void fix_ingred_products_10_0(){
fix_ingred_products_10_0_1();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *'}'
val_s=>'[('struct list *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ea1898>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *'}'
val_s=>'[('struct list *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ea4c18>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('struct list *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ec0278>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>)]'
cval_s=>'[('unsigned int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66ebf978>), ('unsigned int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66ebfcf8>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=10/13][j=4/13][dd=1/13][k=4/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=unsigned int]
unique : ('unsigned int', 'count', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=10/13][j=4/13][dd=2/13][k=4/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=unsigned int]
not unique: ('unsigned int', 'count', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=10/13][j=4/13][dd=3/13][k=4/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=unsigned int]
not unique: ('unsigned int', 'count', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=10/13][j=4/13][dd=12/13][k=4/5] | type: unsigned int ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=unsigned int]
not unique: ('unsigned int', 'count', None) ... continue!
not valid - unsigned int count; count = ((unsigned int)count);

----
UNIQ_INIT: ('unsigned int','count','None','None');

==== Scope 1 ====
void fix_ingred_products_10_4_4(){
unsigned int count;
    bzero(&count,sizeof(unsigned int));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(count); }
    {unsigned int d_len; d_len = (unsigned int)(count); }
    {char tlv5; tlv5 = (char)(count); }
}
void fix_ingred_products_10_4(){
fix_ingred_products_10_4_4();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>)]'
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e9cc88>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e88048>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=6/13][dd=1/13][k=8/10] | type: char * ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[0]%2' - False OR  False
[i=10/13][j=6/13][dd=1/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 0 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,0,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
unique : ('char', 'options [ 4 ]', None)
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=6/13][dd=2/13][k=8/10] | type: char * ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[0]%2' - False OR  False
[i=10/13][j=6/13][dd=2/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 0 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,0,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=6/13][dd=3/13][k=8/10] | type: char * ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[0]%2' - False OR  False
[i=10/13][j=6/13][dd=3/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 0 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,0,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=10/13][j=6/13][dd=12/13][k=8/10] | type: char * ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[0]%2' - False OR  False
[i=10/13][j=6/13][dd=12/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 0 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,0,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
----
UNIQ_INIT: ('char','options [ 4 ]','None','None');

==== Scope 1 ====
void fix_ingred_products_10_6_8(){
char options [ 4 ];
    bzero(&options,( 4 *sizeof(char) ) );
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(0); }
    {unsigned int count; count = (unsigned int)(0); }
    {unsigned int d_len; d_len = (unsigned int)(0); }
    {char tlv5; tlv5 = (char)(0); }
}
void fix_ingred_products_10_6(){
fix_ingred_products_10_6_8();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e8b278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e8b5f8>)]'
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[1]%2' - False OR  False
[i=10/13][j=7/13][dd=1/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 1 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,1,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
unique : ('char', 'options [ 4 ]', None)
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[1]%2' - False OR  False
[i=10/13][j=7/13][dd=2/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 1 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,1,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[1]%2' - False OR  False
[i=10/13][j=7/13][dd=3/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 1 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,1,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[1]%2' - False OR  False
[i=10/13][j=7/13][dd=12/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 1 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,1,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66eb7dd8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eba828>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66ebaba8>)]'
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[2]%2' - False OR  False
[i=10/13][j=8/13][dd=1/13][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : options [ 2 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,2,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
unique : ('char', 'options [ 4 ]', None)
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 2
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[2]%2' - False OR  False
[i=10/13][j=8/13][dd=2/13][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : options [ 2 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,2,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 2
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[2]%2' - False OR  False
[i=10/13][j=8/13][dd=3/13][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : options [ 2 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,2,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 2
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[2]%2' - False OR  False
[i=10/13][j=8/13][dd=12/13][k=10/11] | type: char * ; var :  ; varinfo :  ; value_node : options [ 2 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,2,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 2
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671ab898>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671abc18>)]'
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[3]%2' - False OR  False
[i=10/13][j=9/13][dd=1/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 3 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,3,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
unique : ('char', 'options [ 4 ]', None)
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 3
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[3]%2' - False OR  False
[i=10/13][j=9/13][dd=2/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 3 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,3,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 3
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[3]%2' - False OR  False
[i=10/13][j=9/13][dd=3/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 3 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,3,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 3
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
is_func_ [o] => '[False, False, False]'
has_multiptr_refs 'options[3]%2' - False OR  False
[i=10/13][j=9/13][dd=12/13][k=9/10] | type: char * ; var :  ; varinfo :  ; value_node : options [ 3 ] % 2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : options,[,3,],%,2
 => is literal (False) | is operator (False) options [vtype=char *]
BEFORE => literal (False) options => char *
AFTER => literal (False) options [ 4 ] => char [size=4]
not unique: ('char', 'options [ 4 ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 3
 => is literal (False) | is operator (True) ]
 => is literal (False) | is operator (True) %
 => is literal (True) | is operator (False) 2
sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *', 'tlv6': 'const char *', 'tlv5': 'char'}'
val_s=>'[('char', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6719c128>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6719cc18>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671ab898>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671abc18>)]'
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=10/13][j=10/13][dd=1/13][k=0/12] | type: char ; var : tlv5 ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6,tlv5)' - False OR  False
[i=10/13][j=10/13][dd=1/13][k=1/12] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv6 , tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,,,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
unique : ('const char *', 'tlv6', None)
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv5 [vtype=char]
unique : ('char', 'tlv5', None)
 => is literal (False) | is operator (True) )
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=10/13][j=10/13][dd=2/13][k=0/12] | type: char ; var : tlv5 ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6,tlv5)' - False OR  False
[i=10/13][j=10/13][dd=2/13][k=1/12] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv6 , tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,,,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv5 [vtype=char]
not unique: ('char', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6,tlv5)' - False OR  False
[i=10/13][j=10/13][dd=3/13][k=1/12] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv6 , tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,,,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv5 [vtype=char]
not unique: ('char', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=10/13][j=10/13][dd=12/13][k=0/12] | type: char ; var : tlv5 ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv6,tlv5)' - False OR  False
[i=10/13][j=10/13][dd=12/13][k=1/12] | type: unsigned int ; var : d_len ; varinfo :  ; value_node : cgc_strlen ( tlv6 , tlv5 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv6,,,tlv5,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv6 [vtype=const char *]
not unique: ('const char *', 'tlv6', None) ... continue!
 => is literal (False) | is operator (True) ,
 => is literal (False) | is operator (False) tlv5 [vtype=char]
not unique: ('char', 'tlv5', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('const char *','tlv6','None','None');

UNIQ_INIT: ('char','tlv5','None','None');

not valid - char tlv5; tlv5 = ((char)cgc_strlen ( tlv6 , tlv5 ));

----
UNIQ_INIT: ('const char *','tlv6','None','None');

UNIQ_INIT: ('char','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_products_10_10_0(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
char tlv5;
    bzero(&tlv5,sizeof(char));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)('\0'); }
    {unsigned int count; count = (unsigned int)('\0'); }
    {char tlv5; tlv5 = (char)('\0'); }
}
void fix_ingred_products_10_10_1(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
char tlv5;
    bzero(&tlv5,sizeof(char));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(cgc_strlen ( tlv6 , tlv5 )); }
    {unsigned int count; count = (unsigned int)(cgc_strlen ( tlv6 , tlv5 )); }
    {unsigned int d_len; d_len = (unsigned int)(cgc_strlen ( tlv6 , tlv5 )); }
}
void fix_ingred_products_10_10(){
fix_ingred_products_10_10_0();
fix_ingred_products_10_10_1();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *', 'tlv6': 'const char *', 'tlv5': 'char'}'
val_s=>'[('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671ab898>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671abc18>), ('unsigned int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff6719dcf8>), ('unsigned int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14ff67194048>)]'
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'd_len' - False OR  False
[i=10/13][j=11/13][dd=1/13][k=11/12] | type: unsigned int ; var :  ; varinfo :  ; value_node : d_len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : d_len
 => is literal (False) | is operator (False) d_len [vtype=unsigned int]
unique : ('unsigned int', 'd_len', None)
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'd_len' - False OR  False
[i=10/13][j=11/13][dd=2/13][k=11/12] | type: unsigned int ; var :  ; varinfo :  ; value_node : d_len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : d_len
 => is literal (False) | is operator (False) d_len [vtype=unsigned int]
not unique: ('unsigned int', 'd_len', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'd_len' - False OR  False
[i=10/13][j=11/13][dd=12/13][k=11/12] | type: unsigned int ; var :  ; varinfo :  ; value_node : d_len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : d_len
 => is literal (False) | is operator (False) d_len [vtype=unsigned int]
not unique: ('unsigned int', 'd_len', None) ... continue!
----
UNIQ_INIT: ('unsigned int','d_len','None','None');

==== Scope 1 ====
void fix_ingred_products_10_11_11(){
unsigned int d_len;
    bzero(&d_len,sizeof(unsigned int));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(d_len); }
    {unsigned int count; count = (unsigned int)(d_len); }
    {char tlv5; tlv5 = (char)(d_len); }
}
void fix_ingred_products_10_11(){
fix_ingred_products_10_11_11();
}

sym_lut=>'{'void': 'int', 'p': 'Product *', 'options': 'char *', 'options [ 4 ]': 'char', 'count': 'unsigned int', 'tlv1': 'struct list *', 'd_len': 'unsigned int', 'sale_price': 'float', 'cur': 'struct node *', 'tlv2': 'struct list *', 'end': 'struct node *', 'tlv3': 'struct list *', 'tlv4': 'struct node *'}'
val_s=>'[('struct node *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718d898>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff674f5048>), ('unsigned int', 'd_len', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e965f8>), ('float', 'sale_price', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66ebe4a8>), ('Product *', 'p', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff66e8d5f8>)]'
cval_s=>'[('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98908>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66e98c88>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2978>), ('struct node *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff66eb2cf8>)]'
==== Scope 2 ====
void fix_ingred_products_10_0_1(){
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(0); }
    {unsigned int count; count = (unsigned int)(0); }
    {char tlv5; tlv5 = (char)(0); }
}
void fix_ingred_products_10_0(){
fix_ingred_products_10_0_1();
}
void fix_ingred_products_10_4_4(){
unsigned int count;
    bzero(&count,sizeof(unsigned int));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(count); }
    {unsigned int d_len; d_len = (unsigned int)(count); }
    {char tlv5; tlv5 = (char)(count); }
}
void fix_ingred_products_10_4(){
fix_ingred_products_10_4_4();
}
void fix_ingred_products_10_6_8(){
char options [ 4 ];
    bzero(&options,( 4 *sizeof(char) ) );
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(0); }
    {unsigned int count; count = (unsigned int)(0); }
    {unsigned int d_len; d_len = (unsigned int)(0); }
    {char tlv5; tlv5 = (char)(0); }
}
void fix_ingred_products_10_6(){
fix_ingred_products_10_6_8();
}
void fix_ingred_products_10_10_0(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
char tlv5;
    bzero(&tlv5,sizeof(char));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)('\0'); }
    {unsigned int count; count = (unsigned int)('\0'); }
    {char tlv5; tlv5 = (char)('\0'); }
}
void fix_ingred_products_10_10_1(){
char tlv6_ref;
    bzero(&tlv6_ref,1*sizeof(char));
const char * tlv6 = &tlv6_ref;
char tlv5;
    bzero(&tlv5,sizeof(char));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(cgc_strlen ( tlv6 , tlv5 )); }
    {unsigned int count; count = (unsigned int)(cgc_strlen ( tlv6 , tlv5 )); }
    {unsigned int d_len; d_len = (unsigned int)(cgc_strlen ( tlv6 , tlv5 )); }
}
void fix_ingred_products_10_10(){
fix_ingred_products_10_10_0();
fix_ingred_products_10_10_1();
}
void fix_ingred_products_10_11_11(){
unsigned int d_len;
    bzero(&d_len,sizeof(unsigned int));
    {char options [ 4 ]; options [ ( 4 )-1 ] = (char)(d_len); }
    {unsigned int count; count = (unsigned int)(d_len); }
    {char tlv5; tlv5 = (char)(d_len); }
}
void fix_ingred_products_10_11(){
fix_ingred_products_10_11_11();
}
void fix_ingred_products_10(){
fix_ingred_products_10_0();
fix_ingred_products_10_4();
fix_ingred_products_10_6();
fix_ingred_products_10_10();
fix_ingred_products_10_11();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_10_0_1();
void fix_ingred_products_10_0();
void fix_ingred_products_10_4_4();
void fix_ingred_products_10_4();
void fix_ingred_products_10_6_8();
void fix_ingred_products_10_6();
void fix_ingred_products_10_10_0();
void fix_ingred_products_10_10_1();
void fix_ingred_products_10_10();
void fix_ingred_products_10_11_11();
void fix_ingred_products_10_11();
void fix_ingred_products_10();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_setup] : <class 'CParser.CParser.DeclarationContext'> : struct list * tlv2 ;
def_vars[1]: [cgc_setup] : <class 'CParser.CParser.DeclarationContext'> : nodeDataFreeFn tlv1 = cgc_free ;
def_vars[2]: [cgc_setup] : <class 'CParser.CParser.DeclarationContext'> : Inventory * tlv3 ;
def_vars[3]: [cgc_setup] : <class 'CParser.CParser.DeclarationContext'> : cgc_load_inventory ( tlv3 ) ;
sym_lut=>'{'void': 'int'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_load_inventory( tlv3 )' - is_func=True, is_func_ptr=False
cgc_load_inventory( tlv3 ) is a function.
Skipping.
sym_lut=>'{'void': 'int', 'tlv2': 'struct list *', 'tlv1': 'nodeDataFreeFn'}'
val_s=>'[('struct list *', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671c1828>)]'
cval_s=>'[]'
Checking 'cgc_load_inventory( tlv3 )' - is_func=True, is_func_ptr=False
cgc_load_inventory( tlv3 ) is a function.
Skipping.
sym_lut=>'{'void': 'int', 'tlv2': 'struct list *', 'tlv1': 'nodeDataFreeFn', 'tlv3': 'Inventory *'}'
val_s=>'[('Inventory *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671a8438>)]'
cval_s=>'[]'
Checking 'cgc_load_inventory( tlv3 )' - is_func=True, is_func_ptr=False
cgc_load_inventory( tlv3 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_products_11(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_11();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : char cmd [ 4 ] ;
def_vars[1]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : short ret ;
def_vars[2]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[3]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv12 ;
def_vars[4]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv11 ;
def_vars[5]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv10 ;
def_vars[6]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[7]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv15 ;
def_vars[8]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv14 ;
def_vars[9]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv13 ;
def_vars[10]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[11]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv18 ;
def_vars[12]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv17 ;
def_vars[13]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv16 ;
def_vars[14]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[15]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv21 ;
def_vars[16]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv20 ;
def_vars[17]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv19 ;
def_vars[18]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[19]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv24 ;
def_vars[20]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv23 ;
def_vars[21]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv22 ;
def_vars[22]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv6 ;
def_vars[23]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv27 ;
def_vars[24]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv26 ;
def_vars[25]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv25 ;
def_vars[26]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv7 ;
def_vars[27]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv30 ;
def_vars[28]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv29 ;
def_vars[29]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv28 ;
def_vars[30]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv8 ;
def_vars[31]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv33 ;
def_vars[32]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv32 ;
def_vars[33]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv31 ;
def_vars[34]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : int tlv9 ;
def_vars[35]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv36 ;
def_vars[36]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : void * tlv35 ;
def_vars[37]: [cgc_process_cmd] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv34 ;
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=0/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=1/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=2/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=3/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=4/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=5/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=6/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=7/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=8/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=9/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=10/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=11/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=12/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=13/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=14/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=15/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=16/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=17/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=18/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=19/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=20/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=21/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=22/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=23/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=24/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=25/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=26/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=27/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=28/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=29/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=30/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=31/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=32/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=33/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=34/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=35/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=36/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=0/28][dd=37/38][k=0/1] | type: short ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_products_12_0_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(0); }
    {short ret; ret = (short)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv12; tlv12 = (void *)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {unsigned int tlv10; tlv10 = (unsigned int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {unsigned int tlv13; tlv13 = (unsigned int)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {void * tlv18; tlv18 = (void *)(0); }
    {void * tlv17; tlv17 = (void *)(0); }
    {unsigned int tlv16; tlv16 = (unsigned int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv21; tlv21 = (void *)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {unsigned int tlv19; tlv19 = (unsigned int)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {void * tlv24; tlv24 = (void *)(0); }
    {void * tlv23; tlv23 = (void *)(0); }
    {unsigned int tlv22; tlv22 = (unsigned int)(0); }
    {int tlv6; tlv6 = (int)(0); }
    {void * tlv27; tlv27 = (void *)(0); }
    {void * tlv26; tlv26 = (void *)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {void * tlv30; tlv30 = (void *)(0); }
    {void * tlv29; tlv29 = (void *)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {int tlv8; tlv8 = (int)(0); }
    {void * tlv33; tlv33 = (void *)(0); }
    {void * tlv32; tlv32 = (void *)(0); }
    {unsigned int tlv31; tlv31 = (unsigned int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {void * tlv36; tlv36 = (void *)(0); }
    {void * tlv35; tlv35 = (void *)(0); }
    {unsigned int tlv34; tlv34 = (unsigned int)(0); }
}
void fix_ingred_products_12_0(){
fix_ingred_products_12_0_0();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int'}'
val_s=>'[('void *', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671accf8>), ('void *', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67186f28>), ('unsigned int', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff671b5dd8>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=0/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=0/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
unique : ('char', 'cmd [ 4 ]', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=1/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=1/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=2/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=2/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=3/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=3/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=4/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=4/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=5/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=5/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=6/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=6/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=7/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=7/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=8/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=8/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=9/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=9/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=10/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=10/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=11/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=11/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=12/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=12/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=13/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=13/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=14/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=14/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=15/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=15/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=16/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=16/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=17/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=17/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=18/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=18/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=19/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=19/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=20/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=20/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=21/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=21/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=22/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=22/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=23/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=23/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=24/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=24/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=25/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=25/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=26/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=26/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=27/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=27/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=28/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=28/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=29/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=29/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=30/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=30/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=31/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=31/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=32/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=32/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=33/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=33/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=34/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=34/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=35/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=35/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=36/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=36/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_BUY' - False OR  False
[i=12/13][j=1/28][dd=37/38][k=0/4] | type: void * ; var : tlv12 ; varinfo :  ; value_node : ( void * ) CMD_BUY (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_BUY
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cmd' - False OR  False
[i=12/13][j=1/28][dd=37/38][k=1/4] | type: void * ; var : tlv11 ; varinfo :  ; value_node : cmd (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cmd
 => is literal (False) | is operator (False) cmd [vtype=char *]
BEFORE => literal (False) cmd => char *
AFTER => literal (False) cmd [ 4 ] => char [size=4]
not unique: ('char', 'cmd [ 4 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_BUY)' - False OR  False
[i=12/13][j=1/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv10 ; varinfo :  ; value_node : sizeof ( CMD_BUY ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_BUY,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_BUY [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','cmd [ 4 ]','None','None');

----
UNIQ_INIT: ('char','cmd [ 4 ]','None','None');

----
UNIQ_INIT: ('char','cmd [ 4 ]','None','None');

==== Scope 1 ====
void fix_ingred_products_12_1_0(){
char cmd [ 4 ];
    bzero(&cmd,( 4 *sizeof(char) ) );
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_BUY); }
    {short ret; ret = (short)(( void * ) CMD_BUY); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_BUY); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_BUY); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_BUY); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_BUY); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_BUY); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_BUY); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_BUY); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_BUY); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_BUY); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_BUY); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_BUY); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_BUY); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_BUY); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_BUY); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_BUY); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_BUY); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_BUY); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_BUY); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_BUY); }
}
void fix_ingred_products_12_1_1(){
char cmd [ 4 ];
    bzero(&cmd,( 4 *sizeof(char) ) );
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(cmd); }
    {short ret; ret = (short)(cmd); }
    {int tlv1; tlv1 = (int)(cmd); }
    {void * tlv12; tlv12 = (void *)(cmd); }
    {void * tlv11; tlv11 = (void *)(cmd); }
    {unsigned int tlv10; tlv10 = (unsigned int)(cmd); }
    {int tlv2; tlv2 = (int)(cmd); }
    {void * tlv15; tlv15 = (void *)(cmd); }
    {void * tlv14; tlv14 = (void *)(cmd); }
    {unsigned int tlv13; tlv13 = (unsigned int)(cmd); }
    {int tlv3; tlv3 = (int)(cmd); }
    {void * tlv18; tlv18 = (void *)(cmd); }
    {void * tlv17; tlv17 = (void *)(cmd); }
    {unsigned int tlv16; tlv16 = (unsigned int)(cmd); }
    {int tlv4; tlv4 = (int)(cmd); }
    {void * tlv21; tlv21 = (void *)(cmd); }
    {void * tlv20; tlv20 = (void *)(cmd); }
    {unsigned int tlv19; tlv19 = (unsigned int)(cmd); }
    {int tlv5; tlv5 = (int)(cmd); }
    {void * tlv24; tlv24 = (void *)(cmd); }
    {void * tlv23; tlv23 = (void *)(cmd); }
    {unsigned int tlv22; tlv22 = (unsigned int)(cmd); }
    {int tlv6; tlv6 = (int)(cmd); }
    {void * tlv27; tlv27 = (void *)(cmd); }
    {void * tlv26; tlv26 = (void *)(cmd); }
    {unsigned int tlv25; tlv25 = (unsigned int)(cmd); }
    {int tlv7; tlv7 = (int)(cmd); }
    {void * tlv30; tlv30 = (void *)(cmd); }
    {void * tlv29; tlv29 = (void *)(cmd); }
    {unsigned int tlv28; tlv28 = (unsigned int)(cmd); }
    {int tlv8; tlv8 = (int)(cmd); }
    {void * tlv33; tlv33 = (void *)(cmd); }
    {void * tlv32; tlv32 = (void *)(cmd); }
    {unsigned int tlv31; tlv31 = (unsigned int)(cmd); }
    {int tlv9; tlv9 = (int)(cmd); }
    {void * tlv36; tlv36 = (void *)(cmd); }
    {void * tlv35; tlv35 = (void *)(cmd); }
    {unsigned int tlv34; tlv34 = (unsigned int)(cmd); }
}
void fix_ingred_products_12_1_2(){
char cmd [ 4 ];
    bzero(&cmd,( 4 *sizeof(char) ) );
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_BUY )); }
    {short ret; ret = (short)(sizeof ( CMD_BUY )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_BUY )); }
}
void fix_ingred_products_12_1(){
fix_ingred_products_12_1_0();
fix_ingred_products_12_1_1();
fix_ingred_products_12_1_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671b82e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff671b8668>)]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=0/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=1/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=3/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=5/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=6/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=7/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=8/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=9/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=10/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=11/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=12/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=13/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=14/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=15/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=16/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=17/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=19/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=20/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=21/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=22/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=23/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=24/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=25/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=26/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=27/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=28/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=29/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=31/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=32/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=33/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=34/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=35/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=36/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/13][j=2/28][dd=37/38][k=1/3] | type: int ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=12/13][j=2/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
----
UNIQ_INIT: ('int','tlv1','None','None');

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_products_12_2_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(0); }
    {short ret; ret = (short)(0); }
    {void * tlv12; tlv12 = (void *)(0); }
    {unsigned int tlv10; tlv10 = (unsigned int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {unsigned int tlv13; tlv13 = (unsigned int)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {void * tlv18; tlv18 = (void *)(0); }
    {void * tlv17; tlv17 = (void *)(0); }
    {unsigned int tlv16; tlv16 = (unsigned int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv21; tlv21 = (void *)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {unsigned int tlv19; tlv19 = (unsigned int)(0); }
    {void * tlv24; tlv24 = (void *)(0); }
    {void * tlv23; tlv23 = (void *)(0); }
    {unsigned int tlv22; tlv22 = (unsigned int)(0); }
    {int tlv6; tlv6 = (int)(0); }
    {void * tlv27; tlv27 = (void *)(0); }
    {void * tlv26; tlv26 = (void *)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {void * tlv30; tlv30 = (void *)(0); }
    {void * tlv29; tlv29 = (void *)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {void * tlv33; tlv33 = (void *)(0); }
    {void * tlv32; tlv32 = (void *)(0); }
    {unsigned int tlv31; tlv31 = (unsigned int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {void * tlv36; tlv36 = (void *)(0); }
    {void * tlv35; tlv35 = (void *)(0); }
    {unsigned int tlv34; tlv34 = (unsigned int)(0); }
}
void fix_ingred_products_12_2_2(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv1); }
    {short ret; ret = (short)(tlv1); }
    {void * tlv12; tlv12 = (void *)(tlv1); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {void * tlv15; tlv15 = (void *)(tlv1); }
    {void * tlv14; tlv14 = (void *)(tlv1); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {void * tlv18; tlv18 = (void *)(tlv1); }
    {void * tlv17; tlv17 = (void *)(tlv1); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {void * tlv21; tlv21 = (void *)(tlv1); }
    {void * tlv20; tlv20 = (void *)(tlv1); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv1); }
    {int tlv5; tlv5 = (int)(tlv1); }
    {void * tlv24; tlv24 = (void *)(tlv1); }
    {void * tlv23; tlv23 = (void *)(tlv1); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv1); }
    {int tlv6; tlv6 = (int)(tlv1); }
    {void * tlv27; tlv27 = (void *)(tlv1); }
    {void * tlv26; tlv26 = (void *)(tlv1); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv1); }
    {int tlv7; tlv7 = (int)(tlv1); }
    {void * tlv30; tlv30 = (void *)(tlv1); }
    {void * tlv29; tlv29 = (void *)(tlv1); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv1); }
    {int tlv8; tlv8 = (int)(tlv1); }
    {void * tlv33; tlv33 = (void *)(tlv1); }
    {void * tlv32; tlv32 = (void *)(tlv1); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv1); }
    {int tlv9; tlv9 = (int)(tlv1); }
    {void * tlv36; tlv36 = (void *)(tlv1); }
    {void * tlv35; tlv35 = (void *)(tlv1); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv1); }
}
void fix_ingred_products_12_2(){
fix_ingred_products_12_2_1();
fix_ingred_products_12_2_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int'}'
val_s=>'[('void *', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67198588>), ('void *', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67aad7b8>), ('unsigned int', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67abb668>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=0/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=1/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=2/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=3/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=4/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=5/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=6/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=7/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=8/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=9/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=10/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=11/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=12/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=13/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=14/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=15/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=16/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=17/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=18/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=19/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=20/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=21/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=22/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=23/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=24/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=25/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=26/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=27/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=28/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=29/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=30/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=31/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=32/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=33/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=34/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=35/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=36/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_CHECK' - False OR  False
[i=12/13][j=4/28][dd=37/38][k=0/4] | type: void * ; var : tlv15 ; varinfo :  ; value_node : ( void * ) CMD_CHECK (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_CHECK
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_CHECK)' - False OR  False
[i=12/13][j=4/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv13 ; varinfo :  ; value_node : sizeof ( CMD_CHECK ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_CHECK,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_CHECK [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_4_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_CHECK); }
    {short ret; ret = (short)(( void * ) CMD_CHECK); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_CHECK); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_CHECK); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_CHECK); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_CHECK); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_CHECK); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_CHECK); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_CHECK); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_CHECK); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_CHECK); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_CHECK); }
}
void fix_ingred_products_12_4_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_CHECK )); }
    {short ret; ret = (short)(sizeof ( CMD_CHECK )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_CHECK )); }
}
void fix_ingred_products_12_4(){
fix_ingred_products_12_4_0();
fix_ingred_products_12_4_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67aa5b38>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67aa5eb8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
unique : ('int', 'tlv2', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=12/13][j=5/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
not valid - int tlv2; tlv2 = ((int)tlv2);

----
UNIQ_INIT: ('int','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_products_12_5_2(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv2); }
    {short ret; ret = (short)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {void * tlv12; tlv12 = (void *)(tlv2); }
    {void * tlv11; tlv11 = (void *)(tlv2); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv2); }
    {void * tlv15; tlv15 = (void *)(tlv2); }
    {void * tlv14; tlv14 = (void *)(tlv2); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {void * tlv18; tlv18 = (void *)(tlv2); }
    {void * tlv17; tlv17 = (void *)(tlv2); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {void * tlv21; tlv21 = (void *)(tlv2); }
    {void * tlv20; tlv20 = (void *)(tlv2); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv2); }
    {int tlv5; tlv5 = (int)(tlv2); }
    {void * tlv24; tlv24 = (void *)(tlv2); }
    {void * tlv23; tlv23 = (void *)(tlv2); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv2); }
    {int tlv6; tlv6 = (int)(tlv2); }
    {void * tlv27; tlv27 = (void *)(tlv2); }
    {void * tlv26; tlv26 = (void *)(tlv2); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv2); }
    {int tlv7; tlv7 = (int)(tlv2); }
    {void * tlv30; tlv30 = (void *)(tlv2); }
    {void * tlv29; tlv29 = (void *)(tlv2); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv2); }
    {int tlv8; tlv8 = (int)(tlv2); }
    {void * tlv33; tlv33 = (void *)(tlv2); }
    {void * tlv32; tlv32 = (void *)(tlv2); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv2); }
    {int tlv9; tlv9 = (int)(tlv2); }
    {void * tlv36; tlv36 = (void *)(tlv2); }
    {void * tlv35; tlv35 = (void *)(tlv2); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv2); }
}
void fix_ingred_products_12_5(){
fix_ingred_products_12_5_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int'}'
val_s=>'[('void *', 'tlv18', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a9bdd8>), ('void *', 'tlv17', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67ac1048>), ('unsigned int', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67ac1eb8>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=0/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=1/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=2/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=3/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=4/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=5/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=6/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=7/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=8/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=9/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=10/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=11/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=12/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=13/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=14/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=15/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=16/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=17/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=18/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=19/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=20/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=21/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=22/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=23/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=24/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=25/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=26/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=27/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=28/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=29/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=30/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=31/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=32/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=33/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=34/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=35/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=36/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ADD' - False OR  False
[i=12/13][j=7/28][dd=37/38][k=0/4] | type: void * ; var : tlv18 ; varinfo :  ; value_node : ( void * ) CMD_ADD (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ADD
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ADD)' - False OR  False
[i=12/13][j=7/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv16 ; varinfo :  ; value_node : sizeof ( CMD_ADD ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ADD,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ADD [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_7_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_ADD); }
    {short ret; ret = (short)(( void * ) CMD_ADD); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_ADD); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_ADD); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_ADD); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_ADD); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_ADD); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_ADD); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_ADD); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_ADD); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_ADD); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_ADD); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_ADD); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_ADD); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_ADD); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_ADD); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_ADD); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_ADD); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_ADD); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_ADD); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_ADD); }
}
void fix_ingred_products_12_7_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_ADD )); }
    {short ret; ret = (short)(sizeof ( CMD_ADD )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_ADD )); }
}
void fix_ingred_products_12_7(){
fix_ingred_products_12_7_0();
fix_ingred_products_12_7_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67a8c3c8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67a8c748>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
unique : ('int', 'tlv3', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=12/13][j=8/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
not valid - int tlv3; tlv3 = ((int)tlv3);

----
UNIQ_INIT: ('int','tlv3','None','None');

==== Scope 1 ====
void fix_ingred_products_12_8_2(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv3); }
    {short ret; ret = (short)(tlv3); }
    {int tlv1; tlv1 = (int)(tlv3); }
    {void * tlv12; tlv12 = (void *)(tlv3); }
    {void * tlv11; tlv11 = (void *)(tlv3); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {void * tlv15; tlv15 = (void *)(tlv3); }
    {void * tlv14; tlv14 = (void *)(tlv3); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv3); }
    {void * tlv18; tlv18 = (void *)(tlv3); }
    {void * tlv17; tlv17 = (void *)(tlv3); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv3); }
    {int tlv4; tlv4 = (int)(tlv3); }
    {void * tlv21; tlv21 = (void *)(tlv3); }
    {void * tlv20; tlv20 = (void *)(tlv3); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv3); }
    {int tlv5; tlv5 = (int)(tlv3); }
    {void * tlv24; tlv24 = (void *)(tlv3); }
    {void * tlv23; tlv23 = (void *)(tlv3); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv3); }
    {int tlv6; tlv6 = (int)(tlv3); }
    {void * tlv27; tlv27 = (void *)(tlv3); }
    {void * tlv26; tlv26 = (void *)(tlv3); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv3); }
    {int tlv7; tlv7 = (int)(tlv3); }
    {void * tlv30; tlv30 = (void *)(tlv3); }
    {void * tlv29; tlv29 = (void *)(tlv3); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv3); }
    {int tlv8; tlv8 = (int)(tlv3); }
    {void * tlv33; tlv33 = (void *)(tlv3); }
    {void * tlv32; tlv32 = (void *)(tlv3); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv3); }
    {int tlv9; tlv9 = (int)(tlv3); }
    {void * tlv36; tlv36 = (void *)(tlv3); }
    {void * tlv35; tlv35 = (void *)(tlv3); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv3); }
}
void fix_ingred_products_12_8(){
fix_ingred_products_12_8_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int'}'
val_s=>'[('void *', 'tlv21', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a85668>), ('void *', 'tlv20', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a9f898>), ('unsigned int', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67ab0748>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=0/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=1/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=2/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=3/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=4/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=5/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=6/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=7/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=8/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=9/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=10/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=11/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=12/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=13/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=14/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=15/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=16/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=17/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=18/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=19/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=20/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=21/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=22/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=23/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=24/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=25/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=26/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=27/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=28/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=29/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=30/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=31/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=32/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=33/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=34/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=35/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=36/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_RM' - False OR  False
[i=12/13][j=10/28][dd=37/38][k=0/4] | type: void * ; var : tlv21 ; varinfo :  ; value_node : ( void * ) CMD_RM (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_RM
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_RM)' - False OR  False
[i=12/13][j=10/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv19 ; varinfo :  ; value_node : sizeof ( CMD_RM ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_RM,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_RM [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_10_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_RM); }
    {short ret; ret = (short)(( void * ) CMD_RM); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_RM); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_RM); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_RM); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_RM); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_RM); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_RM); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_RM); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_RM); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_RM); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_RM); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_RM); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_RM); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_RM); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_RM); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_RM); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_RM); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_RM); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_RM); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_RM); }
}
void fix_ingred_products_12_10_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_RM )); }
    {short ret; ret = (short)(sizeof ( CMD_RM )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_RM )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_RM )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_RM )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_RM )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_RM )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_RM )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_RM )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_RM )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_RM )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_RM )); }
}
void fix_ingred_products_12_10(){
fix_ingred_products_12_10_0();
fix_ingred_products_12_10_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67a9dc18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67a9df98>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
unique : ('int', 'tlv4', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv4' - False OR  False
[i=12/13][j=11/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv4 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv4
 => is literal (False) | is operator (False) tlv4 [vtype=int]
not unique: ('int', 'tlv4', None) ... continue!
not valid - int tlv4; tlv4 = ((int)tlv4);

----
UNIQ_INIT: ('int','tlv4','None','None');

==== Scope 1 ====
void fix_ingred_products_12_11_2(){
int tlv4;
    bzero(&tlv4,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv4); }
    {short ret; ret = (short)(tlv4); }
    {int tlv1; tlv1 = (int)(tlv4); }
    {void * tlv12; tlv12 = (void *)(tlv4); }
    {void * tlv11; tlv11 = (void *)(tlv4); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv4); }
    {int tlv2; tlv2 = (int)(tlv4); }
    {void * tlv15; tlv15 = (void *)(tlv4); }
    {void * tlv14; tlv14 = (void *)(tlv4); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv4); }
    {int tlv3; tlv3 = (int)(tlv4); }
    {void * tlv18; tlv18 = (void *)(tlv4); }
    {void * tlv17; tlv17 = (void *)(tlv4); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv4); }
    {void * tlv21; tlv21 = (void *)(tlv4); }
    {void * tlv20; tlv20 = (void *)(tlv4); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv4); }
    {int tlv5; tlv5 = (int)(tlv4); }
    {void * tlv24; tlv24 = (void *)(tlv4); }
    {void * tlv23; tlv23 = (void *)(tlv4); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv4); }
    {int tlv6; tlv6 = (int)(tlv4); }
    {void * tlv27; tlv27 = (void *)(tlv4); }
    {void * tlv26; tlv26 = (void *)(tlv4); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv4); }
    {int tlv7; tlv7 = (int)(tlv4); }
    {void * tlv30; tlv30 = (void *)(tlv4); }
    {void * tlv29; tlv29 = (void *)(tlv4); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv4); }
    {int tlv8; tlv8 = (int)(tlv4); }
    {void * tlv33; tlv33 = (void *)(tlv4); }
    {void * tlv32; tlv32 = (void *)(tlv4); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv4); }
    {int tlv9; tlv9 = (int)(tlv4); }
    {void * tlv36; tlv36 = (void *)(tlv4); }
    {void * tlv35; tlv35 = (void *)(tlv4); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv4); }
}
void fix_ingred_products_12_11(){
fix_ingred_products_12_11_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int'}'
val_s=>'[('void *', 'tlv24', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a92eb8>), ('void *', 'tlv23', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a94128>), ('unsigned int', 'tlv22', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a94f98>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=0/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=1/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=2/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=3/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=4/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=5/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=6/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=7/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=8/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=9/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=10/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=11/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=12/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=13/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=14/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=15/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=16/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=17/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=18/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=19/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=20/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=21/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=22/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=23/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=24/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=25/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=26/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=27/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=28/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=29/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=30/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=31/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=32/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=33/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=34/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=35/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=36/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_UPDATE' - False OR  False
[i=12/13][j=13/28][dd=37/38][k=0/4] | type: void * ; var : tlv24 ; varinfo :  ; value_node : ( void * ) CMD_UPDATE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_UPDATE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_UPDATE)' - False OR  False
[i=12/13][j=13/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv22 ; varinfo :  ; value_node : sizeof ( CMD_UPDATE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_UPDATE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_UPDATE [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_13_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_UPDATE); }
    {short ret; ret = (short)(( void * ) CMD_UPDATE); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_UPDATE); }
}
void fix_ingred_products_12_13_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_UPDATE )); }
    {short ret; ret = (short)(sizeof ( CMD_UPDATE )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_UPDATE )); }
}
void fix_ingred_products_12_13(){
fix_ingred_products_12_13_0();
fix_ingred_products_12_13_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67aba4a8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67aba828>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
unique : ('int', 'tlv5', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv5' - False OR  False
[i=12/13][j=14/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv5 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv5
 => is literal (False) | is operator (False) tlv5 [vtype=int]
not unique: ('int', 'tlv5', None) ... continue!
not valid - int tlv5; tlv5 = ((int)tlv5);

----
UNIQ_INIT: ('int','tlv5','None','None');

==== Scope 1 ====
void fix_ingred_products_12_14_2(){
int tlv5;
    bzero(&tlv5,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv5); }
    {short ret; ret = (short)(tlv5); }
    {int tlv1; tlv1 = (int)(tlv5); }
    {void * tlv12; tlv12 = (void *)(tlv5); }
    {void * tlv11; tlv11 = (void *)(tlv5); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv5); }
    {int tlv2; tlv2 = (int)(tlv5); }
    {void * tlv15; tlv15 = (void *)(tlv5); }
    {void * tlv14; tlv14 = (void *)(tlv5); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv5); }
    {int tlv3; tlv3 = (int)(tlv5); }
    {void * tlv18; tlv18 = (void *)(tlv5); }
    {void * tlv17; tlv17 = (void *)(tlv5); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv5); }
    {int tlv4; tlv4 = (int)(tlv5); }
    {void * tlv21; tlv21 = (void *)(tlv5); }
    {void * tlv20; tlv20 = (void *)(tlv5); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv5); }
    {void * tlv24; tlv24 = (void *)(tlv5); }
    {void * tlv23; tlv23 = (void *)(tlv5); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv5); }
    {int tlv6; tlv6 = (int)(tlv5); }
    {void * tlv27; tlv27 = (void *)(tlv5); }
    {void * tlv26; tlv26 = (void *)(tlv5); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv5); }
    {int tlv7; tlv7 = (int)(tlv5); }
    {void * tlv30; tlv30 = (void *)(tlv5); }
    {void * tlv29; tlv29 = (void *)(tlv5); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv5); }
    {int tlv8; tlv8 = (int)(tlv5); }
    {void * tlv33; tlv33 = (void *)(tlv5); }
    {void * tlv32; tlv32 = (void *)(tlv5); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv5); }
    {int tlv9; tlv9 = (int)(tlv5); }
    {void * tlv36; tlv36 = (void *)(tlv5); }
    {void * tlv35; tlv35 = (void *)(tlv5); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv5); }
}
void fix_ingred_products_12_14(){
fix_ingred_products_12_14_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int'}'
val_s=>'[('void *', 'tlv27', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67a96748>), ('void *', 'tlv26', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67abf978>), ('unsigned int', 'tlv25', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff67aa7828>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=0/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=1/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=2/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=3/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=4/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=5/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=6/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=7/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=8/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=9/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=10/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=11/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=12/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=13/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=14/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=15/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=16/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=17/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=18/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=19/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=20/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=21/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=22/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=23/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=24/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=25/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=26/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=27/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=28/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=29/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=30/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=31/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=32/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=33/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=34/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=35/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=36/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_ONSALE' - False OR  False
[i=12/13][j=16/28][dd=37/38][k=0/4] | type: void * ; var : tlv27 ; varinfo :  ; value_node : ( void * ) CMD_ONSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_ONSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_ONSALE)' - False OR  False
[i=12/13][j=16/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv25 ; varinfo :  ; value_node : sizeof ( CMD_ONSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_ONSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_ONSALE [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_16_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_ONSALE); }
    {short ret; ret = (short)(( void * ) CMD_ONSALE); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_ONSALE); }
}
void fix_ingred_products_12_16_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_ONSALE )); }
    {short ret; ret = (short)(sizeof ( CMD_ONSALE )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_ONSALE )); }
}
void fix_ingred_products_12_16(){
fix_ingred_products_12_16_0();
fix_ingred_products_12_16_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff67a97cf8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676e50b8>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
unique : ('int', 'tlv6', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv6' - False OR  False
[i=12/13][j=17/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv6 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv6
 => is literal (False) | is operator (False) tlv6 [vtype=int]
not unique: ('int', 'tlv6', None) ... continue!
not valid - int tlv6; tlv6 = ((int)tlv6);

----
UNIQ_INIT: ('int','tlv6','None','None');

==== Scope 1 ====
void fix_ingred_products_12_17_2(){
int tlv6;
    bzero(&tlv6,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv6); }
    {short ret; ret = (short)(tlv6); }
    {int tlv1; tlv1 = (int)(tlv6); }
    {void * tlv12; tlv12 = (void *)(tlv6); }
    {void * tlv11; tlv11 = (void *)(tlv6); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv6); }
    {int tlv2; tlv2 = (int)(tlv6); }
    {void * tlv15; tlv15 = (void *)(tlv6); }
    {void * tlv14; tlv14 = (void *)(tlv6); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv6); }
    {int tlv3; tlv3 = (int)(tlv6); }
    {void * tlv18; tlv18 = (void *)(tlv6); }
    {void * tlv17; tlv17 = (void *)(tlv6); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv6); }
    {int tlv4; tlv4 = (int)(tlv6); }
    {void * tlv21; tlv21 = (void *)(tlv6); }
    {void * tlv20; tlv20 = (void *)(tlv6); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv6); }
    {int tlv5; tlv5 = (int)(tlv6); }
    {void * tlv24; tlv24 = (void *)(tlv6); }
    {void * tlv23; tlv23 = (void *)(tlv6); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv6); }
    {void * tlv27; tlv27 = (void *)(tlv6); }
    {void * tlv26; tlv26 = (void *)(tlv6); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv6); }
    {int tlv7; tlv7 = (int)(tlv6); }
    {void * tlv30; tlv30 = (void *)(tlv6); }
    {void * tlv29; tlv29 = (void *)(tlv6); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv6); }
    {int tlv8; tlv8 = (int)(tlv6); }
    {void * tlv33; tlv33 = (void *)(tlv6); }
    {void * tlv32; tlv32 = (void *)(tlv6); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv6); }
    {int tlv9; tlv9 = (int)(tlv6); }
    {void * tlv36; tlv36 = (void *)(tlv6); }
    {void * tlv35; tlv35 = (void *)(tlv6); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv6); }
}
void fix_ingred_products_12_17(){
fix_ingred_products_12_17_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int'}'
val_s=>'[('void *', 'tlv30', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676e2f98>), ('void *', 'tlv29', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676e6208>), ('unsigned int', 'tlv28', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676e90b8>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=0/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=1/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=2/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=3/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=4/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=5/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=6/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=7/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=8/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=9/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=10/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=11/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=12/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=13/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=14/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=15/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=16/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=17/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=18/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=19/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=20/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=21/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=22/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=23/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=24/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=25/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=26/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=27/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=28/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=29/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=30/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=31/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=32/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=33/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=34/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=35/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=36/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_NOSALE' - False OR  False
[i=12/13][j=19/28][dd=37/38][k=0/4] | type: void * ; var : tlv30 ; varinfo :  ; value_node : ( void * ) CMD_NOSALE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_NOSALE
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_NOSALE)' - False OR  False
[i=12/13][j=19/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv28 ; varinfo :  ; value_node : sizeof ( CMD_NOSALE ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_NOSALE,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_NOSALE [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_19_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_NOSALE); }
    {short ret; ret = (short)(( void * ) CMD_NOSALE); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_NOSALE); }
}
void fix_ingred_products_12_19_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_NOSALE )); }
    {short ret; ret = (short)(sizeof ( CMD_NOSALE )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_NOSALE )); }
}
void fix_ingred_products_12_19(){
fix_ingred_products_12_19_0();
fix_ingred_products_12_19_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676d9588>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676d9908>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
unique : ('int', 'tlv7', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv7' - False OR  False
[i=12/13][j=20/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv7 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv7
 => is literal (False) | is operator (False) tlv7 [vtype=int]
not unique: ('int', 'tlv7', None) ... continue!
not valid - int tlv7; tlv7 = ((int)tlv7);

----
UNIQ_INIT: ('int','tlv7','None','None');

==== Scope 1 ====
void fix_ingred_products_12_20_2(){
int tlv7;
    bzero(&tlv7,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv7); }
    {short ret; ret = (short)(tlv7); }
    {int tlv1; tlv1 = (int)(tlv7); }
    {void * tlv12; tlv12 = (void *)(tlv7); }
    {void * tlv11; tlv11 = (void *)(tlv7); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv7); }
    {int tlv2; tlv2 = (int)(tlv7); }
    {void * tlv15; tlv15 = (void *)(tlv7); }
    {void * tlv14; tlv14 = (void *)(tlv7); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv7); }
    {int tlv3; tlv3 = (int)(tlv7); }
    {void * tlv18; tlv18 = (void *)(tlv7); }
    {void * tlv17; tlv17 = (void *)(tlv7); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv7); }
    {int tlv4; tlv4 = (int)(tlv7); }
    {void * tlv21; tlv21 = (void *)(tlv7); }
    {void * tlv20; tlv20 = (void *)(tlv7); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv7); }
    {int tlv5; tlv5 = (int)(tlv7); }
    {void * tlv24; tlv24 = (void *)(tlv7); }
    {void * tlv23; tlv23 = (void *)(tlv7); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv7); }
    {int tlv6; tlv6 = (int)(tlv7); }
    {void * tlv27; tlv27 = (void *)(tlv7); }
    {void * tlv26; tlv26 = (void *)(tlv7); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv7); }
    {void * tlv30; tlv30 = (void *)(tlv7); }
    {void * tlv29; tlv29 = (void *)(tlv7); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv7); }
    {int tlv8; tlv8 = (int)(tlv7); }
    {void * tlv33; tlv33 = (void *)(tlv7); }
    {void * tlv32; tlv32 = (void *)(tlv7); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv7); }
    {int tlv9; tlv9 = (int)(tlv7); }
    {void * tlv36; tlv36 = (void *)(tlv7); }
    {void * tlv35; tlv35 = (void *)(tlv7); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv7); }
}
void fix_ingred_products_12_20(){
fix_ingred_products_12_20_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int', 'tlv33': 'void *', 'tlv32': 'void *', 'tlv31': 'unsigned int'}'
val_s=>'[('void *', 'tlv33', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676ca828>), ('void *', 'tlv32', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676d0a58>), ('unsigned int', 'tlv31', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676f2908>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=0/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=1/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=2/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=3/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=4/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=5/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=6/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=7/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=8/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=9/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=10/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=11/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=12/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=13/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=14/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=15/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=16/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=17/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=18/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=19/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=20/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=21/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=22/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=23/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=24/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=25/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=26/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=27/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=28/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=29/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=30/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=31/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=32/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=33/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=34/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=35/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=36/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_LIST' - False OR  False
[i=12/13][j=22/28][dd=37/38][k=0/4] | type: void * ; var : tlv33 ; varinfo :  ; value_node : ( void * ) CMD_LIST (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_LIST
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_LIST)' - False OR  False
[i=12/13][j=22/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv31 ; varinfo :  ; value_node : sizeof ( CMD_LIST ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_LIST,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_LIST [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_22_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_LIST); }
    {short ret; ret = (short)(( void * ) CMD_LIST); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_LIST); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_LIST); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_LIST); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_LIST); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_LIST); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_LIST); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_LIST); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_LIST); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_LIST); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_LIST); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_LIST); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_LIST); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_LIST); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_LIST); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_LIST); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_LIST); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_LIST); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_LIST); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_LIST); }
}
void fix_ingred_products_12_22_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_LIST )); }
    {short ret; ret = (short)(sizeof ( CMD_LIST )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_LIST )); }
}
void fix_ingred_products_12_22(){
fix_ingred_products_12_22_0();
fix_ingred_products_12_22_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int', 'tlv33': 'void *', 'tlv32': 'void *', 'tlv31': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676ccdd8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676d1198>)]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=0/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
unique : ('int', 'tlv8', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=1/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=2/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=3/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=4/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=5/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=6/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=7/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=8/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=9/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=10/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=11/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=12/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=13/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=14/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=15/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=16/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=17/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=18/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=19/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=20/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=21/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=22/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=23/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=24/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=25/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=26/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=27/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=28/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=29/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=30/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=31/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=32/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=33/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=34/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=35/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=36/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv8' - False OR  False
[i=12/13][j=23/28][dd=37/38][k=2/3] | type: int ; var :  ; varinfo :  ; value_node : tlv8 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv8
 => is literal (False) | is operator (False) tlv8 [vtype=int]
not unique: ('int', 'tlv8', None) ... continue!
not valid - int tlv8; tlv8 = ((int)tlv8);

----
UNIQ_INIT: ('int','tlv8','None','None');

==== Scope 1 ====
void fix_ingred_products_12_23_2(){
int tlv8;
    bzero(&tlv8,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv8); }
    {short ret; ret = (short)(tlv8); }
    {int tlv1; tlv1 = (int)(tlv8); }
    {void * tlv12; tlv12 = (void *)(tlv8); }
    {void * tlv11; tlv11 = (void *)(tlv8); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv8); }
    {int tlv2; tlv2 = (int)(tlv8); }
    {void * tlv15; tlv15 = (void *)(tlv8); }
    {void * tlv14; tlv14 = (void *)(tlv8); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv8); }
    {int tlv3; tlv3 = (int)(tlv8); }
    {void * tlv18; tlv18 = (void *)(tlv8); }
    {void * tlv17; tlv17 = (void *)(tlv8); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv8); }
    {int tlv4; tlv4 = (int)(tlv8); }
    {void * tlv21; tlv21 = (void *)(tlv8); }
    {void * tlv20; tlv20 = (void *)(tlv8); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv8); }
    {int tlv5; tlv5 = (int)(tlv8); }
    {void * tlv24; tlv24 = (void *)(tlv8); }
    {void * tlv23; tlv23 = (void *)(tlv8); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv8); }
    {int tlv6; tlv6 = (int)(tlv8); }
    {void * tlv27; tlv27 = (void *)(tlv8); }
    {void * tlv26; tlv26 = (void *)(tlv8); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv8); }
    {int tlv7; tlv7 = (int)(tlv8); }
    {void * tlv30; tlv30 = (void *)(tlv8); }
    {void * tlv29; tlv29 = (void *)(tlv8); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv8); }
    {void * tlv33; tlv33 = (void *)(tlv8); }
    {void * tlv32; tlv32 = (void *)(tlv8); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv8); }
    {int tlv9; tlv9 = (int)(tlv8); }
    {void * tlv36; tlv36 = (void *)(tlv8); }
    {void * tlv35; tlv35 = (void *)(tlv8); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv8); }
}
void fix_ingred_products_12_23(){
fix_ingred_products_12_23_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int', 'tlv33': 'void *', 'tlv32': 'void *', 'tlv31': 'unsigned int', 'tlv9': 'int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int', 'tlv33': 'void *', 'tlv32': 'void *', 'tlv31': 'unsigned int', 'tlv9': 'int', 'tlv36': 'void *', 'tlv35': 'void *', 'tlv34': 'unsigned int'}'
val_s=>'[('void *', 'tlv36', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676ed0b8>), ('void *', 'tlv35', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676f82e8>), ('unsigned int', 'tlv34', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676c5198>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=0/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=0/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=1/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=1/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=2/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=2/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=3/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=3/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=4/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=4/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=5/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=5/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=6/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=6/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=7/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=7/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=8/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=8/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=9/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=9/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=10/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=10/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=11/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=11/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=12/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=12/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=13/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=13/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=14/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=14/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=15/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=15/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=16/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=16/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=17/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=17/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=18/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=18/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=19/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=19/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=20/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=20/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=21/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=21/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=22/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=22/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=23/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=23/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=24/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=24/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=25/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=25/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=26/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=26/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=27/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=27/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=28/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=28/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=29/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=29/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=30/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=30/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=31/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=31/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=32/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=32/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=33/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=33/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=34/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=34/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=35/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=35/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=36/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=36/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(void*)CMD_QUIT' - False OR  False
[i=12/13][j=25/28][dd=37/38][k=0/4] | type: void * ; var : tlv36 ; varinfo :  ; value_node : ( void * ) CMD_QUIT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,void,*,),CMD_QUIT
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) void [vtype=int]
Skipping void => #define
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(CMD_QUIT)' - False OR  False
[i=12/13][j=25/28][dd=37/38][k=2/4] | type: unsigned int ; var : tlv34 ; varinfo :  ; value_node : sizeof ( CMD_QUIT ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,CMD_QUIT,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) CMD_QUIT [vtype=None]
 => is literal (False) | is operator (True) )
----
----
==== Scope 1 ====
void fix_ingred_products_12_25_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_QUIT); }
    {short ret; ret = (short)(( void * ) CMD_QUIT); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_QUIT); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_QUIT); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_QUIT); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_QUIT); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_QUIT); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_QUIT); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_QUIT); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_QUIT); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_QUIT); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_QUIT); }
}
void fix_ingred_products_12_25_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_QUIT )); }
    {short ret; ret = (short)(sizeof ( CMD_QUIT )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_QUIT )); }
}
void fix_ingred_products_12_25(){
fix_ingred_products_12_25_0();
fix_ingred_products_12_25_2();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int', 'tlv33': 'void *', 'tlv32': 'void *', 'tlv31': 'unsigned int', 'tlv9': 'int', 'tlv36': 'void *', 'tlv35': 'void *', 'tlv34': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676e42e8>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676d2668>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14ff676d29e8>)]'
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=0/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=0/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
unique : ('int', 'tlv9', None)
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=1/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=1/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=2/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=2/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=3/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=3/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=4/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=4/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=5/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=5/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=6/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=6/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=7/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=7/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=8/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=8/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=9/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=9/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=10/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=10/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=11/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=11/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=12/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=12/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=13/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=13/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=14/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=14/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=15/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=15/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=16/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=16/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=17/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=17/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=18/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=18/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=19/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=19/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=20/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=20/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=21/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=21/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=22/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=22/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=23/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=23/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=24/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=24/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=25/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=25/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=26/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=26/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=27/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=27/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=28/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=28/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=29/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=29/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=30/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=30/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=31/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=31/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=32/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=32/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=33/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=33/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=34/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=34/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=35/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=35/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=36/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=36/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-2' - False OR  False
[i=12/13][j=26/28][dd=37/38][k=0/4] | type: short ; var : ret ; varinfo :  ; value_node : - 2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,2
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 2
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv9' - False OR  False
[i=12/13][j=26/28][dd=37/38][k=3/4] | type: int ; var :  ; varinfo :  ; value_node : tlv9 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv9
 => is literal (False) | is operator (False) tlv9 [vtype=int]
not unique: ('int', 'tlv9', None) ... continue!
----
UNIQ_INIT: ('int','tlv9','None','None');

not valid - int tlv9; tlv9 = ((int)tlv9);

----
UNIQ_INIT: ('int','tlv9','None','None');

==== Scope 1 ====
void fix_ingred_products_12_26_0(){
int tlv9;
    bzero(&tlv9,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(- 2); }
    {short ret; ret = (short)(- 2); }
    {int tlv1; tlv1 = (int)(- 2); }
    {void * tlv12; tlv12 = (void *)(- 2); }
    {void * tlv11; tlv11 = (void *)(- 2); }
    {unsigned int tlv10; tlv10 = (unsigned int)(- 2); }
    {int tlv2; tlv2 = (int)(- 2); }
    {void * tlv15; tlv15 = (void *)(- 2); }
    {void * tlv14; tlv14 = (void *)(- 2); }
    {unsigned int tlv13; tlv13 = (unsigned int)(- 2); }
    {int tlv3; tlv3 = (int)(- 2); }
    {void * tlv18; tlv18 = (void *)(- 2); }
    {void * tlv17; tlv17 = (void *)(- 2); }
    {unsigned int tlv16; tlv16 = (unsigned int)(- 2); }
    {int tlv4; tlv4 = (int)(- 2); }
    {void * tlv21; tlv21 = (void *)(- 2); }
    {void * tlv20; tlv20 = (void *)(- 2); }
    {unsigned int tlv19; tlv19 = (unsigned int)(- 2); }
    {int tlv5; tlv5 = (int)(- 2); }
    {void * tlv24; tlv24 = (void *)(- 2); }
    {void * tlv23; tlv23 = (void *)(- 2); }
    {unsigned int tlv22; tlv22 = (unsigned int)(- 2); }
    {int tlv6; tlv6 = (int)(- 2); }
    {void * tlv27; tlv27 = (void *)(- 2); }
    {void * tlv26; tlv26 = (void *)(- 2); }
    {unsigned int tlv25; tlv25 = (unsigned int)(- 2); }
    {int tlv7; tlv7 = (int)(- 2); }
    {void * tlv30; tlv30 = (void *)(- 2); }
    {void * tlv29; tlv29 = (void *)(- 2); }
    {unsigned int tlv28; tlv28 = (unsigned int)(- 2); }
    {int tlv8; tlv8 = (int)(- 2); }
    {void * tlv33; tlv33 = (void *)(- 2); }
    {void * tlv32; tlv32 = (void *)(- 2); }
    {unsigned int tlv31; tlv31 = (unsigned int)(- 2); }
    {int tlv9; tlv9 = (int)(- 2); }
    {void * tlv36; tlv36 = (void *)(- 2); }
    {void * tlv35; tlv35 = (void *)(- 2); }
    {unsigned int tlv34; tlv34 = (unsigned int)(- 2); }
}
void fix_ingred_products_12_26_3(){
int tlv9;
    bzero(&tlv9,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv9); }
    {short ret; ret = (short)(tlv9); }
    {int tlv1; tlv1 = (int)(tlv9); }
    {void * tlv12; tlv12 = (void *)(tlv9); }
    {void * tlv11; tlv11 = (void *)(tlv9); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv9); }
    {int tlv2; tlv2 = (int)(tlv9); }
    {void * tlv15; tlv15 = (void *)(tlv9); }
    {void * tlv14; tlv14 = (void *)(tlv9); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv9); }
    {int tlv3; tlv3 = (int)(tlv9); }
    {void * tlv18; tlv18 = (void *)(tlv9); }
    {void * tlv17; tlv17 = (void *)(tlv9); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv9); }
    {int tlv4; tlv4 = (int)(tlv9); }
    {void * tlv21; tlv21 = (void *)(tlv9); }
    {void * tlv20; tlv20 = (void *)(tlv9); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv9); }
    {int tlv5; tlv5 = (int)(tlv9); }
    {void * tlv24; tlv24 = (void *)(tlv9); }
    {void * tlv23; tlv23 = (void *)(tlv9); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv9); }
    {int tlv6; tlv6 = (int)(tlv9); }
    {void * tlv27; tlv27 = (void *)(tlv9); }
    {void * tlv26; tlv26 = (void *)(tlv9); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv9); }
    {int tlv7; tlv7 = (int)(tlv9); }
    {void * tlv30; tlv30 = (void *)(tlv9); }
    {void * tlv29; tlv29 = (void *)(tlv9); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv9); }
    {int tlv8; tlv8 = (int)(tlv9); }
    {void * tlv33; tlv33 = (void *)(tlv9); }
    {void * tlv32; tlv32 = (void *)(tlv9); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv9); }
    {void * tlv36; tlv36 = (void *)(tlv9); }
    {void * tlv35; tlv35 = (void *)(tlv9); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv9); }
}
void fix_ingred_products_12_26(){
fix_ingred_products_12_26_0();
fix_ingred_products_12_26_3();
}

sym_lut=>'{'void': 'int', 'cmd': 'char *', 'cmd [ 4 ]': 'char', 'ret': 'short', 'tlv1': 'int', 'tlv12': 'void *', 'tlv11': 'void *', 'tlv10': 'unsigned int', 'tlv2': 'int', 'tlv15': 'void *', 'tlv14': 'void *', 'tlv13': 'unsigned int', 'tlv3': 'int', 'tlv18': 'void *', 'tlv17': 'void *', 'tlv16': 'unsigned int', 'tlv4': 'int', 'tlv21': 'void *', 'tlv20': 'void *', 'tlv19': 'unsigned int', 'tlv5': 'int', 'tlv24': 'void *', 'tlv23': 'void *', 'tlv22': 'unsigned int', 'tlv6': 'int', 'tlv27': 'void *', 'tlv26': 'void *', 'tlv25': 'unsigned int', 'tlv7': 'int', 'tlv30': 'void *', 'tlv29': 'void *', 'tlv28': 'unsigned int', 'tlv8': 'int', 'tlv33': 'void *', 'tlv32': 'void *', 'tlv31': 'unsigned int', 'tlv9': 'int', 'tlv36': 'void *', 'tlv35': 'void *', 'tlv34': 'unsigned int'}'
val_s=>'[('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff676de128>), ('short', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x14ff6718ec18>)]'
cval_s=>'[]'
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=0/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=1/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=2/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=3/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=4/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=5/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=6/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=7/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=8/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=9/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=10/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=11/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=12/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=13/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=14/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=15/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=16/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=17/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=18/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=19/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=20/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=21/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=22/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=23/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=24/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=25/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=26/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=27/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=28/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=29/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=30/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=31/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=32/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=33/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=34/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=35/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=36/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
is_func_ [-] => '[False, False, False]'
has_multiptr_refs '-1' - False OR  False
[i=12/13][j=27/28][dd=37/38][k=0/2] | type: short ; var : ret ; varinfo :  ; value_node : - 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : -,1
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_products_12_27_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(- 1); }
    {short ret; ret = (short)(- 1); }
    {int tlv1; tlv1 = (int)(- 1); }
    {void * tlv12; tlv12 = (void *)(- 1); }
    {void * tlv11; tlv11 = (void *)(- 1); }
    {unsigned int tlv10; tlv10 = (unsigned int)(- 1); }
    {int tlv2; tlv2 = (int)(- 1); }
    {void * tlv15; tlv15 = (void *)(- 1); }
    {void * tlv14; tlv14 = (void *)(- 1); }
    {unsigned int tlv13; tlv13 = (unsigned int)(- 1); }
    {int tlv3; tlv3 = (int)(- 1); }
    {void * tlv18; tlv18 = (void *)(- 1); }
    {void * tlv17; tlv17 = (void *)(- 1); }
    {unsigned int tlv16; tlv16 = (unsigned int)(- 1); }
    {int tlv4; tlv4 = (int)(- 1); }
    {void * tlv21; tlv21 = (void *)(- 1); }
    {void * tlv20; tlv20 = (void *)(- 1); }
    {unsigned int tlv19; tlv19 = (unsigned int)(- 1); }
    {int tlv5; tlv5 = (int)(- 1); }
    {void * tlv24; tlv24 = (void *)(- 1); }
    {void * tlv23; tlv23 = (void *)(- 1); }
    {unsigned int tlv22; tlv22 = (unsigned int)(- 1); }
    {int tlv6; tlv6 = (int)(- 1); }
    {void * tlv27; tlv27 = (void *)(- 1); }
    {void * tlv26; tlv26 = (void *)(- 1); }
    {unsigned int tlv25; tlv25 = (unsigned int)(- 1); }
    {int tlv7; tlv7 = (int)(- 1); }
    {void * tlv30; tlv30 = (void *)(- 1); }
    {void * tlv29; tlv29 = (void *)(- 1); }
    {unsigned int tlv28; tlv28 = (unsigned int)(- 1); }
    {int tlv8; tlv8 = (int)(- 1); }
    {void * tlv33; tlv33 = (void *)(- 1); }
    {void * tlv32; tlv32 = (void *)(- 1); }
    {unsigned int tlv31; tlv31 = (unsigned int)(- 1); }
    {int tlv9; tlv9 = (int)(- 1); }
    {void * tlv36; tlv36 = (void *)(- 1); }
    {void * tlv35; tlv35 = (void *)(- 1); }
    {unsigned int tlv34; tlv34 = (unsigned int)(- 1); }
}
void fix_ingred_products_12_27(){
fix_ingred_products_12_27_0();
}

==== Scope 2 ====
void fix_ingred_products_12_0_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(0); }
    {short ret; ret = (short)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {void * tlv12; tlv12 = (void *)(0); }
    {void * tlv11; tlv11 = (void *)(0); }
    {unsigned int tlv10; tlv10 = (unsigned int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {unsigned int tlv13; tlv13 = (unsigned int)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {void * tlv18; tlv18 = (void *)(0); }
    {void * tlv17; tlv17 = (void *)(0); }
    {unsigned int tlv16; tlv16 = (unsigned int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv21; tlv21 = (void *)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {unsigned int tlv19; tlv19 = (unsigned int)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {void * tlv24; tlv24 = (void *)(0); }
    {void * tlv23; tlv23 = (void *)(0); }
    {unsigned int tlv22; tlv22 = (unsigned int)(0); }
    {int tlv6; tlv6 = (int)(0); }
    {void * tlv27; tlv27 = (void *)(0); }
    {void * tlv26; tlv26 = (void *)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {void * tlv30; tlv30 = (void *)(0); }
    {void * tlv29; tlv29 = (void *)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {int tlv8; tlv8 = (int)(0); }
    {void * tlv33; tlv33 = (void *)(0); }
    {void * tlv32; tlv32 = (void *)(0); }
    {unsigned int tlv31; tlv31 = (unsigned int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {void * tlv36; tlv36 = (void *)(0); }
    {void * tlv35; tlv35 = (void *)(0); }
    {unsigned int tlv34; tlv34 = (unsigned int)(0); }
}
void fix_ingred_products_12_0(){
fix_ingred_products_12_0_0();
}
void fix_ingred_products_12_1_0(){
char cmd [ 4 ];
    bzero(&cmd,( 4 *sizeof(char) ) );
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_BUY); }
    {short ret; ret = (short)(( void * ) CMD_BUY); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_BUY); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_BUY); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_BUY); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_BUY); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_BUY); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_BUY); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_BUY); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_BUY); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_BUY); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_BUY); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_BUY); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_BUY); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_BUY); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_BUY); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_BUY); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_BUY); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_BUY); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_BUY); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_BUY); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_BUY); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_BUY); }
}
void fix_ingred_products_12_1_1(){
char cmd [ 4 ];
    bzero(&cmd,( 4 *sizeof(char) ) );
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(cmd); }
    {short ret; ret = (short)(cmd); }
    {int tlv1; tlv1 = (int)(cmd); }
    {void * tlv12; tlv12 = (void *)(cmd); }
    {void * tlv11; tlv11 = (void *)(cmd); }
    {unsigned int tlv10; tlv10 = (unsigned int)(cmd); }
    {int tlv2; tlv2 = (int)(cmd); }
    {void * tlv15; tlv15 = (void *)(cmd); }
    {void * tlv14; tlv14 = (void *)(cmd); }
    {unsigned int tlv13; tlv13 = (unsigned int)(cmd); }
    {int tlv3; tlv3 = (int)(cmd); }
    {void * tlv18; tlv18 = (void *)(cmd); }
    {void * tlv17; tlv17 = (void *)(cmd); }
    {unsigned int tlv16; tlv16 = (unsigned int)(cmd); }
    {int tlv4; tlv4 = (int)(cmd); }
    {void * tlv21; tlv21 = (void *)(cmd); }
    {void * tlv20; tlv20 = (void *)(cmd); }
    {unsigned int tlv19; tlv19 = (unsigned int)(cmd); }
    {int tlv5; tlv5 = (int)(cmd); }
    {void * tlv24; tlv24 = (void *)(cmd); }
    {void * tlv23; tlv23 = (void *)(cmd); }
    {unsigned int tlv22; tlv22 = (unsigned int)(cmd); }
    {int tlv6; tlv6 = (int)(cmd); }
    {void * tlv27; tlv27 = (void *)(cmd); }
    {void * tlv26; tlv26 = (void *)(cmd); }
    {unsigned int tlv25; tlv25 = (unsigned int)(cmd); }
    {int tlv7; tlv7 = (int)(cmd); }
    {void * tlv30; tlv30 = (void *)(cmd); }
    {void * tlv29; tlv29 = (void *)(cmd); }
    {unsigned int tlv28; tlv28 = (unsigned int)(cmd); }
    {int tlv8; tlv8 = (int)(cmd); }
    {void * tlv33; tlv33 = (void *)(cmd); }
    {void * tlv32; tlv32 = (void *)(cmd); }
    {unsigned int tlv31; tlv31 = (unsigned int)(cmd); }
    {int tlv9; tlv9 = (int)(cmd); }
    {void * tlv36; tlv36 = (void *)(cmd); }
    {void * tlv35; tlv35 = (void *)(cmd); }
    {unsigned int tlv34; tlv34 = (unsigned int)(cmd); }
}
void fix_ingred_products_12_1_2(){
char cmd [ 4 ];
    bzero(&cmd,( 4 *sizeof(char) ) );
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_BUY )); }
    {short ret; ret = (short)(sizeof ( CMD_BUY )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_BUY )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_BUY )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_BUY )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_BUY )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_BUY )); }
}
void fix_ingred_products_12_1(){
fix_ingred_products_12_1_0();
fix_ingred_products_12_1_1();
fix_ingred_products_12_1_2();
}
void fix_ingred_products_12_2_1(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(0); }
    {short ret; ret = (short)(0); }
    {void * tlv12; tlv12 = (void *)(0); }
    {unsigned int tlv10; tlv10 = (unsigned int)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {void * tlv15; tlv15 = (void *)(0); }
    {void * tlv14; tlv14 = (void *)(0); }
    {unsigned int tlv13; tlv13 = (unsigned int)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {void * tlv18; tlv18 = (void *)(0); }
    {void * tlv17; tlv17 = (void *)(0); }
    {unsigned int tlv16; tlv16 = (unsigned int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv21; tlv21 = (void *)(0); }
    {void * tlv20; tlv20 = (void *)(0); }
    {unsigned int tlv19; tlv19 = (unsigned int)(0); }
    {void * tlv24; tlv24 = (void *)(0); }
    {void * tlv23; tlv23 = (void *)(0); }
    {unsigned int tlv22; tlv22 = (unsigned int)(0); }
    {int tlv6; tlv6 = (int)(0); }
    {void * tlv27; tlv27 = (void *)(0); }
    {void * tlv26; tlv26 = (void *)(0); }
    {unsigned int tlv25; tlv25 = (unsigned int)(0); }
    {int tlv7; tlv7 = (int)(0); }
    {void * tlv30; tlv30 = (void *)(0); }
    {void * tlv29; tlv29 = (void *)(0); }
    {unsigned int tlv28; tlv28 = (unsigned int)(0); }
    {void * tlv33; tlv33 = (void *)(0); }
    {void * tlv32; tlv32 = (void *)(0); }
    {unsigned int tlv31; tlv31 = (unsigned int)(0); }
    {int tlv9; tlv9 = (int)(0); }
    {void * tlv36; tlv36 = (void *)(0); }
    {void * tlv35; tlv35 = (void *)(0); }
    {unsigned int tlv34; tlv34 = (unsigned int)(0); }
}
void fix_ingred_products_12_2_2(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv1); }
    {short ret; ret = (short)(tlv1); }
    {void * tlv12; tlv12 = (void *)(tlv1); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {void * tlv15; tlv15 = (void *)(tlv1); }
    {void * tlv14; tlv14 = (void *)(tlv1); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {void * tlv18; tlv18 = (void *)(tlv1); }
    {void * tlv17; tlv17 = (void *)(tlv1); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv1); }
    {int tlv4; tlv4 = (int)(tlv1); }
    {void * tlv21; tlv21 = (void *)(tlv1); }
    {void * tlv20; tlv20 = (void *)(tlv1); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv1); }
    {int tlv5; tlv5 = (int)(tlv1); }
    {void * tlv24; tlv24 = (void *)(tlv1); }
    {void * tlv23; tlv23 = (void *)(tlv1); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv1); }
    {int tlv6; tlv6 = (int)(tlv1); }
    {void * tlv27; tlv27 = (void *)(tlv1); }
    {void * tlv26; tlv26 = (void *)(tlv1); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv1); }
    {int tlv7; tlv7 = (int)(tlv1); }
    {void * tlv30; tlv30 = (void *)(tlv1); }
    {void * tlv29; tlv29 = (void *)(tlv1); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv1); }
    {int tlv8; tlv8 = (int)(tlv1); }
    {void * tlv33; tlv33 = (void *)(tlv1); }
    {void * tlv32; tlv32 = (void *)(tlv1); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv1); }
    {int tlv9; tlv9 = (int)(tlv1); }
    {void * tlv36; tlv36 = (void *)(tlv1); }
    {void * tlv35; tlv35 = (void *)(tlv1); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv1); }
}
void fix_ingred_products_12_2(){
fix_ingred_products_12_2_1();
fix_ingred_products_12_2_2();
}
void fix_ingred_products_12_4_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_CHECK); }
    {short ret; ret = (short)(( void * ) CMD_CHECK); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_CHECK); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_CHECK); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_CHECK); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_CHECK); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_CHECK); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_CHECK); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_CHECK); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_CHECK); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_CHECK); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_CHECK); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_CHECK); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_CHECK); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_CHECK); }
}
void fix_ingred_products_12_4_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_CHECK )); }
    {short ret; ret = (short)(sizeof ( CMD_CHECK )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_CHECK )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_CHECK )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_CHECK )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_CHECK )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_CHECK )); }
}
void fix_ingred_products_12_4(){
fix_ingred_products_12_4_0();
fix_ingred_products_12_4_2();
}
void fix_ingred_products_12_5_2(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv2); }
    {short ret; ret = (short)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {void * tlv12; tlv12 = (void *)(tlv2); }
    {void * tlv11; tlv11 = (void *)(tlv2); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv2); }
    {void * tlv15; tlv15 = (void *)(tlv2); }
    {void * tlv14; tlv14 = (void *)(tlv2); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {void * tlv18; tlv18 = (void *)(tlv2); }
    {void * tlv17; tlv17 = (void *)(tlv2); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv2); }
    {int tlv4; tlv4 = (int)(tlv2); }
    {void * tlv21; tlv21 = (void *)(tlv2); }
    {void * tlv20; tlv20 = (void *)(tlv2); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv2); }
    {int tlv5; tlv5 = (int)(tlv2); }
    {void * tlv24; tlv24 = (void *)(tlv2); }
    {void * tlv23; tlv23 = (void *)(tlv2); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv2); }
    {int tlv6; tlv6 = (int)(tlv2); }
    {void * tlv27; tlv27 = (void *)(tlv2); }
    {void * tlv26; tlv26 = (void *)(tlv2); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv2); }
    {int tlv7; tlv7 = (int)(tlv2); }
    {void * tlv30; tlv30 = (void *)(tlv2); }
    {void * tlv29; tlv29 = (void *)(tlv2); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv2); }
    {int tlv8; tlv8 = (int)(tlv2); }
    {void * tlv33; tlv33 = (void *)(tlv2); }
    {void * tlv32; tlv32 = (void *)(tlv2); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv2); }
    {int tlv9; tlv9 = (int)(tlv2); }
    {void * tlv36; tlv36 = (void *)(tlv2); }
    {void * tlv35; tlv35 = (void *)(tlv2); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv2); }
}
void fix_ingred_products_12_5(){
fix_ingred_products_12_5_2();
}
void fix_ingred_products_12_7_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_ADD); }
    {short ret; ret = (short)(( void * ) CMD_ADD); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_ADD); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_ADD); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_ADD); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_ADD); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_ADD); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_ADD); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_ADD); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_ADD); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_ADD); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_ADD); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_ADD); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_ADD); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_ADD); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_ADD); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_ADD); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_ADD); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_ADD); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_ADD); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_ADD); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_ADD); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_ADD); }
}
void fix_ingred_products_12_7_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_ADD )); }
    {short ret; ret = (short)(sizeof ( CMD_ADD )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_ADD )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_ADD )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_ADD )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_ADD )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_ADD )); }
}
void fix_ingred_products_12_7(){
fix_ingred_products_12_7_0();
fix_ingred_products_12_7_2();
}
void fix_ingred_products_12_8_2(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv3); }
    {short ret; ret = (short)(tlv3); }
    {int tlv1; tlv1 = (int)(tlv3); }
    {void * tlv12; tlv12 = (void *)(tlv3); }
    {void * tlv11; tlv11 = (void *)(tlv3); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {void * tlv15; tlv15 = (void *)(tlv3); }
    {void * tlv14; tlv14 = (void *)(tlv3); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv3); }
    {void * tlv18; tlv18 = (void *)(tlv3); }
    {void * tlv17; tlv17 = (void *)(tlv3); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv3); }
    {int tlv4; tlv4 = (int)(tlv3); }
    {void * tlv21; tlv21 = (void *)(tlv3); }
    {void * tlv20; tlv20 = (void *)(tlv3); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv3); }
    {int tlv5; tlv5 = (int)(tlv3); }
    {void * tlv24; tlv24 = (void *)(tlv3); }
    {void * tlv23; tlv23 = (void *)(tlv3); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv3); }
    {int tlv6; tlv6 = (int)(tlv3); }
    {void * tlv27; tlv27 = (void *)(tlv3); }
    {void * tlv26; tlv26 = (void *)(tlv3); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv3); }
    {int tlv7; tlv7 = (int)(tlv3); }
    {void * tlv30; tlv30 = (void *)(tlv3); }
    {void * tlv29; tlv29 = (void *)(tlv3); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv3); }
    {int tlv8; tlv8 = (int)(tlv3); }
    {void * tlv33; tlv33 = (void *)(tlv3); }
    {void * tlv32; tlv32 = (void *)(tlv3); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv3); }
    {int tlv9; tlv9 = (int)(tlv3); }
    {void * tlv36; tlv36 = (void *)(tlv3); }
    {void * tlv35; tlv35 = (void *)(tlv3); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv3); }
}
void fix_ingred_products_12_8(){
fix_ingred_products_12_8_2();
}
void fix_ingred_products_12_10_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_RM); }
    {short ret; ret = (short)(( void * ) CMD_RM); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_RM); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_RM); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_RM); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_RM); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_RM); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_RM); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_RM); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_RM); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_RM); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_RM); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_RM); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_RM); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_RM); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_RM); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_RM); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_RM); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_RM); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_RM); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_RM); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_RM); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_RM); }
}
void fix_ingred_products_12_10_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_RM )); }
    {short ret; ret = (short)(sizeof ( CMD_RM )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_RM )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_RM )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_RM )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_RM )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_RM )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_RM )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_RM )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_RM )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_RM )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_RM )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_RM )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_RM )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_RM )); }
}
void fix_ingred_products_12_10(){
fix_ingred_products_12_10_0();
fix_ingred_products_12_10_2();
}
void fix_ingred_products_12_11_2(){
int tlv4;
    bzero(&tlv4,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv4); }
    {short ret; ret = (short)(tlv4); }
    {int tlv1; tlv1 = (int)(tlv4); }
    {void * tlv12; tlv12 = (void *)(tlv4); }
    {void * tlv11; tlv11 = (void *)(tlv4); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv4); }
    {int tlv2; tlv2 = (int)(tlv4); }
    {void * tlv15; tlv15 = (void *)(tlv4); }
    {void * tlv14; tlv14 = (void *)(tlv4); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv4); }
    {int tlv3; tlv3 = (int)(tlv4); }
    {void * tlv18; tlv18 = (void *)(tlv4); }
    {void * tlv17; tlv17 = (void *)(tlv4); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv4); }
    {void * tlv21; tlv21 = (void *)(tlv4); }
    {void * tlv20; tlv20 = (void *)(tlv4); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv4); }
    {int tlv5; tlv5 = (int)(tlv4); }
    {void * tlv24; tlv24 = (void *)(tlv4); }
    {void * tlv23; tlv23 = (void *)(tlv4); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv4); }
    {int tlv6; tlv6 = (int)(tlv4); }
    {void * tlv27; tlv27 = (void *)(tlv4); }
    {void * tlv26; tlv26 = (void *)(tlv4); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv4); }
    {int tlv7; tlv7 = (int)(tlv4); }
    {void * tlv30; tlv30 = (void *)(tlv4); }
    {void * tlv29; tlv29 = (void *)(tlv4); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv4); }
    {int tlv8; tlv8 = (int)(tlv4); }
    {void * tlv33; tlv33 = (void *)(tlv4); }
    {void * tlv32; tlv32 = (void *)(tlv4); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv4); }
    {int tlv9; tlv9 = (int)(tlv4); }
    {void * tlv36; tlv36 = (void *)(tlv4); }
    {void * tlv35; tlv35 = (void *)(tlv4); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv4); }
}
void fix_ingred_products_12_11(){
fix_ingred_products_12_11_2();
}
void fix_ingred_products_12_13_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_UPDATE); }
    {short ret; ret = (short)(( void * ) CMD_UPDATE); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_UPDATE); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_UPDATE); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_UPDATE); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_UPDATE); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_UPDATE); }
}
void fix_ingred_products_12_13_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_UPDATE )); }
    {short ret; ret = (short)(sizeof ( CMD_UPDATE )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_UPDATE )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_UPDATE )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_UPDATE )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_UPDATE )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_UPDATE )); }
}
void fix_ingred_products_12_13(){
fix_ingred_products_12_13_0();
fix_ingred_products_12_13_2();
}
void fix_ingred_products_12_14_2(){
int tlv5;
    bzero(&tlv5,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv5); }
    {short ret; ret = (short)(tlv5); }
    {int tlv1; tlv1 = (int)(tlv5); }
    {void * tlv12; tlv12 = (void *)(tlv5); }
    {void * tlv11; tlv11 = (void *)(tlv5); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv5); }
    {int tlv2; tlv2 = (int)(tlv5); }
    {void * tlv15; tlv15 = (void *)(tlv5); }
    {void * tlv14; tlv14 = (void *)(tlv5); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv5); }
    {int tlv3; tlv3 = (int)(tlv5); }
    {void * tlv18; tlv18 = (void *)(tlv5); }
    {void * tlv17; tlv17 = (void *)(tlv5); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv5); }
    {int tlv4; tlv4 = (int)(tlv5); }
    {void * tlv21; tlv21 = (void *)(tlv5); }
    {void * tlv20; tlv20 = (void *)(tlv5); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv5); }
    {void * tlv24; tlv24 = (void *)(tlv5); }
    {void * tlv23; tlv23 = (void *)(tlv5); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv5); }
    {int tlv6; tlv6 = (int)(tlv5); }
    {void * tlv27; tlv27 = (void *)(tlv5); }
    {void * tlv26; tlv26 = (void *)(tlv5); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv5); }
    {int tlv7; tlv7 = (int)(tlv5); }
    {void * tlv30; tlv30 = (void *)(tlv5); }
    {void * tlv29; tlv29 = (void *)(tlv5); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv5); }
    {int tlv8; tlv8 = (int)(tlv5); }
    {void * tlv33; tlv33 = (void *)(tlv5); }
    {void * tlv32; tlv32 = (void *)(tlv5); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv5); }
    {int tlv9; tlv9 = (int)(tlv5); }
    {void * tlv36; tlv36 = (void *)(tlv5); }
    {void * tlv35; tlv35 = (void *)(tlv5); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv5); }
}
void fix_ingred_products_12_14(){
fix_ingred_products_12_14_2();
}
void fix_ingred_products_12_16_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_ONSALE); }
    {short ret; ret = (short)(( void * ) CMD_ONSALE); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_ONSALE); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_ONSALE); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_ONSALE); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_ONSALE); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_ONSALE); }
}
void fix_ingred_products_12_16_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_ONSALE )); }
    {short ret; ret = (short)(sizeof ( CMD_ONSALE )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_ONSALE )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_ONSALE )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_ONSALE )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_ONSALE )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_ONSALE )); }
}
void fix_ingred_products_12_16(){
fix_ingred_products_12_16_0();
fix_ingred_products_12_16_2();
}
void fix_ingred_products_12_17_2(){
int tlv6;
    bzero(&tlv6,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv6); }
    {short ret; ret = (short)(tlv6); }
    {int tlv1; tlv1 = (int)(tlv6); }
    {void * tlv12; tlv12 = (void *)(tlv6); }
    {void * tlv11; tlv11 = (void *)(tlv6); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv6); }
    {int tlv2; tlv2 = (int)(tlv6); }
    {void * tlv15; tlv15 = (void *)(tlv6); }
    {void * tlv14; tlv14 = (void *)(tlv6); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv6); }
    {int tlv3; tlv3 = (int)(tlv6); }
    {void * tlv18; tlv18 = (void *)(tlv6); }
    {void * tlv17; tlv17 = (void *)(tlv6); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv6); }
    {int tlv4; tlv4 = (int)(tlv6); }
    {void * tlv21; tlv21 = (void *)(tlv6); }
    {void * tlv20; tlv20 = (void *)(tlv6); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv6); }
    {int tlv5; tlv5 = (int)(tlv6); }
    {void * tlv24; tlv24 = (void *)(tlv6); }
    {void * tlv23; tlv23 = (void *)(tlv6); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv6); }
    {void * tlv27; tlv27 = (void *)(tlv6); }
    {void * tlv26; tlv26 = (void *)(tlv6); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv6); }
    {int tlv7; tlv7 = (int)(tlv6); }
    {void * tlv30; tlv30 = (void *)(tlv6); }
    {void * tlv29; tlv29 = (void *)(tlv6); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv6); }
    {int tlv8; tlv8 = (int)(tlv6); }
    {void * tlv33; tlv33 = (void *)(tlv6); }
    {void * tlv32; tlv32 = (void *)(tlv6); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv6); }
    {int tlv9; tlv9 = (int)(tlv6); }
    {void * tlv36; tlv36 = (void *)(tlv6); }
    {void * tlv35; tlv35 = (void *)(tlv6); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv6); }
}
void fix_ingred_products_12_17(){
fix_ingred_products_12_17_2();
}
void fix_ingred_products_12_19_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_NOSALE); }
    {short ret; ret = (short)(( void * ) CMD_NOSALE); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_NOSALE); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_NOSALE); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_NOSALE); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_NOSALE); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_NOSALE); }
}
void fix_ingred_products_12_19_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_NOSALE )); }
    {short ret; ret = (short)(sizeof ( CMD_NOSALE )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_NOSALE )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_NOSALE )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_NOSALE )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_NOSALE )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_NOSALE )); }
}
void fix_ingred_products_12_19(){
fix_ingred_products_12_19_0();
fix_ingred_products_12_19_2();
}
void fix_ingred_products_12_20_2(){
int tlv7;
    bzero(&tlv7,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv7); }
    {short ret; ret = (short)(tlv7); }
    {int tlv1; tlv1 = (int)(tlv7); }
    {void * tlv12; tlv12 = (void *)(tlv7); }
    {void * tlv11; tlv11 = (void *)(tlv7); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv7); }
    {int tlv2; tlv2 = (int)(tlv7); }
    {void * tlv15; tlv15 = (void *)(tlv7); }
    {void * tlv14; tlv14 = (void *)(tlv7); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv7); }
    {int tlv3; tlv3 = (int)(tlv7); }
    {void * tlv18; tlv18 = (void *)(tlv7); }
    {void * tlv17; tlv17 = (void *)(tlv7); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv7); }
    {int tlv4; tlv4 = (int)(tlv7); }
    {void * tlv21; tlv21 = (void *)(tlv7); }
    {void * tlv20; tlv20 = (void *)(tlv7); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv7); }
    {int tlv5; tlv5 = (int)(tlv7); }
    {void * tlv24; tlv24 = (void *)(tlv7); }
    {void * tlv23; tlv23 = (void *)(tlv7); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv7); }
    {int tlv6; tlv6 = (int)(tlv7); }
    {void * tlv27; tlv27 = (void *)(tlv7); }
    {void * tlv26; tlv26 = (void *)(tlv7); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv7); }
    {void * tlv30; tlv30 = (void *)(tlv7); }
    {void * tlv29; tlv29 = (void *)(tlv7); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv7); }
    {int tlv8; tlv8 = (int)(tlv7); }
    {void * tlv33; tlv33 = (void *)(tlv7); }
    {void * tlv32; tlv32 = (void *)(tlv7); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv7); }
    {int tlv9; tlv9 = (int)(tlv7); }
    {void * tlv36; tlv36 = (void *)(tlv7); }
    {void * tlv35; tlv35 = (void *)(tlv7); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv7); }
}
void fix_ingred_products_12_20(){
fix_ingred_products_12_20_2();
}
void fix_ingred_products_12_22_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_LIST); }
    {short ret; ret = (short)(( void * ) CMD_LIST); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_LIST); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_LIST); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_LIST); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_LIST); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_LIST); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_LIST); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_LIST); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_LIST); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_LIST); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_LIST); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_LIST); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_LIST); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_LIST); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_LIST); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_LIST); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_LIST); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_LIST); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_LIST); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_LIST); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_LIST); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_LIST); }
}
void fix_ingred_products_12_22_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_LIST )); }
    {short ret; ret = (short)(sizeof ( CMD_LIST )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_LIST )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_LIST )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_LIST )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_LIST )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_LIST )); }
}
void fix_ingred_products_12_22(){
fix_ingred_products_12_22_0();
fix_ingred_products_12_22_2();
}
void fix_ingred_products_12_23_2(){
int tlv8;
    bzero(&tlv8,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv8); }
    {short ret; ret = (short)(tlv8); }
    {int tlv1; tlv1 = (int)(tlv8); }
    {void * tlv12; tlv12 = (void *)(tlv8); }
    {void * tlv11; tlv11 = (void *)(tlv8); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv8); }
    {int tlv2; tlv2 = (int)(tlv8); }
    {void * tlv15; tlv15 = (void *)(tlv8); }
    {void * tlv14; tlv14 = (void *)(tlv8); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv8); }
    {int tlv3; tlv3 = (int)(tlv8); }
    {void * tlv18; tlv18 = (void *)(tlv8); }
    {void * tlv17; tlv17 = (void *)(tlv8); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv8); }
    {int tlv4; tlv4 = (int)(tlv8); }
    {void * tlv21; tlv21 = (void *)(tlv8); }
    {void * tlv20; tlv20 = (void *)(tlv8); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv8); }
    {int tlv5; tlv5 = (int)(tlv8); }
    {void * tlv24; tlv24 = (void *)(tlv8); }
    {void * tlv23; tlv23 = (void *)(tlv8); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv8); }
    {int tlv6; tlv6 = (int)(tlv8); }
    {void * tlv27; tlv27 = (void *)(tlv8); }
    {void * tlv26; tlv26 = (void *)(tlv8); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv8); }
    {int tlv7; tlv7 = (int)(tlv8); }
    {void * tlv30; tlv30 = (void *)(tlv8); }
    {void * tlv29; tlv29 = (void *)(tlv8); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv8); }
    {void * tlv33; tlv33 = (void *)(tlv8); }
    {void * tlv32; tlv32 = (void *)(tlv8); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv8); }
    {int tlv9; tlv9 = (int)(tlv8); }
    {void * tlv36; tlv36 = (void *)(tlv8); }
    {void * tlv35; tlv35 = (void *)(tlv8); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv8); }
}
void fix_ingred_products_12_23(){
fix_ingred_products_12_23_2();
}
void fix_ingred_products_12_25_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(( void * ) CMD_QUIT); }
    {short ret; ret = (short)(( void * ) CMD_QUIT); }
    {int tlv1; tlv1 = (int)(( void * ) CMD_QUIT); }
    {void * tlv12; tlv12 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv11; tlv11 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv10; tlv10 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv2; tlv2 = (int)(( void * ) CMD_QUIT); }
    {void * tlv15; tlv15 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv14; tlv14 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv13; tlv13 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv3; tlv3 = (int)(( void * ) CMD_QUIT); }
    {void * tlv18; tlv18 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv17; tlv17 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv16; tlv16 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv4; tlv4 = (int)(( void * ) CMD_QUIT); }
    {void * tlv21; tlv21 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv20; tlv20 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv19; tlv19 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv5; tlv5 = (int)(( void * ) CMD_QUIT); }
    {void * tlv24; tlv24 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv23; tlv23 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv22; tlv22 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv6; tlv6 = (int)(( void * ) CMD_QUIT); }
    {void * tlv27; tlv27 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv26; tlv26 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv25; tlv25 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv7; tlv7 = (int)(( void * ) CMD_QUIT); }
    {void * tlv30; tlv30 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv29; tlv29 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv28; tlv28 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv8; tlv8 = (int)(( void * ) CMD_QUIT); }
    {void * tlv33; tlv33 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv32; tlv32 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv31; tlv31 = (unsigned int)(( void * ) CMD_QUIT); }
    {int tlv9; tlv9 = (int)(( void * ) CMD_QUIT); }
    {void * tlv36; tlv36 = (void *)(( void * ) CMD_QUIT); }
    {void * tlv35; tlv35 = (void *)(( void * ) CMD_QUIT); }
    {unsigned int tlv34; tlv34 = (unsigned int)(( void * ) CMD_QUIT); }
}
void fix_ingred_products_12_25_2(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(sizeof ( CMD_QUIT )); }
    {short ret; ret = (short)(sizeof ( CMD_QUIT )); }
    {int tlv1; tlv1 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv12; tlv12 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv11; tlv11 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv10; tlv10 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv2; tlv2 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv15; tlv15 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv14; tlv14 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv13; tlv13 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv3; tlv3 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv18; tlv18 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv17; tlv17 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv16; tlv16 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv4; tlv4 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv21; tlv21 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv20; tlv20 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv19; tlv19 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv5; tlv5 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv24; tlv24 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv23; tlv23 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv22; tlv22 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv6; tlv6 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv27; tlv27 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv26; tlv26 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv25; tlv25 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv7; tlv7 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv30; tlv30 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv29; tlv29 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv28; tlv28 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv8; tlv8 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv33; tlv33 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv32; tlv32 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv31; tlv31 = (unsigned int)(sizeof ( CMD_QUIT )); }
    {int tlv9; tlv9 = (int)(sizeof ( CMD_QUIT )); }
    {void * tlv36; tlv36 = (void *)(sizeof ( CMD_QUIT )); }
    {void * tlv35; tlv35 = (void *)(sizeof ( CMD_QUIT )); }
    {unsigned int tlv34; tlv34 = (unsigned int)(sizeof ( CMD_QUIT )); }
}
void fix_ingred_products_12_25(){
fix_ingred_products_12_25_0();
fix_ingred_products_12_25_2();
}
void fix_ingred_products_12_26_0(){
int tlv9;
    bzero(&tlv9,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(- 2); }
    {short ret; ret = (short)(- 2); }
    {int tlv1; tlv1 = (int)(- 2); }
    {void * tlv12; tlv12 = (void *)(- 2); }
    {void * tlv11; tlv11 = (void *)(- 2); }
    {unsigned int tlv10; tlv10 = (unsigned int)(- 2); }
    {int tlv2; tlv2 = (int)(- 2); }
    {void * tlv15; tlv15 = (void *)(- 2); }
    {void * tlv14; tlv14 = (void *)(- 2); }
    {unsigned int tlv13; tlv13 = (unsigned int)(- 2); }
    {int tlv3; tlv3 = (int)(- 2); }
    {void * tlv18; tlv18 = (void *)(- 2); }
    {void * tlv17; tlv17 = (void *)(- 2); }
    {unsigned int tlv16; tlv16 = (unsigned int)(- 2); }
    {int tlv4; tlv4 = (int)(- 2); }
    {void * tlv21; tlv21 = (void *)(- 2); }
    {void * tlv20; tlv20 = (void *)(- 2); }
    {unsigned int tlv19; tlv19 = (unsigned int)(- 2); }
    {int tlv5; tlv5 = (int)(- 2); }
    {void * tlv24; tlv24 = (void *)(- 2); }
    {void * tlv23; tlv23 = (void *)(- 2); }
    {unsigned int tlv22; tlv22 = (unsigned int)(- 2); }
    {int tlv6; tlv6 = (int)(- 2); }
    {void * tlv27; tlv27 = (void *)(- 2); }
    {void * tlv26; tlv26 = (void *)(- 2); }
    {unsigned int tlv25; tlv25 = (unsigned int)(- 2); }
    {int tlv7; tlv7 = (int)(- 2); }
    {void * tlv30; tlv30 = (void *)(- 2); }
    {void * tlv29; tlv29 = (void *)(- 2); }
    {unsigned int tlv28; tlv28 = (unsigned int)(- 2); }
    {int tlv8; tlv8 = (int)(- 2); }
    {void * tlv33; tlv33 = (void *)(- 2); }
    {void * tlv32; tlv32 = (void *)(- 2); }
    {unsigned int tlv31; tlv31 = (unsigned int)(- 2); }
    {int tlv9; tlv9 = (int)(- 2); }
    {void * tlv36; tlv36 = (void *)(- 2); }
    {void * tlv35; tlv35 = (void *)(- 2); }
    {unsigned int tlv34; tlv34 = (unsigned int)(- 2); }
}
void fix_ingred_products_12_26_3(){
int tlv9;
    bzero(&tlv9,sizeof(int));
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(tlv9); }
    {short ret; ret = (short)(tlv9); }
    {int tlv1; tlv1 = (int)(tlv9); }
    {void * tlv12; tlv12 = (void *)(tlv9); }
    {void * tlv11; tlv11 = (void *)(tlv9); }
    {unsigned int tlv10; tlv10 = (unsigned int)(tlv9); }
    {int tlv2; tlv2 = (int)(tlv9); }
    {void * tlv15; tlv15 = (void *)(tlv9); }
    {void * tlv14; tlv14 = (void *)(tlv9); }
    {unsigned int tlv13; tlv13 = (unsigned int)(tlv9); }
    {int tlv3; tlv3 = (int)(tlv9); }
    {void * tlv18; tlv18 = (void *)(tlv9); }
    {void * tlv17; tlv17 = (void *)(tlv9); }
    {unsigned int tlv16; tlv16 = (unsigned int)(tlv9); }
    {int tlv4; tlv4 = (int)(tlv9); }
    {void * tlv21; tlv21 = (void *)(tlv9); }
    {void * tlv20; tlv20 = (void *)(tlv9); }
    {unsigned int tlv19; tlv19 = (unsigned int)(tlv9); }
    {int tlv5; tlv5 = (int)(tlv9); }
    {void * tlv24; tlv24 = (void *)(tlv9); }
    {void * tlv23; tlv23 = (void *)(tlv9); }
    {unsigned int tlv22; tlv22 = (unsigned int)(tlv9); }
    {int tlv6; tlv6 = (int)(tlv9); }
    {void * tlv27; tlv27 = (void *)(tlv9); }
    {void * tlv26; tlv26 = (void *)(tlv9); }
    {unsigned int tlv25; tlv25 = (unsigned int)(tlv9); }
    {int tlv7; tlv7 = (int)(tlv9); }
    {void * tlv30; tlv30 = (void *)(tlv9); }
    {void * tlv29; tlv29 = (void *)(tlv9); }
    {unsigned int tlv28; tlv28 = (unsigned int)(tlv9); }
    {int tlv8; tlv8 = (int)(tlv9); }
    {void * tlv33; tlv33 = (void *)(tlv9); }
    {void * tlv32; tlv32 = (void *)(tlv9); }
    {unsigned int tlv31; tlv31 = (unsigned int)(tlv9); }
    {void * tlv36; tlv36 = (void *)(tlv9); }
    {void * tlv35; tlv35 = (void *)(tlv9); }
    {unsigned int tlv34; tlv34 = (unsigned int)(tlv9); }
}
void fix_ingred_products_12_26(){
fix_ingred_products_12_26_0();
fix_ingred_products_12_26_3();
}
void fix_ingred_products_12_27_0(){
    {char cmd [ 4 ]; cmd [ ( 4 )-1 ] = (char)(- 1); }
    {short ret; ret = (short)(- 1); }
    {int tlv1; tlv1 = (int)(- 1); }
    {void * tlv12; tlv12 = (void *)(- 1); }
    {void * tlv11; tlv11 = (void *)(- 1); }
    {unsigned int tlv10; tlv10 = (unsigned int)(- 1); }
    {int tlv2; tlv2 = (int)(- 1); }
    {void * tlv15; tlv15 = (void *)(- 1); }
    {void * tlv14; tlv14 = (void *)(- 1); }
    {unsigned int tlv13; tlv13 = (unsigned int)(- 1); }
    {int tlv3; tlv3 = (int)(- 1); }
    {void * tlv18; tlv18 = (void *)(- 1); }
    {void * tlv17; tlv17 = (void *)(- 1); }
    {unsigned int tlv16; tlv16 = (unsigned int)(- 1); }
    {int tlv4; tlv4 = (int)(- 1); }
    {void * tlv21; tlv21 = (void *)(- 1); }
    {void * tlv20; tlv20 = (void *)(- 1); }
    {unsigned int tlv19; tlv19 = (unsigned int)(- 1); }
    {int tlv5; tlv5 = (int)(- 1); }
    {void * tlv24; tlv24 = (void *)(- 1); }
    {void * tlv23; tlv23 = (void *)(- 1); }
    {unsigned int tlv22; tlv22 = (unsigned int)(- 1); }
    {int tlv6; tlv6 = (int)(- 1); }
    {void * tlv27; tlv27 = (void *)(- 1); }
    {void * tlv26; tlv26 = (void *)(- 1); }
    {unsigned int tlv25; tlv25 = (unsigned int)(- 1); }
    {int tlv7; tlv7 = (int)(- 1); }
    {void * tlv30; tlv30 = (void *)(- 1); }
    {void * tlv29; tlv29 = (void *)(- 1); }
    {unsigned int tlv28; tlv28 = (unsigned int)(- 1); }
    {int tlv8; tlv8 = (int)(- 1); }
    {void * tlv33; tlv33 = (void *)(- 1); }
    {void * tlv32; tlv32 = (void *)(- 1); }
    {unsigned int tlv31; tlv31 = (unsigned int)(- 1); }
    {int tlv9; tlv9 = (int)(- 1); }
    {void * tlv36; tlv36 = (void *)(- 1); }
    {void * tlv35; tlv35 = (void *)(- 1); }
    {unsigned int tlv34; tlv34 = (unsigned int)(- 1); }
}
void fix_ingred_products_12_27(){
fix_ingred_products_12_27_0();
}
void fix_ingred_products_12(){
fix_ingred_products_12_0();
fix_ingred_products_12_1();
fix_ingred_products_12_2();
fix_ingred_products_12_4();
fix_ingred_products_12_5();
fix_ingred_products_12_7();
fix_ingred_products_12_8();
fix_ingred_products_12_10();
fix_ingred_products_12_11();
fix_ingred_products_12_13();
fix_ingred_products_12_14();
fix_ingred_products_12_16();
fix_ingred_products_12_17();
fix_ingred_products_12_19();
fix_ingred_products_12_20();
fix_ingred_products_12_22();
fix_ingred_products_12_23();
fix_ingred_products_12_25();
fix_ingred_products_12_26();
fix_ingred_products_12_27();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_products_12_0_0();
void fix_ingred_products_12_0();
void fix_ingred_products_12_1_0();
void fix_ingred_products_12_1_1();
void fix_ingred_products_12_1_2();
void fix_ingred_products_12_1();
void fix_ingred_products_12_2_1();
void fix_ingred_products_12_2_2();
void fix_ingred_products_12_2();
void fix_ingred_products_12_4_0();
void fix_ingred_products_12_4_2();
void fix_ingred_products_12_4();
void fix_ingred_products_12_5_2();
void fix_ingred_products_12_5();
void fix_ingred_products_12_7_0();
void fix_ingred_products_12_7_2();
void fix_ingred_products_12_7();
void fix_ingred_products_12_8_2();
void fix_ingred_products_12_8();
void fix_ingred_products_12_10_0();
void fix_ingred_products_12_10_2();
void fix_ingred_products_12_10();
void fix_ingred_products_12_11_2();
void fix_ingred_products_12_11();
void fix_ingred_products_12_13_0();
void fix_ingred_products_12_13_2();
void fix_ingred_products_12_13();
void fix_ingred_products_12_14_2();
void fix_ingred_products_12_14();
void fix_ingred_products_12_16_0();
void fix_ingred_products_12_16_2();
void fix_ingred_products_12_16();
void fix_ingred_products_12_17_2();
void fix_ingred_products_12_17();
void fix_ingred_products_12_19_0();
void fix_ingred_products_12_19_2();
void fix_ingred_products_12_19();
void fix_ingred_products_12_20_2();
void fix_ingred_products_12_20();
void fix_ingred_products_12_22_0();
void fix_ingred_products_12_22_2();
void fix_ingred_products_12_22();
void fix_ingred_products_12_23_2();
void fix_ingred_products_12_23();
void fix_ingred_products_12_25_0();
void fix_ingred_products_12_25_2();
void fix_ingred_products_12_25();
void fix_ingred_products_12_26_0();
void fix_ingred_products_12_26_3();
void fix_ingred_products_12_26();
void fix_ingred_products_12_27_0();
void fix_ingred_products_12_27();
void fix_ingred_products_12();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_products_0_0_0
- fix_ingred_products_0_0_1
- fix_ingred_products_0_0
- fix_ingred_products_0
- fix_ingred_products_1_1_0
- fix_ingred_products_1_1_1
- fix_ingred_products_1_1_2
- fix_ingred_products_1_1
- fix_ingred_products_1_2_2
- fix_ingred_products_1_2_3
- fix_ingred_products_1_2
- fix_ingred_products_1
- fix_ingred_products_2_1_1
- fix_ingred_products_2_1
- fix_ingred_products_2
- fix_ingred_products_3_0_2
- fix_ingred_products_3_0_3
- fix_ingred_products_3_0
- fix_ingred_products_3_6_0
- fix_ingred_products_3_6
- fix_ingred_products_3_7_0
- fix_ingred_products_3_7_1
- fix_ingred_products_3_7_2
- fix_ingred_products_3_7
- fix_ingred_products_3_9_0
- fix_ingred_products_3_9_1
- fix_ingred_products_3_9_2
- fix_ingred_products_3_9
- fix_ingred_products_3_10_4
- fix_ingred_products_3_10_5
- fix_ingred_products_3_10
- fix_ingred_products_3
- fix_ingred_products_4_0_1
- fix_ingred_products_4_0_2
- fix_ingred_products_4_0
- fix_ingred_products_4_3_0
- fix_ingred_products_4_3_1
- fix_ingred_products_4_3
- fix_ingred_products_4_4_5
- fix_ingred_products_4_4
- fix_ingred_products_4
- fix_ingred_products_5_0_2
- fix_ingred_products_5_0
- fix_ingred_products_5_1_0
- fix_ingred_products_5_1
- fix_ingred_products_5_4_0
- fix_ingred_products_5_4_1
- fix_ingred_products_5_4_2
- fix_ingred_products_5_4_3
- fix_ingred_products_5_4
- fix_ingred_products_5_5_6
- fix_ingred_products_5_5
- fix_ingred_products_5_6_1
- fix_ingred_products_5_6
- fix_ingred_products_5
- fix_ingred_products_6_1_1
- fix_ingred_products_6_1
- fix_ingred_products_6
- fix_ingred_products_7_0_0
- fix_ingred_products_7_0
- fix_ingred_products_7_3_0
- fix_ingred_products_7_3_1
- fix_ingred_products_7_3_2
- fix_ingred_products_7_3_3
- fix_ingred_products_7_3
- fix_ingred_products_7_4_3
- fix_ingred_products_7_4
- fix_ingred_products_7
- fix_ingred_products_8_0_1
- fix_ingred_products_8_0
- fix_ingred_products_8_3_2
- fix_ingred_products_8_3_3
- fix_ingred_products_8_3
- fix_ingred_products_8
- fix_ingred_products_9
- fix_ingred_products_10_0_1
- fix_ingred_products_10_0
- fix_ingred_products_10_4_4
- fix_ingred_products_10_4
- fix_ingred_products_10_6_8
- fix_ingred_products_10_6
- fix_ingred_products_10_10_0
- fix_ingred_products_10_10_1
- fix_ingred_products_10_10
- fix_ingred_products_10_11_11
- fix_ingred_products_10_11
- fix_ingred_products_10
- fix_ingred_products_11
- fix_ingred_products_12_0_0
- fix_ingred_products_12_0
- fix_ingred_products_12_1_0
- fix_ingred_products_12_1_1
- fix_ingred_products_12_1_2
- fix_ingred_products_12_1
- fix_ingred_products_12_2_1
- fix_ingred_products_12_2_2
- fix_ingred_products_12_2
- fix_ingred_products_12_4_0
- fix_ingred_products_12_4_2
- fix_ingred_products_12_4
- fix_ingred_products_12_5_2
- fix_ingred_products_12_5
- fix_ingred_products_12_7_0
- fix_ingred_products_12_7_2
- fix_ingred_products_12_7
- fix_ingred_products_12_8_2
- fix_ingred_products_12_8
- fix_ingred_products_12_10_0
- fix_ingred_products_12_10_2
- fix_ingred_products_12_10
- fix_ingred_products_12_11_2
- fix_ingred_products_12_11
- fix_ingred_products_12_13_0
- fix_ingred_products_12_13_2
- fix_ingred_products_12_13
- fix_ingred_products_12_14_2
- fix_ingred_products_12_14
- fix_ingred_products_12_16_0
- fix_ingred_products_12_16_2
- fix_ingred_products_12_16
- fix_ingred_products_12_17_2
- fix_ingred_products_12_17
- fix_ingred_products_12_19_0
- fix_ingred_products_12_19_2
- fix_ingred_products_12_19
- fix_ingred_products_12_20_2
- fix_ingred_products_12_20
- fix_ingred_products_12_22_0
- fix_ingred_products_12_22_2
- fix_ingred_products_12_22
- fix_ingred_products_12_23_2
- fix_ingred_products_12_23
- fix_ingred_products_12_25_0
- fix_ingred_products_12_25_2
- fix_ingred_products_12_25
- fix_ingred_products_12_26_0
- fix_ingred_products_12_26_3
- fix_ingred_products_12_26
- fix_ingred_products_12_27_0
- fix_ingred_products_12_27
- fix_ingred_products_12
