[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_edit_dives ( logbook_type * Info )')]
ParameterDeclaration : type = logbook_type *, var = Info [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['Info']
[enterParameterDeclaration] logbook_type * : Info
sym_dict [Info] = logbook_type * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ 1024 ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int rcv_cnt'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rcv_cnt] = int 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'dive_log_type * next_dive'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [next_dive] = dive_log_type * 
var: next_dive (next_dive) = Info -> dives
var: dive_log_type * next_dive (next_dive) = Info -> dives
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int dive_count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [dive_count] = int 
var: dive_count (dive_count) = 1
var: int dive_count (dive_count) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int dive_number_to_edit'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [dive_number_to_edit] = int 
var: dive_number_to_edit (dive_number_to_edit) = 0
var: int dive_number_to_edit (dive_number_to_edit) = 0
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => next_dive == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => next_dive
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => next_dive == 0
=> ['next_dive', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : next_dive
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['next_dive']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['next_dive']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['next_dive']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['next_dive']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['next_dive']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['next_dive']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['next_dive']
FOUND IT! [2.2]  dive_log_type * : next_dive
Resolved type: [2.3]  dive_log_type * : next_dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ next_dive == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 [ ] = "\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv6] = const char * 
[C-t-2] sym_dict [tlv6 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv6 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv7 [ ] = "Dive Log is empty\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv7] = const char * 
[C-t-2] sym_dict [tlv7 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv7 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_list_dives'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( Info )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv1 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv2 [ ] = "Enter Dive # to edit: "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv2] = const char * 
[C-t-2] sym_dict [tlv2 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv2 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = char * 
var: tlv4 (tlv4) = buf
var: char * tlv4 (tlv4) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
var: tlv3 (tlv3) = sizeof ( buf )
var: cgc_size_t tlv3 (tlv3) = sizeof ( buf )
var: rcv_cnt (rcv_cnt) = cgc_getline ( tlv4 , tlv3 )
var: int rcv_cnt (rcv_cnt) = cgc_getline ( tlv4 , tlv3 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }
Assigns = [('char *', 'tlv4', '', 'buf'), ('cgc_size_t', 'tlv3', '', 'sizeof ( buf )'), ('int', 'rcv_cnt', '', 'cgc_getline ( tlv4 , tlv3 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => rcv_cnt == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => rcv_cnt
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => rcv_cnt == 0
=> ['rcv_cnt', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : rcv_cnt
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['rcv_cnt']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['rcv_cnt']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['rcv_cnt']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['rcv_cnt']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['rcv_cnt']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['rcv_cnt']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['rcv_cnt']
FOUND IT! [2.2]  int : rcv_cnt
Resolved type: [2.3]  int : rcv_cnt
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ rcv_cnt == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return 0 ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( rcv_cnt == 0 ) { return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return 0 ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 = buf'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = const char * 
var: dive_number_to_edit (dive_number_to_edit) = cgc_atoi ( tlv5 )
var: int dive_number_to_edit (dive_number_to_edit) = cgc_atoi ( tlv5 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }
Assigns = [('int', 'dive_number_to_edit', '', 'cgc_atoi ( tlv5 )')]
Compares = []
var: next_dive (next_dive) = Info -> dives
var: dive_log_type * next_dive (next_dive) = Info -> dives
var: dive_count (dive_count) = 1
var: int dive_count (dive_count) = 1
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => dive_count < dive_number_to_edit
[0] <class 'CParser.CParser.ShiftExpressionContext'> => dive_count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => dive_number_to_edit
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => dive_count < dive_number_to_edit
=> ['dive_count', 'dive_number_to_edit']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : dive_count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive_count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive_count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive_count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive_count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive_count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['dive_count']
FOUND IT! [1.2]  int : dive_count
Resolved type: [1.3]  int : dive_count
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => next_dive != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => next_dive
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => next_dive != 0
=> ['next_dive', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : next_dive
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['next_dive']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['next_dive']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['next_dive']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['next_dive']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['next_dive']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['next_dive']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['next_dive']
FOUND IT! [2.2]  dive_log_type * : next_dive
Resolved type: [2.3]  dive_log_type * : next_dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: next_dive (next_dive) = next_dive -> next
var: dive_log_type * next_dive (next_dive) = next_dive -> next
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ++ dive_count ; next_dive = next_dive -> next ; }
Assigns = [('dive_log_type *', 'next_dive', '', 'next_dive -> next')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ++ dive_count ; next_dive = next_dive -> next ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive_count == dive_number_to_edit
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive_count
[2] <class 'CParser.CParser.RelationalExpressionContext'> => dive_number_to_edit
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive_count == dive_number_to_edit
=> ['dive_count', 'dive_number_to_edit']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive_count
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive_count']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive_count']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive_count']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive_count']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive_count']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive_count']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['dive_count']
FOUND IT! [2.2]  int : dive_count
Resolved type: [2.3]  int : dive_count
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => next_dive != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => next_dive
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => next_dive != 0
=> ['next_dive', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : next_dive
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['next_dive']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['next_dive']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['next_dive']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['next_dive']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['next_dive']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['next_dive']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['next_dive']
FOUND IT! [2.2]  dive_log_type * : next_dive
Resolved type: [2.3]  dive_log_type * : next_dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive_count == dive_number_to_edit && next_dive != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_update_dive'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( next_dive )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive_count == dive_number_to_edit && next_dive != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 [ ] = "Invalid dive number entered\\n"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv8] = const char * 
[C-t-2] sym_dict [tlv8 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv8 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( rcv_cnt == 0 ) { return 0 ; } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } ]
 6 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } ]
 7 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } ]
Assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_edit_dives ( logbook_type * Info ) { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_update_dive ( dive_log_type * dive )')]
ParameterDeclaration : type = dive_log_type *, var = dive [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['dive']
[enterParameterDeclaration] dive_log_type * : dive
sym_dict [dive] = dive_log_type * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buffer [ 1024 ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buffer] = char * 
[C-t-3] sym_dict [buffer [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf2 [ 1024 ]'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf2] = char * 
[C-t-3] sym_dict [buf2 [ 1024 ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv1 [ ] = "Dive Site"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv1] = const char * 
[C-t-2] sym_dict [tlv1 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv1 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_site_name [ 0 ] != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> dive_site_name [ 0 ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_site_name [ 0 ] != 0
=> ['dive -> dive_site_name [ 0 ]', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> dive_site_name [ 0 ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> dive_site_name [ 0 ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> dive_site_name [ 0 ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> dive_site_name [ 0 ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> dive_site_name [ 0 ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> dive_site_name [ 0 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> dive_site_name [ 0 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'dive_site_name', '[', '0', ']']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> dive_site_name [ 0 ] != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv2 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv2] = const char * 
[C-t-2] sym_dict [tlv2 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv2 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv28'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv28] = char * 
var: tlv28 (tlv28) = buffer
var: char * tlv28 (tlv28) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv27'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv27] = cgc_size_t 
var: tlv27 (tlv27) = sizeof ( dive -> dive_site_name )
var: cgc_size_t tlv27 (tlv27) = sizeof ( dive -> dive_site_name )
var: count (count) = cgc_getline ( tlv28 , tlv27 )
var: cgc_size_t count (count) = cgc_getline ( tlv28 , tlv27 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; }
Assigns = [('char *', 'tlv28', '', 'buffer'), ('cgc_size_t', 'tlv27', '', 'sizeof ( dive -> dive_site_name )'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv28 , tlv27 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv51'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv51] = char * 
var: tlv51 (tlv51) = dive -> dive_site_name
var: char * tlv51 (tlv51) = dive -> dive_site_name
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv50 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv50] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv49'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv49] = cgc_size_t 
var: tlv49 (tlv49) = sizeof ( dive -> dive_site_name )
var: cgc_size_t tlv49 (tlv49) = sizeof ( dive -> dive_site_name )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; }
Assigns = [('char *', 'tlv51', '', 'dive -> dive_site_name'), ('cgc_size_t', 'tlv49', '', 'sizeof ( dive -> dive_site_name )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv3 [ ] = "Date"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv3] = const char * 
[C-t-2] sym_dict [tlv3 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv3 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_date [ 0 ] != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> dive_date [ 0 ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_date [ 0 ] != 0
=> ['dive -> dive_date [ 0 ]', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> dive_date [ 0 ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> dive_date [ 0 ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> dive_date [ 0 ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> dive_date [ 0 ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> dive_date [ 0 ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> dive_date [ 0 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> dive_date [ 0 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'dive_date', '[', '0', ']']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> dive_date [ 0 ] != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@s)" , dive -> dive_date ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@s)" , dive -> dive_date ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv4 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv4] = const char * 
[C-t-2] sym_dict [tlv4 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv30'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv30] = char * 
var: tlv30 (tlv30) = buffer
var: char * tlv30 (tlv30) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv29'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv29] = cgc_size_t 
var: tlv29 (tlv29) = sizeof ( dive -> dive_date )
var: cgc_size_t tlv29 (tlv29) = sizeof ( dive -> dive_date )
var: count (count) = cgc_getline ( tlv30 , tlv29 )
var: cgc_size_t count (count) = cgc_getline ( tlv30 , tlv29 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }
Assigns = [('char *', 'tlv30', '', 'buffer'), ('cgc_size_t', 'tlv29', '', 'sizeof ( dive -> dive_date )'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv30 , tlv29 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv54'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv54] = char * 
var: tlv54 (tlv54) = dive -> dive_date
var: char * tlv54 (tlv54) = dive -> dive_date
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv53 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv53] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv52'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv52] = cgc_size_t 
var: tlv52 (tlv52) = sizeof ( dive -> dive_date )
var: cgc_size_t tlv52 (tlv52) = sizeof ( dive -> dive_date )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; }
Assigns = [('char *', 'tlv54', '', 'dive -> dive_date'), ('cgc_size_t', 'tlv52', '', 'sizeof ( dive -> dive_date )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv5 [ ] = "Time"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv5] = const char * 
[C-t-2] sym_dict [tlv5 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_time [ 0 ] != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> dive_time [ 0 ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_time [ 0 ] != 0
=> ['dive -> dive_time [ 0 ]', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> dive_time [ 0 ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> dive_time [ 0 ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> dive_time [ 0 ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> dive_time [ 0 ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> dive_time [ 0 ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> dive_time [ 0 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> dive_time [ 0 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'dive_time', '[', '0', ']']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> dive_time [ 0 ] != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@s)" , dive -> dive_time ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@s)" , dive -> dive_time ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv6 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv6] = const char * 
[C-t-2] sym_dict [tlv6 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv6 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv32'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv32] = char * 
var: tlv32 (tlv32) = buf2
var: char * tlv32 (tlv32) = buf2
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv31'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv31] = cgc_size_t 
var: tlv31 (tlv31) = sizeof ( dive -> dive_time )
var: cgc_size_t tlv31 (tlv31) = sizeof ( dive -> dive_time )
var: count (count) = cgc_getline ( tlv32 , tlv31 )
var: cgc_size_t count (count) = cgc_getline ( tlv32 , tlv31 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }
Assigns = [('char *', 'tlv32', '', 'buf2'), ('cgc_size_t', 'tlv31', '', 'sizeof ( dive -> dive_time )'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv32 , tlv31 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv57'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv57] = char * 
var: tlv57 (tlv57) = dive -> dive_time
var: char * tlv57 (tlv57) = dive -> dive_time
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv56 = buf2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv56] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv55'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv55] = cgc_size_t 
var: tlv55 (tlv55) = sizeof ( dive -> dive_time )
var: cgc_size_t tlv55 (tlv55) = sizeof ( dive -> dive_time )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; }
Assigns = [('char *', 'tlv57', '', 'dive -> dive_time'), ('cgc_size_t', 'tlv55', '', 'sizeof ( dive -> dive_time )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = char * 
var: tlv9 (tlv9) = buffer
var: char * tlv9 (tlv9) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv8 [ ] = " "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv8] = const char * 
[C-t-2] sym_dict [tlv8 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = cgc_size_t 
var: tlv7 (tlv7) = 1
var: cgc_size_t tlv7 (tlv7) = 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }
Assigns = [('char *', 'tlv9', '', 'buffer'), ('cgc_size_t', 'tlv7', '', '1')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = char * 
var: tlv12 (tlv12) = buffer
var: char * tlv12 (tlv12) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv11 = buf2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv67'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv67] = char * 
var: tlv67 (tlv67) = buf2
var: char * tlv67 (tlv67) = buf2
var: tlv10 (tlv10) = cgc_strlen ( tlv67 )
var: cgc_size_t tlv10 (tlv10) = cgc_strlen ( tlv67 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; }
Assigns = [('char *', 'tlv67', '', 'buf2'), ('cgc_size_t', 'tlv10', '', 'cgc_strlen ( tlv67 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } ]
Assigns = [('char *', 'tlv12', '', 'buffer')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'datetime_struct_type tm'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tm] = datetime_struct_type 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv34'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv34] = char * 
var: tlv34 (tlv34) = buffer
var: char * tlv34 (tlv34) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'datetime_struct_type * tlv33'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv33] = datetime_struct_type * 
var: tlv33 (tlv33) = & tm
var: datetime_struct_type * tlv33 (tlv33) = & tm
var: dive -> timestamp (dive -> timestamp) = cgc_str2datetime ( tlv34 , tlv33 )
var: UNDEF dive -> timestamp (dive -> timestamp) = cgc_str2datetime ( tlv34 , tlv33 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }
Assigns = [('char *', 'tlv34', '', 'buffer'), ('datetime_struct_type *', 'tlv33', '', '& tm'), ('UNDEF', 'dive -> timestamp', '', 'cgc_str2datetime ( tlv34 , tlv33 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv13 [ ] = "Location (area/city)"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv13] = const char * 
[C-t-2] sym_dict [tlv13 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv13 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> location [ 0 ] != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> location [ 0 ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> location [ 0 ] != 0
=> ['dive -> location [ 0 ]', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> location [ 0 ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> location [ 0 ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> location [ 0 ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> location [ 0 ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> location [ 0 ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> location [ 0 ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> location [ 0 ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'location', '[', '0', ']']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> location [ 0 ] != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@s)" , dive -> location ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@s)" , dive -> location ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv14 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv14] = const char * 
[C-t-2] sym_dict [tlv14 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv14 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv36'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv36] = char * 
var: tlv36 (tlv36) = buffer
var: char * tlv36 (tlv36) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv35'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv35] = cgc_size_t 
var: tlv35 (tlv35) = sizeof ( buffer )
var: cgc_size_t tlv35 (tlv35) = sizeof ( buffer )
var: count (count) = cgc_getline ( tlv36 , tlv35 )
var: cgc_size_t count (count) = cgc_getline ( tlv36 , tlv35 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }
Assigns = [('char *', 'tlv36', '', 'buffer'), ('cgc_size_t', 'tlv35', '', 'sizeof ( buffer )'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv36 , tlv35 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv60'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv60] = char * 
var: tlv60 (tlv60) = dive -> location
var: char * tlv60 (tlv60) = dive -> location
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv59 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv59] = const char * 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv58'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv58] = cgc_size_t 
var: tlv58 (tlv58) = count
var: cgc_size_t tlv58 (tlv58) = count
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; }
Assigns = [('char *', 'tlv60', '', 'dive -> location'), ('cgc_size_t', 'tlv58', '', 'count')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv15 [ ] = "Max Depth in ft"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv15] = const char * 
[C-t-2] sym_dict [tlv15 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv15 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> max_depth != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> max_depth
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> max_depth != 0
=> ['dive -> max_depth', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> max_depth
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> max_depth']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> max_depth']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> max_depth']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> max_depth']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> max_depth']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> max_depth']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'max_depth']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> max_depth != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@d)" , dive -> max_depth ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@d)" , dive -> max_depth ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv16 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv16] = const char * 
[C-t-2] sym_dict [tlv16 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv16 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv38'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv38] = char * 
var: tlv38 (tlv38) = buffer
var: char * tlv38 (tlv38) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv37'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv37] = cgc_size_t 
var: tlv37 (tlv37) = sizeof ( buffer )
var: cgc_size_t tlv37 (tlv37) = sizeof ( buffer )
var: count (count) = cgc_getline ( tlv38 , tlv37 )
var: cgc_size_t count (count) = cgc_getline ( tlv38 , tlv37 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }
Assigns = [('char *', 'tlv38', '', 'buffer'), ('cgc_size_t', 'tlv37', '', 'sizeof ( buffer )'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv38 , tlv37 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv61 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv61] = const char * 
var: dive -> max_depth (dive -> max_depth) = cgc_atoi ( tlv61 )
var: UNDEF dive -> max_depth (dive -> max_depth) = cgc_atoi ( tlv61 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; }
Assigns = [('UNDEF', 'dive -> max_depth', '', 'cgc_atoi ( tlv61 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv17 [ ] = "Avg Depth in ft"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv17] = const char * 
[C-t-2] sym_dict [tlv17 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv17 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> avg_depth != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> avg_depth
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> avg_depth != 0
=> ['dive -> avg_depth', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> avg_depth
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> avg_depth']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> avg_depth']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> avg_depth']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> avg_depth']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> avg_depth']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> avg_depth']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'avg_depth']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> avg_depth != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv18 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv18] = const char * 
[C-t-2] sym_dict [tlv18 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv18 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv40'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv40] = char * 
var: tlv40 (tlv40) = buffer
var: char * tlv40 (tlv40) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv39'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv39] = cgc_size_t 
var: tlv39 (tlv39) = sizeof ( buffer )
var: cgc_size_t tlv39 (tlv39) = sizeof ( buffer )
var: count (count) = cgc_getline ( tlv40 , tlv39 )
var: cgc_size_t count (count) = cgc_getline ( tlv40 , tlv39 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }
Assigns = [('char *', 'tlv40', '', 'buffer'), ('cgc_size_t', 'tlv39', '', 'sizeof ( buffer )'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv40 , tlv39 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv62 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv62] = const char * 
var: dive -> avg_depth (dive -> avg_depth) = cgc_atoi ( tlv62 )
var: UNDEF dive -> avg_depth (dive -> avg_depth) = cgc_atoi ( tlv62 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; }
Assigns = [('UNDEF', 'dive -> avg_depth', '', 'cgc_atoi ( tlv62 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv19 [ ] = "Dive Duration (mins)"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv19] = const char * 
[C-t-2] sym_dict [tlv19 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv19 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_length != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> dive_length
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> dive_length != 0
=> ['dive -> dive_length', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> dive_length
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> dive_length']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> dive_length']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> dive_length']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> dive_length']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> dive_length']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> dive_length']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'dive_length']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> dive_length != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@d)" , dive -> dive_length ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@d)" , dive -> dive_length ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv20 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv20] = const char * 
[C-t-2] sym_dict [tlv20 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv20 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv42'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv42] = char * 
var: tlv42 (tlv42) = buffer
var: char * tlv42 (tlv42) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv41'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv41] = cgc_size_t 
var: tlv41 (tlv41) = 13
var: cgc_size_t tlv41 (tlv41) = 13
var: count (count) = cgc_getline ( tlv42 , tlv41 )
var: cgc_size_t count (count) = cgc_getline ( tlv42 , tlv41 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }
Assigns = [('char *', 'tlv42', '', 'buffer'), ('cgc_size_t', 'tlv41', '', '13'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv42 , tlv41 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv63 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv63] = const char * 
var: dive -> dive_length (dive -> dive_length) = cgc_atoi ( tlv63 )
var: UNDEF dive -> dive_length (dive -> dive_length) = cgc_atoi ( tlv63 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; }
Assigns = [('UNDEF', 'dive -> dive_length', '', 'cgc_atoi ( tlv63 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv21 [ ] = "O2 Percentage"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv21] = const char * 
[C-t-2] sym_dict [tlv21 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv21 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> O2_percent != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> O2_percent
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> O2_percent != 0
=> ['dive -> O2_percent', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> O2_percent
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> O2_percent']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> O2_percent']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> O2_percent']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> O2_percent']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> O2_percent']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> O2_percent']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'O2_percent']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> O2_percent != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv22 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv22] = const char * 
[C-t-2] sym_dict [tlv22 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv22 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv44'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv44] = char * 
var: tlv44 (tlv44) = buffer
var: char * tlv44 (tlv44) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv43'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv43] = cgc_size_t 
var: tlv43 (tlv43) = 11
var: cgc_size_t tlv43 (tlv43) = 11
var: count (count) = cgc_getline ( tlv44 , tlv43 )
var: cgc_size_t count (count) = cgc_getline ( tlv44 , tlv43 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }
Assigns = [('char *', 'tlv44', '', 'buffer'), ('cgc_size_t', 'tlv43', '', '11'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv44 , tlv43 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv64 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv64] = const char * 
var: dive -> O2_percent (dive -> O2_percent) = cgc_atoi ( tlv64 )
var: UNDEF dive -> O2_percent (dive -> O2_percent) = cgc_atoi ( tlv64 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; }
Assigns = [('UNDEF', 'dive -> O2_percent', '', 'cgc_atoi ( tlv64 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv23 [ ] = "Pressure In (psi)"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv23] = const char * 
[C-t-2] sym_dict [tlv23 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv23 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> pressure_in != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> pressure_in
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> pressure_in != 0
=> ['dive -> pressure_in', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> pressure_in
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> pressure_in']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> pressure_in']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> pressure_in']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> pressure_in']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> pressure_in']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> pressure_in']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'pressure_in']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> pressure_in != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv24 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv24] = const char * 
[C-t-2] sym_dict [tlv24 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv24 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv46'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv46] = char * 
var: tlv46 (tlv46) = buffer
var: char * tlv46 (tlv46) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv45'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv45] = cgc_size_t 
var: tlv45 (tlv45) = 20
var: cgc_size_t tlv45 (tlv45) = 20
var: count (count) = cgc_getline ( tlv46 , tlv45 )
var: cgc_size_t count (count) = cgc_getline ( tlv46 , tlv45 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }
Assigns = [('char *', 'tlv46', '', 'buffer'), ('cgc_size_t', 'tlv45', '', '20'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv46 , tlv45 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv65 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv65] = const char * 
var: dive -> pressure_in (dive -> pressure_in) = cgc_atoi ( tlv65 )
var: UNDEF dive -> pressure_in (dive -> pressure_in) = cgc_atoi ( tlv65 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; }
Assigns = [('UNDEF', 'dive -> pressure_in', '', 'cgc_atoi ( tlv65 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv25 [ ] = "Pressure Out (psi)"'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv25] = const char * 
[C-t-2] sym_dict [tlv25 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv25 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dive -> pressure_out != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dive -> pressure_out
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dive -> pressure_out != 0
=> ['dive -> pressure_out', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dive -> pressure_out
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dive -> pressure_out']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dive -> pressure_out']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dive -> pressure_out']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dive -> pressure_out']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dive -> pressure_out']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dive -> pressure_out']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['dive', '->', 'pressure_out']
FOUND IT! [2.2]  dive_log_type * : dive
Resolved type: [2.3]  dive_log_type * : dive
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ dive -> pressure_out != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv26 [ ] = ": "'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-2] sym_dict [tlv26] = const char * 
[C-t-2] sym_dict [tlv26 [ ]] = const char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_printf'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv26 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv48'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv48] = char * 
var: tlv48 (tlv48) = buffer
var: char * tlv48 (tlv48) = buffer
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv47'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv47] = cgc_size_t 
var: tlv47 (tlv47) = 11
var: cgc_size_t tlv47 (tlv47) = 11
var: count (count) = cgc_getline ( tlv48 , tlv47 )
var: cgc_size_t count (count) = cgc_getline ( tlv48 , tlv47 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }
Assigns = [('char *', 'tlv48', '', 'buffer'), ('cgc_size_t', 'tlv47', '', '11'), ('cgc_size_t', 'count', '', 'cgc_getline ( tlv48 , tlv47 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 0
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count > 0
=> ['count', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ count > 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'const char *'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'tlv66 = buffer'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv66] = const char * 
var: dive -> pressure_out (dive -> pressure_out) = cgc_atoi ( tlv66 )
var: UNDEF dive -> pressure_out (dive -> pressure_out) = cgc_atoi ( tlv66 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; }
Assigns = [('UNDEF', 'dive -> pressure_out', '', 'cgc_atoi ( tlv66 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } ]
 6 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } ]
 7 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } ]
 8 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } ]
 9 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } ]
 10 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } ]
 11 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } ]
 12 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } ]
 13 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } ]
 14 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } ]
 15 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } ]
 16 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } ]
 17 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } ]
 18 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } ]
 19 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } ]
 20 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } ]
 21 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } ]
 22 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } ]
 23 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } ]
 24 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } ]
 25 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } ]
 26 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } ]
 27 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } ]
 28 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } ]
 29 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } ]
 30 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } ]
 31 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } ]
 32 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } ]
 33 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } ]
 34 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } ]
 35 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } ]
 36 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } ]
 37 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } ]
 38 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } ]
 39 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } ]
 40 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } ]
 41 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } ]
 42 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } ]
 43 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } ]
 44 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } ]
 45 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } ]
 46 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } ]
 47 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } ]
 48 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } ]
 49 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } ]
 50 : <class 'CParser.CParser.CompoundStatementContext'>   [ { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } ]
 51 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } ]
 52 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_update_dive ( dive_log_type * dive ) { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; } ]
compound scope 0 : { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; }
compound scope 1 : { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; }
compound scope 2 : { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; }
compound scope 3 : { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; }
compound scope 4 : { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; }
compound scope 5 : { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }
compound scope 6 : { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }
compound scope 7 : { return 0 ; }
compound scope 8 : { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }
compound scope 9 : { ++ dive_count ; next_dive = next_dive -> next ; }
compound scope 10 : { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; }
compound scope 11 : { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } }
compound scope 12 : { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; }
len(compound_scope) : 13
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; } ] 
p_decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None), ('logbook_type *', 'Info', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = []
===> context { char buf [ 1024 ] ; int rcv_cnt ; dive_log_type * next_dive ; next_dive = Info -> dives ; int dive_count ; dive_count = 1 ; int dive_number_to_edit ; dive_number_to_edit = 0 ; if ( next_dive == 0 ) { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } cgc_list_dives ( Info ) ; { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } if ( rcv_cnt == 0 ) { return 0 ; } { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } next_dive = Info -> dives ; dive_count = 1 ; while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; } if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: char, var: buf [ 1024 ]
2 : |  decl_scope  | type: int, var: rcv_cnt
3 : |  decl_scope  | type: dive_log_type *, var: next_dive
4 : |  decl_scope  | type: int, var: dive_count
5 : |  decl_scope  | type: int, var: dive_number_to_edit
6 : |  decl_scope  | type: logbook_type *, var: Info
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: dive_log_type *, value: Info -> dives
4 : | assign_scope | type: int, value: 1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = ['', '']
===> context { { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } return 0 ; }
ignore sibs: ['cgc_list_dives ( Info ) ;', '{ const char tlv1 [ ] = "\\n" ; cgc_printf ( tlv1 ) ; }', '{ const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }', '{ char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }', 'if ( rcv_cnt == 0 ) { return 0 ; }', '{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: logbook_type *, var: Info
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: rcv_cnt
4 : |  decl_scope  | type: dive_log_type *, var: next_dive
5 : |  decl_scope  | type: int, var: dive_count
6 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: dive_log_type *, value: next_dive
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; } ] 
p_decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None), ('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = ['', '']
===> context { const char tlv6 [ ] = "\n" ; cgc_printf ( tlv6 ) ; }
ignore sibs: ['{ const char tlv7 [ ] = "Dive Log is empty\\n" ; cgc_printf ( tlv7 ) ; }', 'return 0 ;', '}', 'cgc_list_dives ( Info ) ;', '{ const char tlv1 [ ] = "\\n" ; cgc_printf ( tlv1 ) ; }', '{ const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }', '{ char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }', 'if ( rcv_cnt == 0 ) { return 0 ; }', '{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: const char, var: tlv6 [ ]
2 : |  decl_scope  | type: logbook_type *, var: Info
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: rcv_cnt
6 : |  decl_scope  | type: dive_log_type *, var: next_dive
7 : |  decl_scope  | type: int, var: dive_count
8 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: dive_log_type *, value: next_dive
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; } ] 
p_decls = [('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
decls = [('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = ['', '']
decls = [('const char *', 'tlv7', ' [ ]'), ('const char', 'tlv7 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = ['', '']
===> context { const char tlv7 [ ] = "Dive Log is empty\n" ; cgc_printf ( tlv7 ) ; }
ignore sibs: ['return 0 ;', '}', 'cgc_list_dives ( Info ) ;', '{ const char tlv1 [ ] = "\\n" ; cgc_printf ( tlv1 ) ; }', '{ const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }', '{ char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }', 'if ( rcv_cnt == 0 ) { return 0 ; }', '{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv7
1 : |  decl_scope  | type: const char, var: tlv7 [ ]
2 : |  decl_scope  | type: logbook_type *, var: Info
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: rcv_cnt
6 : |  decl_scope  | type: dive_log_type *, var: next_dive
7 : |  decl_scope  | type: int, var: dive_count
8 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: dive_log_type *, value: next_dive
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; } ] 
p_decls = [('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
===> context { const char tlv1 [ ] = "\n" ; cgc_printf ( tlv1 ) ; }
ignore sibs: ['{ const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }', '{ char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }', 'if ( rcv_cnt == 0 ) { return 0 ; }', '{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv1
1 : |  decl_scope  | type: const char, var: tlv1 [ ]
2 : |  decl_scope  | type: logbook_type *, var: Info
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: rcv_cnt
6 : |  decl_scope  | type: dive_log_type *, var: next_dive
7 : |  decl_scope  | type: int, var: dive_count
8 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; } ] 
p_decls = [('const char *', 'tlv2', ' [ ]'), ('const char', 'tlv2 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv2', ' [ ]'), ('const char', 'tlv2 [ ]', None), ('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv2', ' [ ]'), ('const char', 'tlv2 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
===> context { const char tlv2 [ ] = "Enter Dive # to edit: " ; cgc_printf ( tlv2 ) ; }
ignore sibs: ['{ char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }', 'if ( rcv_cnt == 0 ) { return 0 ; }', '{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv2
1 : |  decl_scope  | type: const char, var: tlv2 [ ]
2 : |  decl_scope  | type: logbook_type *, var: Info
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: rcv_cnt
6 : |  decl_scope  | type: dive_log_type *, var: next_dive
7 : |  decl_scope  | type: int, var: dive_count
8 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; } ] 
p_decls = [('char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('logbook_type *', 'Info', None)]
assigns = [('char *', 'tlv4', '', 'buf'), ('cgc_size_t', 'tlv3', '', 'sizeof ( buf )')]
compares = []
decls = [('char *', 'tlv4', None), ('cgc_size_t', 'tlv3', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('char *', 'tlv4', '', 'buf'), ('cgc_size_t', 'tlv3', '', 'sizeof ( buf )'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
===> context { char * tlv4 ; tlv4 = buf ; cgc_size_t tlv3 ; tlv3 = sizeof ( buf ) ; rcv_cnt = cgc_getline ( tlv4 , tlv3 ) ; }
ignore sibs: ['if ( rcv_cnt == 0 ) { return 0 ; }', '{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv4
1 : |  decl_scope  | type: cgc_size_t, var: tlv3
2 : |  decl_scope  | type: logbook_type *, var: Info
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: rcv_cnt
6 : |  decl_scope  | type: dive_log_type *, var: next_dive
7 : |  decl_scope  | type: int, var: dive_count
8 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: cgc_size_t, value: sizeof ( buf )
2 : | assign_scope | type: dive_log_type *, value: Info -> dives
3 : | assign_scope | type: int, value: 1
4 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = ['', '']
===> context { return 0 ; }
ignore sibs: ['{ const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }', 'next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: logbook_type *, var: Info
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: rcv_cnt
4 : |  decl_scope  | type: dive_log_type *, var: next_dive
5 : |  decl_scope  | type: int, var: dive_count
6 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: rcv_cnt
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv5', None), ('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv5', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0')]
compares = []
===> context { const char * tlv5 = buf ; dive_number_to_edit = cgc_atoi ( tlv5 ) ; }
ignore sibs: ['next_dive = Info -> dives ;', 'dive_count = 1 ;', 'while ( dive_count < dive_number_to_edit && next_dive != 0 ) { ++ dive_count ; next_dive = next_dive -> next ; }', 'if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv5
1 : |  decl_scope  | type: logbook_type *, var: Info
2 : |  decl_scope  | type: char *, var: buf
3 : |  decl_scope  | type: char, var: buf [ 1024 ]
4 : |  decl_scope  | type: int, var: rcv_cnt
5 : |  decl_scope  | type: dive_log_type *, var: next_dive
6 : |  decl_scope  | type: int, var: dive_count
7 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ++ dive_count ; next_dive = next_dive -> next ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ++ dive_count ; next_dive = next_dive -> next ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('logbook_type *', 'Info', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'next_dive -> next')]
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'next_dive -> next'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'next_dive -> next'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = ['', '', '', '']
===> context { ++ dive_count ; next_dive = next_dive -> next ; }
ignore sibs: ['if ( dive_count == dive_number_to_edit && next_dive != 0 ) { cgc_printf ( "Editing dive number @d\\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } else { { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: logbook_type *, var: Info
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: rcv_cnt
4 : |  decl_scope  | type: dive_log_type *, var: next_dive
5 : |  decl_scope  | type: int, var: dive_count
6 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: next_dive -> next
1 : | assign_scope | type: dive_log_type *, value: Info -> dives
2 : | assign_scope | type: int, value: 1
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: dive_log_type *, value: Info -> dives
5 : | assign_scope | type: int, value: 1
0 : |compare_scopes| type: int, value: dive_count
1 : |compare_scopes| type: int, value: dive_number_to_edit
2 : |compare_scopes| type: dive_log_type *, value: next_dive
3 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = ['', '', '', '']
===> context { cgc_printf ( "Editing dive number @d\n" , dive_number_to_edit ) ; cgc_update_dive ( next_dive ) ; }
ignore sibs: ['else', '{ { const char tlv8 [ ] = "Invalid dive number entered\\n" ; cgc_printf ( tlv8 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: logbook_type *, var: Info
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: rcv_cnt
4 : |  decl_scope  | type: dive_log_type *, var: next_dive
5 : |  decl_scope  | type: int, var: dive_count
6 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: dive_log_type *, value: Info -> dives
4 : | assign_scope | type: int, value: 1
0 : |compare_scopes| type: int, value: dive_count
1 : |compare_scopes| type: int, value: dive_number_to_edit
2 : |compare_scopes| type: dive_log_type *, value: next_dive
3 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = []
===> context { { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: logbook_type *, var: Info
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: char, var: buf [ 1024 ]
3 : |  decl_scope  | type: int, var: rcv_cnt
4 : |  decl_scope  | type: dive_log_type *, var: next_dive
5 : |  decl_scope  | type: int, var: dive_count
6 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: dive_log_type *, value: Info -> dives
4 : | assign_scope | type: int, value: 1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; } ] 
p_decls = [('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('logbook_type *', 'Info', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = []
decls = [('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('logbook_type *', 'Info', None), ('char *', 'buf', ' [ 1024 ]'), ('char', 'buf [ 1024 ]', None), ('int', 'rcv_cnt', None), ('dive_log_type *', 'next_dive', None), ('int', 'dive_count', None), ('int', 'dive_number_to_edit', None)]
assigns = [('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1'), ('int', 'dive_number_to_edit', '', '0'), ('dive_log_type *', 'next_dive', '', 'Info -> dives'), ('int', 'dive_count', '', '1')]
compares = []
===> context { const char tlv8 [ ] = "Invalid dive number entered\n" ; cgc_printf ( tlv8 ) ; }
ignore sibs: ['}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv8
1 : |  decl_scope  | type: const char, var: tlv8 [ ]
2 : |  decl_scope  | type: logbook_type *, var: Info
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ 1024 ]
5 : |  decl_scope  | type: int, var: rcv_cnt
6 : |  decl_scope  | type: dive_log_type *, var: next_dive
7 : |  decl_scope  | type: int, var: dive_count
8 : |  decl_scope  | type: int, var: dive_number_to_edit
0 : | assign_scope | type: dive_log_type *, value: Info -> dives
1 : | assign_scope | type: int, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: dive_log_type *, value: Info -> dives
4 : | assign_scope | type: int, value: 1
=======END=======
compound scope 0 : { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; }
compound scope 1 : { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; }
compound scope 2 : { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; }
compound scope 3 : { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; }
compound scope 4 : { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; }
compound scope 5 : { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }
compound scope 6 : { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; }
compound scope 7 : { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }
compound scope 8 : { cgc_printf ( " (@s)" , dive -> dive_date ) ; }
compound scope 9 : { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }
compound scope 10 : { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }
compound scope 11 : { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }
compound scope 12 : { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; }
compound scope 13 : { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }
compound scope 14 : { cgc_printf ( " (@s)" , dive -> dive_time ) ; }
compound scope 15 : { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }
compound scope 16 : { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }
compound scope 17 : { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }
compound scope 18 : { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; }
compound scope 19 : { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }
compound scope 20 : { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }
compound scope 21 : { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; }
compound scope 22 : { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }
compound scope 23 : { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }
compound scope 24 : { cgc_printf ( " (@s)" , dive -> location ) ; }
compound scope 25 : { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }
compound scope 26 : { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }
compound scope 27 : { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }
compound scope 28 : { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; }
compound scope 29 : { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }
compound scope 30 : { cgc_printf ( " (@d)" , dive -> max_depth ) ; }
compound scope 31 : { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }
compound scope 32 : { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }
compound scope 33 : { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }
compound scope 34 : { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; }
compound scope 35 : { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }
compound scope 36 : { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }
compound scope 37 : { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }
compound scope 38 : { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }
compound scope 39 : { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }
compound scope 40 : { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; }
compound scope 41 : { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }
compound scope 42 : { cgc_printf ( " (@d)" , dive -> dive_length ) ; }
compound scope 43 : { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }
compound scope 44 : { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }
compound scope 45 : { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }
compound scope 46 : { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; }
compound scope 47 : { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }
compound scope 48 : { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }
compound scope 49 : { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }
compound scope 50 : { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }
compound scope 51 : { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }
compound scope 52 : { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; }
compound scope 53 : { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }
compound scope 54 : { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }
compound scope 55 : { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }
compound scope 56 : { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }
compound scope 57 : { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }
compound scope 58 : { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; }
compound scope 59 : { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }
compound scope 60 : { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }
compound scope 61 : { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }
compound scope 62 : { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }
compound scope 63 : { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }
compound scope 64 : { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; }
len(compound_scope) : 65
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; } ] 
p_decls = [('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
===> context { char buffer [ 1024 ] ; char buf2 [ 1024 ] ; cgc_size_t count ; { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; } { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; } { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } datetime_struct_type tm ; { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; } { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; } { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; } { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } return 0 ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buffer
1 : |  decl_scope  | type: char, var: buffer [ 1024 ]
2 : |  decl_scope  | type: char *, var: buf2
3 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
4 : |  decl_scope  | type: cgc_size_t, var: count
5 : |  decl_scope  | type: datetime_struct_type, var: tm
6 : |  decl_scope  | type: dive_log_type *, var: dive
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; } ] 
p_decls = [('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv1', ' [ ]'), ('const char', 'tlv1 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
===> context { const char tlv1 [ ] = "Dive Site" ; cgc_printf ( tlv1 ) ; }
ignore sibs: ['if ( dive -> dive_site_name [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; }', '{ const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; }', '{ char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; }', 'if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }', '{ const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }', 'if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv1
1 : |  decl_scope  | type: const char, var: tlv1 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@s)" , dive -> dive_site_name ) ; }
ignore sibs: ['{ const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; }', '{ char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; }', 'if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }', '{ const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }', 'if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
0 : |compare_scopes| type: dive_log_type *, value: dive -> dive_site_name [ 0 ]
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; } ] 
p_decls = [('const char *', 'tlv2', ' [ ]'), ('const char', 'tlv2 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv2', ' [ ]'), ('const char', 'tlv2 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv2', ' [ ]'), ('const char', 'tlv2 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
===> context { const char tlv2 [ ] = ": " ; cgc_printf ( tlv2 ) ; }
ignore sibs: ['{ char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; }', 'if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }', '{ const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }', 'if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv2
1 : |  decl_scope  | type: const char, var: tlv2 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; } ] 
p_decls = [('char *', 'tlv28', None), ('cgc_size_t', 'tlv27', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv28', None), ('cgc_size_t', 'tlv27', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv28', '', 'buffer'), ('cgc_size_t', 'tlv27', '', 'sizeof ( dive -> dive_site_name )')]
compares = []
decls = [('char *', 'tlv28', None), ('cgc_size_t', 'tlv27', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv28', '', 'buffer'), ('cgc_size_t', 'tlv27', '', 'sizeof ( dive -> dive_site_name )')]
compares = []
===> context { char * tlv28 ; tlv28 = buffer ; cgc_size_t tlv27 ; tlv27 = sizeof ( dive -> dive_site_name ) ; count = cgc_getline ( tlv28 , tlv27 ) ; }
ignore sibs: ['if ( count > 0 ) { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }', '{ const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }', 'if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv28
1 : |  decl_scope  | type: cgc_size_t, var: tlv27
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: sizeof ( dive -> dive_site_name )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = ['', '']
===> context { { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } }
ignore sibs: ['{ const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }', 'if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; } ] 
p_decls = [('char *', 'tlv51', None), ('const char *', 'tlv50', None), ('cgc_size_t', 'tlv49', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv51', None), ('const char *', 'tlv50', None), ('cgc_size_t', 'tlv49', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv51', '', 'dive -> dive_site_name'), ('cgc_size_t', 'tlv49', '', 'sizeof ( dive -> dive_site_name )')]
compares = []
decls = [('char *', 'tlv51', None), ('const char *', 'tlv50', None), ('cgc_size_t', 'tlv49', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv51', '', 'dive -> dive_site_name'), ('cgc_size_t', 'tlv49', '', 'sizeof ( dive -> dive_site_name )')]
compares = []
decls = [('char *', 'tlv51', None), ('const char *', 'tlv50', None), ('cgc_size_t', 'tlv49', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv51', '', 'dive -> dive_site_name'), ('cgc_size_t', 'tlv49', '', 'sizeof ( dive -> dive_site_name )')]
compares = ['', '']
decls = [('char *', 'tlv51', None), ('const char *', 'tlv50', None), ('cgc_size_t', 'tlv49', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv51', '', 'dive -> dive_site_name'), ('cgc_size_t', 'tlv49', '', 'sizeof ( dive -> dive_site_name )')]
compares = ['', '']
===> context { char * tlv51 ; tlv51 = dive -> dive_site_name ; const char * tlv50 = buffer ; cgc_size_t tlv49 ; tlv49 = sizeof ( dive -> dive_site_name ) ; cgc_strncpy ( tlv51 , tlv50 , tlv49 ) ; }
ignore sibs: ['}', '{ const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }', 'if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv51
1 : |  decl_scope  | type: const char *, var: tlv50
2 : |  decl_scope  | type: cgc_size_t, var: tlv49
3 : |  decl_scope  | type: dive_log_type *, var: dive
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: char, var: buffer [ 1024 ]
6 : |  decl_scope  | type: char *, var: buf2
7 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
8 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: dive -> dive_site_name
1 : | assign_scope | type: cgc_size_t, value: sizeof ( dive -> dive_site_name )
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; } ] 
p_decls = [('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv3', ' [ ]'), ('const char', 'tlv3 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
===> context { const char tlv3 [ ] = "Date" ; cgc_printf ( tlv3 ) ; }
ignore sibs: ['if ( dive -> dive_date [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_date ) ; }', '{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv3
1 : |  decl_scope  | type: const char, var: tlv3 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> dive_date ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> dive_date ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@s)" , dive -> dive_date ) ; }
ignore sibs: ['{ const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }', '{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
0 : |compare_scopes| type: dive_log_type *, value: dive -> dive_date [ 0 ]
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; } ] 
p_decls = [('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv4', ' [ ]'), ('const char', 'tlv4 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
===> context { const char tlv4 [ ] = ": " ; cgc_printf ( tlv4 ) ; }
ignore sibs: ['{ char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }', 'if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv4
1 : |  decl_scope  | type: const char, var: tlv4 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; } ] 
p_decls = [('char *', 'tlv30', None), ('cgc_size_t', 'tlv29', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv30', None), ('cgc_size_t', 'tlv29', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv30', '', 'buffer'), ('cgc_size_t', 'tlv29', '', 'sizeof ( dive -> dive_date )')]
compares = []
decls = [('char *', 'tlv30', None), ('cgc_size_t', 'tlv29', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv30', '', 'buffer'), ('cgc_size_t', 'tlv29', '', 'sizeof ( dive -> dive_date )')]
compares = []
===> context { char * tlv30 ; tlv30 = buffer ; cgc_size_t tlv29 ; tlv29 = sizeof ( dive -> dive_date ) ; count = cgc_getline ( tlv30 , tlv29 ) ; }
ignore sibs: ['if ( count > 0 ) { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv30
1 : |  decl_scope  | type: cgc_size_t, var: tlv29
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: sizeof ( dive -> dive_date )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = ['', '']
===> context { { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } }
ignore sibs: ['{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; } ] 
p_decls = [('char *', 'tlv54', None), ('const char *', 'tlv53', None), ('cgc_size_t', 'tlv52', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv54', None), ('const char *', 'tlv53', None), ('cgc_size_t', 'tlv52', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv54', '', 'dive -> dive_date'), ('cgc_size_t', 'tlv52', '', 'sizeof ( dive -> dive_date )')]
compares = []
decls = [('char *', 'tlv54', None), ('const char *', 'tlv53', None), ('cgc_size_t', 'tlv52', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv54', '', 'dive -> dive_date'), ('cgc_size_t', 'tlv52', '', 'sizeof ( dive -> dive_date )')]
compares = []
decls = [('char *', 'tlv54', None), ('const char *', 'tlv53', None), ('cgc_size_t', 'tlv52', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv54', '', 'dive -> dive_date'), ('cgc_size_t', 'tlv52', '', 'sizeof ( dive -> dive_date )')]
compares = ['', '']
decls = [('char *', 'tlv54', None), ('const char *', 'tlv53', None), ('cgc_size_t', 'tlv52', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv54', '', 'dive -> dive_date'), ('cgc_size_t', 'tlv52', '', 'sizeof ( dive -> dive_date )')]
compares = ['', '']
===> context { char * tlv54 ; tlv54 = dive -> dive_date ; const char * tlv53 = buffer ; cgc_size_t tlv52 ; tlv52 = sizeof ( dive -> dive_date ) ; cgc_strncpy ( tlv54 , tlv53 , tlv52 ) ; }
ignore sibs: ['}', '{ const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }', 'if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv54
1 : |  decl_scope  | type: const char *, var: tlv53
2 : |  decl_scope  | type: cgc_size_t, var: tlv52
3 : |  decl_scope  | type: dive_log_type *, var: dive
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: char, var: buffer [ 1024 ]
6 : |  decl_scope  | type: char *, var: buf2
7 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
8 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: dive -> dive_date
1 : | assign_scope | type: cgc_size_t, value: sizeof ( dive -> dive_date )
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; } ] 
p_decls = [('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv5', ' [ ]'), ('const char', 'tlv5 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
===> context { const char tlv5 [ ] = "Time" ; cgc_printf ( tlv5 ) ; }
ignore sibs: ['if ( dive -> dive_time [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> dive_time ) ; }', '{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv5
1 : |  decl_scope  | type: const char, var: tlv5 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> dive_time ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> dive_time ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@s)" , dive -> dive_time ) ; }
ignore sibs: ['{ const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }', '{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
0 : |compare_scopes| type: dive_log_type *, value: dive -> dive_time [ 0 ]
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; } ] 
p_decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv6', ' [ ]'), ('const char', 'tlv6 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
===> context { const char tlv6 [ ] = ": " ; cgc_printf ( tlv6 ) ; }
ignore sibs: ['{ char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }', 'if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv6
1 : |  decl_scope  | type: const char, var: tlv6 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; } ] 
p_decls = [('char *', 'tlv32', None), ('cgc_size_t', 'tlv31', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv32', None), ('cgc_size_t', 'tlv31', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv32', '', 'buf2'), ('cgc_size_t', 'tlv31', '', 'sizeof ( dive -> dive_time )')]
compares = []
decls = [('char *', 'tlv32', None), ('cgc_size_t', 'tlv31', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv32', '', 'buf2'), ('cgc_size_t', 'tlv31', '', 'sizeof ( dive -> dive_time )')]
compares = []
===> context { char * tlv32 ; tlv32 = buf2 ; cgc_size_t tlv31 ; tlv31 = sizeof ( dive -> dive_time ) ; count = cgc_getline ( tlv32 , tlv31 ) ; }
ignore sibs: ['if ( count > 0 ) { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv32
1 : |  decl_scope  | type: cgc_size_t, var: tlv31
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: buf2
1 : | assign_scope | type: cgc_size_t, value: sizeof ( dive -> dive_time )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = []
compares = ['', '']
===> context { { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } }
ignore sibs: ['{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; } ] 
p_decls = [('char *', 'tlv57', None), ('const char *', 'tlv56', None), ('cgc_size_t', 'tlv55', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv57', None), ('const char *', 'tlv56', None), ('cgc_size_t', 'tlv55', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv57', '', 'dive -> dive_time'), ('cgc_size_t', 'tlv55', '', 'sizeof ( dive -> dive_time )')]
compares = []
decls = [('char *', 'tlv57', None), ('const char *', 'tlv56', None), ('cgc_size_t', 'tlv55', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv57', '', 'dive -> dive_time'), ('cgc_size_t', 'tlv55', '', 'sizeof ( dive -> dive_time )')]
compares = []
decls = [('char *', 'tlv57', None), ('const char *', 'tlv56', None), ('cgc_size_t', 'tlv55', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv57', '', 'dive -> dive_time'), ('cgc_size_t', 'tlv55', '', 'sizeof ( dive -> dive_time )')]
compares = ['', '']
decls = [('char *', 'tlv57', None), ('const char *', 'tlv56', None), ('cgc_size_t', 'tlv55', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv57', '', 'dive -> dive_time'), ('cgc_size_t', 'tlv55', '', 'sizeof ( dive -> dive_time )')]
compares = ['', '']
===> context { char * tlv57 ; tlv57 = dive -> dive_time ; const char * tlv56 = buf2 ; cgc_size_t tlv55 ; tlv55 = sizeof ( dive -> dive_time ) ; cgc_strncpy ( tlv57 , tlv56 , tlv55 ) ; }
ignore sibs: ['}', '{ char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }', '{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv57
1 : |  decl_scope  | type: const char *, var: tlv56
2 : |  decl_scope  | type: cgc_size_t, var: tlv55
3 : |  decl_scope  | type: dive_log_type *, var: dive
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: char, var: buffer [ 1024 ]
6 : |  decl_scope  | type: char *, var: buf2
7 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
8 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: dive -> dive_time
1 : | assign_scope | type: cgc_size_t, value: sizeof ( dive -> dive_time )
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; } ] 
p_decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv9', '', 'buffer'), ('cgc_size_t', 'tlv7', '', '1')]
compares = []
decls = [('char *', 'tlv9', None), ('const char *', 'tlv8', ' [ ]'), ('const char', 'tlv8 [ ]', None), ('cgc_size_t', 'tlv7', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv9', '', 'buffer'), ('cgc_size_t', 'tlv7', '', '1')]
compares = []
===> context { char * tlv9 ; tlv9 = buffer ; const char tlv8 [ ] = " " ; cgc_size_t tlv7 ; tlv7 = 1 ; cgc_strncat ( tlv9 , tlv8 , tlv7 ) ; }
ignore sibs: ['{ char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv9
1 : |  decl_scope  | type: const char *, var: tlv8
2 : |  decl_scope  | type: const char, var: tlv8 [ ]
3 : |  decl_scope  | type: cgc_size_t, var: tlv7
4 : |  decl_scope  | type: dive_log_type *, var: dive
5 : |  decl_scope  | type: char *, var: buffer
6 : |  decl_scope  | type: char, var: buffer [ 1024 ]
7 : |  decl_scope  | type: char *, var: buf2
8 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
9 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 1
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; } ] 
p_decls = [('char *', 'tlv12', None), ('const char *', 'tlv11', None), ('cgc_size_t', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv12', None), ('const char *', 'tlv11', None), ('cgc_size_t', 'tlv10', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv12', '', 'buffer')]
compares = []
decls = [('char *', 'tlv12', None), ('const char *', 'tlv11', None), ('cgc_size_t', 'tlv10', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv12', '', 'buffer')]
compares = []
===> context { char * tlv12 ; tlv12 = buffer ; const char * tlv11 = buf2 ; cgc_size_t tlv10 ; { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } cgc_strncat ( tlv12 , tlv11 , tlv10 ) ; }
ignore sibs: ['datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv12
1 : |  decl_scope  | type: const char *, var: tlv11
2 : |  decl_scope  | type: cgc_size_t, var: tlv10
3 : |  decl_scope  | type: dive_log_type *, var: dive
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: char, var: buffer [ 1024 ]
6 : |  decl_scope  | type: char *, var: buf2
7 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
8 : |  decl_scope  | type: cgc_size_t, var: count
0 : | assign_scope | type: char *, value: buffer
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; } ] 
p_decls = [('char *', 'tlv67', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv67', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv67', '', 'buf2'), ('cgc_size_t', 'tlv10', '', 'cgc_strlen ( tlv67 )')]
compares = []
decls = [('char *', 'tlv67', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None)]
assigns = [('char *', 'tlv67', '', 'buf2'), ('cgc_size_t', 'tlv10', '', 'cgc_strlen ( tlv67 )')]
compares = []
decls = [('char *', 'tlv67', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('char *', 'tlv12', None), ('const char *', 'tlv11', None), ('cgc_size_t', 'tlv10', None)]
assigns = [('char *', 'tlv67', '', 'buf2'), ('cgc_size_t', 'tlv10', '', 'cgc_strlen ( tlv67 )'), ('char *', 'tlv12', '', 'buffer')]
compares = []
===> context { char * tlv67 ; tlv67 = buf2 ; tlv10 = cgc_strlen ( tlv67 ) ; }
ignore sibs: ['cgc_strncat ( tlv12 , tlv11 , tlv10 ) ;', '}', 'datetime_struct_type tm ;', '{ char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }', '{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv67
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: char *, var: tlv12
8 : |  decl_scope  | type: const char *, var: tlv11
9 : |  decl_scope  | type: cgc_size_t, var: tlv10
0 : | assign_scope | type: char *, value: buf2
1 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv67 )
2 : | assign_scope | type: char *, value: buffer
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; } ] 
p_decls = [('char *', 'tlv34', None), ('datetime_struct_type *', 'tlv33', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv34', None), ('datetime_struct_type *', 'tlv33', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv34', '', 'buffer'), ('datetime_struct_type *', 'tlv33', '', '& tm')]
compares = []
decls = [('char *', 'tlv34', None), ('datetime_struct_type *', 'tlv33', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv34', '', 'buffer'), ('datetime_struct_type *', 'tlv33', '', '& tm')]
compares = []
===> context { char * tlv34 ; tlv34 = buffer ; datetime_struct_type * tlv33 ; tlv33 = & tm ; dive -> timestamp = cgc_str2datetime ( tlv34 , tlv33 ) ; }
ignore sibs: ['{ const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }', 'if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv34
1 : |  decl_scope  | type: datetime_struct_type *, var: tlv33
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: datetime_struct_type *, value: & tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; } ] 
p_decls = [('const char *', 'tlv13', ' [ ]'), ('const char', 'tlv13 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv13', ' [ ]'), ('const char', 'tlv13 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv13', ' [ ]'), ('const char', 'tlv13 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv13 [ ] = "Location (area/city)" ; cgc_printf ( tlv13 ) ; }
ignore sibs: ['if ( dive -> location [ 0 ] != 0 ) { cgc_printf ( " (@s)" , dive -> location ) ; }', '{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv13
1 : |  decl_scope  | type: const char, var: tlv13 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> location ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@s)" , dive -> location ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@s)" , dive -> location ) ; }
ignore sibs: ['{ const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }', '{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> location [ 0 ]
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; } ] 
p_decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv14', ' [ ]'), ('const char', 'tlv14 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv14 [ ] = ": " ; cgc_printf ( tlv14 ) ; }
ignore sibs: ['{ char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }', 'if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv14
1 : |  decl_scope  | type: const char, var: tlv14 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; } ] 
p_decls = [('char *', 'tlv36', None), ('cgc_size_t', 'tlv35', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv36', None), ('cgc_size_t', 'tlv35', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv36', '', 'buffer'), ('cgc_size_t', 'tlv35', '', 'sizeof ( buffer )')]
compares = []
decls = [('char *', 'tlv36', None), ('cgc_size_t', 'tlv35', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv36', '', 'buffer'), ('cgc_size_t', 'tlv35', '', 'sizeof ( buffer )')]
compares = []
===> context { char * tlv36 ; tlv36 = buffer ; cgc_size_t tlv35 ; tlv35 = sizeof ( buffer ) ; count = cgc_getline ( tlv36 , tlv35 ) ; }
ignore sibs: ['if ( count > 0 ) { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv36
1 : |  decl_scope  | type: cgc_size_t, var: tlv35
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: sizeof ( buffer )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } }
ignore sibs: ['{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; } ] 
p_decls = [('char *', 'tlv60', None), ('const char *', 'tlv59', None), ('cgc_size_t', 'tlv58', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv60', None), ('const char *', 'tlv59', None), ('cgc_size_t', 'tlv58', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv60', '', 'dive -> location'), ('cgc_size_t', 'tlv58', '', 'count')]
compares = []
decls = [('char *', 'tlv60', None), ('const char *', 'tlv59', None), ('cgc_size_t', 'tlv58', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv60', '', 'dive -> location'), ('cgc_size_t', 'tlv58', '', 'count')]
compares = []
decls = [('char *', 'tlv60', None), ('const char *', 'tlv59', None), ('cgc_size_t', 'tlv58', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv60', '', 'dive -> location'), ('cgc_size_t', 'tlv58', '', 'count')]
compares = ['', '']
decls = [('char *', 'tlv60', None), ('const char *', 'tlv59', None), ('cgc_size_t', 'tlv58', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv60', '', 'dive -> location'), ('cgc_size_t', 'tlv58', '', 'count')]
compares = ['', '']
===> context { char * tlv60 ; tlv60 = dive -> location ; const char * tlv59 = buffer ; cgc_size_t tlv58 ; tlv58 = count ; cgc_strncpy ( tlv60 , tlv59 , tlv58 ) ; }
ignore sibs: ['}', '{ const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }', 'if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv60
1 : |  decl_scope  | type: const char *, var: tlv59
2 : |  decl_scope  | type: cgc_size_t, var: tlv58
3 : |  decl_scope  | type: dive_log_type *, var: dive
4 : |  decl_scope  | type: char *, var: buffer
5 : |  decl_scope  | type: char, var: buffer [ 1024 ]
6 : |  decl_scope  | type: char *, var: buf2
7 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
8 : |  decl_scope  | type: cgc_size_t, var: count
9 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: dive -> location
1 : | assign_scope | type: cgc_size_t, value: count
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; } ] 
p_decls = [('const char *', 'tlv15', ' [ ]'), ('const char', 'tlv15 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv15', ' [ ]'), ('const char', 'tlv15 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv15', ' [ ]'), ('const char', 'tlv15 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv15 [ ] = "Max Depth in ft" ; cgc_printf ( tlv15 ) ; }
ignore sibs: ['if ( dive -> max_depth != 0 ) { cgc_printf ( " (@d)" , dive -> max_depth ) ; }', '{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv15
1 : |  decl_scope  | type: const char, var: tlv15 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> max_depth ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> max_depth ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@d)" , dive -> max_depth ) ; }
ignore sibs: ['{ const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }', '{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> max_depth
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; } ] 
p_decls = [('const char *', 'tlv16', ' [ ]'), ('const char', 'tlv16 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv16', ' [ ]'), ('const char', 'tlv16 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv16', ' [ ]'), ('const char', 'tlv16 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv16 [ ] = ": " ; cgc_printf ( tlv16 ) ; }
ignore sibs: ['{ char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }', 'if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv16
1 : |  decl_scope  | type: const char, var: tlv16 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; } ] 
p_decls = [('char *', 'tlv38', None), ('cgc_size_t', 'tlv37', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv38', None), ('cgc_size_t', 'tlv37', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv38', '', 'buffer'), ('cgc_size_t', 'tlv37', '', 'sizeof ( buffer )')]
compares = []
decls = [('char *', 'tlv38', None), ('cgc_size_t', 'tlv37', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv38', '', 'buffer'), ('cgc_size_t', 'tlv37', '', 'sizeof ( buffer )')]
compares = []
===> context { char * tlv38 ; tlv38 = buffer ; cgc_size_t tlv37 ; tlv37 = sizeof ( buffer ) ; count = cgc_getline ( tlv38 , tlv37 ) ; }
ignore sibs: ['if ( count > 0 ) { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv38
1 : |  decl_scope  | type: cgc_size_t, var: tlv37
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: sizeof ( buffer )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } }
ignore sibs: ['{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; } ] 
p_decls = [('const char *', 'tlv61', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv61', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv61', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv61', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv61', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { const char * tlv61 = buffer ; dive -> max_depth = cgc_atoi ( tlv61 ) ; }
ignore sibs: ['}', '{ const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }', 'if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv61
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; } ] 
p_decls = [('const char *', 'tlv17', ' [ ]'), ('const char', 'tlv17 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv17', ' [ ]'), ('const char', 'tlv17 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv17', ' [ ]'), ('const char', 'tlv17 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv17 [ ] = "Avg Depth in ft" ; cgc_printf ( tlv17 ) ; }
ignore sibs: ['if ( dive -> avg_depth != 0 ) { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }', '{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv17
1 : |  decl_scope  | type: const char, var: tlv17 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> avg_depth ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@d)" , dive -> avg_depth ) ; }
ignore sibs: ['{ const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }', '{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> avg_depth
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; } ] 
p_decls = [('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv18', ' [ ]'), ('const char', 'tlv18 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv18 [ ] = ": " ; cgc_printf ( tlv18 ) ; }
ignore sibs: ['{ char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }', 'if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv18
1 : |  decl_scope  | type: const char, var: tlv18 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; } ] 
p_decls = [('char *', 'tlv40', None), ('cgc_size_t', 'tlv39', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv40', None), ('cgc_size_t', 'tlv39', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv40', '', 'buffer'), ('cgc_size_t', 'tlv39', '', 'sizeof ( buffer )')]
compares = []
decls = [('char *', 'tlv40', None), ('cgc_size_t', 'tlv39', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv40', '', 'buffer'), ('cgc_size_t', 'tlv39', '', 'sizeof ( buffer )')]
compares = []
===> context { char * tlv40 ; tlv40 = buffer ; cgc_size_t tlv39 ; tlv39 = sizeof ( buffer ) ; count = cgc_getline ( tlv40 , tlv39 ) ; }
ignore sibs: ['if ( count > 0 ) { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv40
1 : |  decl_scope  | type: cgc_size_t, var: tlv39
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: sizeof ( buffer )
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } }
ignore sibs: ['{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; } ] 
p_decls = [('const char *', 'tlv62', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv62', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv62', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv62', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv62', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { const char * tlv62 = buffer ; dive -> avg_depth = cgc_atoi ( tlv62 ) ; }
ignore sibs: ['}', '{ const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }', 'if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv62
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; } ] 
p_decls = [('const char *', 'tlv19', ' [ ]'), ('const char', 'tlv19 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv19', ' [ ]'), ('const char', 'tlv19 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv19', ' [ ]'), ('const char', 'tlv19 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv19 [ ] = "Dive Duration (mins)" ; cgc_printf ( tlv19 ) ; }
ignore sibs: ['if ( dive -> dive_length != 0 ) { cgc_printf ( " (@d)" , dive -> dive_length ) ; }', '{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv19
1 : |  decl_scope  | type: const char, var: tlv19 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> dive_length ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> dive_length ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@d)" , dive -> dive_length ) ; }
ignore sibs: ['{ const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }', '{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> dive_length
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; } ] 
p_decls = [('const char *', 'tlv20', ' [ ]'), ('const char', 'tlv20 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv20', ' [ ]'), ('const char', 'tlv20 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv20', ' [ ]'), ('const char', 'tlv20 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv20 [ ] = ": " ; cgc_printf ( tlv20 ) ; }
ignore sibs: ['{ char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }', 'if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv20
1 : |  decl_scope  | type: const char, var: tlv20 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; } ] 
p_decls = [('char *', 'tlv42', None), ('cgc_size_t', 'tlv41', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv42', None), ('cgc_size_t', 'tlv41', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv42', '', 'buffer'), ('cgc_size_t', 'tlv41', '', '13')]
compares = []
decls = [('char *', 'tlv42', None), ('cgc_size_t', 'tlv41', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv42', '', 'buffer'), ('cgc_size_t', 'tlv41', '', '13')]
compares = []
===> context { char * tlv42 ; tlv42 = buffer ; cgc_size_t tlv41 ; tlv41 = 13 ; count = cgc_getline ( tlv42 , tlv41 ) ; }
ignore sibs: ['if ( count > 0 ) { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv42
1 : |  decl_scope  | type: cgc_size_t, var: tlv41
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 13
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } }
ignore sibs: ['{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; } ] 
p_decls = [('const char *', 'tlv63', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv63', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv63', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv63', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv63', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { const char * tlv63 = buffer ; dive -> dive_length = cgc_atoi ( tlv63 ) ; }
ignore sibs: ['}', '{ const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }', 'if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv63
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; } ] 
p_decls = [('const char *', 'tlv21', ' [ ]'), ('const char', 'tlv21 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv21', ' [ ]'), ('const char', 'tlv21 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv21', ' [ ]'), ('const char', 'tlv21 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv21 [ ] = "O2 Percentage" ; cgc_printf ( tlv21 ) ; }
ignore sibs: ['if ( dive -> O2_percent != 0 ) { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }', '{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv21
1 : |  decl_scope  | type: const char, var: tlv21 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> O2_percent ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@d)" , dive -> O2_percent ) ; }
ignore sibs: ['{ const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }', '{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> O2_percent
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; } ] 
p_decls = [('const char *', 'tlv22', ' [ ]'), ('const char', 'tlv22 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv22', ' [ ]'), ('const char', 'tlv22 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv22', ' [ ]'), ('const char', 'tlv22 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv22 [ ] = ": " ; cgc_printf ( tlv22 ) ; }
ignore sibs: ['{ char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }', 'if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv22
1 : |  decl_scope  | type: const char, var: tlv22 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; } ] 
p_decls = [('char *', 'tlv44', None), ('cgc_size_t', 'tlv43', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv44', None), ('cgc_size_t', 'tlv43', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv44', '', 'buffer'), ('cgc_size_t', 'tlv43', '', '11')]
compares = []
decls = [('char *', 'tlv44', None), ('cgc_size_t', 'tlv43', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv44', '', 'buffer'), ('cgc_size_t', 'tlv43', '', '11')]
compares = []
===> context { char * tlv44 ; tlv44 = buffer ; cgc_size_t tlv43 ; tlv43 = 11 ; count = cgc_getline ( tlv44 , tlv43 ) ; }
ignore sibs: ['if ( count > 0 ) { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv44
1 : |  decl_scope  | type: cgc_size_t, var: tlv43
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 11
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } }
ignore sibs: ['{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; } ] 
p_decls = [('const char *', 'tlv64', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv64', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv64', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv64', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv64', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { const char * tlv64 = buffer ; dive -> O2_percent = cgc_atoi ( tlv64 ) ; }
ignore sibs: ['}', '{ const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }', 'if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv64
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; } ] 
p_decls = [('const char *', 'tlv23', ' [ ]'), ('const char', 'tlv23 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv23', ' [ ]'), ('const char', 'tlv23 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv23', ' [ ]'), ('const char', 'tlv23 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv23 [ ] = "Pressure In (psi)" ; cgc_printf ( tlv23 ) ; }
ignore sibs: ['if ( dive -> pressure_in != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }', '{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv23
1 : |  decl_scope  | type: const char, var: tlv23 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> pressure_in ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@d)" , dive -> pressure_in ) ; }
ignore sibs: ['{ const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }', '{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> pressure_in
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; } ] 
p_decls = [('const char *', 'tlv24', ' [ ]'), ('const char', 'tlv24 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv24', ' [ ]'), ('const char', 'tlv24 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv24', ' [ ]'), ('const char', 'tlv24 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv24 [ ] = ": " ; cgc_printf ( tlv24 ) ; }
ignore sibs: ['{ char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }', 'if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv24
1 : |  decl_scope  | type: const char, var: tlv24 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; } ] 
p_decls = [('char *', 'tlv46', None), ('cgc_size_t', 'tlv45', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv46', None), ('cgc_size_t', 'tlv45', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv46', '', 'buffer'), ('cgc_size_t', 'tlv45', '', '20')]
compares = []
decls = [('char *', 'tlv46', None), ('cgc_size_t', 'tlv45', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv46', '', 'buffer'), ('cgc_size_t', 'tlv45', '', '20')]
compares = []
===> context { char * tlv46 ; tlv46 = buffer ; cgc_size_t tlv45 ; tlv45 = 20 ; count = cgc_getline ( tlv46 , tlv45 ) ; }
ignore sibs: ['if ( count > 0 ) { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv46
1 : |  decl_scope  | type: cgc_size_t, var: tlv45
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 20
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } }
ignore sibs: ['{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; } ] 
p_decls = [('const char *', 'tlv65', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv65', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv65', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv65', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv65', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { const char * tlv65 = buffer ; dive -> pressure_in = cgc_atoi ( tlv65 ) ; }
ignore sibs: ['}', '{ const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }', 'if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv65
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; } ] 
p_decls = [('const char *', 'tlv25', ' [ ]'), ('const char', 'tlv25 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv25', ' [ ]'), ('const char', 'tlv25 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv25', ' [ ]'), ('const char', 'tlv25 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv25 [ ] = "Pressure Out (psi)" ; cgc_printf ( tlv25 ) ; }
ignore sibs: ['if ( dive -> pressure_out != 0 ) { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }', '{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv25
1 : |  decl_scope  | type: const char, var: tlv25 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_printf ( " (@d)" , dive -> pressure_out ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { cgc_printf ( " (@d)" , dive -> pressure_out ) ; }
ignore sibs: ['{ const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }', '{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: dive_log_type *, value: dive -> pressure_out
1 : |compare_scopes| type: dive_log_type *, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; } ] 
p_decls = [('const char *', 'tlv26', ' [ ]'), ('const char', 'tlv26 [ ]', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv26', ' [ ]'), ('const char', 'tlv26 [ ]', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv26', ' [ ]'), ('const char', 'tlv26 [ ]', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
===> context { const char tlv26 [ ] = ": " ; cgc_printf ( tlv26 ) ; }
ignore sibs: ['{ char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }', 'if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv26
1 : |  decl_scope  | type: const char, var: tlv26 [ ]
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; } ] 
p_decls = [('char *', 'tlv48', None), ('cgc_size_t', 'tlv47', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv48', None), ('cgc_size_t', 'tlv47', None), ('dive_log_type *', 'dive', None)]
assigns = [('char *', 'tlv48', '', 'buffer'), ('cgc_size_t', 'tlv47', '', '11')]
compares = []
decls = [('char *', 'tlv48', None), ('cgc_size_t', 'tlv47', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = [('char *', 'tlv48', '', 'buffer'), ('cgc_size_t', 'tlv47', '', '11')]
compares = []
===> context { char * tlv48 ; tlv48 = buffer ; cgc_size_t tlv47 ; tlv47 = 11 ; count = cgc_getline ( tlv48 , tlv47 ) ; }
ignore sibs: ['if ( count > 0 ) { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }', 'return 0 ;', '}']
0 : |  decl_scope  | type: char *, var: tlv48
1 : |  decl_scope  | type: cgc_size_t, var: tlv47
2 : |  decl_scope  | type: dive_log_type *, var: dive
3 : |  decl_scope  | type: char *, var: buffer
4 : |  decl_scope  | type: char, var: buffer [ 1024 ]
5 : |  decl_scope  | type: char *, var: buf2
6 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
7 : |  decl_scope  | type: cgc_size_t, var: count
8 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : | assign_scope | type: char *, value: buffer
1 : | assign_scope | type: cgc_size_t, value: 11
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } }
ignore sibs: ['return 0 ;', '}']
0 : |  decl_scope  | type: dive_log_type *, var: dive
1 : |  decl_scope  | type: char *, var: buffer
2 : |  decl_scope  | type: char, var: buffer [ 1024 ]
3 : |  decl_scope  | type: char *, var: buf2
4 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
5 : |  decl_scope  | type: cgc_size_t, var: count
6 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; } ] 
p_decls = [('const char *', 'tlv66', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('const char *', 'tlv66', None), ('dive_log_type *', 'dive', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv66', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = []
decls = [('const char *', 'tlv66', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
decls = [('const char *', 'tlv66', None), ('dive_log_type *', 'dive', None), ('char *', 'buffer', ' [ 1024 ]'), ('char', 'buffer [ 1024 ]', None), ('char *', 'buf2', ' [ 1024 ]'), ('char', 'buf2 [ 1024 ]', None), ('cgc_size_t', 'count', None), ('datetime_struct_type', 'tm', None)]
assigns = []
compares = ['', '']
===> context { const char * tlv66 = buffer ; dive -> pressure_out = cgc_atoi ( tlv66 ) ; }
ignore sibs: ['}', 'return 0 ;', '}']
0 : |  decl_scope  | type: const char *, var: tlv66
1 : |  decl_scope  | type: dive_log_type *, var: dive
2 : |  decl_scope  | type: char *, var: buffer
3 : |  decl_scope  | type: char, var: buffer [ 1024 ]
4 : |  decl_scope  | type: char *, var: buf2
5 : |  decl_scope  | type: char, var: buf2 [ 1024 ]
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: datetime_struct_type, var: tm
0 : |compare_scopes| type: cgc_size_t, value: count
1 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
def_vars[0]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : char buf [ 1024 ] ;
def_vars[1]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : int rcv_cnt ;
def_vars[2]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : dive_log_type * next_dive ;
def_vars[3]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : int dive_count ;
def_vars[4]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : int dive_number_to_edit ;
def_vars[5]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_list_dives ( Info ) ;
def_vars[6]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "\n" ;
def_vars[7]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv1 ) ;
def_vars[8]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : const char tlv2 [ ] = "Enter Dive # to edit: " ;
def_vars[9]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv2 ) ;
def_vars[10]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : char * tlv4 ;
def_vars[11]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[12]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv5 = buf ;
def_vars[13]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_update_dive ( next_dive ) ;
def_vars[14]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : const char tlv6 [ ] = "\n" ;
def_vars[15]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv6 ) ;
def_vars[16]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : const char tlv7 [ ] = "Dive Log is empty\n" ;
def_vars[17]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv7 ) ;
def_vars[18]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : const char tlv8 [ ] = "Invalid dive number entered\n" ;
def_vars[19]: [cgc_edit_dives] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv8 ) ;
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59981ecf8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ac6a58>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/2][j=0/13][dd=0/20][k=1/5] | type: int ; var : dive_count ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/2][j=0/13][dd=0/20][k=2/5] | type: int ; var : dive_number_to_edit ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/2][j=0/13][dd=1/20][k=1/5] | type: int ; var : dive_count ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/2][j=0/13][dd=1/20][k=2/5] | type: int ; var : dive_number_to_edit ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/2][j=0/13][dd=3/20][k=1/5] | type: int ; var : dive_count ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/2][j=0/13][dd=3/20][k=2/5] | type: int ; var : dive_number_to_edit ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/2][j=0/13][dd=4/20][k=1/5] | type: int ; var : dive_count ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/2][j=0/13][dd=4/20][k=2/5] | type: int ; var : dive_number_to_edit ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/2][j=0/13][dd=7/20][k=1/5] | type: int ; var : dive_count ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/2][j=0/13][dd=7/20][k=2/5] | type: int ; var : dive_number_to_edit ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=0/2][j=0/13][dd=8/20][k=1/5] | type: int ; var : dive_count ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/2][j=0/13][dd=8/20][k=2/5] | type: int ; var : dive_number_to_edit ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_edit_dives_0_0_1(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(1); }
    {int rcv_cnt; rcv_cnt = (int)(1); }
    {int dive_count; dive_count = (int)(1); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(1); }
    {char * tlv4; tlv4 = (char *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
}
void fix_ingred_edit_dives_0_0_2(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(0); }
    {int rcv_cnt; rcv_cnt = (int)(0); }
    {int dive_count; dive_count = (int)(0); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(0); }
    {char * tlv4; tlv4 = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
}
void fix_ingred_edit_dives_0_0(){
fix_ingred_edit_dives_0_0_1();
fix_ingred_edit_dives_0_0_2();
}

sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598daac88>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598c53518>)]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598daac88>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598c53518>)]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv7': 'const char *', 'tlv7 [ ]': 'const char'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598daac88>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598c53518>)]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59884ab38>), ('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5990385f8>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/2][j=6/13][dd=0/20][k=0/5] | type: char * ; var : tlv4 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
unique : ('char', 'buf [ 1024 ]', None)
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)' - False OR  False
[i=0/2][j=6/13][dd=0/20][k=1/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/2][j=6/13][dd=1/20][k=0/5] | type: char * ; var : tlv4 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)' - False OR  False
[i=0/2][j=6/13][dd=1/20][k=1/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/2][j=6/13][dd=3/20][k=0/5] | type: char * ; var : tlv4 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)' - False OR  False
[i=0/2][j=6/13][dd=3/20][k=1/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/2][j=6/13][dd=4/20][k=0/5] | type: char * ; var : tlv4 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)' - False OR  False
[i=0/2][j=6/13][dd=4/20][k=1/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/2][j=6/13][dd=7/20][k=0/5] | type: char * ; var : tlv4 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)' - False OR  False
[i=0/2][j=6/13][dd=7/20][k=1/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=0/2][j=6/13][dd=8/20][k=0/5] | type: char * ; var : tlv4 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buf)' - False OR  False
[i=0/2][j=6/13][dd=8/20][k=1/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buf,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ 1024 ] => char [size=1024]
not unique: ('char', 'buf [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

----
UNIQ_INIT: ('char','buf [ 1024 ]','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_0_6_0(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(buf); }
    {int rcv_cnt; rcv_cnt = (int)(buf); }
    {int dive_count; dive_count = (int)(buf); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(buf); }
    {char * tlv4; tlv4 = (char *)(buf); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(buf); }
}
void fix_ingred_edit_dives_0_6_1(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(sizeof ( buf )); }
    {int rcv_cnt; rcv_cnt = (int)(sizeof ( buf )); }
    {int dive_count; dive_count = (int)(sizeof ( buf )); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(sizeof ( buf )); }
    {char * tlv4; tlv4 = (char *)(sizeof ( buf )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( buf )); }
}
void fix_ingred_edit_dives_0_6(){
fix_ingred_edit_dives_0_6_0();
fix_ingred_edit_dives_0_6_1();
}

sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a599116c18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598a96748>)]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rcv_cnt' - False OR  False
[i=0/2][j=7/13][dd=0/20][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : rcv_cnt (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rcv_cnt
 => is literal (False) | is operator (False) rcv_cnt [vtype=int]
unique : ('int', 'rcv_cnt', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rcv_cnt' - False OR  False
[i=0/2][j=7/13][dd=1/20][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : rcv_cnt (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rcv_cnt
 => is literal (False) | is operator (False) rcv_cnt [vtype=int]
not unique: ('int', 'rcv_cnt', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rcv_cnt' - False OR  False
[i=0/2][j=7/13][dd=3/20][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : rcv_cnt (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rcv_cnt
 => is literal (False) | is operator (False) rcv_cnt [vtype=int]
not unique: ('int', 'rcv_cnt', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rcv_cnt' - False OR  False
[i=0/2][j=7/13][dd=4/20][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : rcv_cnt (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rcv_cnt
 => is literal (False) | is operator (False) rcv_cnt [vtype=int]
not unique: ('int', 'rcv_cnt', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rcv_cnt' - False OR  False
[i=0/2][j=7/13][dd=7/20][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : rcv_cnt (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rcv_cnt
 => is literal (False) | is operator (False) rcv_cnt [vtype=int]
not unique: ('int', 'rcv_cnt', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rcv_cnt' - False OR  False
[i=0/2][j=7/13][dd=8/20][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : rcv_cnt (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rcv_cnt
 => is literal (False) | is operator (False) rcv_cnt [vtype=int]
not unique: ('int', 'rcv_cnt', None) ... continue!
not valid - int rcv_cnt; rcv_cnt = ((int)rcv_cnt);

----
UNIQ_INIT: ('int','rcv_cnt','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_0_7_3(){
int rcv_cnt;
    bzero(&rcv_cnt,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(rcv_cnt); }
    {int dive_count; dive_count = (int)(rcv_cnt); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(rcv_cnt); }
    {char * tlv4; tlv4 = (char *)(rcv_cnt); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(rcv_cnt); }
}
void fix_ingred_edit_dives_0_7(){
fix_ingred_edit_dives_0_7_3();
}

sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5989bd0b8>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59981ecf8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ac6a58>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598926898>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598926ba8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598926198>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5989265f8>)]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_count' - False OR  False
[i=0/2][j=9/13][dd=0/20][k=6/10] | type: int ; var :  ; varinfo :  ; value_node : dive_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_count
 => is literal (False) | is operator (False) dive_count [vtype=int]
unique : ('int', 'dive_count', None)
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_number_to_edit' - False OR  False
[i=0/2][j=9/13][dd=0/20][k=7/10] | type: int ; var :  ; varinfo :  ; value_node : dive_number_to_edit (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_number_to_edit
 => is literal (False) | is operator (False) dive_number_to_edit [vtype=int]
unique : ('int', 'dive_number_to_edit', None)
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_count' - False OR  False
[i=0/2][j=9/13][dd=1/20][k=6/10] | type: int ; var :  ; varinfo :  ; value_node : dive_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_count
 => is literal (False) | is operator (False) dive_count [vtype=int]
not unique: ('int', 'dive_count', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_number_to_edit' - False OR  False
[i=0/2][j=9/13][dd=1/20][k=7/10] | type: int ; var :  ; varinfo :  ; value_node : dive_number_to_edit (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_number_to_edit
 => is literal (False) | is operator (False) dive_number_to_edit [vtype=int]
not unique: ('int', 'dive_number_to_edit', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_count' - False OR  False
[i=0/2][j=9/13][dd=3/20][k=6/10] | type: int ; var :  ; varinfo :  ; value_node : dive_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_count
 => is literal (False) | is operator (False) dive_count [vtype=int]
not unique: ('int', 'dive_count', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_number_to_edit' - False OR  False
[i=0/2][j=9/13][dd=3/20][k=7/10] | type: int ; var :  ; varinfo :  ; value_node : dive_number_to_edit (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_number_to_edit
 => is literal (False) | is operator (False) dive_number_to_edit [vtype=int]
not unique: ('int', 'dive_number_to_edit', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_count' - False OR  False
[i=0/2][j=9/13][dd=4/20][k=6/10] | type: int ; var :  ; varinfo :  ; value_node : dive_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_count
 => is literal (False) | is operator (False) dive_count [vtype=int]
not unique: ('int', 'dive_count', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_number_to_edit' - False OR  False
[i=0/2][j=9/13][dd=4/20][k=7/10] | type: int ; var :  ; varinfo :  ; value_node : dive_number_to_edit (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_number_to_edit
 => is literal (False) | is operator (False) dive_number_to_edit [vtype=int]
not unique: ('int', 'dive_number_to_edit', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_count' - False OR  False
[i=0/2][j=9/13][dd=7/20][k=6/10] | type: int ; var :  ; varinfo :  ; value_node : dive_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_count
 => is literal (False) | is operator (False) dive_count [vtype=int]
not unique: ('int', 'dive_count', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_number_to_edit' - False OR  False
[i=0/2][j=9/13][dd=7/20][k=7/10] | type: int ; var :  ; varinfo :  ; value_node : dive_number_to_edit (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_number_to_edit
 => is literal (False) | is operator (False) dive_number_to_edit [vtype=int]
not unique: ('int', 'dive_number_to_edit', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_count' - False OR  False
[i=0/2][j=9/13][dd=8/20][k=6/10] | type: int ; var :  ; varinfo :  ; value_node : dive_count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_count
 => is literal (False) | is operator (False) dive_count [vtype=int]
not unique: ('int', 'dive_count', None) ... continue!
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive_number_to_edit' - False OR  False
[i=0/2][j=9/13][dd=8/20][k=7/10] | type: int ; var :  ; varinfo :  ; value_node : dive_number_to_edit (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive_number_to_edit
 => is literal (False) | is operator (False) dive_number_to_edit [vtype=int]
not unique: ('int', 'dive_number_to_edit', None) ... continue!
not valid - int dive_count; dive_count = ((int)dive_count);

----
UNIQ_INIT: ('int','dive_count','None','None');

UNIQ_INIT: ('int','dive_number_to_edit','None','None');

not valid - int dive_number_to_edit; dive_number_to_edit = ((int)dive_number_to_edit);

----
UNIQ_INIT: ('int','dive_count','None','None');

UNIQ_INIT: ('int','dive_number_to_edit','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_0_9_6(){
int dive_count;
    bzero(&dive_count,sizeof(int));
int dive_number_to_edit;
    bzero(&dive_number_to_edit,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(dive_count); }
    {int rcv_cnt; rcv_cnt = (int)(dive_count); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(dive_count); }
    {char * tlv4; tlv4 = (char *)(dive_count); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(dive_count); }
}
void fix_ingred_edit_dives_0_9_7(){
int dive_count;
    bzero(&dive_count,sizeof(int));
int dive_number_to_edit;
    bzero(&dive_number_to_edit,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(dive_number_to_edit); }
    {int rcv_cnt; rcv_cnt = (int)(dive_number_to_edit); }
    {int dive_count; dive_count = (int)(dive_number_to_edit); }
    {char * tlv4; tlv4 = (char *)(dive_number_to_edit); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(dive_number_to_edit); }
}
void fix_ingred_edit_dives_0_9(){
fix_ingred_edit_dives_0_9_6();
fix_ingred_edit_dives_0_9_7();
}

sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59981ecf8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ac6a58>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5989bdc18>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a59909fe48>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a59909fba8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a59909ff28>)]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t', 'tlv5': 'const char *'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59981ecf8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ac6a58>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
sym_lut=>'{'Info': 'logbook_type *', 'buf': 'char *', 'buf [ 1024 ]': 'char', 'rcv_cnt': 'int', 'next_dive': 'dive_log_type *', 'dive_count': 'int', 'dive_number_to_edit': 'int', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv4': 'char *', 'tlv3': 'cgc_size_t', 'tlv5': 'const char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char'}'
val_s=>'[('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598eb82e8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f0b128>), ('int', 'dive_number_to_edit', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598daaf28>), ('dive_log_type *', 'next_dive', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59981ecf8>), ('int', 'dive_count', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ac6a58>)]'
cval_s=>'[]'
Checking 'cgc_list_dives( Info )' - is_func=True, is_func_ptr=False
cgc_list_dives( Info ) is a function.
Skipping.
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_update_dive( next_dive )' - is_func=True, is_func_ptr=False
cgc_update_dive( next_dive ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv7 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv7 ) is a function.
Skipping.
Checking 'cgc_printf( tlv8 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv8 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_edit_dives_0_0_1(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(1); }
    {int rcv_cnt; rcv_cnt = (int)(1); }
    {int dive_count; dive_count = (int)(1); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(1); }
    {char * tlv4; tlv4 = (char *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
}
void fix_ingred_edit_dives_0_0_2(){
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(0); }
    {int rcv_cnt; rcv_cnt = (int)(0); }
    {int dive_count; dive_count = (int)(0); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(0); }
    {char * tlv4; tlv4 = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
}
void fix_ingred_edit_dives_0_0(){
fix_ingred_edit_dives_0_0_1();
fix_ingred_edit_dives_0_0_2();
}
void fix_ingred_edit_dives_0_6_0(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(buf); }
    {int rcv_cnt; rcv_cnt = (int)(buf); }
    {int dive_count; dive_count = (int)(buf); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(buf); }
    {char * tlv4; tlv4 = (char *)(buf); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(buf); }
}
void fix_ingred_edit_dives_0_6_1(){
char buf [ 1024 ];
    bzero(&buf,( 1024 *sizeof(char) ) );
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(sizeof ( buf )); }
    {int rcv_cnt; rcv_cnt = (int)(sizeof ( buf )); }
    {int dive_count; dive_count = (int)(sizeof ( buf )); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(sizeof ( buf )); }
    {char * tlv4; tlv4 = (char *)(sizeof ( buf )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( buf )); }
}
void fix_ingred_edit_dives_0_6(){
fix_ingred_edit_dives_0_6_0();
fix_ingred_edit_dives_0_6_1();
}
void fix_ingred_edit_dives_0_7_3(){
int rcv_cnt;
    bzero(&rcv_cnt,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(rcv_cnt); }
    {int dive_count; dive_count = (int)(rcv_cnt); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(rcv_cnt); }
    {char * tlv4; tlv4 = (char *)(rcv_cnt); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(rcv_cnt); }
}
void fix_ingred_edit_dives_0_7(){
fix_ingred_edit_dives_0_7_3();
}
void fix_ingred_edit_dives_0_9_6(){
int dive_count;
    bzero(&dive_count,sizeof(int));
int dive_number_to_edit;
    bzero(&dive_number_to_edit,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(dive_count); }
    {int rcv_cnt; rcv_cnt = (int)(dive_count); }
    {int dive_number_to_edit; dive_number_to_edit = (int)(dive_count); }
    {char * tlv4; tlv4 = (char *)(dive_count); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(dive_count); }
}
void fix_ingred_edit_dives_0_9_7(){
int dive_count;
    bzero(&dive_count,sizeof(int));
int dive_number_to_edit;
    bzero(&dive_number_to_edit,sizeof(int));
    {char buf [ 1024 ]; buf [ ( 1024 )-1 ] = (char)(dive_number_to_edit); }
    {int rcv_cnt; rcv_cnt = (int)(dive_number_to_edit); }
    {int dive_count; dive_count = (int)(dive_number_to_edit); }
    {char * tlv4; tlv4 = (char *)(dive_number_to_edit); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(dive_number_to_edit); }
}
void fix_ingred_edit_dives_0_9(){
fix_ingred_edit_dives_0_9_6();
fix_ingred_edit_dives_0_9_7();
}
void fix_ingred_edit_dives_0(){
fix_ingred_edit_dives_0_0();
fix_ingred_edit_dives_0_6();
fix_ingred_edit_dives_0_7();
fix_ingred_edit_dives_0_9();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_edit_dives_0_0_1();
void fix_ingred_edit_dives_0_0_2();
void fix_ingred_edit_dives_0_0();
void fix_ingred_edit_dives_0_6_0();
void fix_ingred_edit_dives_0_6_1();
void fix_ingred_edit_dives_0_6();
void fix_ingred_edit_dives_0_7_3();
void fix_ingred_edit_dives_0_7();
void fix_ingred_edit_dives_0_9_6();
void fix_ingred_edit_dives_0_9_7();
void fix_ingred_edit_dives_0_9();
void fix_ingred_edit_dives_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char buffer [ 1024 ] ;
def_vars[1]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char buf2 [ 1024 ] ;
def_vars[2]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t count ;
def_vars[3]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : datetime_struct_type tm ;
def_vars[4]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv1 [ ] = "Dive Site" ;
def_vars[5]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv1 ) ;
def_vars[6]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv2 [ ] = ": " ;
def_vars[7]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv2 ) ;
def_vars[8]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv28 ;
def_vars[9]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv27 ;
def_vars[10]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv3 [ ] = "Date" ;
def_vars[11]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv3 ) ;
def_vars[12]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv4 [ ] = ": " ;
def_vars[13]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv4 ) ;
def_vars[14]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv30 ;
def_vars[15]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv29 ;
def_vars[16]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv5 [ ] = "Time" ;
def_vars[17]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv5 ) ;
def_vars[18]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv6 [ ] = ": " ;
def_vars[19]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv6 ) ;
def_vars[20]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv32 ;
def_vars[21]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv31 ;
def_vars[22]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv9 ;
def_vars[23]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv8 [ ] = " " ;
def_vars[24]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv7 ;
def_vars[25]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv12 ;
def_vars[26]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv11 = buf2 ;
def_vars[27]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv10 ;
def_vars[28]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv34 ;
def_vars[29]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : datetime_struct_type * tlv33 ;
def_vars[30]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv13 [ ] = "Location (area/city)" ;
def_vars[31]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv13 ) ;
def_vars[32]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv14 [ ] = ": " ;
def_vars[33]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv14 ) ;
def_vars[34]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv36 ;
def_vars[35]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv35 ;
def_vars[36]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv15 [ ] = "Max Depth in ft" ;
def_vars[37]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv15 ) ;
def_vars[38]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv16 [ ] = ": " ;
def_vars[39]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv16 ) ;
def_vars[40]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv38 ;
def_vars[41]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv37 ;
def_vars[42]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv17 [ ] = "Avg Depth in ft" ;
def_vars[43]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv17 ) ;
def_vars[44]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv18 [ ] = ": " ;
def_vars[45]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv18 ) ;
def_vars[46]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv40 ;
def_vars[47]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv39 ;
def_vars[48]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv19 [ ] = "Dive Duration (mins)" ;
def_vars[49]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv19 ) ;
def_vars[50]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv20 [ ] = ": " ;
def_vars[51]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv20 ) ;
def_vars[52]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv42 ;
def_vars[53]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv41 ;
def_vars[54]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv21 [ ] = "O2 Percentage" ;
def_vars[55]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv21 ) ;
def_vars[56]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv22 [ ] = ": " ;
def_vars[57]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv22 ) ;
def_vars[58]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv44 ;
def_vars[59]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv43 ;
def_vars[60]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv23 [ ] = "Pressure In (psi)" ;
def_vars[61]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv23 ) ;
def_vars[62]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv24 [ ] = ": " ;
def_vars[63]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv24 ) ;
def_vars[64]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv46 ;
def_vars[65]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv45 ;
def_vars[66]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv25 [ ] = "Pressure Out (psi)" ;
def_vars[67]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv25 ) ;
def_vars[68]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char tlv26 [ ] = ": " ;
def_vars[69]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_printf ( tlv26 ) ;
def_vars[70]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv48 ;
def_vars[71]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv47 ;
def_vars[72]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv67 ;
def_vars[73]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv51 ;
def_vars[74]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv50 = buffer ;
def_vars[75]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv49 ;
def_vars[76]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv54 ;
def_vars[77]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv53 = buffer ;
def_vars[78]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv52 ;
def_vars[79]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv57 ;
def_vars[80]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv56 = buf2 ;
def_vars[81]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv55 ;
def_vars[82]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : char * tlv60 ;
def_vars[83]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv59 = buffer ;
def_vars[84]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv58 ;
def_vars[85]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv61 = buffer ;
def_vars[86]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv62 = buffer ;
def_vars[87]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv63 = buffer ;
def_vars[88]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv64 = buffer ;
def_vars[89]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv65 = buffer ;
def_vars[90]: [cgc_update_dive] : <class 'CParser.CParser.DeclarationContext'> : const char * tlv66 = buffer ;
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598a66dd8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598a66198>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv28', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598e36c18>), ('cgc_size_t', 'tlv27', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598973c88>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=0/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
unique : ('char', 'buffer [ 1024 ]', None)
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=1/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=2/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=6/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=7/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=10/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=11/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=14/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=15/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=16/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=18/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=19/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=21/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=22/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=26/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=27/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=30/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=31/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=34/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=35/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=38/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=39/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=42/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=43/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=46/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=47/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=50/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=51/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=52/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=53/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=55/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=56/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=58/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=59/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=61/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=62/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buffer' - False OR  False
[i=1/2][j=4/65][dd=64/91][k=0/2] | type: char * ; var : tlv28 ; varinfo :  ; value_node : buffer (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buffer
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_site_name)' - False OR  False
[i=1/2][j=4/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv27 ; varinfo :  ; value_node : sizeof ( dive -> dive_site_name ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_site_name,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','buffer [ 1024 ]','None','None');

UNIQ_INIT: ('dive_log_type *','dive','None','None');

----
UNIQ_INIT: ('char','buffer [ 1024 ]','None','None');

UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_4_0(){
char buffer [ 1024 ];
    bzero(&buffer,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(buffer); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(buffer); }
    {cgc_size_t count; count = (cgc_size_t)(buffer); }
    {char * tlv28; tlv28 = (char *)(buffer); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(buffer); }
    {char * tlv30; tlv30 = (char *)(buffer); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(buffer); }
    {char * tlv32; tlv32 = (char *)(buffer); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(buffer); }
    {char * tlv9; tlv9 = (char *)(buffer); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(buffer); }
    {char * tlv12; tlv12 = (char *)(buffer); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(buffer); }
    {char * tlv34; tlv34 = (char *)(buffer); }
    {char * tlv36; tlv36 = (char *)(buffer); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(buffer); }
    {char * tlv38; tlv38 = (char *)(buffer); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(buffer); }
    {char * tlv40; tlv40 = (char *)(buffer); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(buffer); }
    {char * tlv42; tlv42 = (char *)(buffer); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(buffer); }
    {char * tlv44; tlv44 = (char *)(buffer); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(buffer); }
    {char * tlv46; tlv46 = (char *)(buffer); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(buffer); }
    {char * tlv48; tlv48 = (char *)(buffer); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(buffer); }
    {char * tlv67; tlv67 = (char *)(buffer); }
    {char * tlv51; tlv51 = (char *)(buffer); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(buffer); }
    {char * tlv54; tlv54 = (char *)(buffer); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(buffer); }
    {char * tlv57; tlv57 = (char *)(buffer); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(buffer); }
    {char * tlv60; tlv60 = (char *)(buffer); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(buffer); }
}
void fix_ingred_edit_dives_1_4_1(){
char buffer [ 1024 ];
    bzero(&buffer,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_site_name )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( dive -> dive_site_name )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( dive -> dive_site_name )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
}
void fix_ingred_edit_dives_1_4(){
fix_ingred_edit_dives_1_4_0();
fix_ingred_edit_dives_1_4_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a599053c88>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a599053cf8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=0/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=0/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=1/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=1/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=2/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=2/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=6/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=6/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=7/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=7/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=10/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=10/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=11/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=11/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=14/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=14/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=15/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=15/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=16/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=16/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=18/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=18/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=19/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=19/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=21/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=21/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=22/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=22/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=26/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=26/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=27/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=27/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=30/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=30/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=31/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=31/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=34/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=34/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=35/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=35/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=38/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=38/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=39/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=39/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=42/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=42/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=43/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=43/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=46/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=46/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=47/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=47/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=50/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=50/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=51/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=51/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=52/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=52/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=53/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=53/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=55/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=55/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=56/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=56/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=58/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=58/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=59/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=59/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=61/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=61/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=62/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=62/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=1/2][j=5/65][dd=64/91][k=0/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/2][j=5/65][dd=64/91][k=1/2] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
not valid - cgc_size_t count; count = ((cgc_size_t)count);

----
UNIQ_INIT: ('cgc_size_t','count','None','None');

----
UNIQ_INIT: ('cgc_size_t','count','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_5_0(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(count); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(count); }
    {char * tlv28; tlv28 = (char *)(count); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(count); }
    {char * tlv30; tlv30 = (char *)(count); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(count); }
    {char * tlv32; tlv32 = (char *)(count); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(count); }
    {char * tlv9; tlv9 = (char *)(count); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(count); }
    {char * tlv12; tlv12 = (char *)(count); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(count); }
    {char * tlv34; tlv34 = (char *)(count); }
    {char * tlv36; tlv36 = (char *)(count); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(count); }
    {char * tlv38; tlv38 = (char *)(count); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(count); }
    {char * tlv40; tlv40 = (char *)(count); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(count); }
    {char * tlv42; tlv42 = (char *)(count); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(count); }
    {char * tlv44; tlv44 = (char *)(count); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(count); }
    {char * tlv46; tlv46 = (char *)(count); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(count); }
    {char * tlv48; tlv48 = (char *)(count); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(count); }
    {char * tlv67; tlv67 = (char *)(count); }
    {char * tlv51; tlv51 = (char *)(count); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(count); }
    {char * tlv54; tlv54 = (char *)(count); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(count); }
    {char * tlv57; tlv57 = (char *)(count); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(count); }
    {char * tlv60; tlv60 = (char *)(count); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(count); }
}
void fix_ingred_edit_dives_1_5_1(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(0); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(0); }
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char * tlv28; tlv28 = (char *)(0); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(0); }
    {char * tlv30; tlv30 = (char *)(0); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(0); }
    {char * tlv32; tlv32 = (char *)(0); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(0); }
    {char * tlv12; tlv12 = (char *)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
    {char * tlv34; tlv34 = (char *)(0); }
    {char * tlv36; tlv36 = (char *)(0); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(0); }
    {char * tlv38; tlv38 = (char *)(0); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(0); }
    {char * tlv40; tlv40 = (char *)(0); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(0); }
    {char * tlv42; tlv42 = (char *)(0); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(0); }
    {char * tlv44; tlv44 = (char *)(0); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(0); }
    {char * tlv46; tlv46 = (char *)(0); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(0); }
    {char * tlv48; tlv48 = (char *)(0); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(0); }
    {char * tlv67; tlv67 = (char *)(0); }
    {char * tlv51; tlv51 = (char *)(0); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(0); }
    {char * tlv54; tlv54 = (char *)(0); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(0); }
    {char * tlv57; tlv57 = (char *)(0); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(0); }
    {char * tlv60; tlv60 = (char *)(0); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(0); }
}
void fix_ingred_edit_dives_1_5(){
fix_ingred_edit_dives_1_5_0();
fix_ingred_edit_dives_1_5_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv51': 'char *', 'tlv50': 'const char *', 'tlv49': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv51', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a599340dd8>), ('cgc_size_t', 'tlv49', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598db6e48>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a599053c88>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a599053cf8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=0/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=1/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=2/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=6/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=7/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=10/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=11/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=14/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=15/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=16/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=18/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=19/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=21/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=22/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=26/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=27/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=30/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=31/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=34/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=35/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=38/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=39/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=42/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=43/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=46/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=47/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=50/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=51/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=52/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=53/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=55/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=56/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=58/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=59/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=61/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=62/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_site_name' - False OR  False
[i=1/2][j=6/65][dd=64/91][k=0/4] | type: char * ; var : tlv51 ; varinfo :  ; value_node : dive -> dive_site_name (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_site_name
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_site_name [vtype=None]
----
UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_6_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> dive_site_name); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> dive_site_name); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv28; tlv28 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv30; tlv30 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv32; tlv32 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv9; tlv9 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv12; tlv12 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv34; tlv34 = (char *)(dive -> dive_site_name); }
    {char * tlv36; tlv36 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv38; tlv38 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv40; tlv40 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv42; tlv42 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv44; tlv44 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv46; tlv46 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv48; tlv48 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv67; tlv67 = (char *)(dive -> dive_site_name); }
    {char * tlv51; tlv51 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv54; tlv54 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv57; tlv57 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv60; tlv60 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> dive_site_name); }
}
void fix_ingred_edit_dives_1_6(){
fix_ingred_edit_dives_1_6_0();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598a89128>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a59912ab38>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv30', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598a63e48>), ('cgc_size_t', 'tlv29', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f8aac8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_date)' - False OR  False
[i=1/2][j=10/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv29 ; varinfo :  ; value_node : sizeof ( dive -> dive_date ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_date,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_10_1(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_date )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_date )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( dive -> dive_date )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( dive -> dive_date )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
}
void fix_ingred_edit_dives_1_10(){
fix_ingred_edit_dives_1_10_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598ebfc88>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a599005358>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv54': 'char *', 'tlv53': 'const char *', 'tlv52': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv54', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a599005c88>), ('cgc_size_t', 'tlv52', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598adcb38>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598ebfc88>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a599005358>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=0/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=1/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=2/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=6/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=7/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=10/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=11/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=14/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=15/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=16/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=18/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=19/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=21/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=22/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=26/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=27/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=30/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=31/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=34/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=35/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=38/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=39/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=42/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=43/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=46/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=47/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=50/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=51/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=52/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=53/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=55/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=56/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=58/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=59/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=61/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=62/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_date' - False OR  False
[i=1/2][j=12/65][dd=64/91][k=0/4] | type: char * ; var : tlv54 ; varinfo :  ; value_node : dive -> dive_date (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_date
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_date [vtype=None]
----
UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_12_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> dive_date); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> dive_date); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> dive_date); }
    {char * tlv28; tlv28 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv30; tlv30 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv32; tlv32 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv9; tlv9 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv12; tlv12 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv34; tlv34 = (char *)(dive -> dive_date); }
    {char * tlv36; tlv36 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv38; tlv38 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv40; tlv40 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv42; tlv42 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv44; tlv44 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv46; tlv46 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv48; tlv48 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv67; tlv67 = (char *)(dive -> dive_date); }
    {char * tlv51; tlv51 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv54; tlv54 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv57; tlv57 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv60; tlv60 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> dive_date); }
}
void fix_ingred_edit_dives_1_12(){
fix_ingred_edit_dives_1_12_0();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598ce24a8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598c21048>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv32', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598cd92e8>), ('cgc_size_t', 'tlv31', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598beaeb8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=0/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
unique : ('char', 'buf2 [ 1024 ]', None)
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=1/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=2/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=6/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=7/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=10/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=11/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=14/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=15/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=16/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=18/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=19/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=21/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=22/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=26/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=27/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=30/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=31/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=34/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=35/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=38/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=39/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=42/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=43/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=46/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=47/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=50/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=51/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=52/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=53/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=55/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=56/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=58/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=59/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=61/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=62/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf2' - False OR  False
[i=1/2][j=16/65][dd=64/91][k=0/2] | type: char * ; var : tlv32 ; varinfo :  ; value_node : buf2 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf2
 => is literal (False) | is operator (False) buf2 [vtype=char *]
BEFORE => literal (False) buf2 => char *
AFTER => literal (False) buf2 [ 1024 ] => char [size=1024]
not unique: ('char', 'buf2 [ 1024 ]', None) ... continue!
is_func_ [s] => '[False, False, True]'
has_multiptr_refs 'sizeof(dive->dive_time)' - False OR  False
[i=1/2][j=16/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv31 ; varinfo :  ; value_node : sizeof ( dive -> dive_time ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,dive,->,dive_time,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','buf2 [ 1024 ]','None','None');

UNIQ_INIT: ('dive_log_type *','dive','None','None');

----
UNIQ_INIT: ('char','buf2 [ 1024 ]','None','None');

UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_16_0(){
char buf2 [ 1024 ];
    bzero(&buf2,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(buf2); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(buf2); }
    {cgc_size_t count; count = (cgc_size_t)(buf2); }
    {char * tlv28; tlv28 = (char *)(buf2); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(buf2); }
    {char * tlv30; tlv30 = (char *)(buf2); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(buf2); }
    {char * tlv32; tlv32 = (char *)(buf2); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(buf2); }
    {char * tlv9; tlv9 = (char *)(buf2); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(buf2); }
    {char * tlv12; tlv12 = (char *)(buf2); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(buf2); }
    {char * tlv34; tlv34 = (char *)(buf2); }
    {char * tlv36; tlv36 = (char *)(buf2); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(buf2); }
    {char * tlv38; tlv38 = (char *)(buf2); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(buf2); }
    {char * tlv40; tlv40 = (char *)(buf2); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(buf2); }
    {char * tlv42; tlv42 = (char *)(buf2); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(buf2); }
    {char * tlv44; tlv44 = (char *)(buf2); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(buf2); }
    {char * tlv46; tlv46 = (char *)(buf2); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(buf2); }
    {char * tlv48; tlv48 = (char *)(buf2); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(buf2); }
    {char * tlv67; tlv67 = (char *)(buf2); }
    {char * tlv51; tlv51 = (char *)(buf2); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(buf2); }
    {char * tlv54; tlv54 = (char *)(buf2); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(buf2); }
    {char * tlv57; tlv57 = (char *)(buf2); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(buf2); }
    {char * tlv60; tlv60 = (char *)(buf2); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(buf2); }
}
void fix_ingred_edit_dives_1_16_1(){
char buf2 [ 1024 ];
    bzero(&buf2,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_time )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_time )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( dive -> dive_time )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( dive -> dive_time )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
}
void fix_ingred_edit_dives_1_16(){
fix_ingred_edit_dives_1_16_0();
fix_ingred_edit_dives_1_16_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5989d6f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5989d6dd8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv57': 'char *', 'tlv56': 'const char *', 'tlv55': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv57', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ae4198>), ('cgc_size_t', 'tlv55', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f79d68>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5989d6f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5989d6dd8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=0/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=1/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=2/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=6/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=7/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=10/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=11/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=14/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=15/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=16/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=18/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=19/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=21/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=22/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=26/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=27/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=30/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=31/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=34/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=35/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=38/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=39/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=42/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=43/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=46/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=47/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=50/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=51/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=52/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=53/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=55/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=56/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=58/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=59/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=61/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=62/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->dive_time' - False OR  False
[i=1/2][j=18/65][dd=64/91][k=0/4] | type: char * ; var : tlv57 ; varinfo :  ; value_node : dive -> dive_time (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,dive_time
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) dive_time [vtype=None]
----
UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_18_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> dive_time); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> dive_time); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> dive_time); }
    {char * tlv28; tlv28 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv30; tlv30 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv32; tlv32 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv9; tlv9 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv12; tlv12 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv34; tlv34 = (char *)(dive -> dive_time); }
    {char * tlv36; tlv36 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv38; tlv38 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv40; tlv40 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv42; tlv42 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv44; tlv44 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv46; tlv46 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv48; tlv48 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv67; tlv67 = (char *)(dive -> dive_time); }
    {char * tlv51; tlv51 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv54; tlv54 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv57; tlv57 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv60; tlv60 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> dive_time); }
}
void fix_ingred_edit_dives_1_18(){
fix_ingred_edit_dives_1_18_0();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598c34ac8>), ('cgc_size_t', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f99d68>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/2][j=19/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv7 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_edit_dives_1_19_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(1); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(1); }
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {char * tlv28; tlv28 = (char *)(1); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(1); }
    {char * tlv30; tlv30 = (char *)(1); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(1); }
    {char * tlv32; tlv32 = (char *)(1); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(1); }
    {char * tlv9; tlv9 = (char *)(1); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(1); }
    {char * tlv12; tlv12 = (char *)(1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(1); }
    {char * tlv34; tlv34 = (char *)(1); }
    {char * tlv36; tlv36 = (char *)(1); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(1); }
    {char * tlv38; tlv38 = (char *)(1); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(1); }
    {char * tlv40; tlv40 = (char *)(1); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(1); }
    {char * tlv42; tlv42 = (char *)(1); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(1); }
    {char * tlv44; tlv44 = (char *)(1); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(1); }
    {char * tlv46; tlv46 = (char *)(1); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(1); }
    {char * tlv48; tlv48 = (char *)(1); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(1); }
    {char * tlv67; tlv67 = (char *)(1); }
    {char * tlv51; tlv51 = (char *)(1); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(1); }
    {char * tlv54; tlv54 = (char *)(1); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(1); }
    {char * tlv57; tlv57 = (char *)(1); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(1); }
    {char * tlv60; tlv60 = (char *)(1); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(1); }
}
void fix_ingred_edit_dives_1_19(){
fix_ingred_edit_dives_1_19_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598a405f8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tlv67': 'char *'}'
val_s=>'[('char *', 'tlv67', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988d5518>), ('cgc_size_t', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988d5048>), ('char *', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598a405f8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=0/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
unique : ('char *', 'tlv67', None)
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=1/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=2/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=6/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=7/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=10/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=11/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=14/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=15/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=16/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=18/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=19/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=21/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=22/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=26/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=27/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=30/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=31/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=34/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=35/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=38/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=39/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=42/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=43/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=46/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=47/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=50/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=51/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=52/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=53/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=55/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=56/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=58/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=59/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=61/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=62/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv67)' - False OR  False
[i=1/2][j=21/65][dd=64/91][k=1/3] | type: cgc_size_t ; var : tlv10 ; varinfo :  ; value_node : cgc_strlen ( tlv67 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv67,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv67 [vtype=char *]
not unique: ('char *', 'tlv67', None) ... continue!
 => is literal (False) | is operator (True) )
not valid - char * tlv67; tlv67 = ((char *)cgc_strlen ( tlv67 ));

----
UNIQ_INIT: ('char *','tlv67','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_21_1(){
char tlv67_ref;
    bzero(&tlv67_ref,1*sizeof(char));
char * tlv67 = &tlv67_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(cgc_strlen ( tlv67 )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(cgc_strlen ( tlv67 )); }
    {cgc_size_t count; count = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv28; tlv28 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv30; tlv30 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv32; tlv32 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv12; tlv12 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv34; tlv34 = (char *)(cgc_strlen ( tlv67 )); }
    {char * tlv36; tlv36 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv38; tlv38 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv40; tlv40 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv42; tlv42 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv44; tlv44 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv46; tlv46 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv48; tlv48 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv51; tlv51 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv54; tlv54 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv57; tlv57 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv60; tlv60 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
}
void fix_ingred_edit_dives_1_21(){
fix_ingred_edit_dives_1_21_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *'}'
val_s=>'[('char *', 'tlv34', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598a31438>), ('datetime_struct_type *', 'tlv33', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598b14908>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598fe46d8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598fe4668>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv36', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598caa278>), ('cgc_size_t', 'tlv35', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598f08d68>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
unique : ('char', 'buffer [ 1024 ]', None)
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(buffer)' - False OR  False
[i=1/2][j=26/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv35 ; varinfo :  ; value_node : sizeof ( buffer ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,buffer,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) buffer [vtype=char *]
BEFORE => literal (False) buffer => char *
AFTER => literal (False) buffer [ 1024 ] => char [size=1024]
not unique: ('char', 'buffer [ 1024 ]', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','buffer [ 1024 ]','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_26_1(){
char buffer [ 1024 ];
    bzero(&buffer,( 1024 *sizeof(char) ) );
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( buffer )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( buffer )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( buffer )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( buffer )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( buffer )); }
}
void fix_ingred_edit_dives_1_26(){
fix_ingred_edit_dives_1_26_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598c10908>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598c10278>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv60': 'char *', 'tlv59': 'const char *', 'tlv58': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv60', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598ebb898>), ('cgc_size_t', 'tlv58', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a59902b128>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598c10908>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598c10278>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=0/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
unique : ('dive_log_type *', 'dive', None)
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=1/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=2/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=6/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=7/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=10/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=11/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=14/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=15/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=16/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=18/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=19/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=21/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=22/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=26/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=27/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=30/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=31/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=34/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=35/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=38/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=39/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=42/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=43/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=46/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=47/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=50/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=51/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=52/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=53/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=55/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=56/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=58/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=59/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=61/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=62/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dive->location' - False OR  False
[i=1/2][j=28/65][dd=64/91][k=0/4] | type: char * ; var : tlv60 ; varinfo :  ; value_node : dive -> location (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dive,->,location
 => is literal (False) | is operator (False) dive [vtype=dive_log_type *]
not unique: ('dive_log_type *', 'dive', None) ... continue!
 => is literal (False) | is operator (True) ->
 => is literal (False) | is operator (False) location [vtype=None]
----
UNIQ_INIT: ('dive_log_type *','dive','None','None');

==== Scope 1 ====
void fix_ingred_edit_dives_1_28_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> location); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> location); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> location); }
    {char * tlv28; tlv28 = (char *)(dive -> location); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> location); }
    {char * tlv30; tlv30 = (char *)(dive -> location); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> location); }
    {char * tlv32; tlv32 = (char *)(dive -> location); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> location); }
    {char * tlv9; tlv9 = (char *)(dive -> location); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> location); }
    {char * tlv12; tlv12 = (char *)(dive -> location); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> location); }
    {char * tlv34; tlv34 = (char *)(dive -> location); }
    {char * tlv36; tlv36 = (char *)(dive -> location); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> location); }
    {char * tlv38; tlv38 = (char *)(dive -> location); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> location); }
    {char * tlv40; tlv40 = (char *)(dive -> location); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> location); }
    {char * tlv42; tlv42 = (char *)(dive -> location); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> location); }
    {char * tlv44; tlv44 = (char *)(dive -> location); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> location); }
    {char * tlv46; tlv46 = (char *)(dive -> location); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> location); }
    {char * tlv48; tlv48 = (char *)(dive -> location); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> location); }
    {char * tlv67; tlv67 = (char *)(dive -> location); }
    {char * tlv51; tlv51 = (char *)(dive -> location); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> location); }
    {char * tlv54; tlv54 = (char *)(dive -> location); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> location); }
    {char * tlv57; tlv57 = (char *)(dive -> location); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> location); }
    {char * tlv60; tlv60 = (char *)(dive -> location); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> location); }
}
void fix_ingred_edit_dives_1_28(){
fix_ingred_edit_dives_1_28_0();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598f0aba8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598b494a8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv38', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598846c88>), ('cgc_size_t', 'tlv37', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598833ba8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598853f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a59884e278>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv61': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598853f28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a59884e278>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a59882dc88>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a59883c048>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv40', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988e2ba8>), ('cgc_size_t', 'tlv39', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988e6ac8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988b3e48>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988db198>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv62': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988b3e48>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988db198>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5988cdba8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5988cdf28>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv42', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988d0ac8>), ('cgc_size_t', 'tlv41', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988cb9e8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '13' - False OR  False
[i=1/2][j=44/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv41 ; varinfo :  ; value_node : 13 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 13
 => is literal (True) | is operator (False) 13
----
==== Scope 1 ====
void fix_ingred_edit_dives_1_44_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(13); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(13); }
    {cgc_size_t count; count = (cgc_size_t)(13); }
    {char * tlv28; tlv28 = (char *)(13); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(13); }
    {char * tlv30; tlv30 = (char *)(13); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(13); }
    {char * tlv32; tlv32 = (char *)(13); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(13); }
    {char * tlv9; tlv9 = (char *)(13); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(13); }
    {char * tlv12; tlv12 = (char *)(13); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(13); }
    {char * tlv34; tlv34 = (char *)(13); }
    {char * tlv36; tlv36 = (char *)(13); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(13); }
    {char * tlv38; tlv38 = (char *)(13); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(13); }
    {char * tlv40; tlv40 = (char *)(13); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(13); }
    {char * tlv42; tlv42 = (char *)(13); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(13); }
    {char * tlv44; tlv44 = (char *)(13); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(13); }
    {char * tlv46; tlv46 = (char *)(13); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(13); }
    {char * tlv48; tlv48 = (char *)(13); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(13); }
    {char * tlv67; tlv67 = (char *)(13); }
    {char * tlv51; tlv51 = (char *)(13); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(13); }
    {char * tlv54; tlv54 = (char *)(13); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(13); }
    {char * tlv57; tlv57 = (char *)(13); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(13); }
    {char * tlv60; tlv60 = (char *)(13); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(13); }
}
void fix_ingred_edit_dives_1_44(){
fix_ingred_edit_dives_1_44_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988c85f8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988c8908>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv63': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988c85f8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988c8908>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5988e7358>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5988e76d8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv44', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988bb278>), ('cgc_size_t', 'tlv43', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5988ce198>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '11' - False OR  False
[i=1/2][j=50/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv43 ; varinfo :  ; value_node : 11 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 11
 => is literal (True) | is operator (False) 11
----
==== Scope 1 ====
void fix_ingred_edit_dives_1_50_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(11); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(11); }
    {cgc_size_t count; count = (cgc_size_t)(11); }
    {char * tlv28; tlv28 = (char *)(11); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(11); }
    {char * tlv30; tlv30 = (char *)(11); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(11); }
    {char * tlv32; tlv32 = (char *)(11); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(11); }
    {char * tlv9; tlv9 = (char *)(11); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(11); }
    {char * tlv12; tlv12 = (char *)(11); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(11); }
    {char * tlv34; tlv34 = (char *)(11); }
    {char * tlv36; tlv36 = (char *)(11); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(11); }
    {char * tlv38; tlv38 = (char *)(11); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(11); }
    {char * tlv40; tlv40 = (char *)(11); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(11); }
    {char * tlv42; tlv42 = (char *)(11); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(11); }
    {char * tlv44; tlv44 = (char *)(11); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(11); }
    {char * tlv46; tlv46 = (char *)(11); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(11); }
    {char * tlv48; tlv48 = (char *)(11); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(11); }
    {char * tlv67; tlv67 = (char *)(11); }
    {char * tlv51; tlv51 = (char *)(11); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(11); }
    {char * tlv54; tlv54 = (char *)(11); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(11); }
    {char * tlv57; tlv57 = (char *)(11); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(11); }
    {char * tlv60; tlv60 = (char *)(11); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(11); }
}
void fix_ingred_edit_dives_1_50(){
fix_ingred_edit_dives_1_50_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988ded68>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988e90b8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv64': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988ded68>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a5988e90b8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598a27ac8>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a598a27e48>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv46', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598a0c9e8>), ('cgc_size_t', 'tlv45', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5989f1908>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=0/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=1/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=2/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=6/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=7/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=10/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=11/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=14/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=15/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=16/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=18/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=19/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=21/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=22/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=26/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=27/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=30/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=31/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=34/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=35/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=38/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=39/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=42/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=43/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=46/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=47/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=50/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=51/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=52/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=53/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=55/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=56/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=58/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=59/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=61/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=62/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
is_func_ [2] => '[False, False, False]'
has_multiptr_refs '20' - False OR  False
[i=1/2][j=56/65][dd=64/91][k=1/2] | type: cgc_size_t ; var : tlv45 ; varinfo :  ; value_node : 20 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 20
 => is literal (True) | is operator (False) 20
----
==== Scope 1 ====
void fix_ingred_edit_dives_1_56_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(20); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(20); }
    {cgc_size_t count; count = (cgc_size_t)(20); }
    {char * tlv28; tlv28 = (char *)(20); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(20); }
    {char * tlv30; tlv30 = (char *)(20); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(20); }
    {char * tlv32; tlv32 = (char *)(20); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(20); }
    {char * tlv9; tlv9 = (char *)(20); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(20); }
    {char * tlv12; tlv12 = (char *)(20); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(20); }
    {char * tlv34; tlv34 = (char *)(20); }
    {char * tlv36; tlv36 = (char *)(20); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(20); }
    {char * tlv38; tlv38 = (char *)(20); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(20); }
    {char * tlv40; tlv40 = (char *)(20); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(20); }
    {char * tlv42; tlv42 = (char *)(20); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(20); }
    {char * tlv44; tlv44 = (char *)(20); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(20); }
    {char * tlv46; tlv46 = (char *)(20); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(20); }
    {char * tlv48; tlv48 = (char *)(20); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(20); }
    {char * tlv67; tlv67 = (char *)(20); }
    {char * tlv51; tlv51 = (char *)(20); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(20); }
    {char * tlv54; tlv54 = (char *)(20); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(20); }
    {char * tlv57; tlv57 = (char *)(20); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(20); }
    {char * tlv60; tlv60 = (char *)(20); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(20); }
}
void fix_ingred_edit_dives_1_56(){
fix_ingred_edit_dives_1_56_1();
}

sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a01518>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a01828>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv65': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a01518>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a01828>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv25': 'const char *', 'tlv25 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv25': 'const char *', 'tlv25 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5989ed278>), ('dive_log_type *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x14a5989ed5f8>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv25': 'const char *', 'tlv25 [ ]': 'const char', 'tlv26': 'const char *', 'tlv26 [ ]': 'const char'}'
val_s=>'[]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv25': 'const char *', 'tlv25 [ ]': 'const char', 'tlv26': 'const char *', 'tlv26 [ ]': 'const char', 'tlv48': 'char *', 'tlv47': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv48', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a598a0a198>), ('cgc_size_t', 'tlv47', '', <CParser.CParser.AssignmentExpressionContext object at 0x14a5989fe0b8>)]'
cval_s=>'[]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv25': 'const char *', 'tlv25 [ ]': 'const char', 'tlv26': 'const char *', 'tlv26 [ ]': 'const char', 'tlv48': 'char *', 'tlv47': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a22c88>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a22f98>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
sym_lut=>'{'dive': 'dive_log_type *', 'buffer': 'char *', 'buffer [ 1024 ]': 'char', 'buf2': 'char *', 'buf2 [ 1024 ]': 'char', 'count': 'cgc_size_t', 'tlv1': 'const char *', 'tlv1 [ ]': 'const char', 'tlv2': 'const char *', 'tlv2 [ ]': 'const char', 'tlv28': 'char *', 'tlv27': 'cgc_size_t', 'tlv3': 'const char *', 'tlv3 [ ]': 'const char', 'tlv4': 'const char *', 'tlv4 [ ]': 'const char', 'tlv30': 'char *', 'tlv29': 'cgc_size_t', 'tlv5': 'const char *', 'tlv5 [ ]': 'const char', 'tlv6': 'const char *', 'tlv6 [ ]': 'const char', 'tlv32': 'char *', 'tlv31': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'const char *', 'tlv8 [ ]': 'const char', 'tlv7': 'cgc_size_t', 'tlv12': 'char *', 'tlv11': 'const char *', 'tlv10': 'cgc_size_t', 'tm': 'datetime_struct_type', 'tlv34': 'char *', 'tlv33': 'datetime_struct_type *', 'tlv13': 'const char *', 'tlv13 [ ]': 'const char', 'tlv14': 'const char *', 'tlv14 [ ]': 'const char', 'tlv36': 'char *', 'tlv35': 'cgc_size_t', 'tlv15': 'const char *', 'tlv15 [ ]': 'const char', 'tlv16': 'const char *', 'tlv16 [ ]': 'const char', 'tlv38': 'char *', 'tlv37': 'cgc_size_t', 'tlv17': 'const char *', 'tlv17 [ ]': 'const char', 'tlv18': 'const char *', 'tlv18 [ ]': 'const char', 'tlv40': 'char *', 'tlv39': 'cgc_size_t', 'tlv19': 'const char *', 'tlv19 [ ]': 'const char', 'tlv20': 'const char *', 'tlv20 [ ]': 'const char', 'tlv42': 'char *', 'tlv41': 'cgc_size_t', 'tlv21': 'const char *', 'tlv21 [ ]': 'const char', 'tlv22': 'const char *', 'tlv22 [ ]': 'const char', 'tlv44': 'char *', 'tlv43': 'cgc_size_t', 'tlv23': 'const char *', 'tlv23 [ ]': 'const char', 'tlv24': 'const char *', 'tlv24 [ ]': 'const char', 'tlv46': 'char *', 'tlv45': 'cgc_size_t', 'tlv25': 'const char *', 'tlv25 [ ]': 'const char', 'tlv26': 'const char *', 'tlv26 [ ]': 'const char', 'tlv48': 'char *', 'tlv47': 'cgc_size_t', 'tlv66': 'const char *'}'
val_s=>'[]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a22c88>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x14a598a22f98>)]'
Checking 'cgc_printf( tlv1 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv1 ) is a function.
Skipping.
Checking 'cgc_printf( tlv2 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv2 ) is a function.
Skipping.
Checking 'cgc_printf( tlv3 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv3 ) is a function.
Skipping.
Checking 'cgc_printf( tlv4 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv4 ) is a function.
Skipping.
Checking 'cgc_printf( tlv5 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv5 ) is a function.
Skipping.
Checking 'cgc_printf( tlv6 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv6 ) is a function.
Skipping.
Checking 'cgc_printf( tlv13 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv13 ) is a function.
Skipping.
Checking 'cgc_printf( tlv14 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv14 ) is a function.
Skipping.
Checking 'cgc_printf( tlv15 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv15 ) is a function.
Skipping.
Checking 'cgc_printf( tlv16 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv16 ) is a function.
Skipping.
Checking 'cgc_printf( tlv17 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv17 ) is a function.
Skipping.
Checking 'cgc_printf( tlv18 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv18 ) is a function.
Skipping.
Checking 'cgc_printf( tlv19 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv19 ) is a function.
Skipping.
Checking 'cgc_printf( tlv20 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv20 ) is a function.
Skipping.
Checking 'cgc_printf( tlv21 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv21 ) is a function.
Skipping.
Checking 'cgc_printf( tlv22 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv22 ) is a function.
Skipping.
Checking 'cgc_printf( tlv23 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv23 ) is a function.
Skipping.
Checking 'cgc_printf( tlv24 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv24 ) is a function.
Skipping.
Checking 'cgc_printf( tlv25 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv25 ) is a function.
Skipping.
Checking 'cgc_printf( tlv26 )' - is_func=True, is_func_ptr=False
cgc_printf( tlv26 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_edit_dives_1_4_0(){
char buffer [ 1024 ];
    bzero(&buffer,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(buffer); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(buffer); }
    {cgc_size_t count; count = (cgc_size_t)(buffer); }
    {char * tlv28; tlv28 = (char *)(buffer); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(buffer); }
    {char * tlv30; tlv30 = (char *)(buffer); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(buffer); }
    {char * tlv32; tlv32 = (char *)(buffer); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(buffer); }
    {char * tlv9; tlv9 = (char *)(buffer); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(buffer); }
    {char * tlv12; tlv12 = (char *)(buffer); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(buffer); }
    {char * tlv34; tlv34 = (char *)(buffer); }
    {char * tlv36; tlv36 = (char *)(buffer); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(buffer); }
    {char * tlv38; tlv38 = (char *)(buffer); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(buffer); }
    {char * tlv40; tlv40 = (char *)(buffer); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(buffer); }
    {char * tlv42; tlv42 = (char *)(buffer); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(buffer); }
    {char * tlv44; tlv44 = (char *)(buffer); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(buffer); }
    {char * tlv46; tlv46 = (char *)(buffer); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(buffer); }
    {char * tlv48; tlv48 = (char *)(buffer); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(buffer); }
    {char * tlv67; tlv67 = (char *)(buffer); }
    {char * tlv51; tlv51 = (char *)(buffer); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(buffer); }
    {char * tlv54; tlv54 = (char *)(buffer); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(buffer); }
    {char * tlv57; tlv57 = (char *)(buffer); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(buffer); }
    {char * tlv60; tlv60 = (char *)(buffer); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(buffer); }
}
void fix_ingred_edit_dives_1_4_1(){
char buffer [ 1024 ];
    bzero(&buffer,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_site_name )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( dive -> dive_site_name )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( dive -> dive_site_name )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( dive -> dive_site_name )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( dive -> dive_site_name )); }
}
void fix_ingred_edit_dives_1_4(){
fix_ingred_edit_dives_1_4_0();
fix_ingred_edit_dives_1_4_1();
}
void fix_ingred_edit_dives_1_5_0(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(count); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(count); }
    {char * tlv28; tlv28 = (char *)(count); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(count); }
    {char * tlv30; tlv30 = (char *)(count); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(count); }
    {char * tlv32; tlv32 = (char *)(count); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(count); }
    {char * tlv9; tlv9 = (char *)(count); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(count); }
    {char * tlv12; tlv12 = (char *)(count); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(count); }
    {char * tlv34; tlv34 = (char *)(count); }
    {char * tlv36; tlv36 = (char *)(count); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(count); }
    {char * tlv38; tlv38 = (char *)(count); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(count); }
    {char * tlv40; tlv40 = (char *)(count); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(count); }
    {char * tlv42; tlv42 = (char *)(count); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(count); }
    {char * tlv44; tlv44 = (char *)(count); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(count); }
    {char * tlv46; tlv46 = (char *)(count); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(count); }
    {char * tlv48; tlv48 = (char *)(count); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(count); }
    {char * tlv67; tlv67 = (char *)(count); }
    {char * tlv51; tlv51 = (char *)(count); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(count); }
    {char * tlv54; tlv54 = (char *)(count); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(count); }
    {char * tlv57; tlv57 = (char *)(count); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(count); }
    {char * tlv60; tlv60 = (char *)(count); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(count); }
}
void fix_ingred_edit_dives_1_5_1(){
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(0); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(0); }
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char * tlv28; tlv28 = (char *)(0); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(0); }
    {char * tlv30; tlv30 = (char *)(0); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(0); }
    {char * tlv32; tlv32 = (char *)(0); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(0); }
    {char * tlv12; tlv12 = (char *)(0); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(0); }
    {char * tlv34; tlv34 = (char *)(0); }
    {char * tlv36; tlv36 = (char *)(0); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(0); }
    {char * tlv38; tlv38 = (char *)(0); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(0); }
    {char * tlv40; tlv40 = (char *)(0); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(0); }
    {char * tlv42; tlv42 = (char *)(0); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(0); }
    {char * tlv44; tlv44 = (char *)(0); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(0); }
    {char * tlv46; tlv46 = (char *)(0); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(0); }
    {char * tlv48; tlv48 = (char *)(0); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(0); }
    {char * tlv67; tlv67 = (char *)(0); }
    {char * tlv51; tlv51 = (char *)(0); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(0); }
    {char * tlv54; tlv54 = (char *)(0); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(0); }
    {char * tlv57; tlv57 = (char *)(0); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(0); }
    {char * tlv60; tlv60 = (char *)(0); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(0); }
}
void fix_ingred_edit_dives_1_5(){
fix_ingred_edit_dives_1_5_0();
fix_ingred_edit_dives_1_5_1();
}
void fix_ingred_edit_dives_1_6_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> dive_site_name); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> dive_site_name); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv28; tlv28 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv30; tlv30 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv32; tlv32 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv9; tlv9 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv12; tlv12 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv34; tlv34 = (char *)(dive -> dive_site_name); }
    {char * tlv36; tlv36 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv38; tlv38 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv40; tlv40 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv42; tlv42 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv44; tlv44 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv46; tlv46 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv48; tlv48 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv67; tlv67 = (char *)(dive -> dive_site_name); }
    {char * tlv51; tlv51 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv54; tlv54 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv57; tlv57 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> dive_site_name); }
    {char * tlv60; tlv60 = (char *)(dive -> dive_site_name); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> dive_site_name); }
}
void fix_ingred_edit_dives_1_6(){
fix_ingred_edit_dives_1_6_0();
}
void fix_ingred_edit_dives_1_10_1(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_date )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_date )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( dive -> dive_date )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( dive -> dive_date )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( dive -> dive_date )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( dive -> dive_date )); }
}
void fix_ingred_edit_dives_1_10(){
fix_ingred_edit_dives_1_10_1();
}
void fix_ingred_edit_dives_1_12_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> dive_date); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> dive_date); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> dive_date); }
    {char * tlv28; tlv28 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv30; tlv30 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv32; tlv32 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv9; tlv9 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv12; tlv12 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv34; tlv34 = (char *)(dive -> dive_date); }
    {char * tlv36; tlv36 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv38; tlv38 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv40; tlv40 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv42; tlv42 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv44; tlv44 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv46; tlv46 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv48; tlv48 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv67; tlv67 = (char *)(dive -> dive_date); }
    {char * tlv51; tlv51 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv54; tlv54 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv57; tlv57 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> dive_date); }
    {char * tlv60; tlv60 = (char *)(dive -> dive_date); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> dive_date); }
}
void fix_ingred_edit_dives_1_12(){
fix_ingred_edit_dives_1_12_0();
}
void fix_ingred_edit_dives_1_16_0(){
char buf2 [ 1024 ];
    bzero(&buf2,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(buf2); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(buf2); }
    {cgc_size_t count; count = (cgc_size_t)(buf2); }
    {char * tlv28; tlv28 = (char *)(buf2); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(buf2); }
    {char * tlv30; tlv30 = (char *)(buf2); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(buf2); }
    {char * tlv32; tlv32 = (char *)(buf2); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(buf2); }
    {char * tlv9; tlv9 = (char *)(buf2); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(buf2); }
    {char * tlv12; tlv12 = (char *)(buf2); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(buf2); }
    {char * tlv34; tlv34 = (char *)(buf2); }
    {char * tlv36; tlv36 = (char *)(buf2); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(buf2); }
    {char * tlv38; tlv38 = (char *)(buf2); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(buf2); }
    {char * tlv40; tlv40 = (char *)(buf2); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(buf2); }
    {char * tlv42; tlv42 = (char *)(buf2); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(buf2); }
    {char * tlv44; tlv44 = (char *)(buf2); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(buf2); }
    {char * tlv46; tlv46 = (char *)(buf2); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(buf2); }
    {char * tlv48; tlv48 = (char *)(buf2); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(buf2); }
    {char * tlv67; tlv67 = (char *)(buf2); }
    {char * tlv51; tlv51 = (char *)(buf2); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(buf2); }
    {char * tlv54; tlv54 = (char *)(buf2); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(buf2); }
    {char * tlv57; tlv57 = (char *)(buf2); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(buf2); }
    {char * tlv60; tlv60 = (char *)(buf2); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(buf2); }
}
void fix_ingred_edit_dives_1_16_1(){
char buf2 [ 1024 ];
    bzero(&buf2,( 1024 *sizeof(char) ) );
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_time )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( dive -> dive_time )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( dive -> dive_time )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( dive -> dive_time )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( dive -> dive_time )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( dive -> dive_time )); }
}
void fix_ingred_edit_dives_1_16(){
fix_ingred_edit_dives_1_16_0();
fix_ingred_edit_dives_1_16_1();
}
void fix_ingred_edit_dives_1_18_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> dive_time); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> dive_time); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> dive_time); }
    {char * tlv28; tlv28 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv30; tlv30 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv32; tlv32 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv9; tlv9 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv12; tlv12 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv34; tlv34 = (char *)(dive -> dive_time); }
    {char * tlv36; tlv36 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv38; tlv38 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv40; tlv40 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv42; tlv42 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv44; tlv44 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv46; tlv46 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv48; tlv48 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv67; tlv67 = (char *)(dive -> dive_time); }
    {char * tlv51; tlv51 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv54; tlv54 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv57; tlv57 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> dive_time); }
    {char * tlv60; tlv60 = (char *)(dive -> dive_time); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> dive_time); }
}
void fix_ingred_edit_dives_1_18(){
fix_ingred_edit_dives_1_18_0();
}
void fix_ingred_edit_dives_1_19_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(1); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(1); }
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {char * tlv28; tlv28 = (char *)(1); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(1); }
    {char * tlv30; tlv30 = (char *)(1); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(1); }
    {char * tlv32; tlv32 = (char *)(1); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(1); }
    {char * tlv9; tlv9 = (char *)(1); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(1); }
    {char * tlv12; tlv12 = (char *)(1); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(1); }
    {char * tlv34; tlv34 = (char *)(1); }
    {char * tlv36; tlv36 = (char *)(1); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(1); }
    {char * tlv38; tlv38 = (char *)(1); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(1); }
    {char * tlv40; tlv40 = (char *)(1); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(1); }
    {char * tlv42; tlv42 = (char *)(1); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(1); }
    {char * tlv44; tlv44 = (char *)(1); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(1); }
    {char * tlv46; tlv46 = (char *)(1); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(1); }
    {char * tlv48; tlv48 = (char *)(1); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(1); }
    {char * tlv67; tlv67 = (char *)(1); }
    {char * tlv51; tlv51 = (char *)(1); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(1); }
    {char * tlv54; tlv54 = (char *)(1); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(1); }
    {char * tlv57; tlv57 = (char *)(1); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(1); }
    {char * tlv60; tlv60 = (char *)(1); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(1); }
}
void fix_ingred_edit_dives_1_19(){
fix_ingred_edit_dives_1_19_1();
}
void fix_ingred_edit_dives_1_21_1(){
char tlv67_ref;
    bzero(&tlv67_ref,1*sizeof(char));
char * tlv67 = &tlv67_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(cgc_strlen ( tlv67 )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(cgc_strlen ( tlv67 )); }
    {cgc_size_t count; count = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv28; tlv28 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv30; tlv30 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv32; tlv32 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv12; tlv12 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv34; tlv34 = (char *)(cgc_strlen ( tlv67 )); }
    {char * tlv36; tlv36 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv38; tlv38 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv40; tlv40 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv42; tlv42 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv44; tlv44 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv46; tlv46 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv48; tlv48 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv51; tlv51 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv54; tlv54 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv57; tlv57 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
    {char * tlv60; tlv60 = (char *)(cgc_strlen ( tlv67 )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(cgc_strlen ( tlv67 )); }
}
void fix_ingred_edit_dives_1_21(){
fix_ingred_edit_dives_1_21_1();
}
void fix_ingred_edit_dives_1_26_1(){
char buffer [ 1024 ];
    bzero(&buffer,( 1024 *sizeof(char) ) );
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(sizeof ( buffer )); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(sizeof ( buffer )); }
    {cgc_size_t count; count = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv28; tlv28 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv30; tlv30 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv32; tlv32 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv12; tlv12 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv34; tlv34 = (char *)(sizeof ( buffer )); }
    {char * tlv36; tlv36 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv38; tlv38 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv40; tlv40 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv42; tlv42 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv44; tlv44 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv46; tlv46 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv48; tlv48 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv67; tlv67 = (char *)(sizeof ( buffer )); }
    {char * tlv51; tlv51 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv54; tlv54 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv57; tlv57 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(sizeof ( buffer )); }
    {char * tlv60; tlv60 = (char *)(sizeof ( buffer )); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(sizeof ( buffer )); }
}
void fix_ingred_edit_dives_1_26(){
fix_ingred_edit_dives_1_26_1();
}
void fix_ingred_edit_dives_1_28_0(){
dive_log_type dive_ref;
    bzero(&dive_ref,1*sizeof(dive_log_type));
dive_log_type * dive = &dive_ref;
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(dive -> location); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(dive -> location); }
    {cgc_size_t count; count = (cgc_size_t)(dive -> location); }
    {char * tlv28; tlv28 = (char *)(dive -> location); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(dive -> location); }
    {char * tlv30; tlv30 = (char *)(dive -> location); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(dive -> location); }
    {char * tlv32; tlv32 = (char *)(dive -> location); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(dive -> location); }
    {char * tlv9; tlv9 = (char *)(dive -> location); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(dive -> location); }
    {char * tlv12; tlv12 = (char *)(dive -> location); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(dive -> location); }
    {char * tlv34; tlv34 = (char *)(dive -> location); }
    {char * tlv36; tlv36 = (char *)(dive -> location); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(dive -> location); }
    {char * tlv38; tlv38 = (char *)(dive -> location); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(dive -> location); }
    {char * tlv40; tlv40 = (char *)(dive -> location); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(dive -> location); }
    {char * tlv42; tlv42 = (char *)(dive -> location); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(dive -> location); }
    {char * tlv44; tlv44 = (char *)(dive -> location); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(dive -> location); }
    {char * tlv46; tlv46 = (char *)(dive -> location); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(dive -> location); }
    {char * tlv48; tlv48 = (char *)(dive -> location); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(dive -> location); }
    {char * tlv67; tlv67 = (char *)(dive -> location); }
    {char * tlv51; tlv51 = (char *)(dive -> location); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(dive -> location); }
    {char * tlv54; tlv54 = (char *)(dive -> location); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(dive -> location); }
    {char * tlv57; tlv57 = (char *)(dive -> location); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(dive -> location); }
    {char * tlv60; tlv60 = (char *)(dive -> location); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(dive -> location); }
}
void fix_ingred_edit_dives_1_28(){
fix_ingred_edit_dives_1_28_0();
}
void fix_ingred_edit_dives_1_44_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(13); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(13); }
    {cgc_size_t count; count = (cgc_size_t)(13); }
    {char * tlv28; tlv28 = (char *)(13); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(13); }
    {char * tlv30; tlv30 = (char *)(13); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(13); }
    {char * tlv32; tlv32 = (char *)(13); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(13); }
    {char * tlv9; tlv9 = (char *)(13); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(13); }
    {char * tlv12; tlv12 = (char *)(13); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(13); }
    {char * tlv34; tlv34 = (char *)(13); }
    {char * tlv36; tlv36 = (char *)(13); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(13); }
    {char * tlv38; tlv38 = (char *)(13); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(13); }
    {char * tlv40; tlv40 = (char *)(13); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(13); }
    {char * tlv42; tlv42 = (char *)(13); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(13); }
    {char * tlv44; tlv44 = (char *)(13); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(13); }
    {char * tlv46; tlv46 = (char *)(13); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(13); }
    {char * tlv48; tlv48 = (char *)(13); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(13); }
    {char * tlv67; tlv67 = (char *)(13); }
    {char * tlv51; tlv51 = (char *)(13); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(13); }
    {char * tlv54; tlv54 = (char *)(13); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(13); }
    {char * tlv57; tlv57 = (char *)(13); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(13); }
    {char * tlv60; tlv60 = (char *)(13); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(13); }
}
void fix_ingred_edit_dives_1_44(){
fix_ingred_edit_dives_1_44_1();
}
void fix_ingred_edit_dives_1_50_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(11); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(11); }
    {cgc_size_t count; count = (cgc_size_t)(11); }
    {char * tlv28; tlv28 = (char *)(11); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(11); }
    {char * tlv30; tlv30 = (char *)(11); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(11); }
    {char * tlv32; tlv32 = (char *)(11); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(11); }
    {char * tlv9; tlv9 = (char *)(11); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(11); }
    {char * tlv12; tlv12 = (char *)(11); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(11); }
    {char * tlv34; tlv34 = (char *)(11); }
    {char * tlv36; tlv36 = (char *)(11); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(11); }
    {char * tlv38; tlv38 = (char *)(11); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(11); }
    {char * tlv40; tlv40 = (char *)(11); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(11); }
    {char * tlv42; tlv42 = (char *)(11); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(11); }
    {char * tlv44; tlv44 = (char *)(11); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(11); }
    {char * tlv46; tlv46 = (char *)(11); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(11); }
    {char * tlv48; tlv48 = (char *)(11); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(11); }
    {char * tlv67; tlv67 = (char *)(11); }
    {char * tlv51; tlv51 = (char *)(11); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(11); }
    {char * tlv54; tlv54 = (char *)(11); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(11); }
    {char * tlv57; tlv57 = (char *)(11); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(11); }
    {char * tlv60; tlv60 = (char *)(11); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(11); }
}
void fix_ingred_edit_dives_1_50(){
fix_ingred_edit_dives_1_50_1();
}
void fix_ingred_edit_dives_1_56_1(){
    {char buffer [ 1024 ]; buffer [ ( 1024 )-1 ] = (char)(20); }
    {char buf2 [ 1024 ]; buf2 [ ( 1024 )-1 ] = (char)(20); }
    {cgc_size_t count; count = (cgc_size_t)(20); }
    {char * tlv28; tlv28 = (char *)(20); }
    {cgc_size_t tlv27; tlv27 = (cgc_size_t)(20); }
    {char * tlv30; tlv30 = (char *)(20); }
    {cgc_size_t tlv29; tlv29 = (cgc_size_t)(20); }
    {char * tlv32; tlv32 = (char *)(20); }
    {cgc_size_t tlv31; tlv31 = (cgc_size_t)(20); }
    {char * tlv9; tlv9 = (char *)(20); }
    {cgc_size_t tlv7; tlv7 = (cgc_size_t)(20); }
    {char * tlv12; tlv12 = (char *)(20); }
    {cgc_size_t tlv10; tlv10 = (cgc_size_t)(20); }
    {char * tlv34; tlv34 = (char *)(20); }
    {char * tlv36; tlv36 = (char *)(20); }
    {cgc_size_t tlv35; tlv35 = (cgc_size_t)(20); }
    {char * tlv38; tlv38 = (char *)(20); }
    {cgc_size_t tlv37; tlv37 = (cgc_size_t)(20); }
    {char * tlv40; tlv40 = (char *)(20); }
    {cgc_size_t tlv39; tlv39 = (cgc_size_t)(20); }
    {char * tlv42; tlv42 = (char *)(20); }
    {cgc_size_t tlv41; tlv41 = (cgc_size_t)(20); }
    {char * tlv44; tlv44 = (char *)(20); }
    {cgc_size_t tlv43; tlv43 = (cgc_size_t)(20); }
    {char * tlv46; tlv46 = (char *)(20); }
    {cgc_size_t tlv45; tlv45 = (cgc_size_t)(20); }
    {char * tlv48; tlv48 = (char *)(20); }
    {cgc_size_t tlv47; tlv47 = (cgc_size_t)(20); }
    {char * tlv67; tlv67 = (char *)(20); }
    {char * tlv51; tlv51 = (char *)(20); }
    {cgc_size_t tlv49; tlv49 = (cgc_size_t)(20); }
    {char * tlv54; tlv54 = (char *)(20); }
    {cgc_size_t tlv52; tlv52 = (cgc_size_t)(20); }
    {char * tlv57; tlv57 = (char *)(20); }
    {cgc_size_t tlv55; tlv55 = (cgc_size_t)(20); }
    {char * tlv60; tlv60 = (char *)(20); }
    {cgc_size_t tlv58; tlv58 = (cgc_size_t)(20); }
}
void fix_ingred_edit_dives_1_56(){
fix_ingred_edit_dives_1_56_1();
}
void fix_ingred_edit_dives_1(){
fix_ingred_edit_dives_1_4();
fix_ingred_edit_dives_1_5();
fix_ingred_edit_dives_1_6();
fix_ingred_edit_dives_1_10();
fix_ingred_edit_dives_1_12();
fix_ingred_edit_dives_1_16();
fix_ingred_edit_dives_1_18();
fix_ingred_edit_dives_1_19();
fix_ingred_edit_dives_1_21();
fix_ingred_edit_dives_1_26();
fix_ingred_edit_dives_1_28();
fix_ingred_edit_dives_1_44();
fix_ingred_edit_dives_1_50();
fix_ingred_edit_dives_1_56();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_edit_dives_1_4_0();
void fix_ingred_edit_dives_1_4_1();
void fix_ingred_edit_dives_1_4();
void fix_ingred_edit_dives_1_5_0();
void fix_ingred_edit_dives_1_5_1();
void fix_ingred_edit_dives_1_5();
void fix_ingred_edit_dives_1_6_0();
void fix_ingred_edit_dives_1_6();
void fix_ingred_edit_dives_1_10_1();
void fix_ingred_edit_dives_1_10();
void fix_ingred_edit_dives_1_12_0();
void fix_ingred_edit_dives_1_12();
void fix_ingred_edit_dives_1_16_0();
void fix_ingred_edit_dives_1_16_1();
void fix_ingred_edit_dives_1_16();
void fix_ingred_edit_dives_1_18_0();
void fix_ingred_edit_dives_1_18();
void fix_ingred_edit_dives_1_19_1();
void fix_ingred_edit_dives_1_19();
void fix_ingred_edit_dives_1_21_1();
void fix_ingred_edit_dives_1_21();
void fix_ingred_edit_dives_1_26_1();
void fix_ingred_edit_dives_1_26();
void fix_ingred_edit_dives_1_28_0();
void fix_ingred_edit_dives_1_28();
void fix_ingred_edit_dives_1_44_1();
void fix_ingred_edit_dives_1_44();
void fix_ingred_edit_dives_1_50_1();
void fix_ingred_edit_dives_1_50();
void fix_ingred_edit_dives_1_56_1();
void fix_ingred_edit_dives_1_56();
void fix_ingred_edit_dives_1();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_edit_dives_0_0_1
- fix_ingred_edit_dives_0_0_2
- fix_ingred_edit_dives_0_0
- fix_ingred_edit_dives_0_6_0
- fix_ingred_edit_dives_0_6_1
- fix_ingred_edit_dives_0_6
- fix_ingred_edit_dives_0_7_3
- fix_ingred_edit_dives_0_7
- fix_ingred_edit_dives_0_9_6
- fix_ingred_edit_dives_0_9_7
- fix_ingred_edit_dives_0_9
- fix_ingred_edit_dives_0
- fix_ingred_edit_dives_1_4_0
- fix_ingred_edit_dives_1_4_1
- fix_ingred_edit_dives_1_4
- fix_ingred_edit_dives_1_5_0
- fix_ingred_edit_dives_1_5_1
- fix_ingred_edit_dives_1_5
- fix_ingred_edit_dives_1_6_0
- fix_ingred_edit_dives_1_6
- fix_ingred_edit_dives_1_10_1
- fix_ingred_edit_dives_1_10
- fix_ingred_edit_dives_1_12_0
- fix_ingred_edit_dives_1_12
- fix_ingred_edit_dives_1_16_0
- fix_ingred_edit_dives_1_16_1
- fix_ingred_edit_dives_1_16
- fix_ingred_edit_dives_1_18_0
- fix_ingred_edit_dives_1_18
- fix_ingred_edit_dives_1_19_1
- fix_ingred_edit_dives_1_19
- fix_ingred_edit_dives_1_21_1
- fix_ingred_edit_dives_1_21
- fix_ingred_edit_dives_1_26_1
- fix_ingred_edit_dives_1_26
- fix_ingred_edit_dives_1_28_0
- fix_ingred_edit_dives_1_28
- fix_ingred_edit_dives_1_44_1
- fix_ingred_edit_dives_1_44
- fix_ingred_edit_dives_1_50_1
- fix_ingred_edit_dives_1_50
- fix_ingred_edit_dives_1_56_1
- fix_ingred_edit_dives_1_56
- fix_ingred_edit_dives_1
