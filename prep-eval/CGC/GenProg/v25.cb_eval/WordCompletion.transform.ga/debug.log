[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_strlen ( char * str )')]
ParameterDeclaration : type = char *, var = str [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['str']
[enterParameterDeclaration] char * : str
sym_dict [str] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = cgc_size_t 
var: ret (ret) = 0
var: cgc_size_t ret (ret) = 0
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => str == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => str
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => str == NULL
=> ['str', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : str
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['str']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['str']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['str']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['str']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['str']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['str']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['str']
FOUND IT! [2.2]  char * : str
Resolved type: [2.3]  char * : str
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ str == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( str == NULL ) { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: ret (ret) = 0
var: cgc_size_t ret (ret) = 0
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => str [ ret ] != '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => str [ ret ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => str [ ret ] != '\0'
=> ['str [ ret ]', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : str [ ret ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['str [ ret ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['str [ ret ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['str [ ret ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['str [ ret ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['str [ ret ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['str [ ret ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['str', '[', 'ret', ']']
FOUND IT! [2.2]  char * : str
Resolved type: [2.3]  char * : str
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( str == NULL ) { return ( 0 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } ]
Assigns = [('cgc_size_t', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_strlen ( char * str ) { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_transmit_all ( char * buf , cgc_size_t size )')]
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
ParameterDeclaration : type = cgc_size_t, var = size [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['size']
[enterParameterDeclaration] cgc_size_t : size
sym_dict [size] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t rx_bytes'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rx_bytes] = cgc_size_t 
var: rx_bytes (rx_bytes) = 0
var: cgc_size_t rx_bytes (rx_bytes) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t total'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [total] = cgc_size_t 
var: total (total) = 0
var: cgc_size_t total (total) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => buf == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => buf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => buf == NULL
=> ['buf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : buf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['buf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['buf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['buf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['buf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['buf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['buf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['buf']
FOUND IT! [2.2]  char * : buf
Resolved type: [2.3]  char * : buf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ buf == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( buf == NULL ) { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = STDOUT
var: int tlv4 (tlv4) = STDOUT
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = buf
var: void * tlv3 (tlv3) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = size - total
var: cgc_size_t tlv2 (tlv2) = size - total
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t * 
var: tlv1 (tlv1) = & rx_bytes
var: cgc_size_t * tlv1 (tlv1) = & rx_bytes
var: ret (ret) = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 )
var: int ret (ret) = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv4', '', 'STDOUT'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('int', 'ret', '', 'cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => rx_bytes == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => rx_bytes
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => rx_bytes == 0
=> ['rx_bytes', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : rx_bytes
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['rx_bytes']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['rx_bytes']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['rx_bytes']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['rx_bytes']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['rx_bytes']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['rx_bytes']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['rx_bytes']
FOUND IT! [2.2]  cgc_size_t : rx_bytes
Resolved type: [2.3]  cgc_size_t : rx_bytes
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( ret != 0 ) || ( rx_bytes == 0 ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 1
var: unsigned int tlv5 (tlv5) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ]
var: total (total) = rx_bytes
var: cgc_size_t total (total) = rx_bytes
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ]
Assigns = [('cgc_size_t', 'total', '', 'rx_bytes')]
Compares = []
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => total < size
[0] <class 'CParser.CParser.ShiftExpressionContext'> => total
[2] <class 'CParser.CParser.ShiftExpressionContext'> => size
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => total < size
=> ['total', 'size']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : total
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['total']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['total']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['total']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['total']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['total']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['total']
FOUND IT! [1.2]  cgc_size_t : total
Resolved type: [1.3]  cgc_size_t : total
Descendants of <class 'CParser.CParser.IterationStatementContext'> : do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( buf == NULL ) { return ( 0 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; ]
Assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_transmit_all ( char * buf , cgc_size_t size ) { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_transmit_str ( char * buf )')]
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t len'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [len] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = char * 
var: tlv1 (tlv1) = buf
var: char * tlv1 (tlv1) = buf
var: len (len) = cgc_strlen ( tlv1 )
var: cgc_size_t len (len) = cgc_strlen ( tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; }
Assigns = [('char *', 'tlv1', '', 'buf'), ('cgc_size_t', 'len', '', 'cgc_strlen ( tlv1 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_transmit_str ( char * buf ) { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_receive_all ( char * buf , cgc_size_t size )')]
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
ParameterDeclaration : type = cgc_size_t, var = size [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['size']
[enterParameterDeclaration] cgc_size_t : size
sym_dict [size] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t rx_bytes'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rx_bytes] = cgc_size_t 
var: rx_bytes (rx_bytes) = 0
var: cgc_size_t rx_bytes (rx_bytes) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t total'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [total] = cgc_size_t 
var: total (total) = 0
var: cgc_size_t total (total) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => buf == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => buf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => buf == NULL
=> ['buf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : buf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['buf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['buf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['buf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['buf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['buf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['buf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['buf']
FOUND IT! [2.2]  char * : buf
Resolved type: [2.3]  char * : buf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ buf == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( buf == NULL ) { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = STDIN
var: int tlv4 (tlv4) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = buf
var: void * tlv3 (tlv3) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = size - total
var: cgc_size_t tlv2 (tlv2) = size - total
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t * 
var: tlv1 (tlv1) = & rx_bytes
var: cgc_size_t * tlv1 (tlv1) = & rx_bytes
var: ret (ret) = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 )
var: int ret (ret) = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('int', 'ret', '', 'cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => rx_bytes == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => rx_bytes
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => rx_bytes == 0
=> ['rx_bytes', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : rx_bytes
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['rx_bytes']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['rx_bytes']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['rx_bytes']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['rx_bytes']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['rx_bytes']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['rx_bytes']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['rx_bytes']
FOUND IT! [2.2]  cgc_size_t : rx_bytes
Resolved type: [2.3]  cgc_size_t : rx_bytes
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( ret != 0 ) || ( rx_bytes == 0 ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 1
var: unsigned int tlv5 (tlv5) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ]
var: total (total) = rx_bytes
var: cgc_size_t total (total) = rx_bytes
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ]
Assigns = [('cgc_size_t', 'total', '', 'rx_bytes')]
Compares = []
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => total < size
[0] <class 'CParser.CParser.ShiftExpressionContext'> => total
[2] <class 'CParser.CParser.ShiftExpressionContext'> => size
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => total < size
=> ['total', 'size']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : total
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['total']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['total']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['total']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['total']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['total']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['total']
FOUND IT! [1.2]  cgc_size_t : total
Resolved type: [1.3]  cgc_size_t : total
Descendants of <class 'CParser.CParser.IterationStatementContext'> : do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( buf == NULL ) { return ( 0 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; ]
Assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_receive_all ( char * buf , cgc_size_t size ) { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_readline ( char * buf , cgc_size_t len )')]
ParameterDeclaration : type = char *, var = buf [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['buf']
[enterParameterDeclaration] char * : buf
sym_dict [buf] = char * 
ParameterDeclaration : type = cgc_size_t, var = len [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['len']
[enterParameterDeclaration] cgc_size_t : len
sym_dict [len] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => buf == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => buf
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => buf == NULL
=> ['buf', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : buf
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['buf']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['buf']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['buf']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['buf']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['buf']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['buf']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['buf']
FOUND IT! [2.2]  char * : buf
Resolved type: [2.3]  char * : buf
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ buf == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( buf == NULL ) { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t count'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [count] = cgc_size_t 
var: count (count) = 0
var: cgc_size_t count (count) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char c'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [c] = char 
var: c (c) = 0
var: char c (c) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t rx_bytes'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [rx_bytes] = cgc_size_t 
var: rx_bytes (rx_bytes) = 0
var: cgc_size_t rx_bytes (rx_bytes) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = int 
var: tlv4 (tlv4) = STDIN
var: int tlv4 (tlv4) = STDIN
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = void * 
var: tlv3 (tlv3) = & c
var: void * tlv3 (tlv3) = & c
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = cgc_size_t 
var: tlv2 (tlv2) = 1
var: cgc_size_t tlv2 (tlv2) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = cgc_size_t * 
var: tlv1 (tlv1) = & rx_bytes
var: cgc_size_t * tlv1 (tlv1) = & rx_bytes
var: ret (ret) = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 )
var: int ret (ret) = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', '& c'), ('cgc_size_t', 'tlv2', '', '1'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('int', 'ret', '', 'cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => rx_bytes == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => rx_bytes
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => rx_bytes == 0
=> ['rx_bytes', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : rx_bytes
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['rx_bytes']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['rx_bytes']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['rx_bytes']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['rx_bytes']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['rx_bytes']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['rx_bytes']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['rx_bytes']
FOUND IT! [2.2]  cgc_size_t : rx_bytes
Resolved type: [2.3]  cgc_size_t : rx_bytes
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( ret != 0 ) || ( rx_bytes == 0 ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'unsigned int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = unsigned int 
var: tlv5 (tlv5) = 1
var: unsigned int tlv5 (tlv5) = 1
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc__terminate'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv5 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
Assigns = [('unsigned int', 'tlv5', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ]
var: buf  (buf [ count ]) = c
var: UNDEF buf  (buf [ count ]) = c
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ]
Assigns = [('UNDEF', 'buf ', '[ count ]', 'c')]
Compares = []
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => c != '\n'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => c
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\n'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => c != '\n'
=> ['c', "'\\n'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : c
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['c']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [2.2]  char : c
Resolved type: [2.3]  char : c
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => count < len
[0] <class 'CParser.CParser.ShiftExpressionContext'> => count
[2] <class 'CParser.CParser.ShiftExpressionContext'> => len
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => count < len
=> ['count', 'len']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : count
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['count']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['count']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['count']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['count']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['count']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['count']
FOUND IT! [1.2]  cgc_size_t : count
Resolved type: [1.3]  cgc_size_t : count
Descendants of <class 'CParser.CParser.IterationStatementContext'> : do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ;
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( buf == NULL ) { return ( 0 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; ]
Assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_readline ( char * buf , cgc_size_t len ) { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_rotN ( char c , int n )')]
ParameterDeclaration : type = char, var = c [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['c']
[enterParameterDeclaration] char : c
sym_dict [c] = char 
ParameterDeclaration : type = int, var = n [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['n']
[enterParameterDeclaration] int : n
sym_dict [n] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int temp'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [temp] = int 
var: temp (temp) = 0
var: int temp (temp) = 0
var: n (n) = n % VALID_CHARS_LEN
var: int n (n) = n % VALID_CHARS_LEN
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c >= 'a'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 'a'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c >= 'a'
=> ['c', "'a'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [1.2]  char : c
Resolved type: [1.3]  char : c
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c <= 'z'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 'z'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c <= 'z'
=> ['c', "'z'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [1.2]  char : c
Resolved type: [1.3]  char : c
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c >= 'a' ) && ( c <= 'z' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: temp (temp) = c - 'a'
var: int temp (temp) = c - 'a'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { temp = c - 'a' ; ; }
Assigns = [('int', 'temp', '', "c - 'a'")]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c >= 'a' ) && ( c <= 'z' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { temp = c - 'a' ; ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c >= 'A'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 'A'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c >= 'A'
=> ['c', "'A'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [1.2]  char : c
Resolved type: [1.3]  char : c
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c <= 'Z'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c
[2] <class 'CParser.CParser.ShiftExpressionContext'> => 'Z'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c <= 'Z'
=> ['c', "'Z'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [1.2]  char : c
Resolved type: [1.3]  char : c
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c >= 'A' ) && ( c <= 'Z' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: temp (temp) = c - 'A' + 26
var: int temp (temp) = c - 'A' + 26
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { temp = c - 'A' + 26 ; }
Assigns = [('int', 'temp', '', "c - 'A' + 26")]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c >= 'A' ) && ( c <= 'Z' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { temp = c - 'A' + 26 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c >= '0'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c
[2] <class 'CParser.CParser.ShiftExpressionContext'> => '0'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c >= '0'
=> ['c', "'0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [1.2]  char : c
Resolved type: [1.3]  char : c
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c <= '9'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c
[2] <class 'CParser.CParser.ShiftExpressionContext'> => '9'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c <= '9'
=> ['c', "'9'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c']
FOUND IT! [1.2]  char : c
Resolved type: [1.3]  char : c
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c >= '0' ) && ( c <= '9' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: temp (temp) = c - '0' + 52
var: int temp (temp) = c - '0' + 52
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { temp = c - '0' + 52 ; }
Assigns = [('int', 'temp', '', "c - '0' + 52")]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c >= '0' ) && ( c <= '9' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { temp = c - '0' + 52 ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( c ) ; ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { temp = c - '0' + 52 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( c ) ; ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { temp = c - 'A' + 26 ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { temp = c - 'a' ; ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } ]
var: temp (temp) = n
var: int temp (temp) = n
var: temp (temp) = temp % VALID_CHARS_LEN
var: int temp (temp) = temp % VALID_CHARS_LEN
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } ]
Assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN'), ('int', 'temp', '', 'n'), ('int', 'temp', '', 'temp % VALID_CHARS_LEN')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : char cgc_rotN ( char c , int n ) { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'cgc_size_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_strrotcpy ( char * dst , char * src , int rot )')]
ParameterDeclaration : type = char *, var = dst [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['dst']
[enterParameterDeclaration] char * : dst
sym_dict [dst] = char * 
ParameterDeclaration : type = char *, var = src [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['src']
[enterParameterDeclaration] char * : src
sym_dict [src] = char * 
ParameterDeclaration : type = int, var = rot [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['rot']
[enterParameterDeclaration] int : rot
sym_dict [rot] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => src == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => src
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => src == NULL
=> ['src', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : src
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['src']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['src']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['src']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['src']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['src']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['src']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['src']
FOUND IT! [2.2]  char * : src
Resolved type: [2.3]  char * : src
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => dst == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => dst
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => dst == NULL
=> ['dst', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : dst
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['dst']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['dst']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['dst']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['dst']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['dst']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['dst']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['dst']
FOUND IT! [2.2]  char * : dst
Resolved type: [2.3]  char * : dst
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( src == NULL ) || ( dst == NULL ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = cgc_size_t 
var: ret (ret) = 0
var: cgc_size_t ret (ret) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: ret (ret) = 0
var: cgc_size_t ret (ret) = 0
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => src [ ret ] != '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => src [ ret ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => src [ ret ] != '\0'
=> ['src [ ret ]', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : src [ ret ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['src [ ret ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['src [ ret ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['src [ ret ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['src [ ret ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['src [ ret ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['src [ ret ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['src', '[', 'ret', ']']
FOUND IT! [2.2]  char * : src
Resolved type: [2.3]  char * : src
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = char 
var: tlv2 (tlv2) = src [ ret ]
var: char tlv2 (tlv2) = src [ ret ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
var: tlv1 (tlv1) = rot
var: int tlv1 (tlv1) = rot
var: dst  (dst [ ret ]) = cgc_rotN ( tlv2 , tlv1 )
var: UNDEF dst  (dst [ ret ]) = cgc_rotN ( tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; }
Assigns = [('char', 'tlv2', '', 'src [ ret ]'), ('int', 'tlv1', '', 'rot'), ('UNDEF', 'dst ', '[ ret ]', 'cgc_rotN ( tlv2 , tlv1 )')]
Compares = []
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } ]
var: dst  (dst [ ret ]) = '\0'
var: UNDEF dst  (dst [ ret ]) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } ]
 1 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } ]
Assigns = [('cgc_size_t', 'ret', '', '0'), ('UNDEF', 'dst ', '[ ret ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : cgc_size_t cgc_strrotcpy ( char * dst , char * src , int rot ) { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; } ]
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : NULL
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : NULL
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_init ( int rot )')]
ParameterDeclaration : type = int, var = rot [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['rot']
[enterParameterDeclaration] int : rot
sym_dict [rot] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t numWords'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [numWords] = cgc_size_t 
var: numWords (numWords) = NUM_WORDS
var: cgc_size_t numWords (numWords) = NUM_WORDS
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = cgc_size_t 
var: tlv3 (tlv3) = sizeof ( gSeedWords )
var: cgc_size_t tlv3 (tlv3) = sizeof ( gSeedWords )
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
var: tlv2 (tlv2) = 0
var: int tlv2 (tlv2) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * * tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = void * * 
var: tlv1 (tlv1) = ( void * * ) ( & cgc_gWords )
var: void * * tlv1 (tlv1) = ( void * * ) ( & cgc_gWords )
var: ret (ret) = cgc_allocate ( tlv3 , tlv2 , tlv1 )
var: int ret (ret) = cgc_allocate ( tlv3 , tlv2 , tlv1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; }
Assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( gSeedWords )'), ('int', 'tlv2', '', '0'), ('void * *', 'tlv1', '', '( void * * ) ( & cgc_gWords )'), ('int', 'ret', '', 'cgc_allocate ( tlv3 , tlv2 , tlv1 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( ret ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { return ( ret ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( ret ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t total'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [total] = cgc_size_t 
var: total (total) = 0
var: cgc_size_t total (total) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < numWords
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => numWords
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < numWords
=> ['i', 'numWords']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = gSeedWords [ i ]
var: char * tlv7 (tlv7) = gSeedWords [ i ]
var: total (total) = cgc_strlen ( tlv7 )
var: cgc_size_t total (total) = cgc_strlen ( tlv7 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; }
Assigns = [('char *', 'tlv7', '', 'gSeedWords [ i ]'), ('cgc_size_t', 'total', '', 'cgc_strlen ( tlv7 )')]
Compares = []
var: total (total) = 1
var: cgc_size_t total (total) = 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } ]
Assigns = [('cgc_size_t', 'total', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = cgc_size_t 
var: tlv6 (tlv6) = total
var: cgc_size_t tlv6 (tlv6) = total
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = int 
var: tlv5 (tlv5) = 0
var: int tlv5 (tlv5) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'void * * tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = void * * 
var: tlv4 (tlv4) = ( void * * ) ( & cgc_gWordData )
var: void * * tlv4 (tlv4) = ( void * * ) ( & cgc_gWordData )
var: ret (ret) = cgc_allocate ( tlv6 , tlv5 , tlv4 )
var: int ret (ret) = cgc_allocate ( tlv6 , tlv5 , tlv4 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }
Assigns = [('cgc_size_t', 'tlv6', '', 'total'), ('int', 'tlv5', '', '0'), ('void * *', 'tlv4', '', '( void * * ) ( & cgc_gWordData )'), ('int', 'ret', '', 'cgc_allocate ( tlv6 , tlv5 , tlv4 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => ret
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => ret != 0
=> ['ret', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : ret
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['ret']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['ret']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['ret']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['ret']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['ret']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['ret']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['ret']
FOUND IT! [2.2]  int : ret
Resolved type: [2.3]  int : ret
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ret != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( ret ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ret != 0 ) { return ( ret ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( ret ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t temp'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [temp] = cgc_size_t 
var: temp (temp) = 0
var: cgc_size_t temp (temp) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * pTemp'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [pTemp] = char * 
var: pTemp (pTemp) = cgc_gWordData
var: char * pTemp (pTemp) = cgc_gWordData
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < numWords
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => numWords
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < numWords
=> ['i', 'numWords']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: cgc_gWords  (cgc_gWords [ i ]) = pTemp
var: UNDEF cgc_gWords  (cgc_gWords [ i ]) = pTemp
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = char * 
var: tlv10 (tlv10) = pTemp
var: char * tlv10 (tlv10) = pTemp
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = char * 
var: tlv9 (tlv9) = gSeedWords [ i ]
var: char * tlv9 (tlv9) = gSeedWords [ i ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = int 
var: tlv8 (tlv8) = rot
var: int tlv8 (tlv8) = rot
var: pTemp (pTemp) = cgc_strrotcpy ( tlv10 , tlv9 , tlv8 )
var: char * pTemp (pTemp) = cgc_strrotcpy ( tlv10 , tlv9 , tlv8 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; }
Assigns = [('char *', 'tlv10', '', 'pTemp'), ('char *', 'tlv9', '', 'gSeedWords [ i ]'), ('int', 'tlv8', '', 'rot'), ('char *', 'pTemp', '', 'cgc_strrotcpy ( tlv10 , tlv9 , tlv8 )')]
Compares = []
var: pTemp (pTemp) = 1
var: char * pTemp (pTemp) = 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } ]
Assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', 'pTemp'), ('char *', 'pTemp', '', '1')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } ]
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < ( PAGE_SIZE / sizeof ( char * ) )
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => ( PAGE_SIZE / sizeof ( char * ) )
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < ( PAGE_SIZE / sizeof ( char * ) )
=> ['i', '( PAGE_SIZE / sizeof ( char * ) )']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
var: cgc_gWords  (cgc_gWords [ i ]) = 0
var: UNDEF cgc_gWords  (cgc_gWords [ i ]) = 0
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_gWords [ i ] = 0 ; }
Assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', '0')]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_gWords [ i ] = 0 ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { return ( ret ) ; } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ret != 0 ) { return ( ret ) ; } ]
 5 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } ]
 6 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } ]
Assigns = [('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_init ( int rot ) { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_toInt ( char c1 , char c2 )')]
ParameterDeclaration : type = char, var = c1 [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['c1']
[enterParameterDeclaration] char : c1
sym_dict [c1] = char 
ParameterDeclaration : type = char, var = c2 [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['c2']
[enterParameterDeclaration] char : c2
sym_dict [c2] = char 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c1 >= '0'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c1
[2] <class 'CParser.CParser.ShiftExpressionContext'> => '0'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c1 >= '0'
=> ['c1', "'0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c1
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c1']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c1']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c1']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c1']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c1']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c1']
FOUND IT! [1.2]  char : c1
Resolved type: [1.3]  char : c1
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c1 <= '9'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c1
[2] <class 'CParser.CParser.ShiftExpressionContext'> => '9'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c1 <= '9'
=> ['c1', "'9'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c1
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c1']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c1']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c1']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c1']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c1']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c1']
FOUND IT! [1.2]  char : c1
Resolved type: [1.3]  char : c1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c1 >= '0' ) && ( c1 <= '9' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = c1 - '0'
var: int ret (ret) = c1 - '0'
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c2 >= '0'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c2
[2] <class 'CParser.CParser.ShiftExpressionContext'> => '0'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c2 >= '0'
=> ['c2', "'0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c2
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c2']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c2']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c2']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c2']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c2']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c2']
FOUND IT! [1.2]  char : c2
Resolved type: [1.3]  char : c2
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => c2 <= '9'
[0] <class 'CParser.CParser.ShiftExpressionContext'> => c2
[2] <class 'CParser.CParser.ShiftExpressionContext'> => '9'
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => c2 <= '9'
=> ['c2', "'9'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : c2
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c2']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c2']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c2']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c2']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c2']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c2']
FOUND IT! [1.2]  char : c2
Resolved type: [1.3]  char : c2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c2 >= '0' ) && ( c2 <= '9' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: ret (ret) = 10
var: int ret (ret) = 10
var: ret (ret) = c2 - '0'
var: int ret (ret) = c2 - '0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; }
Assigns = [('int', 'ret', '', '10'), ('int', 'ret', '', "c2 - '0'")]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ ( c2 >= '0' ) && ( c2 <= '9' ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => c2 != '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => c2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => c2 != '\0'
=> ['c2', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : c2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['c2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['c2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['c2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['c2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['c2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['c2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['c2']
FOUND IT! [2.2]  char : c2
Resolved type: [2.3]  char : c2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ c2 != '\0' ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( ret ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ c2 != '\0' ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return ( ret ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( ret ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } ]
Assigns = [('int', 'ret', '', "c1 - '0'")]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } ]
Assigns = [('int', 'ret', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_toInt ( char c1 , char c2 ) { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; } ]
[WARNING] : self.current_scope = 'None'
[WARNING] : self.cur_symbol_lut[self.current_scope] = 'None'
[WARNING] ctx : 0xDA2bAC9C
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'uint32_t'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_RANDOM ( )')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
var: gRandRegister (gRandRegister) = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 )
var: UNDEF gRandRegister (gRandRegister) = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; }
Assigns = [('UNDEF', 'gRandRegister', '', '( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 )')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : uint32_t cgc_RANDOM ( ) { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_strcmp ( char * s1 , char * s2 )')]
ParameterDeclaration : type = char *, var = s1 [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['s1']
[enterParameterDeclaration] char * : s1
sym_dict [s1] = char * 
ParameterDeclaration : type = char *, var = s2 [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['s2']
[enterParameterDeclaration] char * : s2
sym_dict [s2] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => s1 == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => s1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => s1 == NULL
=> ['s1', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : s1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['s1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['s1']
FOUND IT! [2.2]  char * : s1
Resolved type: [2.3]  char * : s1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s1 == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => s2 == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => s2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => s2 == NULL
=> ['s2', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : s2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['s2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['s2']
FOUND IT! [2.2]  char * : s2
Resolved type: [2.3]  char * : s2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s2 == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s2 == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return ( 0 ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( - 1 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( - 1 ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => s2 == NULL
[0] <class 'CParser.CParser.RelationalExpressionContext'> => s2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => NULL
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => s2 == NULL
=> ['s2', 'NULL']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : s2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['s2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['s2']
FOUND IT! [2.2]  char * : s2
Resolved type: [2.3]  char * : s2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s2 == NULL ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 1 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s2 == NULL ) { return ( 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 1 ) ; } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => s1 [ i ] != '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => s1 [ i ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => s1 [ i ] != '\0'
=> ['s1 [ i ]', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : s1 [ i ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['s1 [ i ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s1 [ i ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s1 [ i ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s1 [ i ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s1 [ i ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s1 [ i ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['s1', '[', 'i', ']']
FOUND IT! [2.2]  char * : s1
Resolved type: [2.3]  char * : s1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => s2 [ i ] == '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => s2 [ i ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => s2 [ i ] == '\0'
=> ['s2 [ i ]', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : s2 [ i ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['s2 [ i ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s2 [ i ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s2 [ i ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s2 [ i ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s2 [ i ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s2 [ i ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['s2', '[', 'i', ']']
FOUND IT! [2.2]  char * : s2
Resolved type: [2.3]  char * : s2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s2 [ i ] == '\0' ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 1 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s2 [ i ] == '\0' ) { return ( 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 1 ) ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => s1 [ i ] < s2 [ i ]
[0] <class 'CParser.CParser.ShiftExpressionContext'> => s1 [ i ]
[2] <class 'CParser.CParser.ShiftExpressionContext'> => s2 [ i ]
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => s1 [ i ] < s2 [ i ]
=> ['s1 [ i ]', 's2 [ i ]']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : s1 [ i ]
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s1 [ i ]']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s1 [ i ]']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s1 [ i ]']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s1 [ i ]']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s1 [ i ]']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['s1', '[', 'i', ']']
FOUND IT! [1.2]  char * : s1
Resolved type: [1.3]  char * : s1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s1 [ i ] < s2 [ i ] ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( - 1 ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s1 [ i ] < s2 [ i ] ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { return ( - 1 ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => s1 [ i ] > s2 [ i ]
[0] <class 'CParser.CParser.ShiftExpressionContext'> => s1 [ i ]
[2] <class 'CParser.CParser.ShiftExpressionContext'> => s2 [ i ]
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => s1 [ i ] > s2 [ i ]
=> ['s1 [ i ]', 's2 [ i ]']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : s1 [ i ]
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s1 [ i ]']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s1 [ i ]']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s1 [ i ]']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s1 [ i ]']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s1 [ i ]']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['s1', '[', 'i', ']']
FOUND IT! [1.2]  char * : s1
Resolved type: [1.3]  char * : s1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s1 [ i ] > s2 [ i ] ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 1 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 1 ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( - 1 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } ]
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => s2 [ i ] == '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => s2 [ i ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => s2 [ i ] == '\0'
=> ['s2 [ i ]', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : s2 [ i ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['s2 [ i ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['s2 [ i ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['s2 [ i ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['s2 [ i ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['s2 [ i ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['s2 [ i ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['s2', '[', 'i', ']']
FOUND IT! [2.2]  char * : s2
Resolved type: [2.3]  char * : s2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ s2 [ i ] == '\0' ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( s2 [ i ] == '\0' ) { return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( 0 ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } ]
 1 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s2 == NULL ) { return ( 1 ) ; } ]
 2 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } ]
 3 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } ]
Assigns = [('int', 'i', '', '0')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int cgc_strcmp ( char * s1 , char * s2 ) { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_my_srand ( uint32_t seed )')]
ParameterDeclaration : type = uint32_t, var = seed [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['seed']
[enterParameterDeclaration] uint32_t : seed
sym_dict [seed] = uint32_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
var: gRandRegister (gRandRegister) = seed
var: UNDEF gRandRegister (gRandRegister) = seed
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { gRandRegister = seed ; }
Assigns = [('UNDEF', 'gRandRegister', '', 'seed')]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_my_srand ( uint32_t seed ) { gRandRegister = seed ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { gRandRegister = seed ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'void'), (<class 'CParser.CParser.DeclaratorContext'>, 'cgc_scramble ( char * dst , char * src , cgc_size_t len )')]
ParameterDeclaration : type = char *, var = dst [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['dst']
[enterParameterDeclaration] char * : dst
sym_dict [dst] = char * 
ParameterDeclaration : type = char *, var = src [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['src']
[enterParameterDeclaration] char * : src
sym_dict [src] = char * 
ParameterDeclaration : type = cgc_size_t, var = len [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['len']
[enterParameterDeclaration] cgc_size_t : len
sym_dict [len] = cgc_size_t 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t r'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [r] = uint32_t 
var: r (r) = ( cgc_RANDOM ( ) % 3 ) + 2
var: uint32_t r (r) = ( cgc_RANDOM ( ) % 3 ) + 2
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => src [ i ] != '\0'
[0] <class 'CParser.CParser.RelationalExpressionContext'> => src [ i ]
[2] <class 'CParser.CParser.RelationalExpressionContext'> => '\0'
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => src [ i ] != '\0'
=> ['src [ i ]', "'\\0'"]
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : src [ i ]
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['src [ i ]']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['src [ i ]']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['src [ i ]']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['src [ i ]']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['src [ i ]']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['src [ i ]']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>, <class 'CParser.CParser.ExpressionContext'>, <class 'antlr4.tree.Tree.TerminalNodeImpl'>] ['src', '[', 'i', ']']
FOUND IT! [2.2]  char * : src
Resolved type: [2.3]  char * : src
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < len
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => len
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < len
=> ['i', 'len']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ IS_VALID_CHAR ( src [ i ] ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ i % r ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
var: dst  (dst [ i ]) = src [ i ]
var: UNDEF dst  (dst [ i ]) = src [ i ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { dst [ i ] = src [ i ] ; }
Assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ i % r ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { dst [ i ] = src [ i ] ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: dst  (dst [ i ]) = '_'
var: UNDEF dst  (dst [ i ]) = '_'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { dst [ i ] = '_' ; }
Assigns = [('UNDEF', 'dst ', '[ i ]', "'_'")]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { dst [ i ] = src [ i ] ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { dst [ i ] = '_' ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } ]
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ IS_VALID_CHAR ( src [ i ] ) ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: dst  (dst [ i ]) = src [ i ]
var: UNDEF dst  (dst [ i ]) = src [ i ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { dst [ i ] = src [ i ] ; }
Assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]')]
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { dst [ i ] = src [ i ] ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } ]
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } ]
var: dst  (dst [ i ]) = '\0'
var: UNDEF dst  (dst [ i ]) = '\0'
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; }
 0 : <class 'CParser.CParser.IterationStatementContext'>   [ while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } ]
Assigns = [('int', 'i', '', '0'), ('uint32_t', 'r', '', '( cgc_RANDOM ( ) % 3 ) + 2'), ('UNDEF', 'dst ', '[ i ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : void cgc_scramble ( char * dst , char * src , cgc_size_t len ) { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; } ]
[enterFunctionDefinition]
[(<class 'CParser.CParser.FuncDeclarationSpecifiersContext'>, 'int'), (<class 'CParser.CParser.DeclaratorContext'>, 'main ( int cgc_argc , char * cgc_argv [ ] )')]
ParameterDeclaration : type = int, var = cgc_argc [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cgc_argc']
[enterParameterDeclaration] int : cgc_argc
sym_dict [cgc_argc] = int 
ParameterDeclaration : type = char *, var = cgc_argv [ ] [type=<class 'CParser.CParser.DeclaratorContext'>]
 dec = ['cgc_argv [ ]']
[enterParameterDeclaration] char * : cgc_argv [ ]
sym_dict [cgc_argv] = char * * 
sym_dict [cgc_argv [ ]] = char * 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.FunctionDefinitionContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.FunctionDefinitionContext'>
 ===> Last 2 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.FunctionDefinitionContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.FunctionDefinitionContext'> 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char'), (<class 'CParser.CParser.InitDeclaratorListContext'>, 'buf [ BUF_SIZE ] = { }'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[A-t-3] sym_dict [buf] = char * 
[C-t-3] sym_dict [buf [ BUF_SIZE ]] = char 
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int i'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [i] = int 
var: i (i) = 0
var: int i (i) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int ret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [ret] = int 
var: ret (ret) = 0
var: int ret (ret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int temp'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [temp] = int 
var: temp (temp) = 0
var: int temp (temp) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t sret'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [sret] = cgc_size_t 
var: sret (sret) = 0
var: cgc_size_t sret (sret) = 0
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char c'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [c] = char 
var: c (c) = '\n'
var: char c (c) = '\n'
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( ENTER_NUM_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv11'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv11] = char 
var: tlv11 (tlv11) = buf [ 0 ]
var: char tlv11 (tlv11) = buf [ 0 ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv10'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv10] = char 
var: tlv10 (tlv10) = buf [ 1 ]
var: char tlv10 (tlv10) = buf [ 1 ]
var: i (i) = cgc_toInt ( tlv11 , tlv10 )
var: int i (i) = cgc_toInt ( tlv11 , tlv10 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; }
Assigns = [('char', 'tlv11', '', 'buf [ 0 ]'), ('char', 'tlv10', '', 'buf [ 1 ]'), ('int', 'i', '', 'cgc_toInt ( tlv11 , tlv10 )')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv1'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv1] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv12'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv12] = int 
var: tlv12 (tlv12) = i + 1
var: int tlv12 (tlv12) = i + 1
var: tlv1 (tlv1) = cgc_init ( tlv12 )
var: int tlv1 (tlv1) = cgc_init ( tlv12 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; }
Assigns = [('int', 'tlv12', '', 'i + 1'), ('int', 'tlv1', '', 'cgc_init ( tlv12 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv1
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv1 != 0
=> ['tlv1', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv1
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv1']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv1']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv1']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv1']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv1']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv1']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv1']
FOUND IT! [2.2]  int : tlv1
Resolved type: [2.3]  int : tlv1
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv1 != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { return ( - 1 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv1 != 0 ) { return ( - 1 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { return ( - 1 ) ; } ]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'uint32_t tlv4'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv4] = uint32_t 
var: tlv4 (tlv4) = * ( ( int * ) buf )
var: uint32_t tlv4 (tlv4) = * ( ( int * ) buf )
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_my_srand'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( tlv4 )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; }
Assigns = [('uint32_t', 'tlv4', '', '* ( ( int * ) buf )')]
Compares = []
0 : <class 'CParser.CParser.IterationStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.IterationStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.IterationStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
var: i (i) = 0
var: int i (i) = 0
[is_comparator] <class 'CParser.CParser.RelationalExpressionContext'> => i < NUM_ROUNDS
[0] <class 'CParser.CParser.ShiftExpressionContext'> => i
[2] <class 'CParser.CParser.ShiftExpressionContext'> => NUM_ROUNDS
[enterRelationalExpression] : <class 'CParser.CParser.RelationalExpressionContext'> => i < NUM_ROUNDS
=> ['i', 'NUM_ROUNDS']
[get_basic_type_or_expression]
<class 'CParser.CParser.ShiftExpressionContext'> : i
-<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
--<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
---<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
-----<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [1.2]  int : i
Resolved type: [1.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.IterationStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.IterationStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.IterationStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.IterationStatementContext'> 
 converged parent => <class 'CParser.CParser.IterationStatementContext'>
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => i == 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => i
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => i == 0
=> ['i', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : i
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['i']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['i']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['i']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['i']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['i']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['i']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['i']
FOUND IT! [2.2]  int : i
Resolved type: [2.3]  int : i
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ i == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( WORD_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_transmit_str ( WORD_MSG ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ i == 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_transmit_str ( WORD_MSG ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( NEXT_WORD_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_transmit_str ( NEXT_WORD_MSG ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_transmit_str ( WORD_MSG ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_transmit_str ( NEXT_WORD_MSG ) ; } ]
var: temp (temp) = cgc_RANDOM ( ) % NUM_WORDS
var: int temp (temp) = cgc_RANDOM ( ) % NUM_WORDS
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv19'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv19] = char * 
var: tlv19 (tlv19) = buf
var: char * tlv19 (tlv19) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv18'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv18] = char * 
var: tlv18 (tlv18) = cgc_gWords [ temp ]
var: char * tlv18 (tlv18) = cgc_gWords [ temp ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv17'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv17] = cgc_size_t 
var: tlv17 (tlv17) = BUF_SIZE
var: cgc_size_t tlv17 (tlv17) = BUF_SIZE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; }
Assigns = [('char *', 'tlv19', '', 'buf'), ('char *', 'tlv18', '', 'cgc_gWords [ temp ]'), ('cgc_size_t', 'tlv17', '', 'BUF_SIZE')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( buf )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv21'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv21] = char * 
var: tlv21 (tlv21) = & c
var: char * tlv21 (tlv21) = & c
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv20'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv20] = cgc_size_t 
var: tlv20 (tlv20) = 1
var: cgc_size_t tlv20 (tlv20) = 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; }
Assigns = [('char *', 'tlv21', '', '& c'), ('cgc_size_t', 'tlv20', '', '1')]
Compares = []
var: buf  (buf [ sret - 1 ]) = '\0'
var: UNDEF buf  (buf [ sret - 1 ]) = '\0'
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv3'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv3] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv23'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv23] = char * 
var: tlv23 (tlv23) = buf
var: char * tlv23 (tlv23) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv22'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv22] = char * 
var: tlv22 (tlv22) = cgc_gWords [ temp ]
var: char * tlv22 (tlv22) = cgc_gWords [ temp ]
var: tlv3 (tlv3) = cgc_strcmp ( tlv23 , tlv22 )
var: int tlv3 (tlv3) = cgc_strcmp ( tlv23 , tlv22 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }
Assigns = [('char *', 'tlv23', '', 'buf'), ('char *', 'tlv22', '', 'cgc_gWords [ temp ]'), ('int', 'tlv3', '', 'cgc_strcmp ( tlv23 , tlv22 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv3
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv3 != 0
=> ['tlv3', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv3
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv3']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv3']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv3']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv3']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv3']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv3']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv3']
FOUND IT! [2.2]  int : tlv3
Resolved type: [2.3]  int : tlv3
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv3 != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( LOSE_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }
 0 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } ]
 2 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } ]
 4 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } ]
Assigns = [('int', 'temp', '', 'cgc_RANDOM ( ) % NUM_WORDS'), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.IterationStatementContext'> : for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( FINAL_RND_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv14'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv14] = char 
var: tlv14 (tlv14) = buf [ 0 ]
var: char tlv14 (tlv14) = buf [ 0 ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char tlv13'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv13] = char 
var: tlv13 (tlv13) = buf [ 1 ]
var: char tlv13 (tlv13) = buf [ 1 ]
var: i (i) = cgc_toInt ( tlv14 , tlv13 )
var: int i (i) = cgc_toInt ( tlv14 , tlv13 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }
Assigns = [('char', 'tlv14', '', 'buf [ 0 ]'), ('char', 'tlv13', '', 'buf [ 1 ]'), ('int', 'i', '', 'cgc_toInt ( tlv14 , tlv13 )')]
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv7'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv7] = char * 
var: tlv7 (tlv7) = buf
var: char * tlv7 (tlv7) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv6'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv6] = char * 
var: tlv6 (tlv6) = cgc_gWords [ i ]
var: char * tlv6 (tlv6) = cgc_gWords [ i ]
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv5'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv5] = cgc_size_t 
var: tlv5 (tlv5) = BUF_SIZE
var: cgc_size_t tlv5 (tlv5) = BUF_SIZE
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }
Assigns = [('char *', 'tlv7', '', 'buf'), ('char *', 'tlv6', '', 'cgc_gWords [ i ]'), ('cgc_size_t', 'tlv5', '', 'BUF_SIZE')]
Compares = []
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( buf )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv9'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv9] = char * 
var: tlv9 (tlv9) = & c
var: char * tlv9 (tlv9) = & c
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_size_t tlv8'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv8] = cgc_size_t 
var: tlv8 (tlv8) = 1
var: cgc_size_t tlv8 (tlv8) = 1
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }
Assigns = [('char *', 'tlv9', '', '& c'), ('cgc_size_t', 'tlv8', '', '1')]
Compares = []
var: buf  (buf [ sret - 1 ]) = '\0'
var: UNDEF buf  (buf [ sret - 1 ]) = '\0'
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'int tlv2'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv2] = int 
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv16'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv16] = char * 
var: tlv16 (tlv16) = buf
var: char * tlv16 (tlv16) = buf
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'char * tlv15'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
[C-t-0] sym_dict [tlv15] = char * 
var: tlv15 (tlv15) = cgc_gWords [ i ]
var: char * tlv15 (tlv15) = cgc_gWords [ i ]
var: tlv2 (tlv2) = cgc_strcmp ( tlv16 , tlv15 )
var: int tlv2 (tlv2) = cgc_strcmp ( tlv16 , tlv15 )
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }
Assigns = [('char *', 'tlv16', '', 'buf'), ('char *', 'tlv15', '', 'cgc_gWords [ i ]'), ('int', 'tlv2', '', 'cgc_strcmp ( tlv16 , tlv15 )')]
Compares = []
0 : <class 'CParser.CParser.SelectionStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.BlockItemContext'> [start? False]
3 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
4 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.SelectionStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[is_comparator] <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 != 0
[0] <class 'CParser.CParser.RelationalExpressionContext'> => tlv2
[2] <class 'CParser.CParser.RelationalExpressionContext'> => 0
[enterEqualityExpression] : <class 'CParser.CParser.EqualityExpressionContext'> => tlv2 != 0
=> ['tlv2', '0']
[get_basic_type_or_expression]
<class 'CParser.CParser.RelationalExpressionContext'> : tlv2
-<class 'CParser.CParser.RelationalExpressionContext'> [<class 'CParser.CParser.ShiftExpressionContext'>] ['tlv2']
--<class 'CParser.CParser.ShiftExpressionContext'> [<class 'CParser.CParser.AdditiveExpressionContext'>] ['tlv2']
---<class 'CParser.CParser.AdditiveExpressionContext'> [<class 'CParser.CParser.MultiplicativeExpressionContext'>] ['tlv2']
----<class 'CParser.CParser.MultiplicativeExpressionContext'> [<class 'CParser.CParser.CastExpressionContext'>] ['tlv2']
-----<class 'CParser.CParser.CastExpressionContext'> [<class 'CParser.CParser.UnaryExpressionContext'>] ['tlv2']
------<class 'CParser.CParser.UnaryExpressionContext'> [<class 'CParser.CParser.PostfixExpressionContext'>] ['tlv2']
-------<class 'CParser.CParser.PostfixExpressionContext'> [<class 'CParser.CParser.PrimaryExpressionContext'>] ['tlv2']
FOUND IT! [2.2]  int : tlv2
Resolved type: [2.3]  int : tlv2
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.SelectionStatementContext'> 
 converged parent => <class 'CParser.CParser.SelectionStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( LOSE_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_transmit_str ( LOSE_MSG ) ; }
Assigns = []
Compares = []
0 : <class 'CParser.CParser.CompoundStatementContext'> [start? True]
1 : <class 'CParser.CParser.StatementContext'> [start? False]
2 : <class 'CParser.CParser.SelectionStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.SelectionStatementContext'>
 ===> Last 3 parents! 
 [0] : <class 'CParser.CParser.CompoundStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.SelectionStatementContext'> 
 sibling [0] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ if ]
 sibling [1] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ( ]
 sibling [2] : <class 'CParser.CParser.ExpressionContext'> [ tlv2 != 0 ]
 sibling [3] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ ) ]
 sibling [4] : <class 'CParser.CParser.StatementContext'> [ { cgc_transmit_str ( LOSE_MSG ) ; } ]
 sibling [5] : <class 'antlr4.tree.Tree.TerminalNodeImpl'> [ else ]
In an else condition, don't capture <class 'CParser.CParser.SelectionStatementContext'>
3 : <class 'CParser.CParser.StatementContext'> [start? False]
4 : <class 'CParser.CParser.BlockItemContext'> [start? False]
5 : <class 'CParser.CParser.BlockItemListContext'> [start? False]
6 : <class 'CParser.CParser.CompoundStatementContext'> [start? False]
Valid scope parent: <class 'CParser.CParser.CompoundStatementContext'>
 ===> Last 5 parents! 
 [0] : <class 'CParser.CParser.SelectionStatementContext'> 
 [1] : <class 'CParser.CParser.StatementContext'> 
 [2] : <class 'CParser.CParser.BlockItemContext'> 
 [3] : <class 'CParser.CParser.BlockItemListContext'> 
 [4] : <class 'CParser.CParser.CompoundStatementContext'> 
RESOLVED : <class 'CParser.CParser.CompoundStatementContext'> => <class 'CParser.CParser.CompoundStatementContext'> 
 converged parent => <class 'CParser.CParser.CompoundStatementContext'>
[enterDeclaration] [(<class 'CParser.CParser.DeclarationSpecifiersContext'>, 'cgc_transmit_str'), (<class 'CParser.CParser.InitDeclaratorListContext'>, '( WIN_MSG )'), (<class 'antlr4.tree.Tree.TerminalNodeImpl'>, ';')]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { cgc_transmit_str ( WIN_MSG ) ; }
Assigns = []
Compares = []
Descendants of <class 'CParser.CParser.SelectionStatementContext'> : if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_transmit_str ( LOSE_MSG ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { cgc_transmit_str ( WIN_MSG ) ; } ]
Descendants of <class 'CParser.CParser.CompoundStatementContext'> : { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } ]
 1 : <class 'CParser.CParser.CompoundStatementContext'>   [ { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } ]
 2 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv1 != 0 ) { return ( - 1 ) ; } ]
 3 : <class 'CParser.CParser.CompoundStatementContext'>   [ { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } ]
 4 : <class 'CParser.CParser.IterationStatementContext'>   [ for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } ]
 5 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } ]
 6 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } ]
 7 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } ]
 8 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } ]
 9 : <class 'CParser.CParser.SelectionStatementContext'>   [ if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } ]
Assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
Compares = []
Descendants of <class 'CParser.CParser.FunctionDefinitionContext'> : int main ( int cgc_argc , char * cgc_argv [ ] ) { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; }
 0 : <class 'CParser.CParser.CompoundStatementContext'>   [ { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; } ]
compound scope 0 : { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; }
compound scope 1 : { return ( 0 ) ; }
compound scope 2 : { }
len(compound_scope) : 3
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; } ] 
p_decls = [('cgc_size_t', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'ret', None), ('char *', 'str', None)]
assigns = [('cgc_size_t', 'ret', '', '0')]
compares = []
===> context { cgc_size_t ret ; ret = 0 ; if ( str == NULL ) { return ( 0 ) ; } for ( ret = 0 ; str [ ret ] != '\0' ; ret ++ ) { } return ( ret ) ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: ret
1 : |  decl_scope  | type: char *, var: str
0 : | assign_scope | type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'str', None)]
assigns = []
compares = []
decls = [('char *', 'str', None), ('cgc_size_t', 'ret', None)]
assigns = [('cgc_size_t', 'ret', '', '0')]
compares = []
decls = [('char *', 'str', None), ('cgc_size_t', 'ret', None)]
assigns = [('cgc_size_t', 'ret', '', '0')]
compares = ['', '']
===> context { return ( 0 ) ; }
ignore sibs: ["for ( ret = 0 ; str [ ret ] != '\\0' ; ret ++ ) { }", 'return ( ret ) ;', '}']
0 : |  decl_scope  | type: char *, var: str
1 : |  decl_scope  | type: cgc_size_t, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: char *, value: str
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'str', None)]
assigns = []
compares = []
decls = [('char *', 'str', None), ('cgc_size_t', 'ret', None)]
assigns = [('cgc_size_t', 'ret', '', '0')]
compares = []
decls = [('char *', 'str', None), ('cgc_size_t', 'ret', None)]
assigns = [('cgc_size_t', 'ret', '', '0'), ('cgc_size_t', 'ret', '', '0')]
compares = ['', '']
===> context { }
ignore sibs: ['return ( ret ) ;', '}']
0 : |  decl_scope  | type: char *, var: str
1 : |  decl_scope  | type: cgc_size_t, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: char *, value: str [ ret ]
1 : |compare_scopes| type: char *, value: '\0'
=======END=======
compound scope 0 : { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
compound scope 1 : { return ( 0 ) ; }
iteration/selection scope corner case 2 : do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;
compound scope 3 : { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; }
compound scope 4 : { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
compound scope 5 : { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
compound scope 6 : { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; } ] 
p_decls = [('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
1 : |  decl_scope  | type: cgc_size_t, var: total
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: cgc_size_t, var: size
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { return ( 0 ) ; }
ignore sibs: ['do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: buf
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : True 
START SCOPE : [ <class 'CParser.CParser.IterationStatementContext'> => do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; ] 
END SCOPE   : [ <class 'CParser.CParser.BlockItemListContext'> => cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context do { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;
ignore sibs: ['return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: cgc_size_t, value: total
1 : |compare_scopes| type: cgc_size_t, value: size
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('cgc_size_t', 'total', '', 'rx_bytes')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'total', '', 'rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'total', '', 'rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; }
ignore sibs: ['while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: rx_bytes
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('int', 'tlv4', '', 'STDOUT'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('int', 'tlv4', '', 'STDOUT'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('int', 'tlv4', '', 'STDOUT'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('int', 'tlv4', '', 'STDOUT'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { int tlv4 ; tlv4 = STDOUT ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_transmit ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }', 'total += rx_bytes ;', '}', 'while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: cgc_size_t *, var: tlv1
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: cgc_size_t, var: size
6 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
7 : |  decl_scope  | type: cgc_size_t, var: total
8 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: STDOUT
1 : | assign_scope | type: void *, value: buf
2 : | assign_scope | type: cgc_size_t, value: size - total
3 : | assign_scope | type: cgc_size_t *, value: & rx_bytes
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
===> context { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['total += rx_bytes ;', '}', 'while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: cgc_size_t, value: rx_bytes
3 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('unsigned int', 'tlv5', '', '1')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
===> context { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'total += rx_bytes ;', '}', 'while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
4 : |  decl_scope  | type: cgc_size_t, var: total
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 1
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: cgc_size_t, value: rx_bytes
3 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
compound scope 0 : { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; }
compound scope 1 : { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; }
len(compound_scope) : 2
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; } ] 
p_decls = [('cgc_size_t', 'len', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'len', None), ('char *', 'buf', None)]
assigns = []
compares = []
===> context { cgc_size_t len ; { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } return ( cgc_transmit_all ( buf , len ) ) ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: len
1 : |  decl_scope  | type: char *, var: buf
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; } ] 
p_decls = [('char *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv1', None), ('char *', 'buf', None)]
assigns = [('char *', 'tlv1', '', 'buf'), ('cgc_size_t', 'len', '', 'cgc_strlen ( tlv1 )')]
compares = []
decls = [('char *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = [('char *', 'tlv1', '', 'buf'), ('cgc_size_t', 'len', '', 'cgc_strlen ( tlv1 )')]
compares = []
===> context { char * tlv1 ; tlv1 = buf ; len = cgc_strlen ( tlv1 ) ; }
ignore sibs: ['return ( cgc_transmit_all ( buf , len ) ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv1
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: cgc_size_t, var: len
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv1 )
=======END=======
compound scope 0 : { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
compound scope 1 : { return ( 0 ) ; }
iteration/selection scope corner case 2 : do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;
compound scope 3 : { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; }
compound scope 4 : { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
compound scope 5 : { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
compound scope 6 : { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; } ] 
p_decls = [('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
1 : |  decl_scope  | type: cgc_size_t, var: total
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: cgc_size_t, var: size
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context { return ( 0 ) ; }
ignore sibs: ['do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: buf
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : True 
START SCOPE : [ <class 'CParser.CParser.IterationStatementContext'> => do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; ] 
END SCOPE   : [ <class 'CParser.CParser.BlockItemListContext'> => cgc_size_t rx_bytes ; rx_bytes = 0 ; cgc_size_t total ; total = 0 ; int ret ; ret = 0 ; if ( buf == NULL ) { return ( 0 ) ; } do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ; return ( size ) ; ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '']
===> context do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } while ( total < size ) ;
ignore sibs: ['return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: cgc_size_t, value: total
1 : |compare_scopes| type: cgc_size_t, value: size
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('cgc_size_t', 'total', '', 'rx_bytes')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'total', '', 'rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'total', '', 'rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } total += rx_bytes ; }
ignore sibs: ['while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: rx_bytes
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', 'buf'), ('cgc_size_t', 'tlv2', '', 'size - total'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
===> context { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = buf ; cgc_size_t tlv2 ; tlv2 = size - total ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }', 'total += rx_bytes ;', '}', 'while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: cgc_size_t *, var: tlv1
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: cgc_size_t, var: size
6 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
7 : |  decl_scope  | type: cgc_size_t, var: total
8 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: void *, value: buf
2 : | assign_scope | type: cgc_size_t, value: size - total
3 : | assign_scope | type: cgc_size_t *, value: & rx_bytes
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
===> context { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['total += rx_bytes ;', '}', 'while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: size
2 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: cgc_size_t, value: rx_bytes
3 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None)]
assigns = [('unsigned int', 'tlv5', '', '1')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'size', None), ('cgc_size_t', 'rx_bytes', None), ('cgc_size_t', 'total', None), ('int', 'ret', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'rx_bytes', '', '0'), ('cgc_size_t', 'total', '', '0'), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
===> context { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'total += rx_bytes ;', '}', 'while', '(', 'total < size', ')', ';', 'return ( size ) ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: cgc_size_t, var: size
3 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
4 : |  decl_scope  | type: cgc_size_t, var: total
5 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: unsigned int, value: 1
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: cgc_size_t, value: rx_bytes
3 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
compound scope 0 : { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; }
compound scope 1 : { return ( 0 ) ; }
iteration/selection scope corner case 2 : do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ;
compound scope 3 : { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; }
compound scope 4 : { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
compound scope 5 : { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
compound scope 6 : { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; } ] 
p_decls = [('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
===> context { if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: count
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: char, var: c
3 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: cgc_size_t, var: len
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = ['', '']
===> context { return ( 0 ) ; }
ignore sibs: ['cgc_size_t count ;', 'count = 0 ;', 'int ret ;', 'ret = 0 ;', 'char c ;', 'c = 0 ;', 'cgc_size_t rx_bytes ;', 'rx_bytes = 0 ;', "do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\\n' ) && ( count < len ) ) ;", 'return ( count ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: len
0 : |compare_scopes| type: char *, value: buf
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : True 
START SCOPE : [ <class 'CParser.CParser.IterationStatementContext'> => do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; ] 
END SCOPE   : [ <class 'CParser.CParser.BlockItemListContext'> => if ( buf == NULL ) { return ( 0 ) ; } cgc_size_t count ; count = 0 ; int ret ; ret = 0 ; char c ; c = 0 ; cgc_size_t rx_bytes ; rx_bytes = 0 ; do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ; return ( count ) ; ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = ['', '', '', '']
===> context do { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } while ( ( c != '\n' ) && ( count < len ) ) ;
ignore sibs: ['return ( count ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: len
2 : |  decl_scope  | type: cgc_size_t, var: count
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char, var: c
5 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: char, value: c
1 : |compare_scopes| type: char, value: '\n'
2 : |compare_scopes| type: cgc_size_t, value: count
3 : |compare_scopes| type: cgc_size_t, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = [('UNDEF', 'buf ', '[ count ]', 'c')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('UNDEF', 'buf ', '[ count ]', 'c'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('UNDEF', 'buf ', '[ count ]', 'c'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
===> context { { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } buf [ count ] = c ; count ++ ; }
ignore sibs: ['while', '(', "( c != '\\n' ) && ( count < len )", ')', ';', 'return ( count ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: len
2 : |  decl_scope  | type: cgc_size_t, var: count
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char, var: c
5 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
0 : | assign_scope | type: UNDEF, value: c
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: char, value: 0
4 : | assign_scope | type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', '& c'), ('cgc_size_t', 'tlv2', '', '1'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', '& c'), ('cgc_size_t', 'tlv2', '', '1'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', '& c'), ('cgc_size_t', 'tlv2', '', '1'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('int', 'tlv4', None), ('void *', 'tlv3', None), ('cgc_size_t', 'tlv2', None), ('cgc_size_t *', 'tlv1', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('int', 'tlv4', '', 'STDIN'), ('void *', 'tlv3', '', '& c'), ('cgc_size_t', 'tlv2', '', '1'), ('cgc_size_t *', 'tlv1', '', '& rx_bytes'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
===> context { int tlv4 ; tlv4 = STDIN ; void * tlv3 ; tlv3 = & c ; cgc_size_t tlv2 ; tlv2 = 1 ; cgc_size_t * tlv1 ; tlv1 = & rx_bytes ; ret = cgc_receive ( tlv4 , tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( ( ret != 0 ) || ( rx_bytes == 0 ) ) { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }', 'buf [ count ] = c ;', 'count ++ ;', '}', 'while', '(', "( c != '\\n' ) && ( count < len )", ')', ';', 'return ( count ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv4
1 : |  decl_scope  | type: void *, var: tlv3
2 : |  decl_scope  | type: cgc_size_t, var: tlv2
3 : |  decl_scope  | type: cgc_size_t *, var: tlv1
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: cgc_size_t, var: len
6 : |  decl_scope  | type: cgc_size_t, var: count
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: char, var: c
9 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
0 : | assign_scope | type: int, value: STDIN
1 : | assign_scope | type: void *, value: & c
2 : | assign_scope | type: cgc_size_t, value: 1
3 : | assign_scope | type: cgc_size_t *, value: & rx_bytes
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: char, value: 0
7 : | assign_scope | type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = ['', '', '', '']
===> context { { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } }
ignore sibs: ['buf [ count ] = c ;', 'count ++ ;', '}', 'while', '(', "( c != '\\n' ) && ( count < len )", ')', ';', 'return ( count ) ;', '}']
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: cgc_size_t, var: len
2 : |  decl_scope  | type: cgc_size_t, var: count
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: char, var: c
5 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: char, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: cgc_size_t, value: rx_bytes
3 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; } ] 
p_decls = [('unsigned int', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None)]
assigns = [('unsigned int', 'tlv5', '', '1')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = []
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = ['', '', '', '']
decls = [('unsigned int', 'tlv5', None), ('char *', 'buf', None), ('cgc_size_t', 'len', None), ('cgc_size_t', 'count', None), ('int', 'ret', None), ('char', 'c', None), ('cgc_size_t', 'rx_bytes', None)]
assigns = [('unsigned int', 'tlv5', '', '1'), ('cgc_size_t', 'count', '', '0'), ('int', 'ret', '', '0'), ('char', 'c', '', '0'), ('cgc_size_t', 'rx_bytes', '', '0')]
compares = ['', '', '', '']
===> context { unsigned int tlv5 ; tlv5 = 1 ; cgc__terminate ( tlv5 ) ; }
ignore sibs: ['}', 'buf [ count ] = c ;', 'count ++ ;', '}', 'while', '(', "( c != '\\n' ) && ( count < len )", ')', ';', 'return ( count ) ;', '}']
0 : |  decl_scope  | type: unsigned int, var: tlv5
1 : |  decl_scope  | type: char *, var: buf
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: cgc_size_t, var: count
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: char, var: c
6 : |  decl_scope  | type: cgc_size_t, var: rx_bytes
0 : | assign_scope | type: unsigned int, value: 1
1 : | assign_scope | type: cgc_size_t, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: char, value: 0
4 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
2 : |compare_scopes| type: cgc_size_t, value: rx_bytes
3 : |compare_scopes| type: cgc_size_t, value: 0
=======END=======
compound scope 0 : { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; }
compound scope 1 : { temp = c - 'a' ; ; }
compound scope 2 : { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } }
compound scope 3 : { temp = c - 'A' + 26 ; }
compound scope 4 : { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } }
compound scope 5 : { temp = c - '0' + 52 ; }
compound scope 6 : { return ( c ) ; ; }
len(compound_scope) : 7
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; } ] 
p_decls = [('int', 'temp', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'temp', None), ('char', 'c', None), ('int', 'n', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN'), ('int', 'temp', '', 'n'), ('int', 'temp', '', 'temp % VALID_CHARS_LEN')]
compares = []
===> context { int temp ; temp = 0 ; n = n % VALID_CHARS_LEN ; if ( ( c >= 'a' ) && ( c <= 'z' ) ) { temp = c - 'a' ; ; } else { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } temp += n ; temp = temp % VALID_CHARS_LEN ; return ( gValidChars [ temp ] ) ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: temp
1 : |  decl_scope  | type: char, var: c
2 : |  decl_scope  | type: int, var: n
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
2 : | assign_scope | type: int, value: n
3 : | assign_scope | type: int, value: temp % VALID_CHARS_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { temp = c - 'a' ; ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { temp = c - 'a' ; ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c', None), ('int', 'n', None)]
assigns = [('int', 'temp', '', "c - 'a'")]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - 'a'"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - 'a'"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = ['', '', '', '']
===> context { temp = c - 'a' ; ; }
ignore sibs: ['else', "{ if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } }", 'temp += n ;', 'temp = temp % VALID_CHARS_LEN ;', 'return ( gValidChars [ temp ] ) ;', '}']
0 : |  decl_scope  | type: char, var: c
1 : |  decl_scope  | type: int, var: n
2 : |  decl_scope  | type: int, var: temp
0 : | assign_scope | type: int, value: c - 'a'
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
0 : |compare_scopes| type: char, value: c
1 : |compare_scopes| type: char, value: 'a'
2 : |compare_scopes| type: char, value: c
3 : |compare_scopes| type: char, value: 'z'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c', None), ('int', 'n', None)]
assigns = []
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
===> context { if ( ( c >= 'A' ) && ( c <= 'Z' ) ) { temp = c - 'A' + 26 ; } else { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } }
ignore sibs: ['temp += n ;', 'temp = temp % VALID_CHARS_LEN ;', 'return ( gValidChars [ temp ] ) ;', '}']
0 : |  decl_scope  | type: char, var: c
1 : |  decl_scope  | type: int, var: n
2 : |  decl_scope  | type: int, var: temp
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { temp = c - 'A' + 26 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { temp = c - 'A' + 26 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c', None), ('int', 'n', None)]
assigns = [('int', 'temp', '', "c - 'A' + 26")]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - 'A' + 26"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - 'A' + 26"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - 'A' + 26"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = ['', '', '', '']
===> context { temp = c - 'A' + 26 ; }
ignore sibs: ['else', "{ if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } }", '}', 'temp += n ;', 'temp = temp % VALID_CHARS_LEN ;', 'return ( gValidChars [ temp ] ) ;', '}']
0 : |  decl_scope  | type: char, var: c
1 : |  decl_scope  | type: int, var: n
2 : |  decl_scope  | type: int, var: temp
0 : | assign_scope | type: int, value: c - 'A' + 26
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
0 : |compare_scopes| type: char, value: c
1 : |compare_scopes| type: char, value: 'A'
2 : |compare_scopes| type: char, value: c
3 : |compare_scopes| type: char, value: 'Z'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c', None), ('int', 'n', None)]
assigns = []
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
===> context { if ( ( c >= '0' ) && ( c <= '9' ) ) { temp = c - '0' + 52 ; } else { return ( c ) ; ; } }
ignore sibs: ['}', 'temp += n ;', 'temp = temp % VALID_CHARS_LEN ;', 'return ( gValidChars [ temp ] ) ;', '}']
0 : |  decl_scope  | type: char, var: c
1 : |  decl_scope  | type: int, var: n
2 : |  decl_scope  | type: int, var: temp
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { temp = c - '0' + 52 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { temp = c - '0' + 52 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c', None), ('int', 'n', None)]
assigns = [('int', 'temp', '', "c - '0' + 52")]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - '0' + 52"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - '0' + 52"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - '0' + 52"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', "c - '0' + 52"), ('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = ['', '', '', '']
===> context { temp = c - '0' + 52 ; }
ignore sibs: ['else', '{ return ( c ) ; ; }', '}', '}', 'temp += n ;', 'temp = temp % VALID_CHARS_LEN ;', 'return ( gValidChars [ temp ] ) ;', '}']
0 : |  decl_scope  | type: char, var: c
1 : |  decl_scope  | type: int, var: n
2 : |  decl_scope  | type: int, var: temp
0 : | assign_scope | type: int, value: c - '0' + 52
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
0 : |compare_scopes| type: char, value: c
1 : |compare_scopes| type: char, value: '0'
2 : |compare_scopes| type: char, value: c
3 : |compare_scopes| type: char, value: '9'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( c ) ; ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( c ) ; ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c', None), ('int', 'n', None)]
assigns = []
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
decls = [('char', 'c', None), ('int', 'n', None), ('int', 'temp', None)]
assigns = [('int', 'temp', '', '0'), ('int', 'n', '', 'n % VALID_CHARS_LEN')]
compares = []
===> context { return ( c ) ; ; }
ignore sibs: ['}', '}', 'temp += n ;', 'temp = temp % VALID_CHARS_LEN ;', 'return ( gValidChars [ temp ] ) ;', '}']
0 : |  decl_scope  | type: char, var: c
1 : |  decl_scope  | type: int, var: n
2 : |  decl_scope  | type: int, var: temp
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: n % VALID_CHARS_LEN
=======END=======
compound scope 0 : { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; }
compound scope 1 : { return ( 0 ) ; }
compound scope 2 : { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } }
compound scope 3 : { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; }
len(compound_scope) : 4
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; } ] 
p_decls = [('cgc_size_t', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'ret', None), ('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None)]
assigns = [('cgc_size_t', 'ret', '', '0'), ('UNDEF', 'dst ', '[ ret ]', "'\\0'")]
compares = []
===> context { if ( ( src == NULL ) || ( dst == NULL ) ) { return ( 0 ) ; } cgc_size_t ret ; ret = 0 ; for ( ret = 0 ; src [ ret ] != '\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } dst [ ret ] = '\0' ; return ( ret ) ; }
ignore sibs: []
0 : |  decl_scope  | type: cgc_size_t, var: ret
1 : |  decl_scope  | type: char *, var: dst
2 : |  decl_scope  | type: char *, var: src
3 : |  decl_scope  | type: int, var: rot
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None)]
assigns = []
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None)]
assigns = []
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None)]
assigns = []
compares = ['', '', '', '']
===> context { return ( 0 ) ; }
ignore sibs: ['cgc_size_t ret ;', 'ret = 0 ;', "for ( ret = 0 ; src [ ret ] != '\\0' ; ret ++ ) { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } }", "dst [ ret ] = '\\0' ;", 'return ( ret ) ;', '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: int, var: rot
0 : |compare_scopes| type: char *, value: src
1 : |compare_scopes| type: char *, value: NULL
2 : |compare_scopes| type: char *, value: dst
3 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None)]
assigns = []
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None), ('cgc_size_t', 'ret', None)]
assigns = [('cgc_size_t', 'ret', '', '0')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None), ('cgc_size_t', 'ret', None)]
assigns = [('cgc_size_t', 'ret', '', '0'), ('cgc_size_t', 'ret', '', '0')]
compares = ['', '']
===> context { { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } }
ignore sibs: ["dst [ ret ] = '\\0' ;", 'return ( ret ) ;', '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: int, var: rot
3 : |  decl_scope  | type: cgc_size_t, var: ret
0 : | assign_scope | type: cgc_size_t, value: 0
1 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: char *, value: src [ ret ]
1 : |compare_scopes| type: char *, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; } ] 
p_decls = [('char', 'tlv2', None), ('int', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'tlv2', None), ('int', 'tlv1', None), ('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None)]
assigns = [('char', 'tlv2', '', 'src [ ret ]'), ('int', 'tlv1', '', 'rot')]
compares = []
decls = [('char', 'tlv2', None), ('int', 'tlv1', None), ('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None), ('cgc_size_t', 'ret', None)]
assigns = [('char', 'tlv2', '', 'src [ ret ]'), ('int', 'tlv1', '', 'rot'), ('cgc_size_t', 'ret', '', '0')]
compares = []
decls = [('char', 'tlv2', None), ('int', 'tlv1', None), ('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None), ('cgc_size_t', 'ret', None)]
assigns = [('char', 'tlv2', '', 'src [ ret ]'), ('int', 'tlv1', '', 'rot'), ('cgc_size_t', 'ret', '', '0'), ('cgc_size_t', 'ret', '', '0')]
compares = ['', '']
decls = [('char', 'tlv2', None), ('int', 'tlv1', None), ('char *', 'dst', None), ('char *', 'src', None), ('int', 'rot', None), ('cgc_size_t', 'ret', None)]
assigns = [('char', 'tlv2', '', 'src [ ret ]'), ('int', 'tlv1', '', 'rot'), ('cgc_size_t', 'ret', '', '0'), ('cgc_size_t', 'ret', '', '0')]
compares = ['', '']
===> context { char tlv2 ; tlv2 = src [ ret ] ; int tlv1 ; tlv1 = rot ; dst [ ret ] = cgc_rotN ( tlv2 , tlv1 ) ; }
ignore sibs: ['}', "dst [ ret ] = '\\0' ;", 'return ( ret ) ;', '}']
0 : |  decl_scope  | type: char, var: tlv2
1 : |  decl_scope  | type: int, var: tlv1
2 : |  decl_scope  | type: char *, var: dst
3 : |  decl_scope  | type: char *, var: src
4 : |  decl_scope  | type: int, var: rot
5 : |  decl_scope  | type: cgc_size_t, var: ret
0 : | assign_scope | type: char, value: src [ ret ]
1 : | assign_scope | type: int, value: rot
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
0 : |compare_scopes| type: char *, value: src [ ret ]
1 : |compare_scopes| type: char *, value: '\0'
=======END=======
compound scope 0 : { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; }
compound scope 1 : { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; }
compound scope 2 : { return ( ret ) ; }
compound scope 3 : { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; }
compound scope 4 : { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; }
compound scope 5 : { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }
compound scope 6 : { return ( ret ) ; }
compound scope 7 : { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }
compound scope 8 : { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; }
compound scope 9 : { cgc_gWords [ i ] = 0 ; }
len(compound_scope) : 10
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; } ] 
p_decls = [('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None), ('int', 'rot', None)]
assigns = [('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData')]
compares = []
===> context { int ret ; ret = 0 ; cgc_size_t numWords ; numWords = NUM_WORDS ; { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t total ; total = 0 ; int i ; i = 0 ; for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } if ( ret != 0 ) { return ( ret ) ; } cgc_size_t temp ; temp = 0 ; char * pTemp ; pTemp = cgc_gWordData ; for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; } return ( 0 ) ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: cgc_size_t, var: numWords
2 : |  decl_scope  | type: cgc_size_t, var: total
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: cgc_size_t, var: temp
5 : |  decl_scope  | type: char *, var: pTemp
6 : |  decl_scope  | type: int, var: rot
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: char *, value: cgc_gWordData
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv3', None), ('int', 'tlv2', None), ('void * *', 'tlv1', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv3', None), ('int', 'tlv2', None), ('void * *', 'tlv1', None), ('int', 'rot', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( gSeedWords )'), ('int', 'tlv2', '', '0'), ('void * *', 'tlv1', '', '( void * * ) ( & cgc_gWords )')]
compares = []
decls = [('cgc_size_t', 'tlv3', None), ('int', 'tlv2', None), ('void * *', 'tlv1', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None)]
assigns = [('cgc_size_t', 'tlv3', '', 'sizeof ( gSeedWords )'), ('int', 'tlv2', '', '0'), ('void * *', 'tlv1', '', '( void * * ) ( & cgc_gWords )'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS')]
compares = []
===> context { cgc_size_t tlv3 ; tlv3 = sizeof ( gSeedWords ) ; int tlv2 ; tlv2 = 0 ; void * * tlv1 ; tlv1 = ( void * * ) ( & cgc_gWords ) ; ret = cgc_allocate ( tlv3 , tlv2 , tlv1 ) ; }
ignore sibs: ['if ( ret != 0 ) { return ( ret ) ; }', 'cgc_size_t total ;', 'total = 0 ;', 'int i ;', 'i = 0 ;', 'for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; }', '{ cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }', 'if ( ret != 0 ) { return ( ret ) ; }', 'cgc_size_t temp ;', 'temp = 0 ;', 'char * pTemp ;', 'pTemp = cgc_gWordData ;', 'for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv3
1 : |  decl_scope  | type: int, var: tlv2
2 : |  decl_scope  | type: void * *, var: tlv1
3 : |  decl_scope  | type: int, var: rot
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: cgc_size_t, var: numWords
0 : | assign_scope | type: cgc_size_t, value: sizeof ( gSeedWords )
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void * *, value: ( void * * ) ( & cgc_gWords )
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( ret ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( ret ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'rot', None)]
assigns = []
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None)]
assigns = [('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None)]
assigns = [('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS')]
compares = ['', '']
===> context { return ( ret ) ; }
ignore sibs: ['cgc_size_t total ;', 'total = 0 ;', 'int i ;', 'i = 0 ;', 'for ( i = 0 ; i < numWords ; i ++ ) { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; }', '{ cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }', 'if ( ret != 0 ) { return ( ret ) ; }', 'cgc_size_t temp ;', 'temp = 0 ;', 'char * pTemp ;', 'pTemp = cgc_gWordData ;', 'for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: rot
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: cgc_size_t, var: numWords
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'rot', None)]
assigns = [('cgc_size_t', 'total', '', '1')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('cgc_size_t', 'total', '', '1'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('cgc_size_t', 'total', '', '1'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } total += 1 ; ; }
ignore sibs: ['{ cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }', 'if ( ret != 0 ) { return ( ret ) ; }', 'cgc_size_t temp ;', 'temp = 0 ;', 'char * pTemp ;', 'pTemp = cgc_gWordData ;', 'for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: rot
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: cgc_size_t, var: numWords
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: cgc_size_t, value: 1
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: numWords
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; } ] 
p_decls = [('char *', 'tlv7', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv7', None), ('int', 'rot', None)]
assigns = [('char *', 'tlv7', '', 'gSeedWords [ i ]'), ('cgc_size_t', 'total', '', 'cgc_strlen ( tlv7 )')]
compares = []
decls = [('char *', 'tlv7', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('char *', 'tlv7', '', 'gSeedWords [ i ]'), ('cgc_size_t', 'total', '', 'cgc_strlen ( tlv7 )'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0')]
compares = []
decls = [('char *', 'tlv7', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('char *', 'tlv7', '', 'gSeedWords [ i ]'), ('cgc_size_t', 'total', '', 'cgc_strlen ( tlv7 )'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv7', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('char *', 'tlv7', '', 'gSeedWords [ i ]'), ('cgc_size_t', 'total', '', 'cgc_strlen ( tlv7 )'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { char * tlv7 ; tlv7 = gSeedWords [ i ] ; total += cgc_strlen ( tlv7 ) ; }
ignore sibs: ['total += 1 ;', ';', '}', '{ cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }', 'if ( ret != 0 ) { return ( ret ) ; }', 'cgc_size_t temp ;', 'temp = 0 ;', 'char * pTemp ;', 'pTemp = cgc_gWordData ;', 'for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv7
1 : |  decl_scope  | type: int, var: rot
2 : |  decl_scope  | type: int, var: ret
3 : |  decl_scope  | type: cgc_size_t, var: numWords
4 : |  decl_scope  | type: cgc_size_t, var: total
5 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: char *, value: gSeedWords [ i ]
1 : | assign_scope | type: cgc_size_t, value: cgc_strlen ( tlv7 )
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: numWords
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; } ] 
p_decls = [('cgc_size_t', 'tlv6', None), ('int', 'tlv5', None), ('void * *', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('cgc_size_t', 'tlv6', None), ('int', 'tlv5', None), ('void * *', 'tlv4', None), ('int', 'rot', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'total'), ('int', 'tlv5', '', '0'), ('void * *', 'tlv4', '', '( void * * ) ( & cgc_gWordData )')]
compares = []
decls = [('cgc_size_t', 'tlv6', None), ('int', 'tlv5', None), ('void * *', 'tlv4', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('cgc_size_t', 'tlv6', '', 'total'), ('int', 'tlv5', '', '0'), ('void * *', 'tlv4', '', '( void * * ) ( & cgc_gWordData )'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0')]
compares = []
===> context { cgc_size_t tlv6 ; tlv6 = total ; int tlv5 ; tlv5 = 0 ; void * * tlv4 ; tlv4 = ( void * * ) ( & cgc_gWordData ) ; ret = cgc_allocate ( tlv6 , tlv5 , tlv4 ) ; }
ignore sibs: ['if ( ret != 0 ) { return ( ret ) ; }', 'cgc_size_t temp ;', 'temp = 0 ;', 'char * pTemp ;', 'pTemp = cgc_gWordData ;', 'for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: cgc_size_t, var: tlv6
1 : |  decl_scope  | type: int, var: tlv5
2 : |  decl_scope  | type: void * *, var: tlv4
3 : |  decl_scope  | type: int, var: rot
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: cgc_size_t, var: numWords
6 : |  decl_scope  | type: cgc_size_t, var: total
7 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: cgc_size_t, value: total
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: void * *, value: ( void * * ) ( & cgc_gWordData )
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( ret ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( ret ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'rot', None)]
assigns = []
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None)]
assigns = [('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { return ( ret ) ; }
ignore sibs: ['cgc_size_t temp ;', 'temp = 0 ;', 'char * pTemp ;', 'pTemp = cgc_gWordData ;', 'for ( i = 0 ; i < numWords ; i ++ ) { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: rot
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: cgc_size_t, var: numWords
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
2 : | assign_scope | type: cgc_size_t, value: 0
3 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: ret
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'rot', None)]
assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', 'pTemp'), ('char *', 'pTemp', '', '1')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', 'pTemp'), ('char *', 'pTemp', '', '1'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', 'pTemp'), ('char *', 'pTemp', '', '1'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData'), ('int', 'i', '', '0')]
compares = ['', '']
===> context { cgc_gWords [ i ] = pTemp ; { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } pTemp += 1 ; ; }
ignore sibs: ['for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: rot
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: cgc_size_t, var: numWords
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: i
5 : |  decl_scope  | type: cgc_size_t, var: temp
6 : |  decl_scope  | type: char *, var: pTemp
0 : | assign_scope | type: UNDEF, value: pTemp
1 : | assign_scope | type: char *, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: cgc_size_t, value: 0
7 : | assign_scope | type: char *, value: cgc_gWordData
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: numWords
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; } ] 
p_decls = [('char *', 'tlv10', None), ('char *', 'tlv9', None), ('int', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv10', None), ('char *', 'tlv9', None), ('int', 'tlv8', None), ('int', 'rot', None)]
assigns = [('char *', 'tlv10', '', 'pTemp'), ('char *', 'tlv9', '', 'gSeedWords [ i ]'), ('int', 'tlv8', '', 'rot')]
compares = []
decls = [('char *', 'tlv10', None), ('char *', 'tlv9', None), ('int', 'tlv8', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('char *', 'tlv10', '', 'pTemp'), ('char *', 'tlv9', '', 'gSeedWords [ i ]'), ('int', 'tlv8', '', 'rot'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData')]
compares = []
decls = [('char *', 'tlv10', None), ('char *', 'tlv9', None), ('int', 'tlv8', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('char *', 'tlv10', '', 'pTemp'), ('char *', 'tlv9', '', 'gSeedWords [ i ]'), ('int', 'tlv8', '', 'rot'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData'), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv10', None), ('char *', 'tlv9', None), ('int', 'tlv8', None), ('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('char *', 'tlv10', '', 'pTemp'), ('char *', 'tlv9', '', 'gSeedWords [ i ]'), ('int', 'tlv8', '', 'rot'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData'), ('int', 'i', '', '0'), ('UNDEF', 'cgc_gWords ', '[ i ]', 'pTemp')]
compares = ['', '']
===> context { char * tlv10 ; tlv10 = pTemp ; char * tlv9 ; tlv9 = gSeedWords [ i ] ; int tlv8 ; tlv8 = rot ; pTemp += cgc_strrotcpy ( tlv10 , tlv9 , tlv8 ) ; }
ignore sibs: ['pTemp += 1 ;', ';', '}', 'for ( ; i < ( PAGE_SIZE / sizeof ( char * ) ) ; i ++ ) { cgc_gWords [ i ] = 0 ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv10
1 : |  decl_scope  | type: char *, var: tlv9
2 : |  decl_scope  | type: int, var: tlv8
3 : |  decl_scope  | type: int, var: rot
4 : |  decl_scope  | type: int, var: ret
5 : |  decl_scope  | type: cgc_size_t, var: numWords
6 : |  decl_scope  | type: cgc_size_t, var: total
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: cgc_size_t, var: temp
9 : |  decl_scope  | type: char *, var: pTemp
0 : | assign_scope | type: char *, value: pTemp
1 : | assign_scope | type: char *, value: gSeedWords [ i ]
2 : | assign_scope | type: int, value: rot
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: int, value: 0
7 : | assign_scope | type: cgc_size_t, value: 0
8 : | assign_scope | type: char *, value: cgc_gWordData
9 : | assign_scope | type: int, value: 0
10 : | assign_scope | type: UNDEF, value: pTemp
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: numWords
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_gWords [ i ] = 0 ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_gWords [ i ] = 0 ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'rot', None)]
assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', '0')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', '0'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData')]
compares = []
decls = [('int', 'rot', None), ('int', 'ret', None), ('cgc_size_t', 'numWords', None), ('cgc_size_t', 'total', None), ('int', 'i', None), ('cgc_size_t', 'temp', None), ('char *', 'pTemp', None)]
assigns = [('UNDEF', 'cgc_gWords ', '[ i ]', '0'), ('int', 'ret', '', '0'), ('cgc_size_t', 'numWords', '', 'NUM_WORDS'), ('cgc_size_t', 'total', '', '0'), ('int', 'i', '', '0'), ('cgc_size_t', 'temp', '', '0'), ('char *', 'pTemp', '', 'cgc_gWordData')]
compares = ['', '']
===> context { cgc_gWords [ i ] = 0 ; }
ignore sibs: ['return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: rot
1 : |  decl_scope  | type: int, var: ret
2 : |  decl_scope  | type: cgc_size_t, var: numWords
3 : |  decl_scope  | type: cgc_size_t, var: total
4 : |  decl_scope  | type: int, var: i
5 : |  decl_scope  | type: cgc_size_t, var: temp
6 : |  decl_scope  | type: char *, var: pTemp
0 : | assign_scope | type: UNDEF, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: cgc_size_t, value: NUM_WORDS
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char *, value: cgc_gWordData
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: ( PAGE_SIZE / sizeof ( char * ) )
=======END=======
compound scope 0 : { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; }
compound scope 1 : { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } }
compound scope 2 : { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; }
compound scope 3 : { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } }
compound scope 4 : { return ( ret ) ; }
compound scope 5 : { return ( 0 ) ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; } ] 
p_decls = [('int', 'ret', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'ret', None), ('char', 'c1', None), ('char', 'c2', None)]
assigns = [('int', 'ret', '', '0')]
compares = []
===> context { int ret ; ret = 0 ; if ( ( c1 >= '0' ) && ( c1 <= '9' ) ) { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } return ( 0 ) ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: ret
1 : |  decl_scope  | type: char, var: c1
2 : |  decl_scope  | type: char, var: c2
0 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c1', None), ('char', 'c2', None)]
assigns = [('int', 'ret', '', "c1 - '0'")]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', "c1 - '0'"), ('int', 'ret', '', '0')]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', "c1 - '0'"), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
===> context { ret = c1 - '0' ; if ( ( c2 >= '0' ) && ( c2 <= '9' ) ) { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } else { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } }
ignore sibs: ['return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: c1
1 : |  decl_scope  | type: char, var: c2
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: c1 - '0'
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char, value: c1
1 : |compare_scopes| type: char, value: '0'
2 : |compare_scopes| type: char, value: c1
3 : |compare_scopes| type: char, value: '9'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c1', None), ('char', 'c2', None)]
assigns = [('int', 'ret', '', '10'), ('int', 'ret', '', "c2 - '0'")]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '10'), ('int', 'ret', '', "c2 - '0'"), ('int', 'ret', '', '0')]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '10'), ('int', 'ret', '', "c2 - '0'"), ('int', 'ret', '', '0')]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '10'), ('int', 'ret', '', "c2 - '0'"), ('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '10'), ('int', 'ret', '', "c2 - '0'"), ('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '', '', '', '', '']
===> context { ret *= 10 ; ret += c2 - '0' ; return ( ret ) ; }
ignore sibs: ['else', "{ if ( c2 != '\\0' ) { return ( ret ) ; } else { return ( 0 ) ; } }", '}', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: c1
1 : |  decl_scope  | type: char, var: c2
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: 10
1 : | assign_scope | type: int, value: c2 - '0'
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: c1 - '0'
0 : |compare_scopes| type: char, value: c1
1 : |compare_scopes| type: char, value: '0'
2 : |compare_scopes| type: char, value: c1
3 : |compare_scopes| type: char, value: '9'
4 : |compare_scopes| type: char, value: c2
5 : |compare_scopes| type: char, value: '0'
6 : |compare_scopes| type: char, value: c2
7 : |compare_scopes| type: char, value: '9'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c1', None), ('char', 'c2', None)]
assigns = []
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0')]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0')]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '']
===> context { if ( c2 != '\0' ) { return ( ret ) ; } else { return ( 0 ) ; } }
ignore sibs: ['}', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: c1
1 : |  decl_scope  | type: char, var: c2
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: c1 - '0'
0 : |compare_scopes| type: char, value: c1
1 : |compare_scopes| type: char, value: '0'
2 : |compare_scopes| type: char, value: c1
3 : |compare_scopes| type: char, value: '9'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( ret ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( ret ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c1', None), ('char', 'c2', None)]
assigns = []
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0')]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0')]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '', '', '']
===> context { return ( ret ) ; }
ignore sibs: ['else', '{ return ( 0 ) ; }', '}', '}', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: c1
1 : |  decl_scope  | type: char, var: c2
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: c1 - '0'
0 : |compare_scopes| type: char, value: c1
1 : |compare_scopes| type: char, value: '0'
2 : |compare_scopes| type: char, value: c1
3 : |compare_scopes| type: char, value: '9'
4 : |compare_scopes| type: char, value: c2
5 : |compare_scopes| type: char, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'c1', None), ('char', 'c2', None)]
assigns = []
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0')]
compares = []
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0')]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '']
decls = [('char', 'c1', None), ('char', 'c2', None), ('int', 'ret', None)]
assigns = [('int', 'ret', '', '0'), ('int', 'ret', '', "c1 - '0'")]
compares = ['', '', '', '']
===> context { return ( 0 ) ; }
ignore sibs: ['}', '}', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: c1
1 : |  decl_scope  | type: char, var: c2
2 : |  decl_scope  | type: int, var: ret
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: c1 - '0'
0 : |compare_scopes| type: char, value: c1
1 : |compare_scopes| type: char, value: '0'
2 : |compare_scopes| type: char, value: c1
3 : |compare_scopes| type: char, value: '9'
=======END=======
compound scope 0 : { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = []
assigns = [('UNDEF', 'gRandRegister', '', '( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 )')]
compares = []
===> context { gRandRegister = ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 ) ; return ( gRandRegister ) ; }
ignore sibs: []
0 : | assign_scope | type: UNDEF, value: ( ( ( ( gRandRegister >> 31 ) ^ ( gRandRegister >> 6 ) ^ ( gRandRegister >> 4 ) ^ ( gRandRegister >> 2 ) ^ ( gRandRegister >> 1 ) ^ gRandRegister ) & 0x00000001 ) << 31 ) | ( gRandRegister >> 1 )
=======END=======
compound scope 0 : { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; }
compound scope 1 : { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } }
compound scope 2 : { return ( 0 ) ; }
compound scope 3 : { return ( - 1 ) ; }
compound scope 4 : { return ( 1 ) ; }
compound scope 5 : { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }
compound scope 6 : { return ( 1 ) ; }
compound scope 7 : { return ( - 1 ) ; }
compound scope 8 : { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } }
compound scope 9 : { return ( 1 ) ; }
compound scope 10 : { return ( 0 ) ; }
len(compound_scope) : 11
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; } ] 
p_decls = [('int', 'i', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'i', None), ('char *', 's1', None), ('char *', 's2', None)]
assigns = [('int', 'i', '', '0')]
compares = []
===> context { if ( s1 == NULL ) { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } if ( s2 == NULL ) { return ( 1 ) ; } int i ; i = 0 ; while ( s1 [ i ] != '\0' ) { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } if ( s2 [ i ] == '\0' ) { return ( 0 ) ; } return ( - 1 ) ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: char *, var: s1
2 : |  decl_scope  | type: char *, var: s2
0 : | assign_scope | type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '']
===> context { if ( s2 == NULL ) { return ( 0 ) ; } else { return ( - 1 ) ; } }
ignore sibs: ['if ( s2 == NULL ) { return ( 1 ) ; }', 'int i ;', 'i = 0 ;', "while ( s1 [ i ] != '\\0' ) { if ( s2 [ i ] == '\\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }", "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
0 : |compare_scopes| type: char *, value: s1
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '', '', '']
===> context { return ( 0 ) ; }
ignore sibs: ['else', '{ return ( - 1 ) ; }', '}', 'if ( s2 == NULL ) { return ( 1 ) ; }', 'int i ;', 'i = 0 ;', "while ( s1 [ i ] != '\\0' ) { if ( s2 [ i ] == '\\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }", "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
0 : |compare_scopes| type: char *, value: s1
1 : |compare_scopes| type: char *, value: NULL
2 : |compare_scopes| type: char *, value: s2
3 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( - 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( - 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '']
===> context { return ( - 1 ) ; }
ignore sibs: ['}', 'if ( s2 == NULL ) { return ( 1 ) ; }', 'int i ;', 'i = 0 ;', "while ( s1 [ i ] != '\\0' ) { if ( s2 [ i ] == '\\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }", "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
0 : |compare_scopes| type: char *, value: s1
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = ['', '']
===> context { return ( 1 ) ; }
ignore sibs: ['int i ;', 'i = 0 ;', "while ( s1 [ i ] != '\\0' ) { if ( s2 [ i ] == '\\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }", "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
0 : |compare_scopes| type: char *, value: s2
1 : |compare_scopes| type: char *, value: NULL
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
===> context { if ( s2 [ i ] == '\0' ) { return ( 1 ) ; } if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } i ++ ; }
ignore sibs: ["if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
2 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: s1 [ i ]
1 : |compare_scopes| type: char *, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { return ( 1 ) ; }
ignore sibs: ['if ( s1 [ i ] < s2 [ i ] ) { return ( - 1 ) ; } else { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } }', 'i ++ ;', '}', "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
2 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: s1 [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: char *, value: s2 [ i ]
3 : |compare_scopes| type: char *, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( - 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( - 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { return ( - 1 ) ; }
ignore sibs: ['else', '{ if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } }', 'i ++ ;', '}', "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
2 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: s1 [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: char *, value: s1 [ i ]
3 : |compare_scopes| type: char *, value: s2 [ i ]
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
===> context { if ( s1 [ i ] > s2 [ i ] ) { return ( 1 ) ; } }
ignore sibs: ['i ++ ;', '}', "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
2 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: s1 [ i ]
1 : |compare_scopes| type: char *, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { return ( 1 ) ; }
ignore sibs: ['}', 'i ++ ;', '}', "if ( s2 [ i ] == '\\0' ) { return ( 0 ) ; }", 'return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
2 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: s1 [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: char *, value: s1 [ i ]
3 : |compare_scopes| type: char *, value: s2 [ i ]
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 's1', None), ('char *', 's2', None)]
assigns = []
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 's1', None), ('char *', 's2', None), ('int', 'i', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '']
===> context { return ( 0 ) ; }
ignore sibs: ['return ( - 1 ) ;', '}']
0 : |  decl_scope  | type: char *, var: s1
1 : |  decl_scope  | type: char *, var: s2
2 : |  decl_scope  | type: int, var: i
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: s2 [ i ]
1 : |compare_scopes| type: char *, value: '\0'
=======END=======
compound scope 0 : { gRandRegister = seed ; }
len(compound_scope) : 1
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { gRandRegister = seed ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { gRandRegister = seed ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'seed', None)]
assigns = [('UNDEF', 'gRandRegister', '', 'seed')]
compares = []
===> context { gRandRegister = seed ; }
ignore sibs: []
0 : |  decl_scope  | type: uint32_t, var: seed
0 : | assign_scope | type: UNDEF, value: seed
=======END=======
compound scope 0 : { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; }
compound scope 1 : { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; }
compound scope 2 : { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } }
compound scope 3 : { dst [ i ] = src [ i ] ; }
compound scope 4 : { dst [ i ] = '_' ; }
compound scope 5 : { dst [ i ] = src [ i ] ; }
len(compound_scope) : 6
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; } ] 
p_decls = [('int', 'i', None), ('uint32_t', 'r', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'i', None), ('uint32_t', 'r', None), ('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None)]
assigns = [('int', 'i', '', '0'), ('UNDEF', 'dst ', '[ i ]', "'\\0'")]
compares = []
===> context { int i ; i = 0 ; uint32_t r ; r = ( cgc_RANDOM ( ) % 3 ) + 2 ; while ( ( src [ i ] != '\0' ) && ( i < len ) ) { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } dst [ i ] = '\0' ; }
ignore sibs: []
0 : |  decl_scope  | type: int, var: i
1 : |  decl_scope  | type: uint32_t, var: r
2 : |  decl_scope  | type: char *, var: dst
3 : |  decl_scope  | type: char *, var: src
4 : |  decl_scope  | type: cgc_size_t, var: len
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { if ( IS_VALID_CHAR ( src [ i ] ) ) { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } else { dst [ i ] = src [ i ] ; } i ++ ; }
ignore sibs: ["dst [ i ] = '\\0' ;", '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: uint32_t, var: r
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: src [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None)]
assigns = []
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('int', 'i', '', '0')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { if ( i % r ) { dst [ i ] = src [ i ] ; } else { dst [ i ] = '_' ; } }
ignore sibs: ['else', '{ dst [ i ] = src [ i ] ; }', 'i ++ ;', '}', "dst [ i ] = '\\0' ;", '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: uint32_t, var: r
0 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: src [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { dst [ i ] = src [ i ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { dst [ i ] = src [ i ] ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.IterationStatementContext'>
 scope [5] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [6] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { dst [ i ] = src [ i ] ; }
ignore sibs: ['else', "{ dst [ i ] = '_' ; }", '}', 'else', '{ dst [ i ] = src [ i ] ; }', 'i ++ ;', '}', "dst [ i ] = '\\0' ;", '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: uint32_t, var: r
0 : | assign_scope | type: UNDEF, value: src [ i ]
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: src [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { dst [ i ] = '_' ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { dst [ i ] = '_' ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.IterationStatementContext'>
 scope [4] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [5] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', "'_'")]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', "'_'"), ('int', 'i', '', '0')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', "'_'"), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', "'_'"), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', "'_'"), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', "'_'"), ('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { dst [ i ] = '_' ; }
ignore sibs: ['}', 'else', '{ dst [ i ] = src [ i ] ; }', 'i ++ ;', '}', "dst [ i ] = '\\0' ;", '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: uint32_t, var: r
0 : | assign_scope | type: UNDEF, value: '_'
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: src [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: len
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { dst [ i ] = src [ i ] ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { dst [ i ] = src [ i ] ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = []
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
decls = [('char *', 'dst', None), ('char *', 'src', None), ('cgc_size_t', 'len', None), ('int', 'i', None), ('uint32_t', 'r', None)]
assigns = [('UNDEF', 'dst ', '[ i ]', 'src [ i ]'), ('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { dst [ i ] = src [ i ] ; }
ignore sibs: ['i ++ ;', '}', "dst [ i ] = '\\0' ;", '}']
0 : |  decl_scope  | type: char *, var: dst
1 : |  decl_scope  | type: char *, var: src
2 : |  decl_scope  | type: cgc_size_t, var: len
3 : |  decl_scope  | type: int, var: i
4 : |  decl_scope  | type: uint32_t, var: r
0 : | assign_scope | type: UNDEF, value: src [ i ]
1 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: char *, value: src [ i ]
1 : |compare_scopes| type: char *, value: '\0'
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: len
=======END=======
compound scope 0 : { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; }
compound scope 1 : { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; }
compound scope 2 : { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; }
compound scope 3 : { return ( - 1 ) ; }
compound scope 4 : { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; }
compound scope 5 : { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }
compound scope 6 : { cgc_transmit_str ( WORD_MSG ) ; }
compound scope 7 : { cgc_transmit_str ( NEXT_WORD_MSG ) ; }
compound scope 8 : { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; }
compound scope 9 : { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; }
compound scope 10 : { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }
compound scope 11 : { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }
compound scope 12 : { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }
compound scope 13 : { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }
compound scope 14 : { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }
compound scope 15 : { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }
compound scope 16 : { cgc_transmit_str ( LOSE_MSG ) ; }
compound scope 17 : { cgc_transmit_str ( WIN_MSG ) ; }
len(compound_scope) : 18
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; } ] 
p_decls = [('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
 scope [0] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv2', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = []
===> context { char buf [ BUF_SIZE ] = { } ; int i ; i = 0 ; int ret ; ret = 0 ; int temp ; temp = 0 ; cgc_size_t sret ; sret = 0 ; char c ; c = '\n' ; cgc_transmit_str ( ENTER_NUM_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } int tlv1 ; { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } if ( tlv1 != 0 ) { return ( - 1 ) ; } { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } cgc_transmit_str ( FINAL_RND_MSG ) ; READLINE ( buf , BUF_SIZE ) ; { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } cgc_transmit_str ( buf ) ; { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv2 ; { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; } return ( 0 ) ; }
ignore sibs: []
0 : |  decl_scope  | type: char *, var: buf
1 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
2 : |  decl_scope  | type: int, var: i
3 : |  decl_scope  | type: int, var: ret
4 : |  decl_scope  | type: int, var: temp
5 : |  decl_scope  | type: cgc_size_t, var: sret
6 : |  decl_scope  | type: char, var: c
7 : |  decl_scope  | type: int, var: tlv1
8 : |  decl_scope  | type: int, var: tlv2
9 : |  decl_scope  | type: int, var: cgc_argc
10 : |  decl_scope  | type: char * *, var: cgc_argv
11 : |  decl_scope  | type: char *, var: cgc_argv [ ]
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
5 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; } ] 
p_decls = [('char', 'tlv11', None), ('char', 'tlv10', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'tlv11', None), ('char', 'tlv10', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char', 'tlv11', '', 'buf [ 0 ]'), ('char', 'tlv10', '', 'buf [ 1 ]')]
compares = []
decls = [('char', 'tlv11', None), ('char', 'tlv10', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None)]
assigns = [('char', 'tlv11', '', 'buf [ 0 ]'), ('char', 'tlv10', '', 'buf [ 1 ]'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
===> context { char tlv11 ; tlv11 = buf [ 0 ] ; char tlv10 ; tlv10 = buf [ 1 ] ; i = cgc_toInt ( tlv11 , tlv10 ) ; }
ignore sibs: ['int tlv1 ;', '{ int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; }', 'if ( tlv1 != 0 ) { return ( - 1 ) ; }', '{ uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; }', "for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }", 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: tlv11
1 : |  decl_scope  | type: char, var: tlv10
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: temp
10 : |  decl_scope  | type: cgc_size_t, var: sret
11 : |  decl_scope  | type: char, var: c
0 : | assign_scope | type: char, value: buf [ 0 ]
1 : | assign_scope | type: char, value: buf [ 1 ]
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char, value: '\n'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; } ] 
p_decls = [('int', 'tlv12', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv12', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('int', 'tlv12', '', 'i + 1')]
compares = []
decls = [('int', 'tlv12', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'tlv12', '', 'i + 1'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
===> context { int tlv12 ; tlv12 = i + 1 ; tlv1 = cgc_init ( tlv12 ) ; }
ignore sibs: ['if ( tlv1 != 0 ) { return ( - 1 ) ; }', '{ uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; }', "for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }", 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv12
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
6 : |  decl_scope  | type: int, var: i
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: int, var: temp
9 : |  decl_scope  | type: cgc_size_t, var: sret
10 : |  decl_scope  | type: char, var: c
11 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: i + 1
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: char, value: '\n'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( - 1 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { return ( - 1 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = ['', '']
===> context { return ( - 1 ) ; }
ignore sibs: ['{ uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; }', "for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }", 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: temp
8 : |  decl_scope  | type: cgc_size_t, var: sret
9 : |  decl_scope  | type: char, var: c
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
0 : |compare_scopes| type: int, value: tlv1
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; } ] 
p_decls = [('uint32_t', 'tlv4', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('uint32_t', 'tlv4', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('uint32_t', 'tlv4', '', '* ( ( int * ) buf )')]
compares = []
decls = [('uint32_t', 'tlv4', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('uint32_t', 'tlv4', '', '* ( ( int * ) buf )'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
===> context { uint32_t tlv4 ; tlv4 = * ( ( int * ) buf ) ; cgc_my_srand ( tlv4 ) ; }
ignore sibs: ["for ( i = 0 ; i < NUM_ROUNDS ; i ++ ) { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }", 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: uint32_t, var: tlv4
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
6 : |  decl_scope  | type: int, var: i
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: int, var: temp
9 : |  decl_scope  | type: cgc_size_t, var: sret
10 : |  decl_scope  | type: char, var: c
11 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: uint32_t, value: * ( ( int * ) buf )
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: char, value: '\n'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } } ] 
p_decls = [('int', 'tlv3', None)]
 scope [0] : <class 'CParser.CParser.IterationStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'tlv3', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = []
decls = [('int', 'tlv3', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'"), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('int', 'tlv3', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'"), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
===> context { if ( i == 0 ) { cgc_transmit_str ( WORD_MSG ) ; } else { cgc_transmit_str ( NEXT_WORD_MSG ) ; } temp = cgc_RANDOM ( ) % NUM_WORDS ; { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } cgc_transmit_str ( buf ) ; { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } READLINE ( buf , BUF_SIZE ) ; buf [ sret - 1 ] = '\0' ; int tlv3 ; { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } }
ignore sibs: ['cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: tlv3
1 : |  decl_scope  | type: int, var: cgc_argc
2 : |  decl_scope  | type: char * *, var: cgc_argv
3 : |  decl_scope  | type: char *, var: cgc_argv [ ]
4 : |  decl_scope  | type: char *, var: buf
5 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
6 : |  decl_scope  | type: int, var: i
7 : |  decl_scope  | type: int, var: ret
8 : |  decl_scope  | type: int, var: temp
9 : |  decl_scope  | type: cgc_size_t, var: sret
10 : |  decl_scope  | type: char, var: c
11 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: UNDEF, value: '\0'
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: cgc_size_t, value: 0
5 : | assign_scope | type: char, value: '\n'
6 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( WORD_MSG ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( WORD_MSG ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '', '', '']
===> context { cgc_transmit_str ( WORD_MSG ) ; }
ignore sibs: ['else', '{ cgc_transmit_str ( NEXT_WORD_MSG ) ; }', 'temp = cgc_RANDOM ( ) % NUM_WORDS ;', '{ char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv3 ;', '{ char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }', 'if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }', '}', 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: temp
8 : |  decl_scope  | type: cgc_size_t, var: sret
9 : |  decl_scope  | type: char, var: c
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
2 : |compare_scopes| type: int, value: i
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( NEXT_WORD_MSG ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( NEXT_WORD_MSG ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
===> context { cgc_transmit_str ( NEXT_WORD_MSG ) ; }
ignore sibs: ['temp = cgc_RANDOM ( ) % NUM_WORDS ;', '{ char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv3 ;', '{ char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }', 'if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }', '}', 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: temp
8 : |  decl_scope  | type: cgc_size_t, var: sret
9 : |  decl_scope  | type: char, var: c
10 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
5 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; } ] 
p_decls = [('char *', 'tlv19', None), ('char *', 'tlv18', None), ('cgc_size_t', 'tlv17', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv19', None), ('char *', 'tlv18', None), ('cgc_size_t', 'tlv17', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char *', 'tlv19', '', 'buf'), ('char *', 'tlv18', '', 'cgc_gWords [ temp ]'), ('cgc_size_t', 'tlv17', '', 'BUF_SIZE')]
compares = []
decls = [('char *', 'tlv19', None), ('char *', 'tlv18', None), ('cgc_size_t', 'tlv17', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv19', '', 'buf'), ('char *', 'tlv18', '', 'cgc_gWords [ temp ]'), ('cgc_size_t', 'tlv17', '', 'BUF_SIZE'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('char *', 'tlv19', None), ('char *', 'tlv18', None), ('cgc_size_t', 'tlv17', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv19', '', 'buf'), ('char *', 'tlv18', '', 'cgc_gWords [ temp ]'), ('cgc_size_t', 'tlv17', '', 'BUF_SIZE'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv19', None), ('char *', 'tlv18', None), ('cgc_size_t', 'tlv17', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv19', '', 'buf'), ('char *', 'tlv18', '', 'cgc_gWords [ temp ]'), ('cgc_size_t', 'tlv17', '', 'BUF_SIZE'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
===> context { char * tlv19 ; tlv19 = buf ; char * tlv18 ; tlv18 = cgc_gWords [ temp ] ; cgc_size_t tlv17 ; tlv17 = BUF_SIZE ; cgc_scramble ( tlv19 , tlv18 , tlv17 ) ; }
ignore sibs: ['cgc_transmit_str ( buf ) ;', '{ char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv3 ;', '{ char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }', 'if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }', '}', 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv19
1 : |  decl_scope  | type: char *, var: tlv18
2 : |  decl_scope  | type: cgc_size_t, var: tlv17
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: temp
11 : |  decl_scope  | type: cgc_size_t, var: sret
12 : |  decl_scope  | type: char, var: c
13 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: char *, value: cgc_gWords [ temp ]
2 : | assign_scope | type: cgc_size_t, value: BUF_SIZE
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: cgc_size_t, value: 0
7 : | assign_scope | type: char, value: '\n'
8 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; } ] 
p_decls = [('char *', 'tlv21', None), ('cgc_size_t', 'tlv20', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv21', None), ('cgc_size_t', 'tlv20', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char *', 'tlv21', '', '& c'), ('cgc_size_t', 'tlv20', '', '1')]
compares = []
decls = [('char *', 'tlv21', None), ('cgc_size_t', 'tlv20', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv21', '', '& c'), ('cgc_size_t', 'tlv20', '', '1'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('char *', 'tlv21', None), ('cgc_size_t', 'tlv20', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv21', '', '& c'), ('cgc_size_t', 'tlv20', '', '1'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv21', None), ('cgc_size_t', 'tlv20', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv21', '', '& c'), ('cgc_size_t', 'tlv20', '', '1'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
===> context { char * tlv21 ; tlv21 = & c ; cgc_size_t tlv20 ; tlv20 = 1 ; cgc_transmit_all ( tlv21 , tlv20 ) ; }
ignore sibs: ['READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv3 ;', '{ char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }', 'if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }', '}', 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv21
1 : |  decl_scope  | type: cgc_size_t, var: tlv20
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: temp
10 : |  decl_scope  | type: cgc_size_t, var: sret
11 : |  decl_scope  | type: char, var: c
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: & c
1 : | assign_scope | type: cgc_size_t, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char, value: '\n'
7 : | assign_scope | type: int, value: 0
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; } ] 
p_decls = [('char *', 'tlv23', None), ('char *', 'tlv22', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.IterationStatementContext'>
 scope [2] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [3] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv23', None), ('char *', 'tlv22', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char *', 'tlv23', '', 'buf'), ('char *', 'tlv22', '', 'cgc_gWords [ temp ]')]
compares = []
decls = [('char *', 'tlv23', None), ('char *', 'tlv22', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv23', '', 'buf'), ('char *', 'tlv22', '', 'cgc_gWords [ temp ]'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('char *', 'tlv23', None), ('char *', 'tlv22', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv23', '', 'buf'), ('char *', 'tlv22', '', 'cgc_gWords [ temp ]'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('char *', 'tlv23', None), ('char *', 'tlv22', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('char *', 'tlv23', '', 'buf'), ('char *', 'tlv22', '', 'cgc_gWords [ temp ]'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0'), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = ['', '']
===> context { char * tlv23 ; tlv23 = buf ; char * tlv22 ; tlv22 = cgc_gWords [ temp ] ; tlv3 = cgc_strcmp ( tlv23 , tlv22 ) ; }
ignore sibs: ['if ( tlv3 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }', '}', 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv23
1 : |  decl_scope  | type: char *, var: tlv22
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: temp
10 : |  decl_scope  | type: cgc_size_t, var: sret
11 : |  decl_scope  | type: char, var: c
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: char *, value: cgc_gWords [ temp ]
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char, value: '\n'
7 : | assign_scope | type: int, value: 0
8 : | assign_scope | type: UNDEF, value: '\0'
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.IterationStatementContext'>
 scope [3] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [4] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0')]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0'), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = ['', '']
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv3', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('int', 'i', '', '0'), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = ['', '', '', '']
===> context { cgc_transmit_str ( LOSE_MSG ) ; return ( 0 ) ; }
ignore sibs: ['}', 'cgc_transmit_str ( FINAL_RND_MSG ) ;', 'READLINE ( buf , BUF_SIZE ) ;', '{ char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }', '{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: temp
8 : |  decl_scope  | type: cgc_size_t, var: sret
9 : |  decl_scope  | type: char, var: c
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv3
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: UNDEF, value: '\0'
0 : |compare_scopes| type: int, value: i
1 : |compare_scopes| type: int, value: NUM_ROUNDS
2 : |compare_scopes| type: int, value: tlv3
3 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; } ] 
p_decls = [('char', 'tlv14', None), ('char', 'tlv13', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char', 'tlv14', None), ('char', 'tlv13', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char', 'tlv14', '', 'buf [ 0 ]'), ('char', 'tlv13', '', 'buf [ 1 ]')]
compares = []
decls = [('char', 'tlv14', None), ('char', 'tlv13', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char', 'tlv14', '', 'buf [ 0 ]'), ('char', 'tlv13', '', 'buf [ 1 ]'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
===> context { char tlv14 ; tlv14 = buf [ 0 ] ; char tlv13 ; tlv13 = buf [ 1 ] ; i = cgc_toInt ( tlv14 , tlv13 ) ; }
ignore sibs: ['{ char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }', 'cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char, var: tlv14
1 : |  decl_scope  | type: char, var: tlv13
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: temp
10 : |  decl_scope  | type: cgc_size_t, var: sret
11 : |  decl_scope  | type: char, var: c
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char, value: buf [ 0 ]
1 : | assign_scope | type: char, value: buf [ 1 ]
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char, value: '\n'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; } ] 
p_decls = [('char *', 'tlv7', None), ('char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv7', None), ('char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('char *', 'tlv6', '', 'cgc_gWords [ i ]'), ('cgc_size_t', 'tlv5', '', 'BUF_SIZE')]
compares = []
decls = [('char *', 'tlv7', None), ('char *', 'tlv6', None), ('cgc_size_t', 'tlv5', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv7', '', 'buf'), ('char *', 'tlv6', '', 'cgc_gWords [ i ]'), ('cgc_size_t', 'tlv5', '', 'BUF_SIZE'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
===> context { char * tlv7 ; tlv7 = buf ; char * tlv6 ; tlv6 = cgc_gWords [ i ] ; cgc_size_t tlv5 ; tlv5 = BUF_SIZE ; cgc_scramble ( tlv7 , tlv6 , tlv5 ) ; }
ignore sibs: ['cgc_transmit_str ( buf ) ;', '{ char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }', 'READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv7
1 : |  decl_scope  | type: char *, var: tlv6
2 : |  decl_scope  | type: cgc_size_t, var: tlv5
3 : |  decl_scope  | type: int, var: cgc_argc
4 : |  decl_scope  | type: char * *, var: cgc_argv
5 : |  decl_scope  | type: char *, var: cgc_argv [ ]
6 : |  decl_scope  | type: char *, var: buf
7 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
8 : |  decl_scope  | type: int, var: i
9 : |  decl_scope  | type: int, var: ret
10 : |  decl_scope  | type: int, var: temp
11 : |  decl_scope  | type: cgc_size_t, var: sret
12 : |  decl_scope  | type: char, var: c
13 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: char *, value: cgc_gWords [ i ]
2 : | assign_scope | type: cgc_size_t, value: BUF_SIZE
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: int, value: 0
6 : | assign_scope | type: cgc_size_t, value: 0
7 : | assign_scope | type: char, value: '\n'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; } ] 
p_decls = [('char *', 'tlv9', None), ('cgc_size_t', 'tlv8', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv9', None), ('cgc_size_t', 'tlv8', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char *', 'tlv9', '', '& c'), ('cgc_size_t', 'tlv8', '', '1')]
compares = []
decls = [('char *', 'tlv9', None), ('cgc_size_t', 'tlv8', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None)]
assigns = [('char *', 'tlv9', '', '& c'), ('cgc_size_t', 'tlv8', '', '1'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'")]
compares = []
===> context { char * tlv9 ; tlv9 = & c ; cgc_size_t tlv8 ; tlv8 = 1 ; cgc_transmit_all ( tlv9 , tlv8 ) ; }
ignore sibs: ['READLINE ( buf , BUF_SIZE ) ;', "buf [ sret - 1 ] = '\\0' ;", 'int tlv2 ;', '{ char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }', 'if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv9
1 : |  decl_scope  | type: cgc_size_t, var: tlv8
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: temp
10 : |  decl_scope  | type: cgc_size_t, var: sret
11 : |  decl_scope  | type: char, var: c
12 : |  decl_scope  | type: int, var: tlv1
0 : | assign_scope | type: char *, value: & c
1 : | assign_scope | type: cgc_size_t, value: 1
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char, value: '\n'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; } ] 
p_decls = [('char *', 'tlv16', None), ('char *', 'tlv15', None)]
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('char *', 'tlv16', None), ('char *', 'tlv15', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = [('char *', 'tlv16', '', 'buf'), ('char *', 'tlv15', '', 'cgc_gWords [ i ]')]
compares = []
decls = [('char *', 'tlv16', None), ('char *', 'tlv15', None), ('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('char *', 'tlv16', '', 'buf'), ('char *', 'tlv15', '', 'cgc_gWords [ i ]'), ('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = []
===> context { char * tlv16 ; tlv16 = buf ; char * tlv15 ; tlv15 = cgc_gWords [ i ] ; tlv2 = cgc_strcmp ( tlv16 , tlv15 ) ; }
ignore sibs: ['if ( tlv2 != 0 ) { cgc_transmit_str ( LOSE_MSG ) ; } else { cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: char *, var: tlv16
1 : |  decl_scope  | type: char *, var: tlv15
2 : |  decl_scope  | type: int, var: cgc_argc
3 : |  decl_scope  | type: char * *, var: cgc_argv
4 : |  decl_scope  | type: char *, var: cgc_argv [ ]
5 : |  decl_scope  | type: char *, var: buf
6 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
7 : |  decl_scope  | type: int, var: i
8 : |  decl_scope  | type: int, var: ret
9 : |  decl_scope  | type: int, var: temp
10 : |  decl_scope  | type: cgc_size_t, var: sret
11 : |  decl_scope  | type: char, var: c
12 : |  decl_scope  | type: int, var: tlv1
13 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: char *, value: buf
1 : | assign_scope | type: char *, value: cgc_gWords [ i ]
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: int, value: 0
4 : | assign_scope | type: int, value: 0
5 : | assign_scope | type: cgc_size_t, value: 0
6 : | assign_scope | type: char, value: '\n'
7 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( LOSE_MSG ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( LOSE_MSG ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.SelectionStatementContext'>
 scope [1] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [2] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = ['', '']
===> context { cgc_transmit_str ( LOSE_MSG ) ; }
ignore sibs: ['else', '{ cgc_transmit_str ( WIN_MSG ) ; }', 'return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: temp
8 : |  decl_scope  | type: cgc_size_t, var: sret
9 : |  decl_scope  | type: char, var: c
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
5 : | assign_scope | type: UNDEF, value: '\0'
0 : |compare_scopes| type: int, value: tlv2
1 : |compare_scopes| type: int, value: 0
=======END=======
=======START=======
SCOPE STACK : False 
START SCOPE : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( WIN_MSG ) ; } ] 
END SCOPE   : [ <class 'CParser.CParser.CompoundStatementContext'> => { cgc_transmit_str ( WIN_MSG ) ; } ] 
p_decls = []
 scope [0] : <class 'CParser.CParser.CompoundStatementContext'>
 scope [1] : <class 'CParser.CParser.FunctionDefinitionContext'>
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None)]
assigns = []
compares = []
decls = [('int', 'cgc_argc', None), ('char * *', 'cgc_argv', ' [ ]'), ('char *', 'cgc_argv [ ]', None), ('char *', 'buf', ' [ BUF_SIZE ]'), ('char', 'buf [ BUF_SIZE ]', None), ('int', 'i', None), ('int', 'ret', None), ('int', 'temp', None), ('cgc_size_t', 'sret', None), ('char', 'c', None), ('int', 'tlv1', None), ('int', 'tlv2', None)]
assigns = [('int', 'i', '', '0'), ('int', 'ret', '', '0'), ('int', 'temp', '', '0'), ('cgc_size_t', 'sret', '', '0'), ('char', 'c', '', "'\\n'"), ('UNDEF', 'buf ', '[ sret - 1 ]', "'\\0'")]
compares = []
===> context { cgc_transmit_str ( WIN_MSG ) ; }
ignore sibs: ['return ( 0 ) ;', '}']
0 : |  decl_scope  | type: int, var: cgc_argc
1 : |  decl_scope  | type: char * *, var: cgc_argv
2 : |  decl_scope  | type: char *, var: cgc_argv [ ]
3 : |  decl_scope  | type: char *, var: buf
4 : |  decl_scope  | type: char, var: buf [ BUF_SIZE ]
5 : |  decl_scope  | type: int, var: i
6 : |  decl_scope  | type: int, var: ret
7 : |  decl_scope  | type: int, var: temp
8 : |  decl_scope  | type: cgc_size_t, var: sret
9 : |  decl_scope  | type: char, var: c
10 : |  decl_scope  | type: int, var: tlv1
11 : |  decl_scope  | type: int, var: tlv2
0 : | assign_scope | type: int, value: 0
1 : | assign_scope | type: int, value: 0
2 : | assign_scope | type: int, value: 0
3 : | assign_scope | type: cgc_size_t, value: 0
4 : | assign_scope | type: char, value: '\n'
5 : | assign_scope | type: UNDEF, value: '\0'
=======END=======
def_vars[0]: [cgc_strlen] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t ret ;
sym_lut=>'{'str': 'char *', 'ret': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7ea7b8>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=0/14][j=0/3][dd=0/1][k=0/1] | type: cgc_size_t ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_main_0_0_0(){
    {cgc_size_t ret; ret = (cgc_size_t)(0); }
}
void fix_ingred_main_0_0(){
fix_ingred_main_0_0_0();
}

sym_lut=>'{'str': 'char *', 'ret': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7ea7b8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b7e9438>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b7e97b8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'str' - False OR  False
[i=0/14][j=1/3][dd=0/1][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : str (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : str
 => is literal (False) | is operator (False) str [vtype=char *]
unique : ('char *', 'str', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=0/14][j=1/3][dd=0/1][k=2/3] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
UNIQ_INIT: ('char *','str','None','None');

----
UNIQ_INIT: ('char *','str','None','None');

==== Scope 1 ====
void fix_ingred_main_0_1_1(){
char str_ref;
    bzero(&str_ref,1*sizeof(char));
char * str = &str_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(str); }
}
void fix_ingred_main_0_1_2(){
char str_ref;
    bzero(&str_ref,1*sizeof(char));
char * str = &str_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(NULL); }
}
void fix_ingred_main_0_1(){
fix_ingred_main_0_1_1();
fix_ingred_main_0_1_2();
}

sym_lut=>'{'str': 'char *', 'ret': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7ea7b8>), ('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f0198>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b7f0c88>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b7f17b8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'str[ret]' - False OR  False
[i=0/14][j=2/3][dd=0/1][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : str [ ret ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : str,[,ret,]
 => is literal (False) | is operator (False) str [vtype=char *]
unique : ('char *', 'str', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
unique : ('cgc_size_t', 'ret', None)
 => is literal (False) | is operator (True) ]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=0/14][j=2/3][dd=0/1][k=3/4] | type: char * ; var :  ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
not valid - cgc_size_t ret; ret = ((cgc_size_t)str [ ret ]);

----
UNIQ_INIT: ('char *','str','None','None');

UNIQ_INIT: ('cgc_size_t','ret','None','None');

==== Scope 1 ====
void fix_ingred_main_0_2_3(){
char str_ref;
    bzero(&str_ref,1*sizeof(char));
char * str = &str_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
    {cgc_size_t ret; ret = (cgc_size_t)('\0'); }
}
void fix_ingred_main_0_2(){
fix_ingred_main_0_2_3();
}

==== Scope 2 ====
void fix_ingred_main_0_0_0(){
    {cgc_size_t ret; ret = (cgc_size_t)(0); }
}
void fix_ingred_main_0_0(){
fix_ingred_main_0_0_0();
}
void fix_ingred_main_0_1_1(){
char str_ref;
    bzero(&str_ref,1*sizeof(char));
char * str = &str_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(str); }
}
void fix_ingred_main_0_1_2(){
char str_ref;
    bzero(&str_ref,1*sizeof(char));
char * str = &str_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(NULL); }
}
void fix_ingred_main_0_1(){
fix_ingred_main_0_1_1();
fix_ingred_main_0_1_2();
}
void fix_ingred_main_0_2_3(){
char str_ref;
    bzero(&str_ref,1*sizeof(char));
char * str = &str_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
    {cgc_size_t ret; ret = (cgc_size_t)('\0'); }
}
void fix_ingred_main_0_2(){
fix_ingred_main_0_2_3();
}
void fix_ingred_main_0(){
fix_ingred_main_0_0();
fix_ingred_main_0_1();
fix_ingred_main_0_2();
}

[Fix Ingredient functions]  -- START --
#ifndef FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
static void __attribute((constructor)) fix_ingred_enable_init(){
    char* tmp=getenv("ENABLE_FIXES");
    if (tmp) { fix_ingred_enable=1; }
}
#else
#ifndef FIX_INGREDIENT_CONTENT_VAR
#define FIX_INGREDIENT_CONTENT_VAR
static int fix_ingred_enable=0;
#endif
#endif

void fix_ingred_main_0_0_0();
void fix_ingred_main_0_0();
void fix_ingred_main_0_1_1();
void fix_ingred_main_0_1_2();
void fix_ingred_main_0_1();
void fix_ingred_main_0_2_3();
void fix_ingred_main_0_2();
void fix_ingred_main_0();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t rx_bytes ;
def_vars[1]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t total ;
def_vars[2]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[3]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[4]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[5]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[6]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t * tlv1 ;
def_vars[7]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[8]: [cgc_transmit_all] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=0/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=0/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=1/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=1/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=2/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=2/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=3/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=3/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=4/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=4/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=5/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=5/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=7/9][k=0/3] | type: cgc_size_t ; var : rx_bytes ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=1/14][j=0/7][dd=7/9][k=2/3] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
==== Scope 1 ====
void fix_ingred_main_1_0_0(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(0); }
    {cgc_size_t total; total = (cgc_size_t)(0); }
    {int ret; ret = (int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_main_1_0_2(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(0); }
    {cgc_size_t total; total = (cgc_size_t)(0); }
    {int ret; ret = (int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_main_1_0(){
fix_ingred_main_1_0_0();
fix_ingred_main_1_0_2();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b7fa2e8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b7fa668>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=0/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=0/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=1/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=1/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=2/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=2/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=3/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=3/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=4/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=4/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=5/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=5/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=1/7][dd=7/9][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=1/14][j=1/7][dd=7/9][k=4/5] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
UNIQ_INIT: ('char *','buf','None','None');

----
UNIQ_INIT: ('char *','buf','None','None');

==== Scope 1 ====
void fix_ingred_main_1_1_3(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(buf); }
    {cgc_size_t total; total = (cgc_size_t)(buf); }
    {int ret; ret = (int)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {void * tlv3; tlv3 = (void *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buf); }
}
void fix_ingred_main_1_1_4(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(NULL); }
    {cgc_size_t total; total = (cgc_size_t)(NULL); }
    {int ret; ret = (int)(NULL); }
    {int tlv4; tlv4 = (int)(NULL); }
    {void * tlv3; tlv3 = (void *)(NULL); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(NULL); }
    {unsigned int tlv5; tlv5 = (unsigned int)(NULL); }
}
void fix_ingred_main_1_1(){
fix_ingred_main_1_1_3();
fix_ingred_main_1_1_4();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b91df28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b91e278>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=0/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
unique : ('cgc_size_t', 'total', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=0/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
unique : ('cgc_size_t', 'size', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=1/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=1/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=2/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=2/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=3/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=3/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=4/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=4/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=5/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=5/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=1/14][j=2/7][dd=7/9][k=3/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : total (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size' - False OR  False
[i=1/14][j=2/7][dd=7/9][k=4/5] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : size (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
not valid - cgc_size_t total; total = ((cgc_size_t)total);

----
UNIQ_INIT: ('cgc_size_t','total','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

----
UNIQ_INIT: ('cgc_size_t','total','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

==== Scope 1 ====
void fix_ingred_main_1_2_3(){
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(total); }
    {int ret; ret = (int)(total); }
    {int tlv4; tlv4 = (int)(total); }
    {void * tlv3; tlv3 = (void *)(total); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(total); }
    {unsigned int tlv5; tlv5 = (unsigned int)(total); }
}
void fix_ingred_main_1_2_4(){
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(size); }
    {cgc_size_t total; total = (cgc_size_t)(size); }
    {int ret; ret = (int)(size); }
    {int tlv4; tlv4 = (int)(size); }
    {void * tlv3; tlv3 = (void *)(size); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(size); }
    {unsigned int tlv5; tlv5 = (unsigned int)(size); }
}
void fix_ingred_main_1_2(){
fix_ingred_main_1_2_3();
fix_ingred_main_1_2_4();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b91d3c8>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=0/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
unique : ('cgc_size_t', 'rx_bytes', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=1/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=2/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=3/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=4/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=5/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=1/14][j=3/7][dd=7/9][k=0/4] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
not valid - cgc_size_t rx_bytes; rx_bytes = ((cgc_size_t)rx_bytes);

----
UNIQ_INIT: ('cgc_size_t','rx_bytes','None','None');

==== Scope 1 ====
void fix_ingred_main_1_3_0(){
cgc_size_t rx_bytes;
    bzero(&rx_bytes,sizeof(cgc_size_t));
    {cgc_size_t total; total = (cgc_size_t)(rx_bytes); }
    {int ret; ret = (int)(rx_bytes); }
    {int tlv4; tlv4 = (int)(rx_bytes); }
    {void * tlv3; tlv3 = (void *)(rx_bytes); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(rx_bytes); }
    {unsigned int tlv5; tlv5 = (unsigned int)(rx_bytes); }
}
void fix_ingred_main_1_3(){
fix_ingred_main_1_3_0();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9397b8>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b923748>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b919668>), ('cgc_size_t *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b901898>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=0/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=0/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=0/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
unique : ('cgc_size_t', 'size', None)
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
unique : ('cgc_size_t', 'total', None)
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=1/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=1/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=1/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=2/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=2/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=2/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=3/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=3/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=3/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=4/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=4/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=4/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=5/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=5/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=5/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDOUT' - False OR  False
[i=1/14][j=4/7][dd=7/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDOUT (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDOUT
 => is literal (False) | is operator (False) STDOUT [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=1/14][j=4/7][dd=7/9][k=1/7] | type: void * ; var : tlv3 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'size-total' - False OR  False
[i=1/14][j=4/7][dd=7/9][k=2/7] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : size - total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : size,-,total
 => is literal (False) | is operator (False) size [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'size', None) ... continue!
 => is literal (False) | is operator (True) -
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
----
UNIQ_INIT: ('char *','buf','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

UNIQ_INIT: ('cgc_size_t','total','None','None');

----
UNIQ_INIT: ('char *','buf','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

UNIQ_INIT: ('cgc_size_t','total','None','None');

not valid - cgc_size_t total; total = ((cgc_size_t)size - total);

----
UNIQ_INIT: ('char *','buf','None','None');

UNIQ_INIT: ('cgc_size_t','size','None','None');

UNIQ_INIT: ('cgc_size_t','total','None','None');

==== Scope 1 ====
void fix_ingred_main_1_4_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(STDOUT); }
    {cgc_size_t total; total = (cgc_size_t)(STDOUT); }
    {int ret; ret = (int)(STDOUT); }
    {int tlv4; tlv4 = (int)(STDOUT); }
    {void * tlv3; tlv3 = (void *)(STDOUT); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDOUT); }
    {unsigned int tlv5; tlv5 = (unsigned int)(STDOUT); }
}
void fix_ingred_main_1_4_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(buf); }
    {cgc_size_t total; total = (cgc_size_t)(buf); }
    {int ret; ret = (int)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {void * tlv3; tlv3 = (void *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buf); }
}
void fix_ingred_main_1_4_2(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(size - total); }
    {int ret; ret = (int)(size - total); }
    {int tlv4; tlv4 = (int)(size - total); }
    {void * tlv3; tlv3 = (void *)(size - total); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(size - total); }
    {unsigned int tlv5; tlv5 = (unsigned int)(size - total); }
}
void fix_ingred_main_1_4(){
fix_ingred_main_1_4_0();
fix_ingred_main_1_4_1();
fix_ingred_main_1_4_2();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91c0b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91c438>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91b198>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91b518>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=0/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=1/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=2/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=3/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=4/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=5/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=1/14][j=5/7][dd=7/9][k=3/7] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
not valid - int ret; ret = ((int)ret);

----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_main_1_5_3(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(ret); }
    {cgc_size_t total; total = (cgc_size_t)(ret); }
    {int tlv4; tlv4 = (int)(ret); }
    {void * tlv3; tlv3 = (void *)(ret); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(ret); }
    {unsigned int tlv5; tlv5 = (unsigned int)(ret); }
}
void fix_ingred_main_1_5(){
fix_ingred_main_1_5_3();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b914358>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f9898>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7fb7b8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7f6668>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91c0b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91c438>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91b198>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b91b518>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=0/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=1/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=2/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=3/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=4/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=5/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=1/14][j=6/7][dd=7/9][k=0/8] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_main_1_6_0(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(1); }
    {cgc_size_t total; total = (cgc_size_t)(1); }
    {int ret; ret = (int)(1); }
    {int tlv4; tlv4 = (int)(1); }
    {void * tlv3; tlv3 = (void *)(1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(1); }
}
void fix_ingred_main_1_6(){
fix_ingred_main_1_6_0();
}

==== Scope 2 ====
void fix_ingred_main_1_0_0(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(0); }
    {cgc_size_t total; total = (cgc_size_t)(0); }
    {int ret; ret = (int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_main_1_0_2(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(0); }
    {cgc_size_t total; total = (cgc_size_t)(0); }
    {int ret; ret = (int)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_main_1_0(){
fix_ingred_main_1_0_0();
fix_ingred_main_1_0_2();
}
void fix_ingred_main_1_1_3(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(buf); }
    {cgc_size_t total; total = (cgc_size_t)(buf); }
    {int ret; ret = (int)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {void * tlv3; tlv3 = (void *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buf); }
}
void fix_ingred_main_1_1_4(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(NULL); }
    {cgc_size_t total; total = (cgc_size_t)(NULL); }
    {int ret; ret = (int)(NULL); }
    {int tlv4; tlv4 = (int)(NULL); }
    {void * tlv3; tlv3 = (void *)(NULL); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(NULL); }
    {unsigned int tlv5; tlv5 = (unsigned int)(NULL); }
}
void fix_ingred_main_1_1(){
fix_ingred_main_1_1_3();
fix_ingred_main_1_1_4();
}
void fix_ingred_main_1_2_3(){
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(total); }
    {int ret; ret = (int)(total); }
    {int tlv4; tlv4 = (int)(total); }
    {void * tlv3; tlv3 = (void *)(total); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(total); }
    {unsigned int tlv5; tlv5 = (unsigned int)(total); }
}
void fix_ingred_main_1_2_4(){
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(size); }
    {cgc_size_t total; total = (cgc_size_t)(size); }
    {int ret; ret = (int)(size); }
    {int tlv4; tlv4 = (int)(size); }
    {void * tlv3; tlv3 = (void *)(size); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(size); }
    {unsigned int tlv5; tlv5 = (unsigned int)(size); }
}
void fix_ingred_main_1_2(){
fix_ingred_main_1_2_3();
fix_ingred_main_1_2_4();
}
void fix_ingred_main_1_3_0(){
cgc_size_t rx_bytes;
    bzero(&rx_bytes,sizeof(cgc_size_t));
    {cgc_size_t total; total = (cgc_size_t)(rx_bytes); }
    {int ret; ret = (int)(rx_bytes); }
    {int tlv4; tlv4 = (int)(rx_bytes); }
    {void * tlv3; tlv3 = (void *)(rx_bytes); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(rx_bytes); }
    {unsigned int tlv5; tlv5 = (unsigned int)(rx_bytes); }
}
void fix_ingred_main_1_3(){
fix_ingred_main_1_3_0();
}
void fix_ingred_main_1_4_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(STDOUT); }
    {cgc_size_t total; total = (cgc_size_t)(STDOUT); }
    {int ret; ret = (int)(STDOUT); }
    {int tlv4; tlv4 = (int)(STDOUT); }
    {void * tlv3; tlv3 = (void *)(STDOUT); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDOUT); }
    {unsigned int tlv5; tlv5 = (unsigned int)(STDOUT); }
}
void fix_ingred_main_1_4_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(buf); }
    {cgc_size_t total; total = (cgc_size_t)(buf); }
    {int ret; ret = (int)(buf); }
    {int tlv4; tlv4 = (int)(buf); }
    {void * tlv3; tlv3 = (void *)(buf); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(buf); }
    {unsigned int tlv5; tlv5 = (unsigned int)(buf); }
}
void fix_ingred_main_1_4_2(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
cgc_size_t size;
    bzero(&size,sizeof(cgc_size_t));
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(size - total); }
    {int ret; ret = (int)(size - total); }
    {int tlv4; tlv4 = (int)(size - total); }
    {void * tlv3; tlv3 = (void *)(size - total); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(size - total); }
    {unsigned int tlv5; tlv5 = (unsigned int)(size - total); }
}
void fix_ingred_main_1_4(){
fix_ingred_main_1_4_0();
fix_ingred_main_1_4_1();
fix_ingred_main_1_4_2();
}
void fix_ingred_main_1_5_3(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(ret); }
    {cgc_size_t total; total = (cgc_size_t)(ret); }
    {int tlv4; tlv4 = (int)(ret); }
    {void * tlv3; tlv3 = (void *)(ret); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(ret); }
    {unsigned int tlv5; tlv5 = (unsigned int)(ret); }
}
void fix_ingred_main_1_5(){
fix_ingred_main_1_5_3();
}
void fix_ingred_main_1_6_0(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(1); }
    {cgc_size_t total; total = (cgc_size_t)(1); }
    {int ret; ret = (int)(1); }
    {int tlv4; tlv4 = (int)(1); }
    {void * tlv3; tlv3 = (void *)(1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(1); }
}
void fix_ingred_main_1_6(){
fix_ingred_main_1_6_0();
}
void fix_ingred_main_1(){
fix_ingred_main_1_0();
fix_ingred_main_1_1();
fix_ingred_main_1_2();
fix_ingred_main_1_3();
fix_ingred_main_1_4();
fix_ingred_main_1_5();
fix_ingred_main_1_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_1_0_0();
void fix_ingred_main_1_0_2();
void fix_ingred_main_1_0();
void fix_ingred_main_1_1_3();
void fix_ingred_main_1_1_4();
void fix_ingred_main_1_1();
void fix_ingred_main_1_2_3();
void fix_ingred_main_1_2_4();
void fix_ingred_main_1_2();
void fix_ingred_main_1_3_0();
void fix_ingred_main_1_3();
void fix_ingred_main_1_4_0();
void fix_ingred_main_1_4_1();
void fix_ingred_main_1_4_2();
void fix_ingred_main_1_4();
void fix_ingred_main_1_5_3();
void fix_ingred_main_1_5();
void fix_ingred_main_1_6_0();
void fix_ingred_main_1_6();
void fix_ingred_main_1();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_transmit_str] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t len ;
def_vars[1]: [cgc_transmit_str] : <class 'CParser.CParser.DeclarationContext'> : char * tlv1 ;
sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[]'
sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t', 'tlv1': 'char *'}'
val_s=>'[('char *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b912d68>), ('cgc_size_t', 'len', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b915898>)]'
cval_s=>'[]'
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=2/14][j=1/2][dd=0/2][k=0/2] | type: char * ; var : tlv1 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=2/14][j=1/2][dd=0/2][k=1/2] | type: cgc_size_t ; var : len ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=char *]
unique : ('char *', 'tlv1', None)
 => is literal (False) | is operator (True) )
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=2/14][j=1/2][dd=1/2][k=0/2] | type: char * ; var : tlv1 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv1)' - False OR  False
[i=2/14][j=1/2][dd=1/2][k=1/2] | type: cgc_size_t ; var : len ; varinfo :  ; value_node : cgc_strlen ( tlv1 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv1,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv1 [vtype=char *]
not unique: ('char *', 'tlv1', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char *','buf','None','None');

UNIQ_INIT: ('char *','tlv1','None','None');

not valid - char * tlv1; tlv1 = ((char *)cgc_strlen ( tlv1 ));

----
UNIQ_INIT: ('char *','buf','None','None');

UNIQ_INIT: ('char *','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_main_2_1_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
char tlv1_ref;
    bzero(&tlv1_ref,1*sizeof(char));
char * tlv1 = &tlv1_ref;
    {cgc_size_t len; len = (cgc_size_t)(buf); }
    {char * tlv1; tlv1 = (char *)(buf); }
}
void fix_ingred_main_2_1_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
char tlv1_ref;
    bzero(&tlv1_ref,1*sizeof(char));
char * tlv1 = &tlv1_ref;
    {cgc_size_t len; len = (cgc_size_t)(cgc_strlen ( tlv1 )); }
}
void fix_ingred_main_2_1(){
fix_ingred_main_2_1_0();
fix_ingred_main_2_1_1();
}

==== Scope 2 ====
void fix_ingred_main_2_1_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
char tlv1_ref;
    bzero(&tlv1_ref,1*sizeof(char));
char * tlv1 = &tlv1_ref;
    {cgc_size_t len; len = (cgc_size_t)(buf); }
    {char * tlv1; tlv1 = (char *)(buf); }
}
void fix_ingred_main_2_1_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
char tlv1_ref;
    bzero(&tlv1_ref,1*sizeof(char));
char * tlv1 = &tlv1_ref;
    {cgc_size_t len; len = (cgc_size_t)(cgc_strlen ( tlv1 )); }
}
void fix_ingred_main_2_1(){
fix_ingred_main_2_1_0();
fix_ingred_main_2_1_1();
}
void fix_ingred_main_2(){
fix_ingred_main_2_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_2_1_0();
void fix_ingred_main_2_1_1();
void fix_ingred_main_2_1();
void fix_ingred_main_2();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t rx_bytes ;
def_vars[1]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t total ;
def_vars[2]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[3]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[4]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[5]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[6]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t * tlv1 ;
def_vars[7]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[8]: [cgc_receive_all] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b918518>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b918898>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b859198>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b8594a8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int'}'
val_s=>'[('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b8795f8>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9259e8>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b931978>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b92d898>), ('cgc_size_t *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b90aac8>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=0/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=1/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=2/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=3/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=4/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=5/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=3/14][j=4/7][dd=7/9][k=0/7] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
----
==== Scope 1 ====
void fix_ingred_main_3_4_0(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(STDIN); }
    {cgc_size_t total; total = (cgc_size_t)(STDIN); }
    {int ret; ret = (int)(STDIN); }
    {int tlv4; tlv4 = (int)(STDIN); }
    {void * tlv3; tlv3 = (void *)(STDIN); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDIN); }
    {unsigned int tlv5; tlv5 = (unsigned int)(STDIN); }
}
void fix_ingred_main_3_4(){
fix_ingred_main_3_4_0();
}

sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9272e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b927668>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b8433c8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b843748>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'size': 'cgc_size_t', 'rx_bytes': 'cgc_size_t', 'total': 'cgc_size_t', 'ret': 'int', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b841588>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b916ac8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9289e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b938898>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9272e8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b927668>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b8433c8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b843748>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
==== Scope 2 ====
void fix_ingred_main_3_4_0(){
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(STDIN); }
    {cgc_size_t total; total = (cgc_size_t)(STDIN); }
    {int ret; ret = (int)(STDIN); }
    {int tlv4; tlv4 = (int)(STDIN); }
    {void * tlv3; tlv3 = (void *)(STDIN); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(STDIN); }
    {unsigned int tlv5; tlv5 = (unsigned int)(STDIN); }
}
void fix_ingred_main_3_4(){
fix_ingred_main_3_4_0();
}
void fix_ingred_main_3(){
fix_ingred_main_3_4();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_3_4_0();
void fix_ingred_main_3_4();
void fix_ingred_main_3();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t count ;
def_vars[1]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[2]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : char c ;
def_vars[3]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t rx_bytes ;
def_vars[4]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : int tlv4 ;
def_vars[5]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : void * tlv3 ;
def_vars[6]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv2 ;
def_vars[7]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t * tlv1 ;
def_vars[8]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : unsigned int tlv5 ;
def_vars[9]: [cgc_readline] : <class 'CParser.CParser.DeclarationContext'> : cgc__terminate ( tlv5 ) ;
sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b84fac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b83f978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236c47c908>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ddb38>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=0/10][k=0/4] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=0/10][k=1/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=0/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=1/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=2/10][k=0/4] | type: cgc_size_t ; var : count ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=2/10][k=1/4] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=2/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=3/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=4/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=5/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=6/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=4/14][j=0/7][dd=8/10][k=2/4] | type: char ; var : c ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
----
----
==== Scope 1 ====
void fix_ingred_main_4_0_0(){
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char c; c = (char)(0); }
}
void fix_ingred_main_4_0_1(){
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char c; c = (char)(0); }
}
void fix_ingred_main_4_0_2(){
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {int ret; ret = (int)(0); }
    {char c; c = (char)(0); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_main_4_0(){
fix_ingred_main_4_0_0();
fix_ingred_main_4_0_1();
fix_ingred_main_4_0_2();
}

sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b8789e8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b878d68>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/14][j=1/7][dd=0/10][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
unique : ('char *', 'buf', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/14][j=1/7][dd=0/10][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=4/14][j=1/7][dd=2/10][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : buf (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
not unique: ('char *', 'buf', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=4/14][j=1/7][dd=2/10][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
UNIQ_INIT: ('char *','buf','None','None');

----
UNIQ_INIT: ('char *','buf','None','None');

==== Scope 1 ====
void fix_ingred_main_4_1_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t count; count = (cgc_size_t)(buf); }
    {char c; c = (char)(buf); }
}
void fix_ingred_main_4_1_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t count; count = (cgc_size_t)(NULL); }
    {char c; c = (char)(NULL); }
}
void fix_ingred_main_4_1(){
fix_ingred_main_4_1_0();
fix_ingred_main_4_1_1();
}

sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t', 'count': 'cgc_size_t', 'ret': 'int', 'c': 'char', 'rx_bytes': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b84fac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b83f978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236c47c908>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ddb38>)]'
cval_s=>'[('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bdb6048>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc4df28>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd806d8>), ('cgc_size_t', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd80198>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=0/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
unique : ('char', 'c', None)
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=0/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=0/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
unique : ('cgc_size_t', 'count', None)
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=0/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
unique : ('cgc_size_t', 'len', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=1/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=1/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=1/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=1/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=2/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=2/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=2/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=2/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=3/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=3/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=3/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=3/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=4/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=4/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=4/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=4/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=5/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=5/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=5/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=5/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=6/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=6/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=6/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=6/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=4/14][j=2/7][dd=8/10][k=4/8] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=4/14][j=2/7][dd=8/10][k=5/8] | type: char ; var :  ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'count' - False OR  False
[i=4/14][j=2/7][dd=8/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : count (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : count
 => is literal (False) | is operator (False) count [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'count', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=4/14][j=2/7][dd=8/10][k=7/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
not valid - char c; c = ((char)c);

----
UNIQ_INIT: ('char','c','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

----
UNIQ_INIT: ('char','c','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

not valid - cgc_size_t count; count = ((cgc_size_t)count);

----
UNIQ_INIT: ('char','c','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

----
UNIQ_INIT: ('char','c','None','None');

UNIQ_INIT: ('cgc_size_t','count','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

==== Scope 1 ====
void fix_ingred_main_4_2_4(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(c); }
    {int ret; ret = (int)(c); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(c); }
    {int tlv4; tlv4 = (int)(c); }
    {void * tlv3; tlv3 = (void *)(c); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(c); }
    {unsigned int tlv5; tlv5 = (unsigned int)(c); }
}
void fix_ingred_main_4_2_5(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)('\n'); }
    {int ret; ret = (int)('\n'); }
    {char c; c = (char)('\n'); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)('\n'); }
    {int tlv4; tlv4 = (int)('\n'); }
    {void * tlv3; tlv3 = (void *)('\n'); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)('\n'); }
    {unsigned int tlv5; tlv5 = (unsigned int)('\n'); }
}
void fix_ingred_main_4_2_6(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {int ret; ret = (int)(count); }
    {char c; c = (char)(count); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(count); }
    {int tlv4; tlv4 = (int)(count); }
    {void * tlv3; tlv3 = (void *)(count); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(count); }
    {unsigned int tlv5; tlv5 = (unsigned int)(count); }
}
void fix_ingred_main_4_2_7(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(len); }
    {int ret; ret = (int)(len); }
    {char c; c = (char)(len); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(len); }
    {int tlv4; tlv4 = (int)(len); }
    {void * tlv3; tlv3 = (void *)(len); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(len); }
    {unsigned int tlv5; tlv5 = (unsigned int)(len); }
}
void fix_ingred_main_4_2(){
fix_ingred_main_4_2_4();
fix_ingred_main_4_2_5();
fix_ingred_main_4_2_6();
fix_ingred_main_4_2_7();
}

sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t', 'count': 'cgc_size_t', 'ret': 'int', 'c': 'char', 'rx_bytes': 'cgc_size_t'}'
val_s=>'[('UNDEF', 'buf ', '[ count ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9c9f28>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b84fac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b83f978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236c47c908>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ddb38>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t', 'count': 'cgc_size_t', 'ret': 'int', 'c': 'char', 'rx_bytes': 'cgc_size_t', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('int', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcc0e48>), ('void *', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba93908>), ('cgc_size_t', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9e5358>), ('cgc_size_t *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd1d588>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b84fac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b83f978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236c47c908>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ddb38>)]'
cval_s=>'[]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=4/14][j=4/7][dd=0/10][k=0/8] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=0/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
unique : ('char', 'c', None)
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=0/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=1/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=1/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [S] => '[False, False, False]'
has_multiptr_refs 'STDIN' - False OR  False
[i=4/14][j=4/7][dd=2/10][k=0/8] | type: int ; var : tlv4 ; varinfo :  ; value_node : STDIN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : STDIN
 => is literal (False) | is operator (False) STDIN [vtype=None]
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=2/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=2/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=3/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=3/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=4/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=4/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=5/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=5/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=6/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=6/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=4/14][j=4/7][dd=8/10][k=1/8] | type: void * ; var : tlv3 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=4/7][dd=8/10][k=2/8] | type: cgc_size_t ; var : tlv2 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
UNIQ_INIT: ('char','c','None','None');

not valid - char c; c = ((char)& c);

----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

==== Scope 1 ====
void fix_ingred_main_4_4_0(){
char c;
    bzero(&c,sizeof(char));
    {cgc_size_t count; count = (cgc_size_t)(STDIN); }
    {char c; c = (char)(STDIN); }
}
void fix_ingred_main_4_4_1(){
char c;
    bzero(&c,sizeof(char));
    {cgc_size_t count; count = (cgc_size_t)(& c); }
    {int ret; ret = (int)(& c); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(& c); }
    {int tlv4; tlv4 = (int)(& c); }
    {void * tlv3; tlv3 = (void *)(& c); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(& c); }
    {unsigned int tlv5; tlv5 = (unsigned int)(& c); }
}
void fix_ingred_main_4_4_2(){
char c;
    bzero(&c,sizeof(char));
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {int ret; ret = (int)(1); }
    {char c; c = (char)(1); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(1); }
    {int tlv4; tlv4 = (int)(1); }
    {void * tlv3; tlv3 = (void *)(1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(1); }
}
void fix_ingred_main_4_4(){
fix_ingred_main_4_4_0();
fix_ingred_main_4_4_1();
fix_ingred_main_4_4_2();
}

sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t', 'count': 'cgc_size_t', 'ret': 'int', 'c': 'char', 'rx_bytes': 'cgc_size_t', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *'}'
val_s=>'[('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b84fac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b83f978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236c47c908>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ddb38>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc98518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc987b8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9f34a8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9f39e8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=4/14][j=5/7][dd=0/10][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=4/14][j=5/7][dd=0/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
unique : ('cgc_size_t', 'rx_bytes', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=4/14][j=5/7][dd=2/10][k=4/8] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rx_bytes' - False OR  False
[i=4/14][j=5/7][dd=2/10][k=6/8] | type: cgc_size_t ; var :  ; varinfo :  ; value_node : rx_bytes (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rx_bytes
 => is literal (False) | is operator (False) rx_bytes [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'rx_bytes', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

UNIQ_INIT: ('cgc_size_t','rx_bytes','None','None');

----
UNIQ_INIT: ('int','ret','None','None');

UNIQ_INIT: ('cgc_size_t','rx_bytes','None','None');

==== Scope 1 ====
void fix_ingred_main_4_5_4(){
int ret;
    bzero(&ret,sizeof(int));
cgc_size_t rx_bytes;
    bzero(&rx_bytes,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(ret); }
    {char c; c = (char)(ret); }
}
void fix_ingred_main_4_5_6(){
int ret;
    bzero(&ret,sizeof(int));
cgc_size_t rx_bytes;
    bzero(&rx_bytes,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(rx_bytes); }
    {char c; c = (char)(rx_bytes); }
}
void fix_ingred_main_4_5(){
fix_ingred_main_4_5_4();
fix_ingred_main_4_5_6();
}

sym_lut=>'{'buf': 'char *', 'len': 'cgc_size_t', 'count': 'cgc_size_t', 'ret': 'int', 'c': 'char', 'rx_bytes': 'cgc_size_t', 'tlv4': 'int', 'tlv3': 'void *', 'tlv2': 'cgc_size_t', 'tlv1': 'cgc_size_t *', 'tlv5': 'unsigned int'}'
val_s=>'[('unsigned int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc79518>), ('cgc_size_t', 'count', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b84fac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b83f978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236c47c908>), ('cgc_size_t', 'rx_bytes', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ddb38>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc98518>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc987b8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9f34a8>), ('cgc_size_t', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9f39e8>)]'
Checking 'cgc__terminate( tlv5 )' - is_func=True, is_func_ptr=False
cgc__terminate( tlv5 ) is a function.
Skipping.
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=6/7][dd=0/10][k=0/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=4/14][j=6/7][dd=2/10][k=0/9] | type: unsigned int ; var : tlv5 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_main_4_6_0(){
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {char c; c = (char)(1); }
}
void fix_ingred_main_4_6(){
fix_ingred_main_4_6_0();
}

==== Scope 2 ====
void fix_ingred_main_4_0_0(){
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char c; c = (char)(0); }
}
void fix_ingred_main_4_0_1(){
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {char c; c = (char)(0); }
}
void fix_ingred_main_4_0_2(){
    {cgc_size_t count; count = (cgc_size_t)(0); }
    {int ret; ret = (int)(0); }
    {char c; c = (char)(0); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(0); }
    {int tlv4; tlv4 = (int)(0); }
    {void * tlv3; tlv3 = (void *)(0); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(0); }
    {unsigned int tlv5; tlv5 = (unsigned int)(0); }
}
void fix_ingred_main_4_0(){
fix_ingred_main_4_0_0();
fix_ingred_main_4_0_1();
fix_ingred_main_4_0_2();
}
void fix_ingred_main_4_1_0(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t count; count = (cgc_size_t)(buf); }
    {char c; c = (char)(buf); }
}
void fix_ingred_main_4_1_1(){
char buf_ref;
    bzero(&buf_ref,1*sizeof(char));
char * buf = &buf_ref;
    {cgc_size_t count; count = (cgc_size_t)(NULL); }
    {char c; c = (char)(NULL); }
}
void fix_ingred_main_4_1(){
fix_ingred_main_4_1_0();
fix_ingred_main_4_1_1();
}
void fix_ingred_main_4_2_4(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(c); }
    {int ret; ret = (int)(c); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(c); }
    {int tlv4; tlv4 = (int)(c); }
    {void * tlv3; tlv3 = (void *)(c); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(c); }
    {unsigned int tlv5; tlv5 = (unsigned int)(c); }
}
void fix_ingred_main_4_2_5(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)('\n'); }
    {int ret; ret = (int)('\n'); }
    {char c; c = (char)('\n'); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)('\n'); }
    {int tlv4; tlv4 = (int)('\n'); }
    {void * tlv3; tlv3 = (void *)('\n'); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)('\n'); }
    {unsigned int tlv5; tlv5 = (unsigned int)('\n'); }
}
void fix_ingred_main_4_2_6(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {int ret; ret = (int)(count); }
    {char c; c = (char)(count); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(count); }
    {int tlv4; tlv4 = (int)(count); }
    {void * tlv3; tlv3 = (void *)(count); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(count); }
    {unsigned int tlv5; tlv5 = (unsigned int)(count); }
}
void fix_ingred_main_4_2_7(){
char c;
    bzero(&c,sizeof(char));
cgc_size_t count;
    bzero(&count,sizeof(cgc_size_t));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(len); }
    {int ret; ret = (int)(len); }
    {char c; c = (char)(len); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(len); }
    {int tlv4; tlv4 = (int)(len); }
    {void * tlv3; tlv3 = (void *)(len); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(len); }
    {unsigned int tlv5; tlv5 = (unsigned int)(len); }
}
void fix_ingred_main_4_2(){
fix_ingred_main_4_2_4();
fix_ingred_main_4_2_5();
fix_ingred_main_4_2_6();
fix_ingred_main_4_2_7();
}
void fix_ingred_main_4_4_0(){
char c;
    bzero(&c,sizeof(char));
    {cgc_size_t count; count = (cgc_size_t)(STDIN); }
    {char c; c = (char)(STDIN); }
}
void fix_ingred_main_4_4_1(){
char c;
    bzero(&c,sizeof(char));
    {cgc_size_t count; count = (cgc_size_t)(& c); }
    {int ret; ret = (int)(& c); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(& c); }
    {int tlv4; tlv4 = (int)(& c); }
    {void * tlv3; tlv3 = (void *)(& c); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(& c); }
    {unsigned int tlv5; tlv5 = (unsigned int)(& c); }
}
void fix_ingred_main_4_4_2(){
char c;
    bzero(&c,sizeof(char));
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {int ret; ret = (int)(1); }
    {char c; c = (char)(1); }
    {cgc_size_t rx_bytes; rx_bytes = (cgc_size_t)(1); }
    {int tlv4; tlv4 = (int)(1); }
    {void * tlv3; tlv3 = (void *)(1); }
    {cgc_size_t tlv2; tlv2 = (cgc_size_t)(1); }
    {unsigned int tlv5; tlv5 = (unsigned int)(1); }
}
void fix_ingred_main_4_4(){
fix_ingred_main_4_4_0();
fix_ingred_main_4_4_1();
fix_ingred_main_4_4_2();
}
void fix_ingred_main_4_5_4(){
int ret;
    bzero(&ret,sizeof(int));
cgc_size_t rx_bytes;
    bzero(&rx_bytes,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(ret); }
    {char c; c = (char)(ret); }
}
void fix_ingred_main_4_5_6(){
int ret;
    bzero(&ret,sizeof(int));
cgc_size_t rx_bytes;
    bzero(&rx_bytes,sizeof(cgc_size_t));
    {cgc_size_t count; count = (cgc_size_t)(rx_bytes); }
    {char c; c = (char)(rx_bytes); }
}
void fix_ingred_main_4_5(){
fix_ingred_main_4_5_4();
fix_ingred_main_4_5_6();
}
void fix_ingred_main_4_6_0(){
    {cgc_size_t count; count = (cgc_size_t)(1); }
    {char c; c = (char)(1); }
}
void fix_ingred_main_4_6(){
fix_ingred_main_4_6_0();
}
void fix_ingred_main_4(){
fix_ingred_main_4_0();
fix_ingred_main_4_1();
fix_ingred_main_4_2();
fix_ingred_main_4_4();
fix_ingred_main_4_5();
fix_ingred_main_4_6();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_4_0_0();
void fix_ingred_main_4_0_1();
void fix_ingred_main_4_0_2();
void fix_ingred_main_4_0();
void fix_ingred_main_4_1_0();
void fix_ingred_main_4_1_1();
void fix_ingred_main_4_1();
void fix_ingred_main_4_2_4();
void fix_ingred_main_4_2_5();
void fix_ingred_main_4_2_6();
void fix_ingred_main_4_2_7();
void fix_ingred_main_4_2();
void fix_ingred_main_4_4_0();
void fix_ingred_main_4_4_1();
void fix_ingred_main_4_4_2();
void fix_ingred_main_4_4();
void fix_ingred_main_4_5_4();
void fix_ingred_main_4_5_6();
void fix_ingred_main_4_5();
void fix_ingred_main_4_6_0();
void fix_ingred_main_4_6();
void fix_ingred_main_4();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_rotN] : <class 'CParser.CParser.DeclarationContext'> : int temp ;
sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd676d8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd67208>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=5/14][j=0/7][dd=0/1][k=0/4] | type: int ; var : temp ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'n%VALID_CHARS_LEN' - False OR  False
[i=5/14][j=0/7][dd=0/1][k=1/4] | type: int ; var : n ; varinfo :  ; value_node : n % VALID_CHARS_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : n,%,VALID_CHARS_LEN
 => is literal (False) | is operator (False) n [vtype=int]
unique : ('int', 'n', None)
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) VALID_CHARS_LEN [vtype=None]
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'n' - False OR  False
[i=5/14][j=0/7][dd=0/1][k=2/4] | type: int ; var : temp ; varinfo :  ; value_node : n (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : n
 => is literal (False) | is operator (False) n [vtype=int]
not unique: ('int', 'n', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'temp%VALID_CHARS_LEN' - False OR  False
[i=5/14][j=0/7][dd=0/1][k=3/4] | type: int ; var : temp ; varinfo :  ; value_node : temp % VALID_CHARS_LEN (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : temp,%,VALID_CHARS_LEN
 => is literal (False) | is operator (False) temp [vtype=int]
unique : ('int', 'temp', None)
 => is literal (False) | is operator (True) %
 => is literal (False) | is operator (False) VALID_CHARS_LEN [vtype=None]
----
UNIQ_INIT: ('int','n','None','None');

UNIQ_INIT: ('int','temp','None','None');

----
UNIQ_INIT: ('int','n','None','None');

UNIQ_INIT: ('int','temp','None','None');

not valid - int temp; temp = ((int)temp % VALID_CHARS_LEN);

==== Scope 1 ====
void fix_ingred_main_5_0_0(){
int n;
    bzero(&n,sizeof(int));
int temp;
    bzero(&temp,sizeof(int));
    {int temp; temp = (int)(0); }
}
void fix_ingred_main_5_0_2(){
int n;
    bzero(&n,sizeof(int));
int temp;
    bzero(&temp,sizeof(int));
    {int temp; temp = (int)(n); }
}
void fix_ingred_main_5_0(){
fix_ingred_main_5_0_0();
fix_ingred_main_5_0_2();
}

sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd27518>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bdb93c8>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba6f588>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba6fb38>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd274a8>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c-'a'' - False OR  False
[i=5/14][j=1/7][dd=0/1][k=0/7] | type: int ; var : temp ; varinfo :  ; value_node : c - 'a' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c,-,'a'
 => is literal (False) | is operator (False) c [vtype=char]
unique : ('char', 'c', None)
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 'a'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c' - False OR  False
[i=5/14][j=1/7][dd=0/1][k=3/7] | type: char ; var :  ; varinfo :  ; value_node : c (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''a'' - False OR  False
[i=5/14][j=1/7][dd=0/1][k=4/7] | type: char ; var :  ; varinfo :  ; value_node : 'a' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 'a'
 => is literal (True) | is operator (False) 'a'
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''z'' - False OR  False
[i=5/14][j=1/7][dd=0/1][k=6/7] | type: char ; var :  ; varinfo :  ; value_node : 'z' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 'z'
 => is literal (True) | is operator (False) 'z'
----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

==== Scope 1 ====
void fix_ingred_main_5_1_0(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c - 'a'); }
}
void fix_ingred_main_5_1_3(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c); }
}
void fix_ingred_main_5_1_4(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('a'); }
}
void fix_ingred_main_5_1_6(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('z'); }
}
void fix_ingred_main_5_1(){
fix_ingred_main_5_1_0();
fix_ingred_main_5_1_3();
fix_ingred_main_5_1_4();
fix_ingred_main_5_1_6();
}

sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>)]'
cval_s=>'[]'
sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba08208>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bc630b8>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bc632e8>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bb11048>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba08c18>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c-'A'+26' - False OR  False
[i=5/14][j=3/7][dd=0/1][k=0/7] | type: int ; var : temp ; varinfo :  ; value_node : c - 'A' + 26 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c,-,'A',+,26
 => is literal (False) | is operator (False) c [vtype=char]
unique : ('char', 'c', None)
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) 'A'
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 26
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''A'' - False OR  False
[i=5/14][j=3/7][dd=0/1][k=4/7] | type: char ; var :  ; varinfo :  ; value_node : 'A' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 'A'
 => is literal (True) | is operator (False) 'A'
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''Z'' - False OR  False
[i=5/14][j=3/7][dd=0/1][k=6/7] | type: char ; var :  ; varinfo :  ; value_node : 'Z' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 'Z'
 => is literal (True) | is operator (False) 'Z'
----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

==== Scope 1 ====
void fix_ingred_main_5_3_0(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c - 'A' + 26); }
}
void fix_ingred_main_5_3_4(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('A'); }
}
void fix_ingred_main_5_3_6(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('Z'); }
}
void fix_ingred_main_5_3(){
fix_ingred_main_5_3_0();
fix_ingred_main_5_3_4();
fix_ingred_main_5_3_6();
}

sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>)]'
cval_s=>'[]'
sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bfc4ac8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bc467b8>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bc46e48>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd69ba8>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd69b38>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c-'0'+52' - False OR  False
[i=5/14][j=5/7][dd=0/1][k=0/7] | type: int ; var : temp ; varinfo :  ; value_node : c - '0' + 52 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c,-,'0',+,52
 => is literal (False) | is operator (False) c [vtype=char]
unique : ('char', 'c', None)
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) '0'
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 52
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''0'' - False OR  False
[i=5/14][j=5/7][dd=0/1][k=4/7] | type: char ; var :  ; varinfo :  ; value_node : '0' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '0'
 => is literal (True) | is operator (False) '0'
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''9'' - False OR  False
[i=5/14][j=5/7][dd=0/1][k=6/7] | type: char ; var :  ; varinfo :  ; value_node : '9' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '9'
 => is literal (True) | is operator (False) '9'
----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

==== Scope 1 ====
void fix_ingred_main_5_5_0(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c - '0' + 52); }
}
void fix_ingred_main_5_5_4(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('0'); }
}
void fix_ingred_main_5_5_6(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('9'); }
}
void fix_ingred_main_5_5(){
fix_ingred_main_5_5_0();
fix_ingred_main_5_5_4();
fix_ingred_main_5_5_6();
}

sym_lut=>'{'c': 'char', 'n': 'int', 'temp': 'int'}'
val_s=>'[('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc67198>), ('int', 'n', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bf647b8>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_main_5_0_0(){
int n;
    bzero(&n,sizeof(int));
int temp;
    bzero(&temp,sizeof(int));
    {int temp; temp = (int)(0); }
}
void fix_ingred_main_5_0_2(){
int n;
    bzero(&n,sizeof(int));
int temp;
    bzero(&temp,sizeof(int));
    {int temp; temp = (int)(n); }
}
void fix_ingred_main_5_0(){
fix_ingred_main_5_0_0();
fix_ingred_main_5_0_2();
}
void fix_ingred_main_5_1_0(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c - 'a'); }
}
void fix_ingred_main_5_1_3(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c); }
}
void fix_ingred_main_5_1_4(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('a'); }
}
void fix_ingred_main_5_1_6(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('z'); }
}
void fix_ingred_main_5_1(){
fix_ingred_main_5_1_0();
fix_ingred_main_5_1_3();
fix_ingred_main_5_1_4();
fix_ingred_main_5_1_6();
}
void fix_ingred_main_5_3_0(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c - 'A' + 26); }
}
void fix_ingred_main_5_3_4(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('A'); }
}
void fix_ingred_main_5_3_6(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('Z'); }
}
void fix_ingred_main_5_3(){
fix_ingred_main_5_3_0();
fix_ingred_main_5_3_4();
fix_ingred_main_5_3_6();
}
void fix_ingred_main_5_5_0(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)(c - '0' + 52); }
}
void fix_ingred_main_5_5_4(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('0'); }
}
void fix_ingred_main_5_5_6(){
char c;
    bzero(&c,sizeof(char));
    {int temp; temp = (int)('9'); }
}
void fix_ingred_main_5_5(){
fix_ingred_main_5_5_0();
fix_ingred_main_5_5_4();
fix_ingred_main_5_5_6();
}
void fix_ingred_main_5(){
fix_ingred_main_5_0();
fix_ingred_main_5_1();
fix_ingred_main_5_3();
fix_ingred_main_5_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_5_0_0();
void fix_ingred_main_5_0_2();
void fix_ingred_main_5_0();
void fix_ingred_main_5_1_0();
void fix_ingred_main_5_1_3();
void fix_ingred_main_5_1_4();
void fix_ingred_main_5_1_6();
void fix_ingred_main_5_1();
void fix_ingred_main_5_3_0();
void fix_ingred_main_5_3_4();
void fix_ingred_main_5_3_6();
void fix_ingred_main_5_3();
void fix_ingred_main_5_5_0();
void fix_ingred_main_5_5_4();
void fix_ingred_main_5_5_6();
void fix_ingred_main_5_5();
void fix_ingred_main_5();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_strrotcpy] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t ret ;
def_vars[1]: [cgc_strrotcpy] : <class 'CParser.CParser.DeclarationContext'> : char tlv2 ;
def_vars[2]: [cgc_strrotcpy] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
sym_lut=>'{'dst': 'char *', 'src': 'char *', 'rot': 'int'}'
val_s=>'[('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd4b588>), ('UNDEF', 'dst ', '[ ret ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba8c2e8>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/14][j=0/4][dd=1/3][k=0/2] | type: cgc_size_t ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=6/14][j=0/4][dd=2/3][k=0/2] | type: cgc_size_t ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_main_6_0_0(){
    {char tlv2; tlv2 = (char)(0); }
    {int tlv1; tlv1 = (int)(0); }
}
void fix_ingred_main_6_0(){
fix_ingred_main_6_0_0();
}

sym_lut=>'{'dst': 'char *', 'src': 'char *', 'rot': 'int'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bbceeb8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bbcedd8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd4c588>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd4c898>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src' - False OR  False
[i=6/14][j=1/4][dd=0/3][k=0/4] | type: char * ; var :  ; varinfo :  ; value_node : src (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src
 => is literal (False) | is operator (False) src [vtype=char *]
unique : ('char *', 'src', None)
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dst' - False OR  False
[i=6/14][j=1/4][dd=0/3][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : dst (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dst
 => is literal (False) | is operator (False) dst [vtype=char *]
unique : ('char *', 'dst', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src' - False OR  False
[i=6/14][j=1/4][dd=1/3][k=0/4] | type: char * ; var :  ; varinfo :  ; value_node : src (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=6/14][j=1/4][dd=1/3][k=1/4] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dst' - False OR  False
[i=6/14][j=1/4][dd=1/3][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : dst (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dst
 => is literal (False) | is operator (False) dst [vtype=char *]
not unique: ('char *', 'dst', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src' - False OR  False
[i=6/14][j=1/4][dd=2/3][k=0/4] | type: char * ; var :  ; varinfo :  ; value_node : src (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=6/14][j=1/4][dd=2/3][k=1/4] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
is_func_ [d] => '[False, False, False]'
has_multiptr_refs 'dst' - False OR  False
[i=6/14][j=1/4][dd=2/3][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : dst (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : dst
 => is literal (False) | is operator (False) dst [vtype=char *]
not unique: ('char *', 'dst', None) ... continue!
----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('char *','dst','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('char *','dst','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('char *','dst','None','None');

==== Scope 1 ====
void fix_ingred_main_6_1_0(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
char dst_ref;
    bzero(&dst_ref,1*sizeof(char));
char * dst = &dst_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(src); }
    {char tlv2; tlv2 = (char)(src); }
    {int tlv1; tlv1 = (int)(src); }
}
void fix_ingred_main_6_1_1(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
char dst_ref;
    bzero(&dst_ref,1*sizeof(char));
char * dst = &dst_ref;
    {char tlv2; tlv2 = (char)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
}
void fix_ingred_main_6_1_2(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
char dst_ref;
    bzero(&dst_ref,1*sizeof(char));
char * dst = &dst_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(dst); }
    {char tlv2; tlv2 = (char)(dst); }
    {int tlv1; tlv1 = (int)(dst); }
}
void fix_ingred_main_6_1(){
fix_ingred_main_6_1_0();
fix_ingred_main_6_1_1();
fix_ingred_main_6_1_2();
}

sym_lut=>'{'dst': 'char *', 'src': 'char *', 'rot': 'int', 'ret': 'cgc_size_t'}'
val_s=>'[('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd4b588>), ('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc9f128>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236baaeeb8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236baae198>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[ret]' - False OR  False
[i=6/14][j=2/4][dd=0/3][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : src [ ret ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,ret,]
 => is literal (False) | is operator (False) src [vtype=char *]
unique : ('char *', 'src', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
unique : ('cgc_size_t', 'ret', None)
 => is literal (False) | is operator (True) ]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[ret]' - False OR  False
[i=6/14][j=2/4][dd=1/3][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : src [ ret ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,ret,]
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'ret', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=6/14][j=2/4][dd=1/3][k=3/4] | type: char * ; var :  ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[ret]' - False OR  False
[i=6/14][j=2/4][dd=2/3][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : src [ ret ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,ret,]
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'ret', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=6/14][j=2/4][dd=2/3][k=3/4] | type: char * ; var :  ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
not valid - cgc_size_t ret; ret = ((cgc_size_t)src [ ret ]);

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('cgc_size_t','ret','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('cgc_size_t','ret','None','None');

==== Scope 1 ====
void fix_ingred_main_6_2_2(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
    {    ret = 0;
         char tlv2; tlv2 = (char)(src [ ret ]); }
    {    ret = 0;
         int tlv1; tlv1 = (int)(src [ ret ]); }
}
void fix_ingred_main_6_2_3(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
    {char tlv2; tlv2 = (char)('\0'); }
    {int tlv1; tlv1 = (int)('\0'); }
}
void fix_ingred_main_6_2(){
fix_ingred_main_6_2_2();
fix_ingred_main_6_2_3();
}

sym_lut=>'{'dst': 'char *', 'src': 'char *', 'rot': 'int', 'ret': 'cgc_size_t', 'tlv2': 'char', 'tlv1': 'int'}'
val_s=>'[('char', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb744a8>), ('int', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc75588>), ('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd4b588>), ('cgc_size_t', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc9f128>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236baaeeb8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236baae198>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[ret]' - False OR  False
[i=6/14][j=3/4][dd=0/3][k=0/6] | type: char ; var : tlv2 ; varinfo :  ; value_node : src [ ret ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,ret,]
 => is literal (False) | is operator (False) src [vtype=char *]
unique : ('char *', 'src', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
unique : ('cgc_size_t', 'ret', None)
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=6/14][j=3/4][dd=0/3][k=1/6] | type: int ; var : tlv1 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
unique : ('int', 'rot', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[ret]' - False OR  False
[i=6/14][j=3/4][dd=1/3][k=0/6] | type: char ; var : tlv2 ; varinfo :  ; value_node : src [ ret ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,ret,]
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'ret', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=6/14][j=3/4][dd=1/3][k=1/6] | type: int ; var : tlv1 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[ret]' - False OR  False
[i=6/14][j=3/4][dd=2/3][k=0/6] | type: char ; var : tlv2 ; varinfo :  ; value_node : src [ ret ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,ret,]
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) ret [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'ret', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=6/14][j=3/4][dd=2/3][k=1/6] | type: int ; var : tlv1 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
not valid - cgc_size_t ret; ret = ((cgc_size_t)src [ ret ]);

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('cgc_size_t','ret','None','None');

UNIQ_INIT: ('int','rot','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('cgc_size_t','ret','None','None');

UNIQ_INIT: ('int','rot','None','None');

==== Scope 1 ====
void fix_ingred_main_6_3_0(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
int rot;
    bzero(&rot,sizeof(int));
    {    ret = 0;
         char tlv2; tlv2 = (char)(src [ ret ]); }
    {    ret = 0;
         int tlv1; tlv1 = (int)(src [ ret ]); }
}
void fix_ingred_main_6_3_1(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
int rot;
    bzero(&rot,sizeof(int));
    {cgc_size_t ret; ret = (cgc_size_t)(rot); }
    {char tlv2; tlv2 = (char)(rot); }
    {int tlv1; tlv1 = (int)(rot); }
}
void fix_ingred_main_6_3(){
fix_ingred_main_6_3_0();
fix_ingred_main_6_3_1();
}

==== Scope 2 ====
void fix_ingred_main_6_0_0(){
    {char tlv2; tlv2 = (char)(0); }
    {int tlv1; tlv1 = (int)(0); }
}
void fix_ingred_main_6_0(){
fix_ingred_main_6_0_0();
}
void fix_ingred_main_6_1_0(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
char dst_ref;
    bzero(&dst_ref,1*sizeof(char));
char * dst = &dst_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(src); }
    {char tlv2; tlv2 = (char)(src); }
    {int tlv1; tlv1 = (int)(src); }
}
void fix_ingred_main_6_1_1(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
char dst_ref;
    bzero(&dst_ref,1*sizeof(char));
char * dst = &dst_ref;
    {char tlv2; tlv2 = (char)(NULL); }
    {int tlv1; tlv1 = (int)(NULL); }
}
void fix_ingred_main_6_1_2(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
char dst_ref;
    bzero(&dst_ref,1*sizeof(char));
char * dst = &dst_ref;
    {cgc_size_t ret; ret = (cgc_size_t)(dst); }
    {char tlv2; tlv2 = (char)(dst); }
    {int tlv1; tlv1 = (int)(dst); }
}
void fix_ingred_main_6_1(){
fix_ingred_main_6_1_0();
fix_ingred_main_6_1_1();
fix_ingred_main_6_1_2();
}
void fix_ingred_main_6_2_2(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
    {    ret = 0;
         char tlv2; tlv2 = (char)(src [ ret ]); }
    {    ret = 0;
         int tlv1; tlv1 = (int)(src [ ret ]); }
}
void fix_ingred_main_6_2_3(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
    {char tlv2; tlv2 = (char)('\0'); }
    {int tlv1; tlv1 = (int)('\0'); }
}
void fix_ingred_main_6_2(){
fix_ingred_main_6_2_2();
fix_ingred_main_6_2_3();
}
void fix_ingred_main_6_3_0(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
int rot;
    bzero(&rot,sizeof(int));
    {    ret = 0;
         char tlv2; tlv2 = (char)(src [ ret ]); }
    {    ret = 0;
         int tlv1; tlv1 = (int)(src [ ret ]); }
}
void fix_ingred_main_6_3_1(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
cgc_size_t ret;
    bzero(&ret,sizeof(cgc_size_t));
int rot;
    bzero(&rot,sizeof(int));
    {cgc_size_t ret; ret = (cgc_size_t)(rot); }
    {char tlv2; tlv2 = (char)(rot); }
    {int tlv1; tlv1 = (int)(rot); }
}
void fix_ingred_main_6_3(){
fix_ingred_main_6_3_0();
fix_ingred_main_6_3_1();
}
void fix_ingred_main_6(){
fix_ingred_main_6_0();
fix_ingred_main_6_1();
fix_ingred_main_6_2();
fix_ingred_main_6_3();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_6_0_0();
void fix_ingred_main_6_0();
void fix_ingred_main_6_1_0();
void fix_ingred_main_6_1_1();
void fix_ingred_main_6_1_2();
void fix_ingred_main_6_1();
void fix_ingred_main_6_2_2();
void fix_ingred_main_6_2_3();
void fix_ingred_main_6_2();
void fix_ingred_main_6_3_0();
void fix_ingred_main_6_3_1();
void fix_ingred_main_6_3();
void fix_ingred_main_6();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[1]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t numWords ;
def_vars[2]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t total ;
def_vars[3]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[4]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t temp ;
def_vars[5]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : char * pTemp ;
def_vars[6]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv3 ;
def_vars[7]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[8]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : void * * tlv1 ;
def_vars[9]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv6 ;
def_vars[10]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : int tlv5 ;
def_vars[11]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : void * * tlv4 ;
def_vars[12]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[13]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : char * tlv10 ;
def_vars[14]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : char * tlv9 ;
def_vars[15]: [cgc_init] : <class 'CParser.CParser.DeclarationContext'> : int tlv8 ;
sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>), ('cgc_size_t', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc9e6d8>), ('char *', 'pTemp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b3dcac8>)]'
cval_s=>'[]'
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=0/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=0/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=1/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=1/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=1/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=1/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=2/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=2/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=3/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=3/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=3/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=3/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=4/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=4/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=4/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=4/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=5/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=5/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=5/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=5/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=6/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=6/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=6/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=6/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=7/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=7/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=7/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=7/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=9/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=9/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=9/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=9/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=10/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=10/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=10/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=10/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=12/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=12/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=12/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=12/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=13/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=13/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=13/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=13/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=14/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=14/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=14/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=14/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=15/16][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_WORDS' - False OR  False
[i=7/14][j=0/10][dd=15/16][k=1/6] | type: cgc_size_t ; var : numWords ; varinfo :  ; value_node : NUM_WORDS (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_WORDS
 => is literal (False) | is operator (False) NUM_WORDS [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=7/14][j=0/10][dd=15/16][k=2/6] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWordData' - False OR  False
[i=7/14][j=0/10][dd=15/16][k=5/6] | type: char * ; var : pTemp ; varinfo :  ; value_node : cgc_gWordData (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWordData
 => is literal (False) | is operator (False) cgc_gWordData [vtype=None]
----
----
----
----
==== Scope 1 ====
void fix_ingred_main_7_0_0(){
    {cgc_size_t numWords; numWords = (cgc_size_t)(0); }
    {int i; i = (int)(0); }
    {cgc_size_t temp; temp = (cgc_size_t)(0); }
    {char * pTemp; pTemp = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
    {char * tlv10; tlv10 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {int tlv8; tlv8 = (int)(0); }
}
void fix_ingred_main_7_0_1(){
    {int ret; ret = (int)(NUM_WORDS); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(NUM_WORDS); }
    {cgc_size_t total; total = (cgc_size_t)(NUM_WORDS); }
    {int i; i = (int)(NUM_WORDS); }
    {cgc_size_t temp; temp = (cgc_size_t)(NUM_WORDS); }
    {char * pTemp; pTemp = (char *)(NUM_WORDS); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(NUM_WORDS); }
    {int tlv2; tlv2 = (int)(NUM_WORDS); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NUM_WORDS); }
    {int tlv5; tlv5 = (int)(NUM_WORDS); }
    {char * tlv7; tlv7 = (char *)(NUM_WORDS); }
    {char * tlv10; tlv10 = (char *)(NUM_WORDS); }
    {char * tlv9; tlv9 = (char *)(NUM_WORDS); }
    {int tlv8; tlv8 = (int)(NUM_WORDS); }
}
void fix_ingred_main_7_0_2(){
    {cgc_size_t numWords; numWords = (cgc_size_t)(0); }
    {int i; i = (int)(0); }
    {cgc_size_t temp; temp = (cgc_size_t)(0); }
    {char * pTemp; pTemp = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
    {char * tlv10; tlv10 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {int tlv8; tlv8 = (int)(0); }
}
void fix_ingred_main_7_0_5(){
    {int ret; ret = (int)(cgc_gWordData); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(cgc_gWordData); }
    {cgc_size_t total; total = (cgc_size_t)(cgc_gWordData); }
    {int i; i = (int)(cgc_gWordData); }
    {cgc_size_t temp; temp = (cgc_size_t)(cgc_gWordData); }
    {char * pTemp; pTemp = (char *)(cgc_gWordData); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_gWordData); }
    {int tlv2; tlv2 = (int)(cgc_gWordData); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_gWordData); }
    {int tlv5; tlv5 = (int)(cgc_gWordData); }
    {char * tlv7; tlv7 = (char *)(cgc_gWordData); }
    {char * tlv10; tlv10 = (char *)(cgc_gWordData); }
    {char * tlv9; tlv9 = (char *)(cgc_gWordData); }
    {int tlv8; tlv8 = (int)(cgc_gWordData); }
}
void fix_ingred_main_7_0(){
fix_ingred_main_7_0_0();
fix_ingred_main_7_0_1();
fix_ingred_main_7_0_2();
fix_ingred_main_7_0_5();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *'}'
val_s=>'[('cgc_size_t', 'tlv3', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bea75f8>), ('int', 'tlv2', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba64048>), ('void * *', 'tlv1', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bca53c8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>)]'
cval_s=>'[]'
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=0/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=1/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=2/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=3/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=4/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=5/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=6/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=7/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=9/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=10/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=12/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=13/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=14/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
is_func_ [s] => '[True, False, True]'
has_multiptr_refs 'sizeof(gSeedWords)' - False OR  False
[i=7/14][j=1/10][dd=15/16][k=0/5] | type: cgc_size_t ; var : tlv3 ; varinfo :  ; value_node : sizeof ( gSeedWords ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : sizeof,(,gSeedWords,)
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) )
----
==== Scope 1 ====
void fix_ingred_main_7_1_0(){
    {int ret; ret = (int)(sizeof ( gSeedWords )); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(sizeof ( gSeedWords )); }
    {cgc_size_t total; total = (cgc_size_t)(sizeof ( gSeedWords )); }
    {int i; i = (int)(sizeof ( gSeedWords )); }
    {cgc_size_t temp; temp = (cgc_size_t)(sizeof ( gSeedWords )); }
    {char * pTemp; pTemp = (char *)(sizeof ( gSeedWords )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( gSeedWords )); }
    {int tlv2; tlv2 = (int)(sizeof ( gSeedWords )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(sizeof ( gSeedWords )); }
    {int tlv5; tlv5 = (int)(sizeof ( gSeedWords )); }
    {char * tlv7; tlv7 = (char *)(sizeof ( gSeedWords )); }
    {char * tlv10; tlv10 = (char *)(sizeof ( gSeedWords )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( gSeedWords )); }
    {int tlv8; tlv8 = (int)(sizeof ( gSeedWords )); }
}
void fix_ingred_main_7_1(){
fix_ingred_main_7_1_0();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236ba947b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236ba355f8>)]'
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=1/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
unique : ('int', 'ret', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=3/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=4/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=5/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=6/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=7/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=9/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=10/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=12/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=13/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=14/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'ret' - False OR  False
[i=7/14][j=2/10][dd=15/16][k=2/4] | type: int ; var :  ; varinfo :  ; value_node : ret (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : ret
 => is literal (False) | is operator (False) ret [vtype=int]
not unique: ('int', 'ret', None) ... continue!
----
UNIQ_INIT: ('int','ret','None','None');

==== Scope 1 ====
void fix_ingred_main_7_2_2(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t numWords; numWords = (cgc_size_t)(ret); }
    {int i; i = (int)(ret); }
    {cgc_size_t temp; temp = (cgc_size_t)(ret); }
    {char * pTemp; pTemp = (char *)(ret); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(ret); }
    {int tlv2; tlv2 = (int)(ret); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ret); }
    {int tlv5; tlv5 = (int)(ret); }
    {char * tlv7; tlv7 = (char *)(ret); }
    {char * tlv10; tlv10 = (char *)(ret); }
    {char * tlv9; tlv9 = (char *)(ret); }
    {int tlv8; tlv8 = (int)(ret); }
}
void fix_ingred_main_7_2(){
fix_ingred_main_7_2_2();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int'}'
val_s=>'[('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc6a198>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbdc518>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbdcba8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd2c898>)]'
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=0/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=0/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
unique : ('cgc_size_t', 'numWords', None)
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=1/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=1/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=1/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=2/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=2/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=2/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=3/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=3/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=3/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=4/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=4/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=4/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=5/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=5/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=5/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=6/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=6/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=6/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=7/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=7/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=7/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=9/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=9/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=9/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=10/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=10/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=10/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=12/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=12/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=12/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=13/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=13/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=13/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=14/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=14/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=14/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=3/10][dd=15/16][k=0/8] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=7/14][j=3/10][dd=15/16][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [n] => '[False, False, False]'
has_multiptr_refs 'numWords' - False OR  False
[i=7/14][j=3/10][dd=15/16][k=7/8] | type: int ; var :  ; varinfo :  ; value_node : numWords (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : numWords
 => is literal (False) | is operator (False) numWords [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'numWords', None) ... continue!
----
UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','numWords','None','None');

not valid - int i; i = ((int)i);

----
UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','numWords','None','None');

not valid - cgc_size_t numWords; numWords = ((cgc_size_t)numWords);

----
UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','numWords','None','None');

==== Scope 1 ====
void fix_ingred_main_7_3_0(){
int i;
    bzero(&i,sizeof(int));
cgc_size_t numWords;
    bzero(&numWords,sizeof(cgc_size_t));
    {cgc_size_t numWords; numWords = (cgc_size_t)(1); }
    {cgc_size_t total; total = (cgc_size_t)(1); }
    {int i; i = (int)(1); }
    {cgc_size_t temp; temp = (cgc_size_t)(1); }
    {char * pTemp; pTemp = (char *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
    {int tlv2; tlv2 = (int)(1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(1); }
    {int tlv5; tlv5 = (int)(1); }
    {char * tlv7; tlv7 = (char *)(1); }
    {char * tlv10; tlv10 = (char *)(1); }
    {char * tlv9; tlv9 = (char *)(1); }
    {int tlv8; tlv8 = (int)(1); }
}
void fix_ingred_main_7_3_6(){
int i;
    bzero(&i,sizeof(int));
cgc_size_t numWords;
    bzero(&numWords,sizeof(cgc_size_t));
    {int ret; ret = (int)(i); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(i); }
    {cgc_size_t total; total = (cgc_size_t)(i); }
    {cgc_size_t temp; temp = (cgc_size_t)(i); }
    {char * pTemp; pTemp = (char *)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
    {int tlv2; tlv2 = (int)(i); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(i); }
    {int tlv5; tlv5 = (int)(i); }
    {char * tlv7; tlv7 = (char *)(i); }
    {char * tlv10; tlv10 = (char *)(i); }
    {char * tlv9; tlv9 = (char *)(i); }
    {int tlv8; tlv8 = (int)(i); }
}
void fix_ingred_main_7_3_7(){
int i;
    bzero(&i,sizeof(int));
cgc_size_t numWords;
    bzero(&numWords,sizeof(cgc_size_t));
    {int ret; ret = (int)(numWords); }
    {cgc_size_t total; total = (cgc_size_t)(numWords); }
    {int i; i = (int)(numWords); }
    {cgc_size_t temp; temp = (cgc_size_t)(numWords); }
    {char * pTemp; pTemp = (char *)(numWords); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(numWords); }
    {int tlv2; tlv2 = (int)(numWords); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(numWords); }
    {int tlv5; tlv5 = (int)(numWords); }
    {char * tlv7; tlv7 = (char *)(numWords); }
    {char * tlv10; tlv10 = (char *)(numWords); }
    {char * tlv9; tlv9 = (char *)(numWords); }
    {int tlv8; tlv8 = (int)(numWords); }
}
void fix_ingred_main_7_3(){
fix_ingred_main_7_3_0();
fix_ingred_main_7_3_6();
fix_ingred_main_7_3_7();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int', 'tlv7': 'char *'}'
val_s=>'[('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd95ba8>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc6e3c8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbdc518>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbdcba8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd2c898>)]'
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=0/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=0/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
unique : ('char *', 'tlv7', None)
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=1/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=1/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=2/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=2/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=3/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=3/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=4/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=4/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=5/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=5/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=6/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=6/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=7/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=7/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=9/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=9/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=10/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=10/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=12/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=12/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=13/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=13/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=14/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=14/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [g] => '[False, False, False]'
has_multiptr_refs 'gSeedWords[i]' - False OR  False
[i=7/14][j=4/10][dd=15/16][k=0/9] | type: char * ; var : tlv7 ; varinfo :  ; value_node : gSeedWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : gSeedWords,[,i,]
 => is literal (False) | is operator (False) gSeedWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[True, False, True]'
has_multiptr_refs 'cgc_strlen(tlv7)' - False OR  False
[i=7/14][j=4/10][dd=15/16][k=1/9] | type: cgc_size_t ; var : total ; varinfo :  ; value_node : cgc_strlen ( tlv7 ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (True) || True )]
Subterms : cgc_strlen,(,tlv7,)
 => is literal (False) | is operator (False) cgc_strlen [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) tlv7 [vtype=char *]
not unique: ('char *', 'tlv7', None) ... continue!
 => is literal (False) | is operator (True) )
not valid - int i; i = ((int)gSeedWords [ i ]);

----
UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('char *','tlv7','None','None');

not valid - char * tlv7; tlv7 = ((char *)cgc_strlen ( tlv7 ));

----
UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('char *','tlv7','None','None');

==== Scope 1 ====
void fix_ingred_main_7_4_0(){
int i;
    bzero(&i,sizeof(int));
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
char * tlv7 = &tlv7_ref;
    {if (gSeedWords){    i = 0;
         int ret; ret = (int)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t numWords; numWords = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t total; total = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t temp; temp = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * pTemp; pTemp = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t tlv3; tlv3 = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         int tlv2; tlv2 = (int)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         int tlv5; tlv5 = (int)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * tlv7; tlv7 = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * tlv10; tlv10 = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * tlv9; tlv9 = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         int tlv8; tlv8 = (int)(gSeedWords [ i ]); }}
}
void fix_ingred_main_7_4_1(){
int i;
    bzero(&i,sizeof(int));
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
char * tlv7 = &tlv7_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t total; total = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int i; i = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t temp; temp = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {char * pTemp; pTemp = (char *)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv5; tlv5 = (int)(cgc_strlen ( tlv7 )); }
    {char * tlv10; tlv10 = (char *)(cgc_strlen ( tlv7 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv7 )); }
    {int tlv8; tlv8 = (int)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_main_7_4(){
fix_ingred_main_7_4_0();
fix_ingred_main_7_4_1();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *'}'
val_s=>'[('cgc_size_t', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc3cc18>), ('int', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236beb5f28>), ('void * *', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236beb7b38>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>)]'
cval_s=>'[]'
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=1/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
unique : ('cgc_size_t', 'total', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=3/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=4/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=5/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=6/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=7/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=9/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=10/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=12/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=13/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=14/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'total' - False OR  False
[i=7/14][j=5/10][dd=15/16][k=0/7] | type: cgc_size_t ; var : tlv6 ; varinfo :  ; value_node : total (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : total
 => is literal (False) | is operator (False) total [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'total', None) ... continue!
----
UNIQ_INIT: ('cgc_size_t','total','None','None');

==== Scope 1 ====
void fix_ingred_main_7_5_0(){
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t numWords; numWords = (cgc_size_t)(total); }
    {int i; i = (int)(total); }
    {cgc_size_t temp; temp = (cgc_size_t)(total); }
    {char * pTemp; pTemp = (char *)(total); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(total); }
    {int tlv2; tlv2 = (int)(total); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(total); }
    {int tlv5; tlv5 = (int)(total); }
    {char * tlv7; tlv7 = (char *)(total); }
    {char * tlv10; tlv10 = (char *)(total); }
    {char * tlv9; tlv9 = (char *)(total); }
    {int tlv8; tlv8 = (int)(total); }
}
void fix_ingred_main_7_5(){
fix_ingred_main_7_5_0();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc4a048>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bc4a358>)]'
sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'temp': 'cgc_size_t', 'pTemp': 'char *'}'
val_s=>'[('UNDEF', 'cgc_gWords ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd1e048>), ('char *', 'pTemp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcf6128>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>), ('cgc_size_t', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc9e6d8>), ('char *', 'pTemp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b3dcac8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba90278>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba76128>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba76908>)]'
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=0/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=1/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=2/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=3/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=4/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=5/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=6/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=7/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=9/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=10/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=12/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=13/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=14/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=7/14][j=7/10][dd=15/16][k=1/11] | type: char * ; var : pTemp ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
----
==== Scope 1 ====
void fix_ingred_main_7_7_1(){
    {int ret; ret = (int)(1); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(1); }
    {cgc_size_t total; total = (cgc_size_t)(1); }
    {int i; i = (int)(1); }
    {cgc_size_t temp; temp = (cgc_size_t)(1); }
    {char * pTemp; pTemp = (char *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
    {int tlv2; tlv2 = (int)(1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(1); }
    {int tlv5; tlv5 = (int)(1); }
    {char * tlv7; tlv7 = (char *)(1); }
    {char * tlv10; tlv10 = (char *)(1); }
    {char * tlv9; tlv9 = (char *)(1); }
    {int tlv8; tlv8 = (int)(1); }
}
void fix_ingred_main_7_7(){
fix_ingred_main_7_7_1();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'temp': 'cgc_size_t', 'pTemp': 'char *', 'tlv10': 'char *', 'tlv9': 'char *', 'tlv8': 'int'}'
val_s=>'[('char *', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd71c18>), ('char *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd32c88>), ('int', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236beb6ac8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>), ('cgc_size_t', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc9e6d8>), ('char *', 'pTemp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b3dcac8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba90278>), ('UNDEF', 'cgc_gWords ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd1e048>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba76128>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236ba76908>)]'
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=0/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
unique : ('char *', 'pTemp', None)
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=0/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
unique : ('int', 'rot', None)
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=1/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=1/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=2/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=2/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=3/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=3/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=4/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=4/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=5/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=5/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=6/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=6/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=7/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=7/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=9/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=9/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=10/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=10/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=12/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=12/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=13/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=13/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=14/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=14/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
is_func_ [p] => '[False, False, False]'
has_multiptr_refs 'pTemp' - False OR  False
[i=7/14][j=8/10][dd=15/16][k=0/13] | type: char * ; var : tlv10 ; varinfo :  ; value_node : pTemp (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : pTemp
 => is literal (False) | is operator (False) pTemp [vtype=char *]
not unique: ('char *', 'pTemp', None) ... continue!
is_func_ [r] => '[False, False, False]'
has_multiptr_refs 'rot' - False OR  False
[i=7/14][j=8/10][dd=15/16][k=2/13] | type: int ; var : tlv8 ; varinfo :  ; value_node : rot (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : rot
 => is literal (False) | is operator (False) rot [vtype=int]
not unique: ('int', 'rot', None) ... continue!
not valid - char * pTemp; pTemp = ((char *)pTemp);

----
UNIQ_INIT: ('char *','pTemp','None','None');

UNIQ_INIT: ('int','rot','None','None');

----
UNIQ_INIT: ('char *','pTemp','None','None');

UNIQ_INIT: ('int','rot','None','None');

==== Scope 1 ====
void fix_ingred_main_7_8_0(){
char pTemp_ref;
    bzero(&pTemp_ref,1*sizeof(char));
char * pTemp = &pTemp_ref;
int rot;
    bzero(&rot,sizeof(int));
    {int ret; ret = (int)(pTemp); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(pTemp); }
    {cgc_size_t total; total = (cgc_size_t)(pTemp); }
    {int i; i = (int)(pTemp); }
    {cgc_size_t temp; temp = (cgc_size_t)(pTemp); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(pTemp); }
    {int tlv2; tlv2 = (int)(pTemp); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(pTemp); }
    {int tlv5; tlv5 = (int)(pTemp); }
    {char * tlv7; tlv7 = (char *)(pTemp); }
    {char * tlv10; tlv10 = (char *)(pTemp); }
    {char * tlv9; tlv9 = (char *)(pTemp); }
    {int tlv8; tlv8 = (int)(pTemp); }
}
void fix_ingred_main_7_8_2(){
char pTemp_ref;
    bzero(&pTemp_ref,1*sizeof(char));
char * pTemp = &pTemp_ref;
int rot;
    bzero(&rot,sizeof(int));
    {int ret; ret = (int)(rot); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(rot); }
    {cgc_size_t total; total = (cgc_size_t)(rot); }
    {int i; i = (int)(rot); }
    {cgc_size_t temp; temp = (cgc_size_t)(rot); }
    {char * pTemp; pTemp = (char *)(rot); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(rot); }
    {int tlv2; tlv2 = (int)(rot); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(rot); }
    {int tlv5; tlv5 = (int)(rot); }
    {char * tlv7; tlv7 = (char *)(rot); }
    {char * tlv10; tlv10 = (char *)(rot); }
    {char * tlv9; tlv9 = (char *)(rot); }
    {int tlv8; tlv8 = (int)(rot); }
}
void fix_ingred_main_7_8(){
fix_ingred_main_7_8_0();
fix_ingred_main_7_8_2();
}

sym_lut=>'{'rot': 'int', 'ret': 'int', 'numWords': 'cgc_size_t', 'tlv3': 'cgc_size_t', 'tlv2': 'int', 'tlv1': 'void * *', 'total': 'cgc_size_t', 'i': 'int', 'tlv6': 'cgc_size_t', 'tlv5': 'int', 'tlv4': 'void * *', 'temp': 'cgc_size_t', 'pTemp': 'char *'}'
val_s=>'[('UNDEF', 'cgc_gWords ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236b4e62e8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0e208>), ('cgc_size_t', 'numWords', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bab9518>), ('cgc_size_t', 'total', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbbb438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd66128>), ('cgc_size_t', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc9e6d8>), ('char *', 'pTemp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b3dcac8>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b87bd68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236c2450b8>)]'
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=0/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=1/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=2/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=3/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=4/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=5/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=6/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=7/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=9/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=10/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=12/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=13/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=14/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
is_func_ [(] => '[False, False, False]'
has_multiptr_refs '(PAGE_SIZE/sizeof(char*))' - False OR  False
[i=7/14][j=9/10][dd=15/16][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : ( PAGE_SIZE / sizeof ( char * ) ) (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : (,PAGE_SIZE,/,sizeof,(,char,*,),)
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) PAGE_SIZE [vtype=None]
 => is literal (False) | is operator (True) /
 => is literal (False) | is operator (False) sizeof [vtype=None]
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) char [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (True) )
==== Scope 2 ====
void fix_ingred_main_7_0_0(){
    {cgc_size_t numWords; numWords = (cgc_size_t)(0); }
    {int i; i = (int)(0); }
    {cgc_size_t temp; temp = (cgc_size_t)(0); }
    {char * pTemp; pTemp = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
    {char * tlv10; tlv10 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {int tlv8; tlv8 = (int)(0); }
}
void fix_ingred_main_7_0_1(){
    {int ret; ret = (int)(NUM_WORDS); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(NUM_WORDS); }
    {cgc_size_t total; total = (cgc_size_t)(NUM_WORDS); }
    {int i; i = (int)(NUM_WORDS); }
    {cgc_size_t temp; temp = (cgc_size_t)(NUM_WORDS); }
    {char * pTemp; pTemp = (char *)(NUM_WORDS); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(NUM_WORDS); }
    {int tlv2; tlv2 = (int)(NUM_WORDS); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(NUM_WORDS); }
    {int tlv5; tlv5 = (int)(NUM_WORDS); }
    {char * tlv7; tlv7 = (char *)(NUM_WORDS); }
    {char * tlv10; tlv10 = (char *)(NUM_WORDS); }
    {char * tlv9; tlv9 = (char *)(NUM_WORDS); }
    {int tlv8; tlv8 = (int)(NUM_WORDS); }
}
void fix_ingred_main_7_0_2(){
    {cgc_size_t numWords; numWords = (cgc_size_t)(0); }
    {int i; i = (int)(0); }
    {cgc_size_t temp; temp = (cgc_size_t)(0); }
    {char * pTemp; pTemp = (char *)(0); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(0); }
    {int tlv2; tlv2 = (int)(0); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(0); }
    {int tlv5; tlv5 = (int)(0); }
    {char * tlv7; tlv7 = (char *)(0); }
    {char * tlv10; tlv10 = (char *)(0); }
    {char * tlv9; tlv9 = (char *)(0); }
    {int tlv8; tlv8 = (int)(0); }
}
void fix_ingred_main_7_0_5(){
    {int ret; ret = (int)(cgc_gWordData); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(cgc_gWordData); }
    {cgc_size_t total; total = (cgc_size_t)(cgc_gWordData); }
    {int i; i = (int)(cgc_gWordData); }
    {cgc_size_t temp; temp = (cgc_size_t)(cgc_gWordData); }
    {char * pTemp; pTemp = (char *)(cgc_gWordData); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_gWordData); }
    {int tlv2; tlv2 = (int)(cgc_gWordData); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_gWordData); }
    {int tlv5; tlv5 = (int)(cgc_gWordData); }
    {char * tlv7; tlv7 = (char *)(cgc_gWordData); }
    {char * tlv10; tlv10 = (char *)(cgc_gWordData); }
    {char * tlv9; tlv9 = (char *)(cgc_gWordData); }
    {int tlv8; tlv8 = (int)(cgc_gWordData); }
}
void fix_ingred_main_7_0(){
fix_ingred_main_7_0_0();
fix_ingred_main_7_0_1();
fix_ingred_main_7_0_2();
fix_ingred_main_7_0_5();
}
void fix_ingred_main_7_1_0(){
    {int ret; ret = (int)(sizeof ( gSeedWords )); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(sizeof ( gSeedWords )); }
    {cgc_size_t total; total = (cgc_size_t)(sizeof ( gSeedWords )); }
    {int i; i = (int)(sizeof ( gSeedWords )); }
    {cgc_size_t temp; temp = (cgc_size_t)(sizeof ( gSeedWords )); }
    {char * pTemp; pTemp = (char *)(sizeof ( gSeedWords )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(sizeof ( gSeedWords )); }
    {int tlv2; tlv2 = (int)(sizeof ( gSeedWords )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(sizeof ( gSeedWords )); }
    {int tlv5; tlv5 = (int)(sizeof ( gSeedWords )); }
    {char * tlv7; tlv7 = (char *)(sizeof ( gSeedWords )); }
    {char * tlv10; tlv10 = (char *)(sizeof ( gSeedWords )); }
    {char * tlv9; tlv9 = (char *)(sizeof ( gSeedWords )); }
    {int tlv8; tlv8 = (int)(sizeof ( gSeedWords )); }
}
void fix_ingred_main_7_1(){
fix_ingred_main_7_1_0();
}
void fix_ingred_main_7_2_2(){
int ret;
    bzero(&ret,sizeof(int));
    {cgc_size_t numWords; numWords = (cgc_size_t)(ret); }
    {int i; i = (int)(ret); }
    {cgc_size_t temp; temp = (cgc_size_t)(ret); }
    {char * pTemp; pTemp = (char *)(ret); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(ret); }
    {int tlv2; tlv2 = (int)(ret); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(ret); }
    {int tlv5; tlv5 = (int)(ret); }
    {char * tlv7; tlv7 = (char *)(ret); }
    {char * tlv10; tlv10 = (char *)(ret); }
    {char * tlv9; tlv9 = (char *)(ret); }
    {int tlv8; tlv8 = (int)(ret); }
}
void fix_ingred_main_7_2(){
fix_ingred_main_7_2_2();
}
void fix_ingred_main_7_3_0(){
int i;
    bzero(&i,sizeof(int));
cgc_size_t numWords;
    bzero(&numWords,sizeof(cgc_size_t));
    {cgc_size_t numWords; numWords = (cgc_size_t)(1); }
    {cgc_size_t total; total = (cgc_size_t)(1); }
    {int i; i = (int)(1); }
    {cgc_size_t temp; temp = (cgc_size_t)(1); }
    {char * pTemp; pTemp = (char *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
    {int tlv2; tlv2 = (int)(1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(1); }
    {int tlv5; tlv5 = (int)(1); }
    {char * tlv7; tlv7 = (char *)(1); }
    {char * tlv10; tlv10 = (char *)(1); }
    {char * tlv9; tlv9 = (char *)(1); }
    {int tlv8; tlv8 = (int)(1); }
}
void fix_ingred_main_7_3_6(){
int i;
    bzero(&i,sizeof(int));
cgc_size_t numWords;
    bzero(&numWords,sizeof(cgc_size_t));
    {int ret; ret = (int)(i); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(i); }
    {cgc_size_t total; total = (cgc_size_t)(i); }
    {cgc_size_t temp; temp = (cgc_size_t)(i); }
    {char * pTemp; pTemp = (char *)(i); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(i); }
    {int tlv2; tlv2 = (int)(i); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(i); }
    {int tlv5; tlv5 = (int)(i); }
    {char * tlv7; tlv7 = (char *)(i); }
    {char * tlv10; tlv10 = (char *)(i); }
    {char * tlv9; tlv9 = (char *)(i); }
    {int tlv8; tlv8 = (int)(i); }
}
void fix_ingred_main_7_3_7(){
int i;
    bzero(&i,sizeof(int));
cgc_size_t numWords;
    bzero(&numWords,sizeof(cgc_size_t));
    {int ret; ret = (int)(numWords); }
    {cgc_size_t total; total = (cgc_size_t)(numWords); }
    {int i; i = (int)(numWords); }
    {cgc_size_t temp; temp = (cgc_size_t)(numWords); }
    {char * pTemp; pTemp = (char *)(numWords); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(numWords); }
    {int tlv2; tlv2 = (int)(numWords); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(numWords); }
    {int tlv5; tlv5 = (int)(numWords); }
    {char * tlv7; tlv7 = (char *)(numWords); }
    {char * tlv10; tlv10 = (char *)(numWords); }
    {char * tlv9; tlv9 = (char *)(numWords); }
    {int tlv8; tlv8 = (int)(numWords); }
}
void fix_ingred_main_7_3(){
fix_ingred_main_7_3_0();
fix_ingred_main_7_3_6();
fix_ingred_main_7_3_7();
}
void fix_ingred_main_7_4_0(){
int i;
    bzero(&i,sizeof(int));
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
char * tlv7 = &tlv7_ref;
    {if (gSeedWords){    i = 0;
         int ret; ret = (int)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t numWords; numWords = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t total; total = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t temp; temp = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * pTemp; pTemp = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t tlv3; tlv3 = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         int tlv2; tlv2 = (int)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         cgc_size_t tlv6; tlv6 = (cgc_size_t)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         int tlv5; tlv5 = (int)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * tlv7; tlv7 = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * tlv10; tlv10 = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         char * tlv9; tlv9 = (char *)(gSeedWords [ i ]); }}
    {if (gSeedWords){    i = 0;
         int tlv8; tlv8 = (int)(gSeedWords [ i ]); }}
}
void fix_ingred_main_7_4_1(){
int i;
    bzero(&i,sizeof(int));
char tlv7_ref;
    bzero(&tlv7_ref,1*sizeof(char));
char * tlv7 = &tlv7_ref;
    {int ret; ret = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {cgc_size_t total; total = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int i; i = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t temp; temp = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {char * pTemp; pTemp = (char *)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv2; tlv2 = (int)(cgc_strlen ( tlv7 )); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(cgc_strlen ( tlv7 )); }
    {int tlv5; tlv5 = (int)(cgc_strlen ( tlv7 )); }
    {char * tlv10; tlv10 = (char *)(cgc_strlen ( tlv7 )); }
    {char * tlv9; tlv9 = (char *)(cgc_strlen ( tlv7 )); }
    {int tlv8; tlv8 = (int)(cgc_strlen ( tlv7 )); }
}
void fix_ingred_main_7_4(){
fix_ingred_main_7_4_0();
fix_ingred_main_7_4_1();
}
void fix_ingred_main_7_5_0(){
cgc_size_t total;
    bzero(&total,sizeof(cgc_size_t));
    {cgc_size_t numWords; numWords = (cgc_size_t)(total); }
    {int i; i = (int)(total); }
    {cgc_size_t temp; temp = (cgc_size_t)(total); }
    {char * pTemp; pTemp = (char *)(total); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(total); }
    {int tlv2; tlv2 = (int)(total); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(total); }
    {int tlv5; tlv5 = (int)(total); }
    {char * tlv7; tlv7 = (char *)(total); }
    {char * tlv10; tlv10 = (char *)(total); }
    {char * tlv9; tlv9 = (char *)(total); }
    {int tlv8; tlv8 = (int)(total); }
}
void fix_ingred_main_7_5(){
fix_ingred_main_7_5_0();
}
void fix_ingred_main_7_7_1(){
    {int ret; ret = (int)(1); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(1); }
    {cgc_size_t total; total = (cgc_size_t)(1); }
    {int i; i = (int)(1); }
    {cgc_size_t temp; temp = (cgc_size_t)(1); }
    {char * pTemp; pTemp = (char *)(1); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(1); }
    {int tlv2; tlv2 = (int)(1); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(1); }
    {int tlv5; tlv5 = (int)(1); }
    {char * tlv7; tlv7 = (char *)(1); }
    {char * tlv10; tlv10 = (char *)(1); }
    {char * tlv9; tlv9 = (char *)(1); }
    {int tlv8; tlv8 = (int)(1); }
}
void fix_ingred_main_7_7(){
fix_ingred_main_7_7_1();
}
void fix_ingred_main_7_8_0(){
char pTemp_ref;
    bzero(&pTemp_ref,1*sizeof(char));
char * pTemp = &pTemp_ref;
int rot;
    bzero(&rot,sizeof(int));
    {int ret; ret = (int)(pTemp); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(pTemp); }
    {cgc_size_t total; total = (cgc_size_t)(pTemp); }
    {int i; i = (int)(pTemp); }
    {cgc_size_t temp; temp = (cgc_size_t)(pTemp); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(pTemp); }
    {int tlv2; tlv2 = (int)(pTemp); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(pTemp); }
    {int tlv5; tlv5 = (int)(pTemp); }
    {char * tlv7; tlv7 = (char *)(pTemp); }
    {char * tlv10; tlv10 = (char *)(pTemp); }
    {char * tlv9; tlv9 = (char *)(pTemp); }
    {int tlv8; tlv8 = (int)(pTemp); }
}
void fix_ingred_main_7_8_2(){
char pTemp_ref;
    bzero(&pTemp_ref,1*sizeof(char));
char * pTemp = &pTemp_ref;
int rot;
    bzero(&rot,sizeof(int));
    {int ret; ret = (int)(rot); }
    {cgc_size_t numWords; numWords = (cgc_size_t)(rot); }
    {cgc_size_t total; total = (cgc_size_t)(rot); }
    {int i; i = (int)(rot); }
    {cgc_size_t temp; temp = (cgc_size_t)(rot); }
    {char * pTemp; pTemp = (char *)(rot); }
    {cgc_size_t tlv3; tlv3 = (cgc_size_t)(rot); }
    {int tlv2; tlv2 = (int)(rot); }
    {cgc_size_t tlv6; tlv6 = (cgc_size_t)(rot); }
    {int tlv5; tlv5 = (int)(rot); }
    {char * tlv7; tlv7 = (char *)(rot); }
    {char * tlv10; tlv10 = (char *)(rot); }
    {char * tlv9; tlv9 = (char *)(rot); }
    {int tlv8; tlv8 = (int)(rot); }
}
void fix_ingred_main_7_8(){
fix_ingred_main_7_8_0();
fix_ingred_main_7_8_2();
}
void fix_ingred_main_7(){
fix_ingred_main_7_0();
fix_ingred_main_7_1();
fix_ingred_main_7_2();
fix_ingred_main_7_3();
fix_ingred_main_7_4();
fix_ingred_main_7_5();
fix_ingred_main_7_7();
fix_ingred_main_7_8();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_7_0_0();
void fix_ingred_main_7_0_1();
void fix_ingred_main_7_0_2();
void fix_ingred_main_7_0_5();
void fix_ingred_main_7_0();
void fix_ingred_main_7_1_0();
void fix_ingred_main_7_1();
void fix_ingred_main_7_2_2();
void fix_ingred_main_7_2();
void fix_ingred_main_7_3_0();
void fix_ingred_main_7_3_6();
void fix_ingred_main_7_3_7();
void fix_ingred_main_7_3();
void fix_ingred_main_7_4_0();
void fix_ingred_main_7_4_1();
void fix_ingred_main_7_4();
void fix_ingred_main_7_5_0();
void fix_ingred_main_7_5();
void fix_ingred_main_7_7_1();
void fix_ingred_main_7_7();
void fix_ingred_main_7_8_0();
void fix_ingred_main_7_8_2();
void fix_ingred_main_7_8();
void fix_ingred_main_7();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_toInt] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
sym_lut=>'{'c1': 'char', 'c2': 'char', 'ret': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc39c88>)]'
cval_s=>'[]'
sym_lut=>'{'c1': 'char', 'c2': 'char', 'ret': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b4bbc88>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc39c88>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9438>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb438>)]'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c1-'0'' - False OR  False
[i=8/14][j=1/6][dd=0/1][k=0/6] | type: int ; var : ret ; varinfo :  ; value_node : c1 - '0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c1,-,'0'
 => is literal (False) | is operator (False) c1 [vtype=char]
unique : ('char', 'c1', None)
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) '0'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c1' - False OR  False
[i=8/14][j=1/6][dd=0/1][k=2/6] | type: char ; var :  ; varinfo :  ; value_node : c1 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c1
 => is literal (False) | is operator (False) c1 [vtype=char]
not unique: ('char', 'c1', None) ... continue!
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''0'' - False OR  False
[i=8/14][j=1/6][dd=0/1][k=3/6] | type: char ; var :  ; varinfo :  ; value_node : '0' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '0'
 => is literal (True) | is operator (False) '0'
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''9'' - False OR  False
[i=8/14][j=1/6][dd=0/1][k=5/6] | type: char ; var :  ; varinfo :  ; value_node : '9' (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '9'
 => is literal (True) | is operator (False) '9'
----
UNIQ_INIT: ('char','c1','None','None');

----
UNIQ_INIT: ('char','c1','None','None');

----
UNIQ_INIT: ('char','c1','None','None');

----
UNIQ_INIT: ('char','c1','None','None');

==== Scope 1 ====
void fix_ingred_main_8_1_0(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)(c1 - '0'); }
}
void fix_ingred_main_8_1_2(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)(c1); }
}
void fix_ingred_main_8_1_3(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)('0'); }
}
void fix_ingred_main_8_1_5(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)('9'); }
}
void fix_ingred_main_8_1(){
fix_ingred_main_8_1_0();
fix_ingred_main_8_1_2();
fix_ingred_main_8_1_3();
fix_ingred_main_8_1_5();
}

sym_lut=>'{'c1': 'char', 'c2': 'char', 'ret': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7bceb8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b7bd208>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc39c88>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b4bbc88>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9438>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb438>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b7be358>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b7be668>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b7bc358>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b7bc668>)]'
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '10' - False OR  False
[i=8/14][j=2/6][dd=0/1][k=0/12] | type: int ; var : ret ; varinfo :  ; value_node : 10 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 10
 => is literal (True) | is operator (False) 10
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c2-'0'' - False OR  False
[i=8/14][j=2/6][dd=0/1][k=1/12] | type: int ; var : ret ; varinfo :  ; value_node : c2 - '0' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c2,-,'0'
 => is literal (False) | is operator (False) c2 [vtype=char]
unique : ('char', 'c2', None)
 => is literal (False) | is operator (True) -
 => is literal (True) | is operator (False) '0'
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'c2' - False OR  False
[i=8/14][j=2/6][dd=0/1][k=8/12] | type: char ; var :  ; varinfo :  ; value_node : c2 (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : c2
 => is literal (False) | is operator (False) c2 [vtype=char]
not unique: ('char', 'c2', None) ... continue!
----
UNIQ_INIT: ('char','c2','None','None');

----
UNIQ_INIT: ('char','c2','None','None');

----
UNIQ_INIT: ('char','c2','None','None');

==== Scope 1 ====
void fix_ingred_main_8_2_0(){
char c2;
    bzero(&c2,sizeof(char));
    {int ret; ret = (int)(10); }
}
void fix_ingred_main_8_2_1(){
char c2;
    bzero(&c2,sizeof(char));
    {int ret; ret = (int)(c2 - '0'); }
}
void fix_ingred_main_8_2_8(){
char c2;
    bzero(&c2,sizeof(char));
    {int ret; ret = (int)(c2); }
}
void fix_ingred_main_8_2(){
fix_ingred_main_8_2_0();
fix_ingred_main_8_2_1();
fix_ingred_main_8_2_8();
}

sym_lut=>'{'c1': 'char', 'c2': 'char', 'ret': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc39c88>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b4bbc88>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9438>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb438>)]'
sym_lut=>'{'c1': 'char', 'c2': 'char', 'ret': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc39c88>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b4bbc88>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9438>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb438>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9767b8>), ('char', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9764a8>)]'
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=8/14][j=4/6][dd=0/1][k=7/8] | type: char ; var :  ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
----
==== Scope 1 ====
void fix_ingred_main_8_4_7(){
    {int ret; ret = (int)('\0'); }
}
void fix_ingred_main_8_4(){
fix_ingred_main_8_4_7();
}

sym_lut=>'{'c1': 'char', 'c2': 'char', 'ret': 'int'}'
val_s=>'[('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bc39c88>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b4bbc88>)]'
cval_s=>'[('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4b9438>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb128>), ('char', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b4bb438>)]'
==== Scope 2 ====
void fix_ingred_main_8_1_0(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)(c1 - '0'); }
}
void fix_ingred_main_8_1_2(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)(c1); }
}
void fix_ingred_main_8_1_3(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)('0'); }
}
void fix_ingred_main_8_1_5(){
char c1;
    bzero(&c1,sizeof(char));
    {int ret; ret = (int)('9'); }
}
void fix_ingred_main_8_1(){
fix_ingred_main_8_1_0();
fix_ingred_main_8_1_2();
fix_ingred_main_8_1_3();
fix_ingred_main_8_1_5();
}
void fix_ingred_main_8_2_0(){
char c2;
    bzero(&c2,sizeof(char));
    {int ret; ret = (int)(10); }
}
void fix_ingred_main_8_2_1(){
char c2;
    bzero(&c2,sizeof(char));
    {int ret; ret = (int)(c2 - '0'); }
}
void fix_ingred_main_8_2_8(){
char c2;
    bzero(&c2,sizeof(char));
    {int ret; ret = (int)(c2); }
}
void fix_ingred_main_8_2(){
fix_ingred_main_8_2_0();
fix_ingred_main_8_2_1();
fix_ingred_main_8_2_8();
}
void fix_ingred_main_8_4_7(){
    {int ret; ret = (int)('\0'); }
}
void fix_ingred_main_8_4(){
fix_ingred_main_8_4_7();
}
void fix_ingred_main_8(){
fix_ingred_main_8_1();
fix_ingred_main_8_2();
fix_ingred_main_8_4();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_8_1_0();
void fix_ingred_main_8_1_2();
void fix_ingred_main_8_1_3();
void fix_ingred_main_8_1_5();
void fix_ingred_main_8_1();
void fix_ingred_main_8_2_0();
void fix_ingred_main_8_2_1();
void fix_ingred_main_8_2_8();
void fix_ingred_main_8_2();
void fix_ingred_main_8_4_7();
void fix_ingred_main_8_4();
void fix_ingred_main_8();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{}'
val_s=>'[('UNDEF', 'gRandRegister', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd17c88>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_main_9(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_9();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_strcmp] : <class 'CParser.CParser.DeclarationContext'> : int i ;
sym_lut=>'{'s1': 'char *', 's2': 'char *'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[]'
sym_lut=>'{'s1': 'char *', 's2': 'char *'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9b5a58>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9b5dd8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 's1' - False OR  False
[i=10/14][j=1/11][dd=0/1][k=0/2] | type: char * ; var :  ; varinfo :  ; value_node : s1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : s1
 => is literal (False) | is operator (False) s1 [vtype=char *]
unique : ('char *', 's1', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NULL' - False OR  False
[i=10/14][j=1/11][dd=0/1][k=1/2] | type: char * ; var :  ; varinfo :  ; value_node : NULL (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NULL
 => is literal (False) | is operator (False) NULL [vtype=None]
----
UNIQ_INIT: ('char *','s1','None','None');

----
UNIQ_INIT: ('char *','s1','None','None');

==== Scope 1 ====
void fix_ingred_main_10_1_0(){
char s1_ref;
    bzero(&s1_ref,1*sizeof(char));
char * s1 = &s1_ref;
    {int i; i = (int)(s1); }
}
void fix_ingred_main_10_1_1(){
char s1_ref;
    bzero(&s1_ref,1*sizeof(char));
char * s1 = &s1_ref;
    {int i; i = (int)(NULL); }
}
void fix_ingred_main_10_1(){
fix_ingred_main_10_1_0();
fix_ingred_main_10_1_1();
}

sym_lut=>'{'s1': 'char *', 's2': 'char *'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9b5a58>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9b5dd8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b98e828>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b98eba8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 's2' - False OR  False
[i=10/14][j=2/11][dd=0/1][k=2/4] | type: char * ; var :  ; varinfo :  ; value_node : s2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : s2
 => is literal (False) | is operator (False) s2 [vtype=char *]
unique : ('char *', 's2', None)
----
UNIQ_INIT: ('char *','s2','None','None');

==== Scope 1 ====
void fix_ingred_main_10_2_2(){
char s2_ref;
    bzero(&s2_ref,1*sizeof(char));
char * s2 = &s2_ref;
    {int i; i = (int)(s2); }
}
void fix_ingred_main_10_2(){
fix_ingred_main_10_2_2();
}

sym_lut=>'{'s1': 'char *', 's2': 'char *'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9b5a58>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9b5dd8>)]'
sym_lut=>'{'s1': 'char *', 's2': 'char *'}'
val_s=>'[]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b985978>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b985cf8>)]'
sym_lut=>'{'s1': 'char *', 's2': 'char *', 'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd75668>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd6b198>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 's1[i]' - False OR  False
[i=10/14][j=5/11][dd=0/1][k=1/3] | type: char * ; var :  ; varinfo :  ; value_node : s1 [ i ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : s1,[,i,]
 => is literal (False) | is operator (False) s1 [vtype=char *]
unique : ('char *', 's1', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
 => is literal (False) | is operator (True) ]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=10/14][j=5/11][dd=0/1][k=2/3] | type: char * ; var :  ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
not valid - int i; i = ((int)s1 [ i ]);

----
UNIQ_INIT: ('char *','s1','None','None');

UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_main_10_5_2(){
char s1_ref;
    bzero(&s1_ref,1*sizeof(char));
char * s1 = &s1_ref;
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)('\0'); }
}
void fix_ingred_main_10_5(){
fix_ingred_main_10_5_2();
}

sym_lut=>'{'s1': 'char *', 's2': 'char *', 'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd75668>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd6b198>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd6bba8>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd626d8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 's2[i]' - False OR  False
[i=10/14][j=6/11][dd=0/1][k=3/5] | type: char * ; var :  ; varinfo :  ; value_node : s2 [ i ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : s2,[,i,]
 => is literal (False) | is operator (False) s2 [vtype=char *]
unique : ('char *', 's2', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
 => is literal (False) | is operator (True) ]
not valid - int i; i = ((int)s2 [ i ]);

sym_lut=>'{'s1': 'char *', 's2': 'char *', 'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd75668>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd6b198>), ('char *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd705f8>), ('char *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bd70b38>)]'
sym_lut=>'{'s1': 'char *', 's2': 'char *', 'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd75668>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd6b198>)]'
sym_lut=>'{'s1': 'char *', 's2': 'char *', 'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd75668>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bd6b198>), ('char *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bfc5198>), ('char *', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bfc5c18>)]'
sym_lut=>'{'s1': 'char *', 's2': 'char *', 'i': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bd565f8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bfd7588>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bfc80b8>)]'
==== Scope 2 ====
void fix_ingred_main_10_1_0(){
char s1_ref;
    bzero(&s1_ref,1*sizeof(char));
char * s1 = &s1_ref;
    {int i; i = (int)(s1); }
}
void fix_ingred_main_10_1_1(){
char s1_ref;
    bzero(&s1_ref,1*sizeof(char));
char * s1 = &s1_ref;
    {int i; i = (int)(NULL); }
}
void fix_ingred_main_10_1(){
fix_ingred_main_10_1_0();
fix_ingred_main_10_1_1();
}
void fix_ingred_main_10_2_2(){
char s2_ref;
    bzero(&s2_ref,1*sizeof(char));
char * s2 = &s2_ref;
    {int i; i = (int)(s2); }
}
void fix_ingred_main_10_2(){
fix_ingred_main_10_2_2();
}
void fix_ingred_main_10_5_2(){
char s1_ref;
    bzero(&s1_ref,1*sizeof(char));
char * s1 = &s1_ref;
int i;
    bzero(&i,sizeof(int));
    {int i; i = (int)('\0'); }
}
void fix_ingred_main_10_5(){
fix_ingred_main_10_5_2();
}
void fix_ingred_main_10(){
fix_ingred_main_10_1();
fix_ingred_main_10_2();
fix_ingred_main_10_5();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_10_1_0();
void fix_ingred_main_10_1_1();
void fix_ingred_main_10_1();
void fix_ingred_main_10_2_2();
void fix_ingred_main_10_2();
void fix_ingred_main_10_5_2();
void fix_ingred_main_10_5();
void fix_ingred_main_10();


[Fix Ingredient functions]  --  END  --
sym_lut=>'{'seed': 'uint32_t'}'
val_s=>'[('UNDEF', 'gRandRegister', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bfcf588>)]'
cval_s=>'[]'
==== Scope 2 ====
void fix_ingred_main_11(){
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_11();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [cgc_scramble] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[1]: [cgc_scramble] : <class 'CParser.CParser.DeclarationContext'> : uint32_t r ;
sym_lut=>'{'dst': 'char *', 'src': 'char *', 'len': 'cgc_size_t', 'i': 'int', 'r': 'uint32_t'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f73c8>), ('UNDEF', 'dst ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ef898>)]'
cval_s=>'[]'
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=12/14][j=0/6][dd=1/2][k=0/2] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
----
==== Scope 1 ====
void fix_ingred_main_12_0_0(){
    {uint32_t r; r = (uint32_t)(0); }
}
void fix_ingred_main_12_0(){
fix_ingred_main_12_0_0();
}

sym_lut=>'{'dst': 'char *', 'src': 'char *', 'len': 'cgc_size_t', 'i': 'int', 'r': 'uint32_t'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f73c8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9da278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9dad68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4dd8>)]'
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[i]' - False OR  False
[i=12/14][j=1/6][dd=0/2][k=1/5] | type: char * ; var :  ; varinfo :  ; value_node : src [ i ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,i,]
 => is literal (False) | is operator (False) src [vtype=char *]
unique : ('char *', 'src', None)
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
 => is literal (False) | is operator (True) ]
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=12/14][j=1/6][dd=0/2][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
unique : ('cgc_size_t', 'len', None)
is_func_ [s] => '[False, False, False]'
has_multiptr_refs 'src[i]' - False OR  False
[i=12/14][j=1/6][dd=1/2][k=1/5] | type: char * ; var :  ; varinfo :  ; value_node : src [ i ] (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : src,[,i,]
 => is literal (False) | is operator (False) src [vtype=char *]
not unique: ('char *', 'src', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\0'' - False OR  False
[i=12/14][j=1/6][dd=1/2][k=2/5] | type: char * ; var :  ; varinfo :  ; value_node : '\0' (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\0'
 => is literal (False) | is operator (False) '\0' [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=12/14][j=1/6][dd=1/2][k=3/5] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [l] => '[False, False, False]'
has_multiptr_refs 'len' - False OR  False
[i=12/14][j=1/6][dd=1/2][k=4/5] | type: int ; var :  ; varinfo :  ; value_node : len (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : len
 => is literal (False) | is operator (False) len [vtype=cgc_size_t]
not unique: ('cgc_size_t', 'len', None) ... continue!
not valid - int i; i = ((int)src [ i ]);

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

----
UNIQ_INIT: ('char *','src','None','None');

UNIQ_INIT: ('int','i','None','None');

UNIQ_INIT: ('cgc_size_t','len','None','None');

==== Scope 1 ====
void fix_ingred_main_12_1_1(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {    i = 0;
         uint32_t r; r = (uint32_t)(src [ i ]); }
}
void fix_ingred_main_12_1_2(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {uint32_t r; r = (uint32_t)('\0'); }
}
void fix_ingred_main_12_1_3(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {uint32_t r; r = (uint32_t)(i); }
}
void fix_ingred_main_12_1_4(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {int i; i = (int)(len); }
    {uint32_t r; r = (uint32_t)(len); }
}
void fix_ingred_main_12_1(){
fix_ingred_main_12_1_1();
fix_ingred_main_12_1_2();
fix_ingred_main_12_1_3();
fix_ingred_main_12_1_4();
}

sym_lut=>'{'dst': 'char *', 'src': 'char *', 'len': 'cgc_size_t', 'i': 'int', 'r': 'uint32_t'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f73c8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9da278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9dad68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4dd8>)]'
sym_lut=>'{'dst': 'char *', 'src': 'char *', 'len': 'cgc_size_t', 'i': 'int', 'r': 'uint32_t'}'
val_s=>'[('UNDEF', 'dst ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f6358>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f73c8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9da278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9dad68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4dd8>)]'
sym_lut=>'{'dst': 'char *', 'src': 'char *', 'len': 'cgc_size_t', 'i': 'int', 'r': 'uint32_t'}'
val_s=>'[('UNDEF', 'dst ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9c5a58>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f73c8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9da278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9dad68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4dd8>)]'
sym_lut=>'{'dst': 'char *', 'src': 'char *', 'len': 'cgc_size_t', 'i': 'int', 'r': 'uint32_t'}'
val_s=>'[('UNDEF', 'dst ', '[ i ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9ca358>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236b9f73c8>)]'
cval_s=>'[('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9da278>), ('char *', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236b9dad68>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4ac8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236b9c4dd8>)]'
==== Scope 2 ====
void fix_ingred_main_12_0_0(){
    {uint32_t r; r = (uint32_t)(0); }
}
void fix_ingred_main_12_0(){
fix_ingred_main_12_0_0();
}
void fix_ingred_main_12_1_1(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {    i = 0;
         uint32_t r; r = (uint32_t)(src [ i ]); }
}
void fix_ingred_main_12_1_2(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {uint32_t r; r = (uint32_t)('\0'); }
}
void fix_ingred_main_12_1_3(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {uint32_t r; r = (uint32_t)(i); }
}
void fix_ingred_main_12_1_4(){
char src_ref;
    bzero(&src_ref,1*sizeof(char));
char * src = &src_ref;
int i;
    bzero(&i,sizeof(int));
cgc_size_t len;
    bzero(&len,sizeof(cgc_size_t));
    {int i; i = (int)(len); }
    {uint32_t r; r = (uint32_t)(len); }
}
void fix_ingred_main_12_1(){
fix_ingred_main_12_1_1();
fix_ingred_main_12_1_2();
fix_ingred_main_12_1_3();
fix_ingred_main_12_1_4();
}
void fix_ingred_main_12(){
fix_ingred_main_12_0();
fix_ingred_main_12_1();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_12_0_0();
void fix_ingred_main_12_0();
void fix_ingred_main_12_1_1();
void fix_ingred_main_12_1_2();
void fix_ingred_main_12_1_3();
void fix_ingred_main_12_1_4();
void fix_ingred_main_12_1();
void fix_ingred_main_12();


[Fix Ingredient functions]  --  END  --
def_vars[0]: [main] : <class 'CParser.CParser.DeclarationContext'> : char buf [ BUF_SIZE ] = { } ;
def_vars[1]: [main] : <class 'CParser.CParser.DeclarationContext'> : int i ;
def_vars[2]: [main] : <class 'CParser.CParser.DeclarationContext'> : int ret ;
def_vars[3]: [main] : <class 'CParser.CParser.DeclarationContext'> : int temp ;
def_vars[4]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t sret ;
def_vars[5]: [main] : <class 'CParser.CParser.DeclarationContext'> : char c ;
def_vars[6]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( ENTER_NUM_MSG ) ;
def_vars[7]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv1 ;
def_vars[8]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( FINAL_RND_MSG ) ;
def_vars[9]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( buf ) ;
def_vars[10]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv2 ;
def_vars[11]: [main] : <class 'CParser.CParser.DeclarationContext'> : char tlv11 ;
def_vars[12]: [main] : <class 'CParser.CParser.DeclarationContext'> : char tlv10 ;
def_vars[13]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv12 ;
def_vars[14]: [main] : <class 'CParser.CParser.DeclarationContext'> : uint32_t tlv4 ;
def_vars[15]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_my_srand ( tlv4 ) ;
def_vars[16]: [main] : <class 'CParser.CParser.DeclarationContext'> : char tlv14 ;
def_vars[17]: [main] : <class 'CParser.CParser.DeclarationContext'> : char tlv13 ;
def_vars[18]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv7 ;
def_vars[19]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv6 ;
def_vars[20]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv5 ;
def_vars[21]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv9 ;
def_vars[22]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv8 ;
def_vars[23]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv16 ;
def_vars[24]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv15 ;
def_vars[25]: [main] : <class 'CParser.CParser.DeclarationContext'> : int tlv3 ;
def_vars[26]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( LOSE_MSG ) ;
def_vars[27]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( WIN_MSG ) ;
def_vars[28]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv19 ;
def_vars[29]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv18 ;
def_vars[30]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv17 ;
def_vars[31]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv21 ;
def_vars[32]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_size_t tlv20 ;
def_vars[33]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv23 ;
def_vars[34]: [main] : <class 'CParser.CParser.DeclarationContext'> : char * tlv22 ;
def_vars[35]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( WORD_MSG ) ;
def_vars[36]: [main] : <class 'CParser.CParser.DeclarationContext'> : cgc_transmit_str ( NEXT_WORD_MSG ) ;
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba42898>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=0/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=0/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=0/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=1/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=3/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=3/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=4/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=4/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=4/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=6/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=6/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=7/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=8/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=8/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=8/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=9/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=9/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=9/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=10/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=10/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=10/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=11/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=11/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=11/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=12/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=12/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=12/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=13/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=13/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=13/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=14/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=15/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=15/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=15/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=16/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=16/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=16/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=17/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=18/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=18/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=18/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=19/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=19/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=19/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=20/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=20/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=20/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=21/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=21/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=21/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=22/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=22/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=22/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=23/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=23/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=23/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=24/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=24/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=24/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=25/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=25/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=25/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=26/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=26/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=26/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=27/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=27/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=27/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=28/37][k=0/6] | type: int ; var : i ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ [0] => '[False, False, False]'
has_multiptr_refs '0' - False OR  False
[i=13/14][j=0/18][dd=28/37][k=3/6] | type: cgc_size_t ; var : sret ; varinfo :  ; value_node : 0 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 0
 => is literal (True) | is operator (False) 0
is_func_ ['] => '[False, False, False]'
has_multiptr_refs ''\n'' - False OR  False
[i=13/14][j=0/18][dd=28/37][k=4/6] | type: char ; var : c ; varinfo :  ; value_node : '\n' (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : '\n'
 => is literal (False) | is operator (False) '\n' [vtype=None]
----
----
----
==== Scope 1 ====
void fix_ingred_main_13_0_0(){
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(0); }
    {cgc_size_t sret; sret = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {char tlv11; tlv11 = (char)(0); }
    {char tlv10; tlv10 = (char)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {uint32_t tlv4; tlv4 = (uint32_t)(0); }
    {char tlv14; tlv14 = (char)(0); }
    {char tlv13; tlv13 = (char)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {char * tlv16; tlv16 = (char *)(0); }
    {char * tlv15; tlv15 = (char *)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {char * tlv19; tlv19 = (char *)(0); }
    {char * tlv18; tlv18 = (char *)(0); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(0); }
    {char * tlv21; tlv21 = (char *)(0); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(0); }
    {char * tlv23; tlv23 = (char *)(0); }
    {char * tlv22; tlv22 = (char *)(0); }
}
void fix_ingred_main_13_0_3(){
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(0); }
    {int temp; temp = (int)(0); }
    {cgc_size_t sret; sret = (cgc_size_t)(0); }
    {char tlv11; tlv11 = (char)(0); }
    {char tlv10; tlv10 = (char)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {uint32_t tlv4; tlv4 = (uint32_t)(0); }
    {char tlv14; tlv14 = (char)(0); }
    {char tlv13; tlv13 = (char)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {char * tlv16; tlv16 = (char *)(0); }
    {char * tlv15; tlv15 = (char *)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {char * tlv19; tlv19 = (char *)(0); }
    {char * tlv18; tlv18 = (char *)(0); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(0); }
    {char * tlv21; tlv21 = (char *)(0); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(0); }
    {char * tlv23; tlv23 = (char *)(0); }
    {char * tlv22; tlv22 = (char *)(0); }
}
void fix_ingred_main_13_0_4(){
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)('\n'); }
    {int i; i = (int)('\n'); }
    {int temp; temp = (int)('\n'); }
    {cgc_size_t sret; sret = (cgc_size_t)('\n'); }
    {int tlv1; tlv1 = (int)('\n'); }
    {int tlv2; tlv2 = (int)('\n'); }
    {char tlv11; tlv11 = (char)('\n'); }
    {char tlv10; tlv10 = (char)('\n'); }
    {int tlv12; tlv12 = (int)('\n'); }
    {uint32_t tlv4; tlv4 = (uint32_t)('\n'); }
    {char tlv14; tlv14 = (char)('\n'); }
    {char tlv13; tlv13 = (char)('\n'); }
    {char * tlv7; tlv7 = (char *)('\n'); }
    {char * tlv6; tlv6 = (char *)('\n'); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)('\n'); }
    {char * tlv9; tlv9 = (char *)('\n'); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)('\n'); }
    {char * tlv16; tlv16 = (char *)('\n'); }
    {char * tlv15; tlv15 = (char *)('\n'); }
    {int tlv3; tlv3 = (int)('\n'); }
    {char * tlv19; tlv19 = (char *)('\n'); }
    {char * tlv18; tlv18 = (char *)('\n'); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)('\n'); }
    {char * tlv21; tlv21 = (char *)('\n'); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)('\n'); }
    {char * tlv23; tlv23 = (char *)('\n'); }
    {char * tlv22; tlv22 = (char *)('\n'); }
}
void fix_ingred_main_13_0(){
fix_ingred_main_13_0_0();
fix_ingred_main_13_0_3();
fix_ingred_main_13_0_4();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char'}'
val_s=>'[('char', 'tlv11', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcefac8>), ('char', 'tlv10', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd8128>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=0/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
unique : ('char', 'buf [ BUF_SIZE ]', None)
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=0/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=1/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=1/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=2/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=2/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=3/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=3/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=4/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=4/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=5/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=5/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=6/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=6/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=7/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=7/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=8/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=8/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=9/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=9/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=10/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=10/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=11/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=11/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=12/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=12/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=13/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=13/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=14/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=14/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=15/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=15/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=16/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=16/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=17/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=17/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=18/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=18/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=19/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=19/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=20/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=20/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=21/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=21/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=22/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=22/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=23/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=23/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=24/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=24/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=25/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=25/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=26/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=26/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=27/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=27/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[0]' - False OR  False
[i=13/14][j=1/18][dd=28/37][k=0/7] | type: char ; var : tlv11 ; varinfo :  ; value_node : buf [ 0 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,0,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 0
 => is literal (False) | is operator (True) ]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf[1]' - False OR  False
[i=13/14][j=1/18][dd=28/37][k=1/7] | type: char ; var : tlv10 ; varinfo :  ; value_node : buf [ 1 ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf,[,1,]
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) [
 => is literal (True) | is operator (False) 1
 => is literal (False) | is operator (True) ]
----
UNIQ_INIT: ('char','buf [ BUF_SIZE ]','None','None');

----
UNIQ_INIT: ('char','buf [ BUF_SIZE ]','None','None');

==== Scope 1 ====
void fix_ingred_main_13_1_0(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
    {if (buf){char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(buf [ 0 ]); }}
    {if (buf){int i; i = (int)(buf [ 0 ]); }}
    {if (buf){int ret; ret = (int)(buf [ 0 ]); }}
    {if (buf){int temp; temp = (int)(buf [ 0 ]); }}
    {if (buf){cgc_size_t sret; sret = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char c; c = (char)(buf [ 0 ]); }}
    {if (buf){int tlv1; tlv1 = (int)(buf [ 0 ]); }}
    {if (buf){int tlv2; tlv2 = (int)(buf [ 0 ]); }}
    {if (buf){char tlv11; tlv11 = (char)(buf [ 0 ]); }}
    {if (buf){char tlv10; tlv10 = (char)(buf [ 0 ]); }}
    {if (buf){int tlv12; tlv12 = (int)(buf [ 0 ]); }}
    {if (buf){uint32_t tlv4; tlv4 = (uint32_t)(buf [ 0 ]); }}
    {if (buf){char tlv14; tlv14 = (char)(buf [ 0 ]); }}
    {if (buf){char tlv13; tlv13 = (char)(buf [ 0 ]); }}
    {if (buf){char * tlv7; tlv7 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv6; tlv6 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv9; tlv9 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv8; tlv8 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv16; tlv16 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv15; tlv15 = (char *)(buf [ 0 ]); }}
    {if (buf){int tlv3; tlv3 = (int)(buf [ 0 ]); }}
    {if (buf){char * tlv19; tlv19 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv18; tlv18 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv17; tlv17 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv21; tlv21 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv20; tlv20 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv23; tlv23 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv22; tlv22 = (char *)(buf [ 0 ]); }}
}
void fix_ingred_main_13_1_1(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
    {if (buf){char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(buf [ 1 ]); }}
    {if (buf){int i; i = (int)(buf [ 1 ]); }}
    {if (buf){int ret; ret = (int)(buf [ 1 ]); }}
    {if (buf){int temp; temp = (int)(buf [ 1 ]); }}
    {if (buf){cgc_size_t sret; sret = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char c; c = (char)(buf [ 1 ]); }}
    {if (buf){int tlv1; tlv1 = (int)(buf [ 1 ]); }}
    {if (buf){int tlv2; tlv2 = (int)(buf [ 1 ]); }}
    {if (buf){char tlv11; tlv11 = (char)(buf [ 1 ]); }}
    {if (buf){char tlv10; tlv10 = (char)(buf [ 1 ]); }}
    {if (buf){int tlv12; tlv12 = (int)(buf [ 1 ]); }}
    {if (buf){uint32_t tlv4; tlv4 = (uint32_t)(buf [ 1 ]); }}
    {if (buf){char tlv14; tlv14 = (char)(buf [ 1 ]); }}
    {if (buf){char tlv13; tlv13 = (char)(buf [ 1 ]); }}
    {if (buf){char * tlv7; tlv7 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv6; tlv6 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv9; tlv9 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv8; tlv8 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv16; tlv16 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv15; tlv15 = (char *)(buf [ 1 ]); }}
    {if (buf){int tlv3; tlv3 = (int)(buf [ 1 ]); }}
    {if (buf){char * tlv19; tlv19 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv18; tlv18 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv17; tlv17 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv21; tlv21 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv20; tlv20 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv23; tlv23 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv22; tlv22 = (char *)(buf [ 1 ]); }}
}
void fix_ingred_main_13_1(){
fix_ingred_main_13_1_0();
fix_ingred_main_13_1_1();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int'}'
val_s=>'[('int', 'tlv12', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcf2ba8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=0/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=1/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=2/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=3/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=4/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=5/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=6/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=7/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=8/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=9/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=10/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=11/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=12/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=13/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=14/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=15/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=16/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=17/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=18/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=19/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=20/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=21/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=22/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=23/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=24/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=25/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=26/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=27/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i+1' - False OR  False
[i=13/14][j=2/18][dd=28/37][k=0/6] | type: int ; var : tlv12 ; varinfo :  ; value_node : i + 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i,+,1
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) +
 => is literal (True) | is operator (False) 1
not valid - int i; i = ((int)i + 1);

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_main_13_2_0(){
int i;
    bzero(&i,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(i + 1); }
    {int ret; ret = (int)(i + 1); }
    {int temp; temp = (int)(i + 1); }
    {cgc_size_t sret; sret = (cgc_size_t)(i + 1); }
    {char c; c = (char)(i + 1); }
    {int tlv1; tlv1 = (int)(i + 1); }
    {int tlv2; tlv2 = (int)(i + 1); }
    {char tlv11; tlv11 = (char)(i + 1); }
    {char tlv10; tlv10 = (char)(i + 1); }
    {int tlv12; tlv12 = (int)(i + 1); }
    {uint32_t tlv4; tlv4 = (uint32_t)(i + 1); }
    {char tlv14; tlv14 = (char)(i + 1); }
    {char tlv13; tlv13 = (char)(i + 1); }
    {char * tlv7; tlv7 = (char *)(i + 1); }
    {char * tlv6; tlv6 = (char *)(i + 1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(i + 1); }
    {char * tlv9; tlv9 = (char *)(i + 1); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(i + 1); }
    {char * tlv16; tlv16 = (char *)(i + 1); }
    {char * tlv15; tlv15 = (char *)(i + 1); }
    {int tlv3; tlv3 = (int)(i + 1); }
    {char * tlv19; tlv19 = (char *)(i + 1); }
    {char * tlv18; tlv18 = (char *)(i + 1); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(i + 1); }
    {char * tlv21; tlv21 = (char *)(i + 1); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(i + 1); }
    {char * tlv23; tlv23 = (char *)(i + 1); }
    {char * tlv22; tlv22 = (char *)(i + 1); }
}
void fix_ingred_main_13_2(){
fix_ingred_main_13_2_0();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bcea7b8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bceab38>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=0/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
unique : ('int', 'tlv1', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=1/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=2/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=3/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=4/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=5/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=6/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=7/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=8/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=9/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=10/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=11/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=12/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=13/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=14/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=15/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=16/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=17/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=18/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=19/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=20/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=21/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=22/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=23/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=24/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=25/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=26/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=27/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv1' - False OR  False
[i=13/14][j=3/18][dd=28/37][k=5/7] | type: int ; var :  ; varinfo :  ; value_node : tlv1 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv1
 => is literal (False) | is operator (False) tlv1 [vtype=int]
not unique: ('int', 'tlv1', None) ... continue!
not valid - int tlv1; tlv1 = ((int)tlv1);

----
UNIQ_INIT: ('int','tlv1','None','None');

==== Scope 1 ====
void fix_ingred_main_13_3_5(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(tlv1); }
    {int i; i = (int)(tlv1); }
    {int ret; ret = (int)(tlv1); }
    {int temp; temp = (int)(tlv1); }
    {cgc_size_t sret; sret = (cgc_size_t)(tlv1); }
    {char c; c = (char)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {char tlv11; tlv11 = (char)(tlv1); }
    {char tlv10; tlv10 = (char)(tlv1); }
    {int tlv12; tlv12 = (int)(tlv1); }
    {uint32_t tlv4; tlv4 = (uint32_t)(tlv1); }
    {char tlv14; tlv14 = (char)(tlv1); }
    {char tlv13; tlv13 = (char)(tlv1); }
    {char * tlv7; tlv7 = (char *)(tlv1); }
    {char * tlv6; tlv6 = (char *)(tlv1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv1); }
    {char * tlv9; tlv9 = (char *)(tlv1); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(tlv1); }
    {char * tlv16; tlv16 = (char *)(tlv1); }
    {char * tlv15; tlv15 = (char *)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {char * tlv19; tlv19 = (char *)(tlv1); }
    {char * tlv18; tlv18 = (char *)(tlv1); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(tlv1); }
    {char * tlv21; tlv21 = (char *)(tlv1); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(tlv1); }
    {char * tlv23; tlv23 = (char *)(tlv1); }
    {char * tlv22; tlv22 = (char *)(tlv1); }
}
void fix_ingred_main_13_3(){
fix_ingred_main_13_3_5();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t'}'
val_s=>'[('uint32_t', 'tlv4', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbc4ba8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=0/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
unique : ('char', 'buf [ BUF_SIZE ]', None)
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=1/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=2/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=3/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=4/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=5/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=6/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=7/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=8/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=9/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=10/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=11/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=12/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=13/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=14/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=15/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=16/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=17/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=18/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=19/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=20/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=21/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=22/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=23/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=24/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=25/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=26/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=27/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
is_func_ [*] => '[False, False, False]'
has_multiptr_refs '*((int*)buf)' - False OR  False
[i=13/14][j=4/18][dd=28/37][k=0/6] | type: uint32_t ; var : tlv4 ; varinfo :  ; value_node : * ( ( int * ) buf ) (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : *,(,(,int,*,),buf,)
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (True) (
 => is literal (False) | is operator (False) int [vtype=None]
 => is literal (False) | is operator (True) *
 => is literal (False) | is operator (True) )
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
 => is literal (False) | is operator (True) )
----
UNIQ_INIT: ('char','buf [ BUF_SIZE ]','None','None');

==== Scope 1 ====
void fix_ingred_main_13_4_0(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(* ( ( int * ) buf )); }
    {int i; i = (int)(* ( ( int * ) buf )); }
    {int ret; ret = (int)(* ( ( int * ) buf )); }
    {int temp; temp = (int)(* ( ( int * ) buf )); }
    {cgc_size_t sret; sret = (cgc_size_t)(* ( ( int * ) buf )); }
    {char c; c = (char)(* ( ( int * ) buf )); }
    {int tlv1; tlv1 = (int)(* ( ( int * ) buf )); }
    {int tlv2; tlv2 = (int)(* ( ( int * ) buf )); }
    {char tlv11; tlv11 = (char)(* ( ( int * ) buf )); }
    {char tlv10; tlv10 = (char)(* ( ( int * ) buf )); }
    {int tlv12; tlv12 = (int)(* ( ( int * ) buf )); }
    {uint32_t tlv4; tlv4 = (uint32_t)(* ( ( int * ) buf )); }
    {char tlv14; tlv14 = (char)(* ( ( int * ) buf )); }
    {char tlv13; tlv13 = (char)(* ( ( int * ) buf )); }
    {char * tlv7; tlv7 = (char *)(* ( ( int * ) buf )); }
    {char * tlv6; tlv6 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv9; tlv9 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv16; tlv16 = (char *)(* ( ( int * ) buf )); }
    {char * tlv15; tlv15 = (char *)(* ( ( int * ) buf )); }
    {int tlv3; tlv3 = (int)(* ( ( int * ) buf )); }
    {char * tlv19; tlv19 = (char *)(* ( ( int * ) buf )); }
    {char * tlv18; tlv18 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv21; tlv21 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv23; tlv23 = (char *)(* ( ( int * ) buf )); }
    {char * tlv22; tlv22 = (char *)(* ( ( int * ) buf )); }
}
void fix_ingred_main_13_4(){
fix_ingred_main_13_4_0();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t'}'
val_s=>'[('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbe4e48>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=0/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=0/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=1/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=2/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=3/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=3/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=4/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=4/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=5/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=5/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=6/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=6/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=7/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=8/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=8/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=9/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=9/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=10/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=10/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=11/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=11/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=12/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=12/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=13/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=13/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=14/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=15/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=15/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=16/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=16/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=17/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=18/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=18/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=19/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=19/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=20/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=20/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=21/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=21/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=22/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=22/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=23/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=23/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=24/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=24/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=25/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=25/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=26/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=26/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=27/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=27/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
is_func_ [i] => '[False, False, False]'
has_multiptr_refs 'i' - False OR  False
[i=13/14][j=5/18][dd=28/37][k=7/9] | type: int ; var :  ; varinfo :  ; value_node : i (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : i
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
is_func_ [N] => '[False, False, False]'
has_multiptr_refs 'NUM_ROUNDS' - False OR  False
[i=13/14][j=5/18][dd=28/37][k=8/9] | type: int ; var :  ; varinfo :  ; value_node : NUM_ROUNDS (<class 'CParser.CParser.ShiftExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : NUM_ROUNDS
 => is literal (False) | is operator (False) NUM_ROUNDS [vtype=None]
----
UNIQ_INIT: ('int','i','None','None');

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_main_13_5_7(){
int i;
    bzero(&i,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(i); }
    {int temp; temp = (int)(i); }
    {cgc_size_t sret; sret = (cgc_size_t)(i); }
    {char c; c = (char)(i); }
    {int tlv1; tlv1 = (int)(i); }
    {char tlv11; tlv11 = (char)(i); }
    {char tlv10; tlv10 = (char)(i); }
    {int tlv12; tlv12 = (int)(i); }
    {uint32_t tlv4; tlv4 = (uint32_t)(i); }
    {char tlv14; tlv14 = (char)(i); }
    {char tlv13; tlv13 = (char)(i); }
    {char * tlv6; tlv6 = (char *)(i); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(i); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(i); }
    {char * tlv16; tlv16 = (char *)(i); }
    {char * tlv15; tlv15 = (char *)(i); }
    {int tlv3; tlv3 = (int)(i); }
    {char * tlv19; tlv19 = (char *)(i); }
    {char * tlv18; tlv18 = (char *)(i); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(i); }
    {char * tlv21; tlv21 = (char *)(i); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(i); }
    {char * tlv23; tlv23 = (char *)(i); }
    {char * tlv22; tlv22 = (char *)(i); }
}
void fix_ingred_main_13_5_8(){
int i;
    bzero(&i,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(NUM_ROUNDS); }
    {int i; i = (int)(NUM_ROUNDS); }
    {int ret; ret = (int)(NUM_ROUNDS); }
    {int temp; temp = (int)(NUM_ROUNDS); }
    {cgc_size_t sret; sret = (cgc_size_t)(NUM_ROUNDS); }
    {char c; c = (char)(NUM_ROUNDS); }
    {int tlv1; tlv1 = (int)(NUM_ROUNDS); }
    {int tlv2; tlv2 = (int)(NUM_ROUNDS); }
    {char tlv11; tlv11 = (char)(NUM_ROUNDS); }
    {char tlv10; tlv10 = (char)(NUM_ROUNDS); }
    {int tlv12; tlv12 = (int)(NUM_ROUNDS); }
    {uint32_t tlv4; tlv4 = (uint32_t)(NUM_ROUNDS); }
    {char tlv14; tlv14 = (char)(NUM_ROUNDS); }
    {char tlv13; tlv13 = (char)(NUM_ROUNDS); }
    {char * tlv7; tlv7 = (char *)(NUM_ROUNDS); }
    {char * tlv6; tlv6 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv9; tlv9 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv16; tlv16 = (char *)(NUM_ROUNDS); }
    {char * tlv15; tlv15 = (char *)(NUM_ROUNDS); }
    {int tlv3; tlv3 = (int)(NUM_ROUNDS); }
    {char * tlv19; tlv19 = (char *)(NUM_ROUNDS); }
    {char * tlv18; tlv18 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv21; tlv21 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv23; tlv23 = (char *)(NUM_ROUNDS); }
    {char * tlv22; tlv22 = (char *)(NUM_ROUNDS); }
}
void fix_ingred_main_13_5(){
fix_ingred_main_13_5_7();
fix_ingred_main_13_5_8();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bbc6828>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bbc6ba8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv19': 'char *', 'tlv18': 'char *', 'tlv17': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv19', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbe33c8>), ('char *', 'tlv18', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbe2358>), ('cgc_size_t', 'tlv17', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbc59e8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=0/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
unique : ('char', 'buf [ BUF_SIZE ]', None)
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=0/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
unique : ('int', 'temp', None)
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=0/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=1/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=1/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=1/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=2/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=2/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=3/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=3/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=3/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=4/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=4/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=4/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=5/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=5/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=6/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=6/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=6/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=7/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=7/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=7/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=8/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=8/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=8/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=9/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=9/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=9/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=10/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=10/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=10/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=11/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=11/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=11/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=12/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=12/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=12/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=13/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=13/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=13/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=14/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=14/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=14/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=15/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=15/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=15/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=16/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=16/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=16/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=17/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=17/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=17/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=18/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=18/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=18/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=19/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=19/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=19/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=20/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=20/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=20/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=21/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=21/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=21/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=22/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=22/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=22/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=23/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=23/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=23/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=24/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=24/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=24/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=25/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=25/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=25/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=26/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=26/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=26/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=27/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=27/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=27/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
is_func_ [b] => '[False, False, False]'
has_multiptr_refs 'buf' - False OR  False
[i=13/14][j=8/18][dd=28/37][k=0/11] | type: char * ; var : tlv19 ; varinfo :  ; value_node : buf (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : buf
 => is literal (False) | is operator (False) buf [vtype=char *]
BEFORE => literal (False) buf => char *
AFTER => literal (False) buf [ BUF_SIZE ] => char [size=BUF_SIZE]
Array size is variable => 'BUF_SIZE'
not unique: ('char', 'buf [ BUF_SIZE ]', None) ... continue!
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[temp]' - False OR  False
[i=13/14][j=8/18][dd=28/37][k=1/11] | type: char * ; var : tlv18 ; varinfo :  ; value_node : cgc_gWords [ temp ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,temp,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) temp [vtype=int]
not unique: ('int', 'temp', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [B] => '[False, False, False]'
has_multiptr_refs 'BUF_SIZE' - False OR  False
[i=13/14][j=8/18][dd=28/37][k=2/11] | type: cgc_size_t ; var : tlv17 ; varinfo :  ; value_node : BUF_SIZE (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : BUF_SIZE
 => is literal (False) | is operator (False) BUF_SIZE [vtype=None]
----
UNIQ_INIT: ('char','buf [ BUF_SIZE ]','None','None');

UNIQ_INIT: ('int','temp','None','None');

not valid - int temp; temp = ((int)cgc_gWords [ temp ]);

----
UNIQ_INIT: ('char','buf [ BUF_SIZE ]','None','None');

UNIQ_INIT: ('int','temp','None','None');

----
UNIQ_INIT: ('char','buf [ BUF_SIZE ]','None','None');

UNIQ_INIT: ('int','temp','None','None');

==== Scope 1 ====
void fix_ingred_main_13_8_0(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
int temp;
    bzero(&temp,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(buf); }
    {int i; i = (int)(buf); }
    {int temp; temp = (int)(buf); }
    {cgc_size_t sret; sret = (cgc_size_t)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {int tlv2; tlv2 = (int)(buf); }
    {char tlv11; tlv11 = (char)(buf); }
    {char tlv10; tlv10 = (char)(buf); }
    {int tlv12; tlv12 = (int)(buf); }
    {uint32_t tlv4; tlv4 = (uint32_t)(buf); }
    {char tlv14; tlv14 = (char)(buf); }
    {char tlv13; tlv13 = (char)(buf); }
    {char * tlv7; tlv7 = (char *)(buf); }
    {char * tlv6; tlv6 = (char *)(buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf); }
    {char * tlv9; tlv9 = (char *)(buf); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(buf); }
    {char * tlv16; tlv16 = (char *)(buf); }
    {char * tlv15; tlv15 = (char *)(buf); }
    {int tlv3; tlv3 = (int)(buf); }
    {char * tlv19; tlv19 = (char *)(buf); }
    {char * tlv18; tlv18 = (char *)(buf); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(buf); }
    {char * tlv21; tlv21 = (char *)(buf); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(buf); }
    {char * tlv23; tlv23 = (char *)(buf); }
    {char * tlv22; tlv22 = (char *)(buf); }
}
void fix_ingred_main_13_8_1(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
int temp;
    bzero(&temp,sizeof(int));
    {if (cgc_gWords){    temp = 0;
         char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int i; i = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int ret; ret = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t sret; sret = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char c; c = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv1; tlv1 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv2; tlv2 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv11; tlv11 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv10; tlv10 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv12; tlv12 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         uint32_t tlv4; tlv4 = (uint32_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv14; tlv14 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv13; tlv13 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv7; tlv7 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv6; tlv6 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv9; tlv9 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv16; tlv16 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv15; tlv15 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv3; tlv3 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv19; tlv19 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv18; tlv18 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv17; tlv17 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv21; tlv21 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv20; tlv20 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv23; tlv23 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv22; tlv22 = (char *)(cgc_gWords [ temp ]); }}
}
void fix_ingred_main_13_8_2(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
int temp;
    bzero(&temp,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(BUF_SIZE); }
    {int i; i = (int)(BUF_SIZE); }
    {int ret; ret = (int)(BUF_SIZE); }
    {int temp; temp = (int)(BUF_SIZE); }
    {cgc_size_t sret; sret = (cgc_size_t)(BUF_SIZE); }
    {char c; c = (char)(BUF_SIZE); }
    {int tlv1; tlv1 = (int)(BUF_SIZE); }
    {int tlv2; tlv2 = (int)(BUF_SIZE); }
    {char tlv11; tlv11 = (char)(BUF_SIZE); }
    {char tlv10; tlv10 = (char)(BUF_SIZE); }
    {int tlv12; tlv12 = (int)(BUF_SIZE); }
    {uint32_t tlv4; tlv4 = (uint32_t)(BUF_SIZE); }
    {char tlv14; tlv14 = (char)(BUF_SIZE); }
    {char tlv13; tlv13 = (char)(BUF_SIZE); }
    {char * tlv7; tlv7 = (char *)(BUF_SIZE); }
    {char * tlv6; tlv6 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv9; tlv9 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv16; tlv16 = (char *)(BUF_SIZE); }
    {char * tlv15; tlv15 = (char *)(BUF_SIZE); }
    {int tlv3; tlv3 = (int)(BUF_SIZE); }
    {char * tlv19; tlv19 = (char *)(BUF_SIZE); }
    {char * tlv18; tlv18 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv21; tlv21 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv23; tlv23 = (char *)(BUF_SIZE); }
    {char * tlv22; tlv22 = (char *)(BUF_SIZE); }
}
void fix_ingred_main_13_8(){
fix_ingred_main_13_8_0();
fix_ingred_main_13_8_1();
fix_ingred_main_13_8_2();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv19': 'char *', 'tlv18': 'char *', 'tlv17': 'cgc_size_t', 'tlv21': 'char *', 'tlv20': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv21', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbc9f28>), ('cgc_size_t', 'tlv20', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbc8f98>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=0/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
unique : ('char', 'c', None)
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=0/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=1/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=2/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=3/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=3/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=4/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=4/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=5/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=6/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=6/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=7/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=8/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=8/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=9/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=9/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=10/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=10/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=11/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=11/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=12/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=12/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=13/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=13/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=14/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=15/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=15/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=16/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=16/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=17/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=18/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=18/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=19/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=19/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=20/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=20/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=21/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=21/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=22/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=22/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=23/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=23/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=24/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=24/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=25/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=25/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=26/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=26/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=27/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=27/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
is_func_ [&] => '[False, False, False]'
has_multiptr_refs '&c' - False OR  False
[i=13/14][j=9/18][dd=28/37][k=0/10] | type: char * ; var : tlv21 ; varinfo :  ; value_node : & c (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : &,c
 => is literal (False) | is operator (False) & [vtype=None]
 => is literal (False) | is operator (False) c [vtype=char]
not unique: ('char', 'c', None) ... continue!
is_func_ [1] => '[False, False, False]'
has_multiptr_refs '1' - False OR  False
[i=13/14][j=9/18][dd=28/37][k=1/10] | type: cgc_size_t ; var : tlv20 ; varinfo :  ; value_node : 1 (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : 1
 => is literal (True) | is operator (False) 1
not valid - char c; c = ((char)& c);

----
UNIQ_INIT: ('char','c','None','None');

----
UNIQ_INIT: ('char','c','None','None');

==== Scope 1 ====
void fix_ingred_main_13_9_0(){
char c;
    bzero(&c,sizeof(char));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(& c); }
    {int i; i = (int)(& c); }
    {int ret; ret = (int)(& c); }
    {int temp; temp = (int)(& c); }
    {cgc_size_t sret; sret = (cgc_size_t)(& c); }
    {int tlv1; tlv1 = (int)(& c); }
    {int tlv2; tlv2 = (int)(& c); }
    {char tlv11; tlv11 = (char)(& c); }
    {char tlv10; tlv10 = (char)(& c); }
    {int tlv12; tlv12 = (int)(& c); }
    {uint32_t tlv4; tlv4 = (uint32_t)(& c); }
    {char tlv14; tlv14 = (char)(& c); }
    {char tlv13; tlv13 = (char)(& c); }
    {char * tlv7; tlv7 = (char *)(& c); }
    {char * tlv6; tlv6 = (char *)(& c); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(& c); }
    {char * tlv9; tlv9 = (char *)(& c); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(& c); }
    {char * tlv16; tlv16 = (char *)(& c); }
    {char * tlv15; tlv15 = (char *)(& c); }
    {int tlv3; tlv3 = (int)(& c); }
    {char * tlv19; tlv19 = (char *)(& c); }
    {char * tlv18; tlv18 = (char *)(& c); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(& c); }
    {char * tlv21; tlv21 = (char *)(& c); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(& c); }
    {char * tlv23; tlv23 = (char *)(& c); }
    {char * tlv22; tlv22 = (char *)(& c); }
}
void fix_ingred_main_13_9_1(){
char c;
    bzero(&c,sizeof(char));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(1); }
    {int temp; temp = (int)(1); }
    {cgc_size_t sret; sret = (cgc_size_t)(1); }
    {int tlv1; tlv1 = (int)(1); }
    {char tlv11; tlv11 = (char)(1); }
    {char tlv10; tlv10 = (char)(1); }
    {int tlv12; tlv12 = (int)(1); }
    {uint32_t tlv4; tlv4 = (uint32_t)(1); }
    {char tlv14; tlv14 = (char)(1); }
    {char tlv13; tlv13 = (char)(1); }
    {char * tlv6; tlv6 = (char *)(1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(1); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(1); }
    {char * tlv16; tlv16 = (char *)(1); }
    {char * tlv15; tlv15 = (char *)(1); }
    {int tlv3; tlv3 = (int)(1); }
    {char * tlv19; tlv19 = (char *)(1); }
    {char * tlv18; tlv18 = (char *)(1); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(1); }
    {char * tlv21; tlv21 = (char *)(1); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(1); }
    {char * tlv23; tlv23 = (char *)(1); }
    {char * tlv22; tlv22 = (char *)(1); }
}
void fix_ingred_main_13_9(){
fix_ingred_main_13_9_0();
fix_ingred_main_13_9_1();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv19': 'char *', 'tlv18': 'char *', 'tlv17': 'cgc_size_t', 'tlv21': 'char *', 'tlv20': 'cgc_size_t', 'tlv3': 'int', 'tlv23': 'char *', 'tlv22': 'char *'}'
val_s=>'[('char *', 'tlv23', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb08358>), ('char *', 'tlv22', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bafd2e8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>), ('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbe4e48>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv19': 'char *', 'tlv18': 'char *', 'tlv17': 'cgc_size_t', 'tlv21': 'char *', 'tlv20': 'cgc_size_t', 'tlv3': 'int', 'tlv23': 'char *', 'tlv22': 'char *'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbd7828>), ('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236bbe4e48>)]'
cval_s=>'[('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc3c8>), ('int', '', '', <CParser.CParser.ShiftExpressionContext object at 0x15236bbcc6d8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bb005f8>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236bb00978>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=0/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
unique : ('int', 'tlv3', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=1/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=2/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=3/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=4/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=5/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=6/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=7/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=8/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=9/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=10/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=11/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=12/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=13/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=14/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=15/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=16/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=17/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=18/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=19/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=20/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=21/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=22/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=23/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=24/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=25/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=26/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=27/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv3' - False OR  False
[i=13/14][j=11/18][dd=28/37][k=9/11] | type: int ; var :  ; varinfo :  ; value_node : tlv3 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv3
 => is literal (False) | is operator (False) tlv3 [vtype=int]
not unique: ('int', 'tlv3', None) ... continue!
not valid - int tlv3; tlv3 = ((int)tlv3);

----
UNIQ_INIT: ('int','tlv3','None','None');

==== Scope 1 ====
void fix_ingred_main_13_11_9(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(tlv3); }
    {int i; i = (int)(tlv3); }
    {int ret; ret = (int)(tlv3); }
    {int temp; temp = (int)(tlv3); }
    {cgc_size_t sret; sret = (cgc_size_t)(tlv3); }
    {char c; c = (char)(tlv3); }
    {int tlv1; tlv1 = (int)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {char tlv11; tlv11 = (char)(tlv3); }
    {char tlv10; tlv10 = (char)(tlv3); }
    {int tlv12; tlv12 = (int)(tlv3); }
    {uint32_t tlv4; tlv4 = (uint32_t)(tlv3); }
    {char tlv14; tlv14 = (char)(tlv3); }
    {char tlv13; tlv13 = (char)(tlv3); }
    {char * tlv7; tlv7 = (char *)(tlv3); }
    {char * tlv6; tlv6 = (char *)(tlv3); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv3); }
    {char * tlv9; tlv9 = (char *)(tlv3); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(tlv3); }
    {char * tlv16; tlv16 = (char *)(tlv3); }
    {char * tlv15; tlv15 = (char *)(tlv3); }
    {char * tlv19; tlv19 = (char *)(tlv3); }
    {char * tlv18; tlv18 = (char *)(tlv3); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(tlv3); }
    {char * tlv21; tlv21 = (char *)(tlv3); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(tlv3); }
    {char * tlv23; tlv23 = (char *)(tlv3); }
    {char * tlv22; tlv22 = (char *)(tlv3); }
}
void fix_ingred_main_13_11(){
fix_ingred_main_13_11_9();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv14': 'char', 'tlv13': 'char'}'
val_s=>'[('char', 'tlv14', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0af98>), ('char', 'tlv13', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb095f8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv14': 'char', 'tlv13': 'char', 'tlv7': 'char *', 'tlv6': 'char *', 'tlv5': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv7', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb05dd8>), ('char *', 'tlv6', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bb0dd68>), ('cgc_size_t', 'tlv5', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bafe438>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=0/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
unique : ('int', 'i', None)
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=1/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=2/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=3/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=4/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=5/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=6/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=7/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=8/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=9/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=10/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=11/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=12/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=13/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=14/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=15/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=16/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=17/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=18/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=19/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=20/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=21/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=22/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=23/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=24/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=25/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=26/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=27/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
is_func_ [c] => '[False, False, False]'
has_multiptr_refs 'cgc_gWords[i]' - False OR  False
[i=13/14][j=13/18][dd=28/37][k=1/8] | type: char * ; var : tlv6 ; varinfo :  ; value_node : cgc_gWords [ i ] (<class 'CParser.CParser.AssignmentExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : cgc_gWords,[,i,]
 => is literal (False) | is operator (False) cgc_gWords [vtype=None]
 => is literal (False) | is operator (True) [
 => is literal (False) | is operator (False) i [vtype=int]
not unique: ('int', 'i', None) ... continue!
 => is literal (False) | is operator (True) ]
not valid - int i; i = ((int)cgc_gWords [ i ]);

----
UNIQ_INIT: ('int','i','None','None');

==== Scope 1 ====
void fix_ingred_main_13_13_1(){
int i;
    bzero(&i,sizeof(int));
    {if (cgc_gWords){    i = 0;
         char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int ret; ret = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int temp; temp = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t sret; sret = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char c; c = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv1; tlv1 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv2; tlv2 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv11; tlv11 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv10; tlv10 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv12; tlv12 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         uint32_t tlv4; tlv4 = (uint32_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv14; tlv14 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv13; tlv13 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv7; tlv7 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv6; tlv6 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv9; tlv9 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv16; tlv16 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv15; tlv15 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv3; tlv3 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv19; tlv19 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv18; tlv18 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv17; tlv17 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv21; tlv21 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv20; tlv20 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv23; tlv23 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv22; tlv22 = (char *)(cgc_gWords [ i ]); }}
}
void fix_ingred_main_13_13(){
fix_ingred_main_13_13_1();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv14': 'char', 'tlv13': 'char', 'tlv7': 'char *', 'tlv6': 'char *', 'tlv5': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'cgc_size_t'}'
val_s=>'[('char *', 'tlv9', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba50978>), ('cgc_size_t', 'tlv8', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba7a9e8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv14': 'char', 'tlv13': 'char', 'tlv7': 'char *', 'tlv6': 'char *', 'tlv5': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'cgc_size_t', 'tlv2': 'int', 'tlv16': 'char *', 'tlv15': 'char *'}'
val_s=>'[('char *', 'tlv16', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba47d68>), ('char *', 'tlv15', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba4ccf8>), ('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba42898>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv14': 'char', 'tlv13': 'char', 'tlv7': 'char *', 'tlv6': 'char *', 'tlv5': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'cgc_size_t', 'tlv2': 'int', 'tlv16': 'char *', 'tlv15': 'char *'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba42898>)]'
cval_s=>'[('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236ba72048>), ('int', '', '', <CParser.CParser.RelationalExpressionContext object at 0x15236ba723c8>)]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=0/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
unique : ('int', 'tlv2', None)
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=1/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=2/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=3/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=4/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=5/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=6/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=7/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=8/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=9/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=10/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=11/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=12/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=13/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=14/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=15/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=16/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=17/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=18/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=19/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=20/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=21/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=22/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=23/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=24/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=25/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=26/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=27/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
is_func_ [t] => '[False, False, False]'
has_multiptr_refs 'tlv2' - False OR  False
[i=13/14][j=16/18][dd=28/37][k=6/8] | type: int ; var :  ; varinfo :  ; value_node : tlv2 (<class 'CParser.CParser.RelationalExpressionContext'>);
 proceed : True [not(False) && ( not (False) || False )]
Subterms : tlv2
 => is literal (False) | is operator (False) tlv2 [vtype=int]
not unique: ('int', 'tlv2', None) ... continue!
not valid - int tlv2; tlv2 = ((int)tlv2);

----
UNIQ_INIT: ('int','tlv2','None','None');

==== Scope 1 ====
void fix_ingred_main_13_16_6(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(tlv2); }
    {int i; i = (int)(tlv2); }
    {int ret; ret = (int)(tlv2); }
    {int temp; temp = (int)(tlv2); }
    {cgc_size_t sret; sret = (cgc_size_t)(tlv2); }
    {char c; c = (char)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {char tlv11; tlv11 = (char)(tlv2); }
    {char tlv10; tlv10 = (char)(tlv2); }
    {int tlv12; tlv12 = (int)(tlv2); }
    {uint32_t tlv4; tlv4 = (uint32_t)(tlv2); }
    {char tlv14; tlv14 = (char)(tlv2); }
    {char tlv13; tlv13 = (char)(tlv2); }
    {char * tlv7; tlv7 = (char *)(tlv2); }
    {char * tlv6; tlv6 = (char *)(tlv2); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv2); }
    {char * tlv9; tlv9 = (char *)(tlv2); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(tlv2); }
    {char * tlv16; tlv16 = (char *)(tlv2); }
    {char * tlv15; tlv15 = (char *)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {char * tlv19; tlv19 = (char *)(tlv2); }
    {char * tlv18; tlv18 = (char *)(tlv2); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(tlv2); }
    {char * tlv21; tlv21 = (char *)(tlv2); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(tlv2); }
    {char * tlv23; tlv23 = (char *)(tlv2); }
    {char * tlv22; tlv22 = (char *)(tlv2); }
}
void fix_ingred_main_13_16(){
fix_ingred_main_13_16_6();
}

sym_lut=>'{'cgc_argc': 'int', 'cgc_argv': 'char * *', 'cgc_argv [ ]': 'char *', 'buf': 'char *', 'buf [ BUF_SIZE ]': 'char', 'i': 'int', 'ret': 'int', 'temp': 'int', 'sret': 'cgc_size_t', 'c': 'char', 'tlv11': 'char', 'tlv10': 'char', 'tlv1': 'int', 'tlv12': 'int', 'tlv4': 'uint32_t', 'tlv14': 'char', 'tlv13': 'char', 'tlv7': 'char *', 'tlv6': 'char *', 'tlv5': 'cgc_size_t', 'tlv9': 'char *', 'tlv8': 'cgc_size_t', 'tlv2': 'int', 'tlv16': 'char *', 'tlv15': 'char *'}'
val_s=>'[('int', 'i', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bceecf8>), ('int', 'ret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd6ba8>), ('int', 'temp', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce7a58>), ('cgc_size_t', 'sret', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bce5978>), ('char', 'c', '', <CParser.CParser.AssignmentExpressionContext object at 0x15236bcd3828>), ('UNDEF', 'buf ', '[ sret - 1 ]', <CParser.CParser.AssignmentExpressionContext object at 0x15236ba42898>)]'
cval_s=>'[]'
Checking 'cgc_transmit_str( ENTER_NUM_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( ENTER_NUM_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( FINAL_RND_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( FINAL_RND_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( buf )' - is_func=True, is_func_ptr=False
cgc_transmit_str( buf ) is a function.
Skipping.
Checking 'cgc_my_srand( tlv4 )' - is_func=True, is_func_ptr=False
cgc_my_srand( tlv4 ) is a function.
Skipping.
Checking 'cgc_transmit_str( LOSE_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( LOSE_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WIN_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WIN_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( WORD_MSG ) is a function.
Skipping.
Checking 'cgc_transmit_str( NEXT_WORD_MSG )' - is_func=True, is_func_ptr=False
cgc_transmit_str( NEXT_WORD_MSG ) is a function.
Skipping.
Skipping BUF_SIZE => #define
==== Scope 2 ====
void fix_ingred_main_13_0_0(){
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(0); }
    {cgc_size_t sret; sret = (cgc_size_t)(0); }
    {int tlv1; tlv1 = (int)(0); }
    {char tlv11; tlv11 = (char)(0); }
    {char tlv10; tlv10 = (char)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {uint32_t tlv4; tlv4 = (uint32_t)(0); }
    {char tlv14; tlv14 = (char)(0); }
    {char tlv13; tlv13 = (char)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {char * tlv16; tlv16 = (char *)(0); }
    {char * tlv15; tlv15 = (char *)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {char * tlv19; tlv19 = (char *)(0); }
    {char * tlv18; tlv18 = (char *)(0); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(0); }
    {char * tlv21; tlv21 = (char *)(0); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(0); }
    {char * tlv23; tlv23 = (char *)(0); }
    {char * tlv22; tlv22 = (char *)(0); }
}
void fix_ingred_main_13_0_3(){
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(0); }
    {int temp; temp = (int)(0); }
    {cgc_size_t sret; sret = (cgc_size_t)(0); }
    {char tlv11; tlv11 = (char)(0); }
    {char tlv10; tlv10 = (char)(0); }
    {int tlv12; tlv12 = (int)(0); }
    {uint32_t tlv4; tlv4 = (uint32_t)(0); }
    {char tlv14; tlv14 = (char)(0); }
    {char tlv13; tlv13 = (char)(0); }
    {char * tlv6; tlv6 = (char *)(0); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(0); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(0); }
    {char * tlv16; tlv16 = (char *)(0); }
    {char * tlv15; tlv15 = (char *)(0); }
    {int tlv3; tlv3 = (int)(0); }
    {char * tlv19; tlv19 = (char *)(0); }
    {char * tlv18; tlv18 = (char *)(0); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(0); }
    {char * tlv21; tlv21 = (char *)(0); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(0); }
    {char * tlv23; tlv23 = (char *)(0); }
    {char * tlv22; tlv22 = (char *)(0); }
}
void fix_ingred_main_13_0_4(){
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)('\n'); }
    {int i; i = (int)('\n'); }
    {int temp; temp = (int)('\n'); }
    {cgc_size_t sret; sret = (cgc_size_t)('\n'); }
    {int tlv1; tlv1 = (int)('\n'); }
    {int tlv2; tlv2 = (int)('\n'); }
    {char tlv11; tlv11 = (char)('\n'); }
    {char tlv10; tlv10 = (char)('\n'); }
    {int tlv12; tlv12 = (int)('\n'); }
    {uint32_t tlv4; tlv4 = (uint32_t)('\n'); }
    {char tlv14; tlv14 = (char)('\n'); }
    {char tlv13; tlv13 = (char)('\n'); }
    {char * tlv7; tlv7 = (char *)('\n'); }
    {char * tlv6; tlv6 = (char *)('\n'); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)('\n'); }
    {char * tlv9; tlv9 = (char *)('\n'); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)('\n'); }
    {char * tlv16; tlv16 = (char *)('\n'); }
    {char * tlv15; tlv15 = (char *)('\n'); }
    {int tlv3; tlv3 = (int)('\n'); }
    {char * tlv19; tlv19 = (char *)('\n'); }
    {char * tlv18; tlv18 = (char *)('\n'); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)('\n'); }
    {char * tlv21; tlv21 = (char *)('\n'); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)('\n'); }
    {char * tlv23; tlv23 = (char *)('\n'); }
    {char * tlv22; tlv22 = (char *)('\n'); }
}
void fix_ingred_main_13_0(){
fix_ingred_main_13_0_0();
fix_ingred_main_13_0_3();
fix_ingred_main_13_0_4();
}
void fix_ingred_main_13_1_0(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
    {if (buf){char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(buf [ 0 ]); }}
    {if (buf){int i; i = (int)(buf [ 0 ]); }}
    {if (buf){int ret; ret = (int)(buf [ 0 ]); }}
    {if (buf){int temp; temp = (int)(buf [ 0 ]); }}
    {if (buf){cgc_size_t sret; sret = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char c; c = (char)(buf [ 0 ]); }}
    {if (buf){int tlv1; tlv1 = (int)(buf [ 0 ]); }}
    {if (buf){int tlv2; tlv2 = (int)(buf [ 0 ]); }}
    {if (buf){char tlv11; tlv11 = (char)(buf [ 0 ]); }}
    {if (buf){char tlv10; tlv10 = (char)(buf [ 0 ]); }}
    {if (buf){int tlv12; tlv12 = (int)(buf [ 0 ]); }}
    {if (buf){uint32_t tlv4; tlv4 = (uint32_t)(buf [ 0 ]); }}
    {if (buf){char tlv14; tlv14 = (char)(buf [ 0 ]); }}
    {if (buf){char tlv13; tlv13 = (char)(buf [ 0 ]); }}
    {if (buf){char * tlv7; tlv7 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv6; tlv6 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv9; tlv9 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv8; tlv8 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv16; tlv16 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv15; tlv15 = (char *)(buf [ 0 ]); }}
    {if (buf){int tlv3; tlv3 = (int)(buf [ 0 ]); }}
    {if (buf){char * tlv19; tlv19 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv18; tlv18 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv17; tlv17 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv21; tlv21 = (char *)(buf [ 0 ]); }}
    {if (buf){cgc_size_t tlv20; tlv20 = (cgc_size_t)(buf [ 0 ]); }}
    {if (buf){char * tlv23; tlv23 = (char *)(buf [ 0 ]); }}
    {if (buf){char * tlv22; tlv22 = (char *)(buf [ 0 ]); }}
}
void fix_ingred_main_13_1_1(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
    {if (buf){char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(buf [ 1 ]); }}
    {if (buf){int i; i = (int)(buf [ 1 ]); }}
    {if (buf){int ret; ret = (int)(buf [ 1 ]); }}
    {if (buf){int temp; temp = (int)(buf [ 1 ]); }}
    {if (buf){cgc_size_t sret; sret = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char c; c = (char)(buf [ 1 ]); }}
    {if (buf){int tlv1; tlv1 = (int)(buf [ 1 ]); }}
    {if (buf){int tlv2; tlv2 = (int)(buf [ 1 ]); }}
    {if (buf){char tlv11; tlv11 = (char)(buf [ 1 ]); }}
    {if (buf){char tlv10; tlv10 = (char)(buf [ 1 ]); }}
    {if (buf){int tlv12; tlv12 = (int)(buf [ 1 ]); }}
    {if (buf){uint32_t tlv4; tlv4 = (uint32_t)(buf [ 1 ]); }}
    {if (buf){char tlv14; tlv14 = (char)(buf [ 1 ]); }}
    {if (buf){char tlv13; tlv13 = (char)(buf [ 1 ]); }}
    {if (buf){char * tlv7; tlv7 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv6; tlv6 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv9; tlv9 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv8; tlv8 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv16; tlv16 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv15; tlv15 = (char *)(buf [ 1 ]); }}
    {if (buf){int tlv3; tlv3 = (int)(buf [ 1 ]); }}
    {if (buf){char * tlv19; tlv19 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv18; tlv18 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv17; tlv17 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv21; tlv21 = (char *)(buf [ 1 ]); }}
    {if (buf){cgc_size_t tlv20; tlv20 = (cgc_size_t)(buf [ 1 ]); }}
    {if (buf){char * tlv23; tlv23 = (char *)(buf [ 1 ]); }}
    {if (buf){char * tlv22; tlv22 = (char *)(buf [ 1 ]); }}
}
void fix_ingred_main_13_1(){
fix_ingred_main_13_1_0();
fix_ingred_main_13_1_1();
}
void fix_ingred_main_13_2_0(){
int i;
    bzero(&i,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(i + 1); }
    {int ret; ret = (int)(i + 1); }
    {int temp; temp = (int)(i + 1); }
    {cgc_size_t sret; sret = (cgc_size_t)(i + 1); }
    {char c; c = (char)(i + 1); }
    {int tlv1; tlv1 = (int)(i + 1); }
    {int tlv2; tlv2 = (int)(i + 1); }
    {char tlv11; tlv11 = (char)(i + 1); }
    {char tlv10; tlv10 = (char)(i + 1); }
    {int tlv12; tlv12 = (int)(i + 1); }
    {uint32_t tlv4; tlv4 = (uint32_t)(i + 1); }
    {char tlv14; tlv14 = (char)(i + 1); }
    {char tlv13; tlv13 = (char)(i + 1); }
    {char * tlv7; tlv7 = (char *)(i + 1); }
    {char * tlv6; tlv6 = (char *)(i + 1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(i + 1); }
    {char * tlv9; tlv9 = (char *)(i + 1); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(i + 1); }
    {char * tlv16; tlv16 = (char *)(i + 1); }
    {char * tlv15; tlv15 = (char *)(i + 1); }
    {int tlv3; tlv3 = (int)(i + 1); }
    {char * tlv19; tlv19 = (char *)(i + 1); }
    {char * tlv18; tlv18 = (char *)(i + 1); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(i + 1); }
    {char * tlv21; tlv21 = (char *)(i + 1); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(i + 1); }
    {char * tlv23; tlv23 = (char *)(i + 1); }
    {char * tlv22; tlv22 = (char *)(i + 1); }
}
void fix_ingred_main_13_2(){
fix_ingred_main_13_2_0();
}
void fix_ingred_main_13_3_5(){
int tlv1;
    bzero(&tlv1,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(tlv1); }
    {int i; i = (int)(tlv1); }
    {int ret; ret = (int)(tlv1); }
    {int temp; temp = (int)(tlv1); }
    {cgc_size_t sret; sret = (cgc_size_t)(tlv1); }
    {char c; c = (char)(tlv1); }
    {int tlv2; tlv2 = (int)(tlv1); }
    {char tlv11; tlv11 = (char)(tlv1); }
    {char tlv10; tlv10 = (char)(tlv1); }
    {int tlv12; tlv12 = (int)(tlv1); }
    {uint32_t tlv4; tlv4 = (uint32_t)(tlv1); }
    {char tlv14; tlv14 = (char)(tlv1); }
    {char tlv13; tlv13 = (char)(tlv1); }
    {char * tlv7; tlv7 = (char *)(tlv1); }
    {char * tlv6; tlv6 = (char *)(tlv1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv1); }
    {char * tlv9; tlv9 = (char *)(tlv1); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(tlv1); }
    {char * tlv16; tlv16 = (char *)(tlv1); }
    {char * tlv15; tlv15 = (char *)(tlv1); }
    {int tlv3; tlv3 = (int)(tlv1); }
    {char * tlv19; tlv19 = (char *)(tlv1); }
    {char * tlv18; tlv18 = (char *)(tlv1); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(tlv1); }
    {char * tlv21; tlv21 = (char *)(tlv1); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(tlv1); }
    {char * tlv23; tlv23 = (char *)(tlv1); }
    {char * tlv22; tlv22 = (char *)(tlv1); }
}
void fix_ingred_main_13_3(){
fix_ingred_main_13_3_5();
}
void fix_ingred_main_13_4_0(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(* ( ( int * ) buf )); }
    {int i; i = (int)(* ( ( int * ) buf )); }
    {int ret; ret = (int)(* ( ( int * ) buf )); }
    {int temp; temp = (int)(* ( ( int * ) buf )); }
    {cgc_size_t sret; sret = (cgc_size_t)(* ( ( int * ) buf )); }
    {char c; c = (char)(* ( ( int * ) buf )); }
    {int tlv1; tlv1 = (int)(* ( ( int * ) buf )); }
    {int tlv2; tlv2 = (int)(* ( ( int * ) buf )); }
    {char tlv11; tlv11 = (char)(* ( ( int * ) buf )); }
    {char tlv10; tlv10 = (char)(* ( ( int * ) buf )); }
    {int tlv12; tlv12 = (int)(* ( ( int * ) buf )); }
    {uint32_t tlv4; tlv4 = (uint32_t)(* ( ( int * ) buf )); }
    {char tlv14; tlv14 = (char)(* ( ( int * ) buf )); }
    {char tlv13; tlv13 = (char)(* ( ( int * ) buf )); }
    {char * tlv7; tlv7 = (char *)(* ( ( int * ) buf )); }
    {char * tlv6; tlv6 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv9; tlv9 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv16; tlv16 = (char *)(* ( ( int * ) buf )); }
    {char * tlv15; tlv15 = (char *)(* ( ( int * ) buf )); }
    {int tlv3; tlv3 = (int)(* ( ( int * ) buf )); }
    {char * tlv19; tlv19 = (char *)(* ( ( int * ) buf )); }
    {char * tlv18; tlv18 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv21; tlv21 = (char *)(* ( ( int * ) buf )); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(* ( ( int * ) buf )); }
    {char * tlv23; tlv23 = (char *)(* ( ( int * ) buf )); }
    {char * tlv22; tlv22 = (char *)(* ( ( int * ) buf )); }
}
void fix_ingred_main_13_4(){
fix_ingred_main_13_4_0();
}
void fix_ingred_main_13_5_7(){
int i;
    bzero(&i,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(i); }
    {int temp; temp = (int)(i); }
    {cgc_size_t sret; sret = (cgc_size_t)(i); }
    {char c; c = (char)(i); }
    {int tlv1; tlv1 = (int)(i); }
    {char tlv11; tlv11 = (char)(i); }
    {char tlv10; tlv10 = (char)(i); }
    {int tlv12; tlv12 = (int)(i); }
    {uint32_t tlv4; tlv4 = (uint32_t)(i); }
    {char tlv14; tlv14 = (char)(i); }
    {char tlv13; tlv13 = (char)(i); }
    {char * tlv6; tlv6 = (char *)(i); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(i); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(i); }
    {char * tlv16; tlv16 = (char *)(i); }
    {char * tlv15; tlv15 = (char *)(i); }
    {int tlv3; tlv3 = (int)(i); }
    {char * tlv19; tlv19 = (char *)(i); }
    {char * tlv18; tlv18 = (char *)(i); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(i); }
    {char * tlv21; tlv21 = (char *)(i); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(i); }
    {char * tlv23; tlv23 = (char *)(i); }
    {char * tlv22; tlv22 = (char *)(i); }
}
void fix_ingred_main_13_5_8(){
int i;
    bzero(&i,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(NUM_ROUNDS); }
    {int i; i = (int)(NUM_ROUNDS); }
    {int ret; ret = (int)(NUM_ROUNDS); }
    {int temp; temp = (int)(NUM_ROUNDS); }
    {cgc_size_t sret; sret = (cgc_size_t)(NUM_ROUNDS); }
    {char c; c = (char)(NUM_ROUNDS); }
    {int tlv1; tlv1 = (int)(NUM_ROUNDS); }
    {int tlv2; tlv2 = (int)(NUM_ROUNDS); }
    {char tlv11; tlv11 = (char)(NUM_ROUNDS); }
    {char tlv10; tlv10 = (char)(NUM_ROUNDS); }
    {int tlv12; tlv12 = (int)(NUM_ROUNDS); }
    {uint32_t tlv4; tlv4 = (uint32_t)(NUM_ROUNDS); }
    {char tlv14; tlv14 = (char)(NUM_ROUNDS); }
    {char tlv13; tlv13 = (char)(NUM_ROUNDS); }
    {char * tlv7; tlv7 = (char *)(NUM_ROUNDS); }
    {char * tlv6; tlv6 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv9; tlv9 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv16; tlv16 = (char *)(NUM_ROUNDS); }
    {char * tlv15; tlv15 = (char *)(NUM_ROUNDS); }
    {int tlv3; tlv3 = (int)(NUM_ROUNDS); }
    {char * tlv19; tlv19 = (char *)(NUM_ROUNDS); }
    {char * tlv18; tlv18 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv21; tlv21 = (char *)(NUM_ROUNDS); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(NUM_ROUNDS); }
    {char * tlv23; tlv23 = (char *)(NUM_ROUNDS); }
    {char * tlv22; tlv22 = (char *)(NUM_ROUNDS); }
}
void fix_ingred_main_13_5(){
fix_ingred_main_13_5_7();
fix_ingred_main_13_5_8();
}
void fix_ingred_main_13_8_0(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
int temp;
    bzero(&temp,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(buf); }
    {int i; i = (int)(buf); }
    {int temp; temp = (int)(buf); }
    {cgc_size_t sret; sret = (cgc_size_t)(buf); }
    {int tlv1; tlv1 = (int)(buf); }
    {int tlv2; tlv2 = (int)(buf); }
    {char tlv11; tlv11 = (char)(buf); }
    {char tlv10; tlv10 = (char)(buf); }
    {int tlv12; tlv12 = (int)(buf); }
    {uint32_t tlv4; tlv4 = (uint32_t)(buf); }
    {char tlv14; tlv14 = (char)(buf); }
    {char tlv13; tlv13 = (char)(buf); }
    {char * tlv7; tlv7 = (char *)(buf); }
    {char * tlv6; tlv6 = (char *)(buf); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(buf); }
    {char * tlv9; tlv9 = (char *)(buf); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(buf); }
    {char * tlv16; tlv16 = (char *)(buf); }
    {char * tlv15; tlv15 = (char *)(buf); }
    {int tlv3; tlv3 = (int)(buf); }
    {char * tlv19; tlv19 = (char *)(buf); }
    {char * tlv18; tlv18 = (char *)(buf); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(buf); }
    {char * tlv21; tlv21 = (char *)(buf); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(buf); }
    {char * tlv23; tlv23 = (char *)(buf); }
    {char * tlv22; tlv22 = (char *)(buf); }
}
void fix_ingred_main_13_8_1(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
int temp;
    bzero(&temp,sizeof(int));
    {if (cgc_gWords){    temp = 0;
         char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int i; i = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int ret; ret = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t sret; sret = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char c; c = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv1; tlv1 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv2; tlv2 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv11; tlv11 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv10; tlv10 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv12; tlv12 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         uint32_t tlv4; tlv4 = (uint32_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv14; tlv14 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char tlv13; tlv13 = (char)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv7; tlv7 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv6; tlv6 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv9; tlv9 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv16; tlv16 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv15; tlv15 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         int tlv3; tlv3 = (int)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv19; tlv19 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv18; tlv18 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv17; tlv17 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv21; tlv21 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         cgc_size_t tlv20; tlv20 = (cgc_size_t)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv23; tlv23 = (char *)(cgc_gWords [ temp ]); }}
    {if (cgc_gWords){    temp = 0;
         char * tlv22; tlv22 = (char *)(cgc_gWords [ temp ]); }}
}
void fix_ingred_main_13_8_2(){
char buf [ BUF_SIZE ];
    bzero(&buf,( BUF_SIZE *sizeof(char) ) );
int temp;
    bzero(&temp,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(BUF_SIZE); }
    {int i; i = (int)(BUF_SIZE); }
    {int ret; ret = (int)(BUF_SIZE); }
    {int temp; temp = (int)(BUF_SIZE); }
    {cgc_size_t sret; sret = (cgc_size_t)(BUF_SIZE); }
    {char c; c = (char)(BUF_SIZE); }
    {int tlv1; tlv1 = (int)(BUF_SIZE); }
    {int tlv2; tlv2 = (int)(BUF_SIZE); }
    {char tlv11; tlv11 = (char)(BUF_SIZE); }
    {char tlv10; tlv10 = (char)(BUF_SIZE); }
    {int tlv12; tlv12 = (int)(BUF_SIZE); }
    {uint32_t tlv4; tlv4 = (uint32_t)(BUF_SIZE); }
    {char tlv14; tlv14 = (char)(BUF_SIZE); }
    {char tlv13; tlv13 = (char)(BUF_SIZE); }
    {char * tlv7; tlv7 = (char *)(BUF_SIZE); }
    {char * tlv6; tlv6 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv9; tlv9 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv16; tlv16 = (char *)(BUF_SIZE); }
    {char * tlv15; tlv15 = (char *)(BUF_SIZE); }
    {int tlv3; tlv3 = (int)(BUF_SIZE); }
    {char * tlv19; tlv19 = (char *)(BUF_SIZE); }
    {char * tlv18; tlv18 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv21; tlv21 = (char *)(BUF_SIZE); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(BUF_SIZE); }
    {char * tlv23; tlv23 = (char *)(BUF_SIZE); }
    {char * tlv22; tlv22 = (char *)(BUF_SIZE); }
}
void fix_ingred_main_13_8(){
fix_ingred_main_13_8_0();
fix_ingred_main_13_8_1();
fix_ingred_main_13_8_2();
}
void fix_ingred_main_13_9_0(){
char c;
    bzero(&c,sizeof(char));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(& c); }
    {int i; i = (int)(& c); }
    {int ret; ret = (int)(& c); }
    {int temp; temp = (int)(& c); }
    {cgc_size_t sret; sret = (cgc_size_t)(& c); }
    {int tlv1; tlv1 = (int)(& c); }
    {int tlv2; tlv2 = (int)(& c); }
    {char tlv11; tlv11 = (char)(& c); }
    {char tlv10; tlv10 = (char)(& c); }
    {int tlv12; tlv12 = (int)(& c); }
    {uint32_t tlv4; tlv4 = (uint32_t)(& c); }
    {char tlv14; tlv14 = (char)(& c); }
    {char tlv13; tlv13 = (char)(& c); }
    {char * tlv7; tlv7 = (char *)(& c); }
    {char * tlv6; tlv6 = (char *)(& c); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(& c); }
    {char * tlv9; tlv9 = (char *)(& c); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(& c); }
    {char * tlv16; tlv16 = (char *)(& c); }
    {char * tlv15; tlv15 = (char *)(& c); }
    {int tlv3; tlv3 = (int)(& c); }
    {char * tlv19; tlv19 = (char *)(& c); }
    {char * tlv18; tlv18 = (char *)(& c); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(& c); }
    {char * tlv21; tlv21 = (char *)(& c); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(& c); }
    {char * tlv23; tlv23 = (char *)(& c); }
    {char * tlv22; tlv22 = (char *)(& c); }
}
void fix_ingred_main_13_9_1(){
char c;
    bzero(&c,sizeof(char));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(1); }
    {int temp; temp = (int)(1); }
    {cgc_size_t sret; sret = (cgc_size_t)(1); }
    {int tlv1; tlv1 = (int)(1); }
    {char tlv11; tlv11 = (char)(1); }
    {char tlv10; tlv10 = (char)(1); }
    {int tlv12; tlv12 = (int)(1); }
    {uint32_t tlv4; tlv4 = (uint32_t)(1); }
    {char tlv14; tlv14 = (char)(1); }
    {char tlv13; tlv13 = (char)(1); }
    {char * tlv6; tlv6 = (char *)(1); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(1); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(1); }
    {char * tlv16; tlv16 = (char *)(1); }
    {char * tlv15; tlv15 = (char *)(1); }
    {int tlv3; tlv3 = (int)(1); }
    {char * tlv19; tlv19 = (char *)(1); }
    {char * tlv18; tlv18 = (char *)(1); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(1); }
    {char * tlv21; tlv21 = (char *)(1); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(1); }
    {char * tlv23; tlv23 = (char *)(1); }
    {char * tlv22; tlv22 = (char *)(1); }
}
void fix_ingred_main_13_9(){
fix_ingred_main_13_9_0();
fix_ingred_main_13_9_1();
}
void fix_ingred_main_13_11_9(){
int tlv3;
    bzero(&tlv3,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(tlv3); }
    {int i; i = (int)(tlv3); }
    {int ret; ret = (int)(tlv3); }
    {int temp; temp = (int)(tlv3); }
    {cgc_size_t sret; sret = (cgc_size_t)(tlv3); }
    {char c; c = (char)(tlv3); }
    {int tlv1; tlv1 = (int)(tlv3); }
    {int tlv2; tlv2 = (int)(tlv3); }
    {char tlv11; tlv11 = (char)(tlv3); }
    {char tlv10; tlv10 = (char)(tlv3); }
    {int tlv12; tlv12 = (int)(tlv3); }
    {uint32_t tlv4; tlv4 = (uint32_t)(tlv3); }
    {char tlv14; tlv14 = (char)(tlv3); }
    {char tlv13; tlv13 = (char)(tlv3); }
    {char * tlv7; tlv7 = (char *)(tlv3); }
    {char * tlv6; tlv6 = (char *)(tlv3); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv3); }
    {char * tlv9; tlv9 = (char *)(tlv3); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(tlv3); }
    {char * tlv16; tlv16 = (char *)(tlv3); }
    {char * tlv15; tlv15 = (char *)(tlv3); }
    {char * tlv19; tlv19 = (char *)(tlv3); }
    {char * tlv18; tlv18 = (char *)(tlv3); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(tlv3); }
    {char * tlv21; tlv21 = (char *)(tlv3); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(tlv3); }
    {char * tlv23; tlv23 = (char *)(tlv3); }
    {char * tlv22; tlv22 = (char *)(tlv3); }
}
void fix_ingred_main_13_11(){
fix_ingred_main_13_11_9();
}
void fix_ingred_main_13_13_1(){
int i;
    bzero(&i,sizeof(int));
    {if (cgc_gWords){    i = 0;
         char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int ret; ret = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int temp; temp = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t sret; sret = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char c; c = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv1; tlv1 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv2; tlv2 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv11; tlv11 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv10; tlv10 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv12; tlv12 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         uint32_t tlv4; tlv4 = (uint32_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv14; tlv14 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char tlv13; tlv13 = (char)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv7; tlv7 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv6; tlv6 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv5; tlv5 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv9; tlv9 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv8; tlv8 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv16; tlv16 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv15; tlv15 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         int tlv3; tlv3 = (int)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv19; tlv19 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv18; tlv18 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv17; tlv17 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv21; tlv21 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         cgc_size_t tlv20; tlv20 = (cgc_size_t)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv23; tlv23 = (char *)(cgc_gWords [ i ]); }}
    {if (cgc_gWords){    i = 0;
         char * tlv22; tlv22 = (char *)(cgc_gWords [ i ]); }}
}
void fix_ingred_main_13_13(){
fix_ingred_main_13_13_1();
}
void fix_ingred_main_13_16_6(){
int tlv2;
    bzero(&tlv2,sizeof(int));
    {char buf [ BUF_SIZE ]; buf [ ( BUF_SIZE )-1 ] = (char)(tlv2); }
    {int i; i = (int)(tlv2); }
    {int ret; ret = (int)(tlv2); }
    {int temp; temp = (int)(tlv2); }
    {cgc_size_t sret; sret = (cgc_size_t)(tlv2); }
    {char c; c = (char)(tlv2); }
    {int tlv1; tlv1 = (int)(tlv2); }
    {char tlv11; tlv11 = (char)(tlv2); }
    {char tlv10; tlv10 = (char)(tlv2); }
    {int tlv12; tlv12 = (int)(tlv2); }
    {uint32_t tlv4; tlv4 = (uint32_t)(tlv2); }
    {char tlv14; tlv14 = (char)(tlv2); }
    {char tlv13; tlv13 = (char)(tlv2); }
    {char * tlv7; tlv7 = (char *)(tlv2); }
    {char * tlv6; tlv6 = (char *)(tlv2); }
    {cgc_size_t tlv5; tlv5 = (cgc_size_t)(tlv2); }
    {char * tlv9; tlv9 = (char *)(tlv2); }
    {cgc_size_t tlv8; tlv8 = (cgc_size_t)(tlv2); }
    {char * tlv16; tlv16 = (char *)(tlv2); }
    {char * tlv15; tlv15 = (char *)(tlv2); }
    {int tlv3; tlv3 = (int)(tlv2); }
    {char * tlv19; tlv19 = (char *)(tlv2); }
    {char * tlv18; tlv18 = (char *)(tlv2); }
    {cgc_size_t tlv17; tlv17 = (cgc_size_t)(tlv2); }
    {char * tlv21; tlv21 = (char *)(tlv2); }
    {cgc_size_t tlv20; tlv20 = (cgc_size_t)(tlv2); }
    {char * tlv23; tlv23 = (char *)(tlv2); }
    {char * tlv22; tlv22 = (char *)(tlv2); }
}
void fix_ingred_main_13_16(){
fix_ingred_main_13_16_6();
}
void fix_ingred_main_13(){
fix_ingred_main_13_0();
fix_ingred_main_13_1();
fix_ingred_main_13_2();
fix_ingred_main_13_3();
fix_ingred_main_13_4();
fix_ingred_main_13_5();
fix_ingred_main_13_8();
fix_ingred_main_13_9();
fix_ingred_main_13_11();
fix_ingred_main_13_13();
fix_ingred_main_13_16();
}

[Fix Ingredient functions]  -- START --
void fix_ingred_main_13_0_0();
void fix_ingred_main_13_0_3();
void fix_ingred_main_13_0_4();
void fix_ingred_main_13_0();
void fix_ingred_main_13_1_0();
void fix_ingred_main_13_1_1();
void fix_ingred_main_13_1();
void fix_ingred_main_13_2_0();
void fix_ingred_main_13_2();
void fix_ingred_main_13_3_5();
void fix_ingred_main_13_3();
void fix_ingred_main_13_4_0();
void fix_ingred_main_13_4();
void fix_ingred_main_13_5_7();
void fix_ingred_main_13_5_8();
void fix_ingred_main_13_5();
void fix_ingred_main_13_8_0();
void fix_ingred_main_13_8_1();
void fix_ingred_main_13_8_2();
void fix_ingred_main_13_8();
void fix_ingred_main_13_9_0();
void fix_ingred_main_13_9_1();
void fix_ingred_main_13_9();
void fix_ingred_main_13_11_9();
void fix_ingred_main_13_11();
void fix_ingred_main_13_13_1();
void fix_ingred_main_13_13();
void fix_ingred_main_13_16_6();
void fix_ingred_main_13_16();
void fix_ingred_main_13();


[Fix Ingredient functions]  --  END  --
Fix Ingredient functions
- fix_ingred_main_0_0_0
- fix_ingred_main_0_0
- fix_ingred_main_0_1_1
- fix_ingred_main_0_1_2
- fix_ingred_main_0_1
- fix_ingred_main_0_2_3
- fix_ingred_main_0_2
- fix_ingred_main_0
- fix_ingred_main_1_0_0
- fix_ingred_main_1_0_2
- fix_ingred_main_1_0
- fix_ingred_main_1_1_3
- fix_ingred_main_1_1_4
- fix_ingred_main_1_1
- fix_ingred_main_1_2_3
- fix_ingred_main_1_2_4
- fix_ingred_main_1_2
- fix_ingred_main_1_3_0
- fix_ingred_main_1_3
- fix_ingred_main_1_4_0
- fix_ingred_main_1_4_1
- fix_ingred_main_1_4_2
- fix_ingred_main_1_4
- fix_ingred_main_1_5_3
- fix_ingred_main_1_5
- fix_ingred_main_1_6_0
- fix_ingred_main_1_6
- fix_ingred_main_1
- fix_ingred_main_2_1_0
- fix_ingred_main_2_1_1
- fix_ingred_main_2_1
- fix_ingred_main_2
- fix_ingred_main_3_4_0
- fix_ingred_main_3_4
- fix_ingred_main_3
- fix_ingred_main_4_0_0
- fix_ingred_main_4_0_1
- fix_ingred_main_4_0_2
- fix_ingred_main_4_0
- fix_ingred_main_4_1_0
- fix_ingred_main_4_1_1
- fix_ingred_main_4_1
- fix_ingred_main_4_2_4
- fix_ingred_main_4_2_5
- fix_ingred_main_4_2_6
- fix_ingred_main_4_2_7
- fix_ingred_main_4_2
- fix_ingred_main_4_4_0
- fix_ingred_main_4_4_1
- fix_ingred_main_4_4_2
- fix_ingred_main_4_4
- fix_ingred_main_4_5_4
- fix_ingred_main_4_5_6
- fix_ingred_main_4_5
- fix_ingred_main_4_6_0
- fix_ingred_main_4_6
- fix_ingred_main_4
- fix_ingred_main_5_0_0
- fix_ingred_main_5_0_2
- fix_ingred_main_5_0
- fix_ingred_main_5_1_0
- fix_ingred_main_5_1_3
- fix_ingred_main_5_1_4
- fix_ingred_main_5_1_6
- fix_ingred_main_5_1
- fix_ingred_main_5_3_0
- fix_ingred_main_5_3_4
- fix_ingred_main_5_3_6
- fix_ingred_main_5_3
- fix_ingred_main_5_5_0
- fix_ingred_main_5_5_4
- fix_ingred_main_5_5_6
- fix_ingred_main_5_5
- fix_ingred_main_5
- fix_ingred_main_6_0_0
- fix_ingred_main_6_0
- fix_ingred_main_6_1_0
- fix_ingred_main_6_1_1
- fix_ingred_main_6_1_2
- fix_ingred_main_6_1
- fix_ingred_main_6_2_2
- fix_ingred_main_6_2_3
- fix_ingred_main_6_2
- fix_ingred_main_6_3_0
- fix_ingred_main_6_3_1
- fix_ingred_main_6_3
- fix_ingred_main_6
- fix_ingred_main_7_0_0
- fix_ingred_main_7_0_1
- fix_ingred_main_7_0_2
- fix_ingred_main_7_0_5
- fix_ingred_main_7_0
- fix_ingred_main_7_1_0
- fix_ingred_main_7_1
- fix_ingred_main_7_2_2
- fix_ingred_main_7_2
- fix_ingred_main_7_3_0
- fix_ingred_main_7_3_6
- fix_ingred_main_7_3_7
- fix_ingred_main_7_3
- fix_ingred_main_7_4_0
- fix_ingred_main_7_4_1
- fix_ingred_main_7_4
- fix_ingred_main_7_5_0
- fix_ingred_main_7_5
- fix_ingred_main_7_7_1
- fix_ingred_main_7_7
- fix_ingred_main_7_8_0
- fix_ingred_main_7_8_2
- fix_ingred_main_7_8
- fix_ingred_main_7
- fix_ingred_main_8_1_0
- fix_ingred_main_8_1_2
- fix_ingred_main_8_1_3
- fix_ingred_main_8_1_5
- fix_ingred_main_8_1
- fix_ingred_main_8_2_0
- fix_ingred_main_8_2_1
- fix_ingred_main_8_2_8
- fix_ingred_main_8_2
- fix_ingred_main_8_4_7
- fix_ingred_main_8_4
- fix_ingred_main_8
- fix_ingred_main_9
- fix_ingred_main_10_1_0
- fix_ingred_main_10_1_1
- fix_ingred_main_10_1
- fix_ingred_main_10_2_2
- fix_ingred_main_10_2
- fix_ingred_main_10_5_2
- fix_ingred_main_10_5
- fix_ingred_main_10
- fix_ingred_main_11
- fix_ingred_main_12_0_0
- fix_ingred_main_12_0
- fix_ingred_main_12_1_1
- fix_ingred_main_12_1_2
- fix_ingred_main_12_1_3
- fix_ingred_main_12_1_4
- fix_ingred_main_12_1
- fix_ingred_main_12
- fix_ingred_main_13_0_0
- fix_ingred_main_13_0_3
- fix_ingred_main_13_0_4
- fix_ingred_main_13_0
- fix_ingred_main_13_1_0
- fix_ingred_main_13_1_1
- fix_ingred_main_13_1
- fix_ingred_main_13_2_0
- fix_ingred_main_13_2
- fix_ingred_main_13_3_5
- fix_ingred_main_13_3
- fix_ingred_main_13_4_0
- fix_ingred_main_13_4
- fix_ingred_main_13_5_7
- fix_ingred_main_13_5_8
- fix_ingred_main_13_5
- fix_ingred_main_13_8_0
- fix_ingred_main_13_8_1
- fix_ingred_main_13_8_2
- fix_ingred_main_13_8
- fix_ingred_main_13_9_0
- fix_ingred_main_13_9_1
- fix_ingred_main_13_9
- fix_ingred_main_13_11_9
- fix_ingred_main_13_11
- fix_ingred_main_13_13_1
- fix_ingred_main_13_13
- fix_ingred_main_13_16_6
- fix_ingred_main_13_16
- fix_ingred_main_13
